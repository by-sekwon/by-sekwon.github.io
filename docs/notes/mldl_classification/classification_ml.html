<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>MLDL 머신러닝 분류 - kNN SVM – 세상의 모든 통계 이야기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-2757cfadcc89ddbfb9e61569f8c3689f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">세상의 모든 통계 이야기</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../notes/math_stat/index.html"> 
<span class="menu-text">기초수학·수리통계</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/intro_stat/index.html"> 
<span class="menu-text">기초통계·조사방법</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/linear_model/index.html"> 
<span class="menu-text">회귀·다변량분석</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl/index.html"> 
<span class="menu-text">MLDL개념 w/GPT</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl_prediction/index.html"> 
<span class="menu-text">MLDL예측방법 w/GPT</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../notes/mldl_classification/index.html" aria-current="page"> 
<span class="menu-text">MLDL분류 w/GPT</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cardnews/index.html"> 
<span class="menu-text">카드뉴스</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../consult.html"> 
<span class="menu-text">통계상담</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../notes/mldl_classification/classification_ml.html">📄 머신러닝 kNN SVM</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_classification/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">【머신·딥러닝 분류문제】</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_classification/classification_intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 분류문제: 정의</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_classification/lm_logistic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 [전통]로지스틱회귀</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_classification/mda_discriminant.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 [전통]판별분석</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_classification/prediction_treebase.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 [머신러닝]트리기반 예측</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_classification/classification_ml.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">📄 머신러닝 kNN SVM</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">MLDL 머신러닝 분류 - kNN SVM</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Chapter 1. 머신러닝 분류 (k-NN | SVM)</p>
<p>1. 전통적 분류방법과 차이</p>
<p>분류 문제는 본질적으로 조건부 확률 <span class="math inline">\(P(Y = k \mid X = x),k = 1,\ldots,K\)</span>을 추정하거나(확률예측), 최소한 그 확률에 기반한 의사결정 규칙 <span class="math inline">\(\widehat{y}(x) = \arg\max_{k}P(Y = k \mid X = x)\)</span>을 구현하는 일이다. 통계적 분류모형과 머신러닝 분류기는 모두 이 목표를 공유하지만, 접근 방식이 다르다.</p>
<p>통계적 분류모형</p>
<p><span dir="rtl">”</span>확률모형을 먼저 세우고, 그 안에서 추정한다”. 통계적 분류모형(로지스틱 회귀, LDA/QDA)의 출발점은 데이터 생성 메커니즘에 대한 가정이다.</p>
<p>(1) 로지스틱 회귀: <span class="math inline">\(P(Y \mid X)\)</span>를 직접 모형화 (Discriminative)</p>
<p>이진분류에서 <span class="math inline">\(P(Y = 1 \mid X = x) = \sigma(\beta_{0} + \beta^{\top}x) = \frac{1}{1 + e^{- (\beta_{0} + \beta^{\top}x)}}\)</span>처럼 조건부 확률을 직접 모형화한다. 즉, <span dir="rtl">”</span>결정경계가 선형(log-odds 선형)“이라는 구조적 가정을 둔다.</p>
<p>(2) LDA/QDA: <span class="math inline">\(P(X \mid Y)\)</span>와 <span class="math inline">\(P(Y)\)</span>를 모형화 (Generative)</p>
<p>베이즈 정리를 이용해 <span class="math inline">\(P(Y = k \mid X = x) \propto \pi_{k}f_{k}(x)\)</span>를 계산한다. 여기서 <span class="math inline">\(\pi_{k} = P(Y = k),f_{k}(x) = p(X = x \mid Y = k)\)</span>.</p>
<p>LDA: <span class="math inline">\(X \mid Y = k \sim N(\mu_{k},\Sigma)\)</span> (공분산 동일) → 결정경계가 선형</p>
<p>QDA: <span class="math inline">\(X \mid Y = k \sim N(\mu_{k},\Sigma_{k})\)</span> (공분산 클래스별) → 결정경계가 이차(곡선)</p>
<p>통계적 분류모형의 강점/한계</p>
<p>강점: 추정/검정/해석(계수, 신뢰구간 등)이 체계적, 소표본에서도 안정적(가정이 맞으면)</p>
<p>한계: 가정이 틀리면(비선형, 복잡한 상호작용, 비정규 등) 성능이 급격히 저하될 수 있음</p>
<p>머신러닝 분류기</p>
<p><span dir="rtl">”</span>가정보다 예측성능·일반화를 먼저 최적화한다”. 머신러닝 분류기는 대체로 명시적 확률가정(정규성, 선형성 등)을 약하게 두거나 거의 두지 않고, 훈련오차만 줄이는 것이 아니라 일반화 성능을 최대화하는 방향으로 설계된다.</p>
<p>(1) 목표함수 관점: 경험위험 + 규제(복잡도 제어)</p>
<p>머신러닝의 공통 형태는 다음과 같이 정리할 수 있다.</p>
<p><span class="math inline">\(\min_{f \in \mathcal{F}}\frac{1}{n}\overset{n}{\sum_{i = 1}}\ell(y_{i},f(x_{i})) + \lambda\Omega(f)\)</span>, 여기서 <span class="math inline">\(\ell( \cdot )\)</span>은 손실함수(예: 0-1 loss, hinge loss, log loss 등), <span class="math inline">\(\Omega(f)\)</span>는 복잡도 페널티(모형이 너무 흔들리지 않게 제어), 그리고 <span class="math inline">\(\lambda\)</span>는 적합 vs 단순성의 균형(튜닝 파라미터)이다.</p>
<p>즉, 머신러닝은 <span dir="rtl">”</span>데이터를 잘 맞추되(적합) 너무 복잡해지지 않게(규제)“라는 Bias–Variance trade-off를 직접 다룬다.</p>
<p>(2) 의사결정규칙을 직접 학습하는 방식이 많다</p>
<p>통계적 모형이 확률모형(혹은 분포가정)으로부터 P(Y\mid X)를 유도하는 경우가 많은 반면, 머신러닝은 종종 결정경계/분류규칙 자체를 직접 최적화한다.</p>
<p>k-NN: 주변 이웃의 다수결(지역적 규칙)</p>
<p>SVM: 분류오차 대신 마진 최대화(hinge loss 기반)</p>
<p>Tree: 불순도 감소로 분할 규칙을 누적</p>
<p>Ensemble: 여러 약한 분류기를 결합해 일반화 향상</p>
<p>(3) <span dir="rtl">”</span>튜닝 + 검증”이 모형의 일부다</p>
<p>머신러닝에서는 하이퍼파라미터(예: k-NN의 k, SVM의 C, <span class="math inline">\(\gamma\)</span>, 트리 깊이, learning rate 등)가 성능을 좌우한다. 따라서 교차검증(CV), 홀드아웃, 조기중단(early stopping) 같은 평가-선택 절차가 모형 학습의 핵심 구성요소가 된다.</p>
<p>전통적 방법과 머신러닝 방법 비교</p>
<p>가정과 유연성: 구조 가정 vs 데이터 주도 유연성</p>
<p>통계적 분류모형(로지스틱 회귀, LDA/QDA)은 먼저 데이터 생성 구조에 대한 비교적 강한 가정(예: 선형성, 정규성, 동분산 등)을 두고 그 틀 안에서 모수를 추정한다. 이 때문에 모형 형태가 명확하고 해석이 쉽지만, 가정이 현실 데이터와 어긋나면(비선형·복잡한 상호작용·비정규 등) 예측 성능이 쉽게 제한될 수 있다. 반면 머신러닝 분류기는 명시적 가정보다는 일반화 성능을 우선하며 더 유연한 결정경계를 허용한다. 그 대신 과적합 위험을 제어하기 위한 하이퍼파라미터 튜닝과 검증(교차검증, 검증셋, 조기중단 등)이 사실상 필수로 포함된다.</p>
<p>확률 예측과 분류 정확도: 확률 모델링 중심 vs 성능 지표 중심</p>
<p>통계모형은 <span class="math inline">\(P(Y \mid X)\)</span>의 확률 추정 자체가 핵심 산출물이다. 예를 들어 로지스틱 회귀는 <span class="math inline">\(P(Y = 1 \mid X = x) = \frac{1}{1 + \exp\{ - (\beta_{0} + \beta^{\top}x)\}}\)</span>처럼 조건부확률을 직접 모형화하여 위험도 해석이나 임계값 기반 의사결정에 자연스럽게 연결된다. 머신러닝 분류는 종종 정확도(Accuracy), F1, AUC 같은 분류 성능 지표를 목표로 최적화되는 경우가 많다. 다만 Random Forest, Gradient Boosting, Neural Network 등은 클래스 확률도 출력할 수 있으며, 이때 출력 확률이 실제 빈도와 잘 맞는지(확률보정, calibration)를 점검·보정해야 하는 상황이 자주 발생한다.</p>
<p>해석가능성: 내재적 해석과 추론 vs 사후적 설명 도구</p>
<p>통계모형은 계수 <span class="math inline">\(\beta\)</span>를 통해 변수 효과를 직접 설명할 수 있고(예: 오즈비 <span class="math inline">\(e^{\beta_{j}}\)</span>), 표준오차·신뢰구간·가설검정 등 불확실성까지 함께 제공한다는 점에서 <span dir="rtl">”</span>설명과 추론”에 강하다. 반면 머신러닝 모형은 구조가 복잡할수록 내부 파라미터만으로 해석하기 어렵기 때문에, permutation importance, PDP/ICE, SHAP 등의 사후적 설명 기법을 활용해 <span dir="rtl">”</span>어떤 변수가 얼마나 기여했는가”를 보완적으로 제시하는 방식이 일반적이다.</p>
<p>데이터 규모와 차원: 소표본 안정성 vs 대규모·고차원 대응(규제 중요)</p>
<p>통계모형은 가정이 적절할 경우 소표본에서도 비교적 안정적으로 추정되며, 모형 복잡도가 제한되어 과적합 위험이 상대적으로 작다. 머신러닝은 데이터가 많을수록(그리고 패턴이 복잡할수록) 강점을 발휘하는 경우가 많지만, 고차원에서는 불필요한 변수로 인해 분산이 커지거나 학습이 불안정해질 수 있다. 따라서 정규화(regularization), 특징선택(feature selection), 차원축소, 적절한 규제 및 튜닝이 성능과 일반화를 좌우한다.</p>
<p>2. 규칙 기반(k-NN)</p>
<p>핵심 아이디어</p>
<p>k-NN은 <span dir="rtl">”</span>입력공간에서 서로 가까운 관측치들은 같은 클래스에 속할 가능성이 높다”는 지역적 평활성 가정에 기반한다. 즉, 어떤 점 x 근처에서는 클래스 확률 <span class="math inline">\(P(Y = k \mid X = x)\)</span>가 급격히 변하지 않는다고 보고, x 주변의 훈련 표본들로부터 그 확률을 국소적으로 추정한다.</p>
<p>이 방법은 회귀계수나 명시적 모수(예:<span class="math inline">\(\beta\)</span>)를 학습하는 형태의 <span dir="rtl">”</span>모형 적합”이라기보다, 훈련 데이터 자체가 분류 규칙을 구성한다는 점에서 사례 기반(instance-based) 혹은 기억 기반(memory-based) 방법으로 분류된다. 새로운 관측치가 들어오면, 미리 정해 둔 규칙(거리 및 K)에 따라 <span dir="rtl">”</span>가까운 이웃들을 찾아” 그들의 클래스 정보를 활용해 예측한다.</p>
<p>베이즈 분류기와 k-NN의 위치</p>
<p>분류 문제의 이상적 목표는, 각 x에서의 참 조건부확률 <span class="math inline">\(P(Y = k \mid X = x)\)</span>을 알고 있을 때, 다음 규칙으로 분류하는 베이즈 분류기(Bayes classifier)를 사용하는 것이다. <span class="math inline">\({\widehat{y}}_{\text{Bayes}}(x) = \arg\max_{k}P(Y = k \mid X = x)\)</span>. 이 규칙은 가능한 모든 분류기 중에서 기대 분류오차를 최소화한다는 의미에서 <span dir="rtl">”</span>최적”이다.</p>
<p>그러나 현실 데이터에서는 <span class="math inline">\(P(Y \mid X)\)</span>의 진짜 형태를 알 수 없으므로, 베이즈 분류기를 직접 계산하는 것은 불가능하다. 따라서 베이즈 분류기는 실제로는 도달할 수 없지만, 다른 방법들의 성능을 판단하는 기준점으로서 이상적인 <span dir="rtl">’</span>황금 기준(gold standard)<span dir="rtl">’</span> 역할을 한다.</p>
<p>이러한 맥락에서 많은 분류 방법들은 다음의 공통 전략을 따른다. 데이터로부터 P(Y=k\mid X=x)를 어떤 방식으로든 추정하고 추정 확률이 가장 큰 클래스로 할당한다. <span class="math inline">\(\widehat{y}(x) = \arg\max_{k}\widehat{P}(Y = k \mid X = x)\)</span></p>
<p>k-NN은 이 전략을 가장 직관적으로 구현한 대표적 방법이다. 즉, x 주변의 <span dir="rtl">”</span>가까운 이웃”들이 보여주는 클래스 비율을 이용해 <span class="math inline">\(P(Y \mid X = x)\)</span>를 국소적으로 근사하고, 그 값이 최대가 되는 클래스로 분류한다.</p>
<p>요약하면, 베이즈 분류기가 <span dir="rtl">”</span>알 수 없는 진짜 확률에 기반한 최적 규칙”이라면, k-NN은 그 확률을 <span dir="rtl">”</span>이웃의 경험적 비율”로 대체하여 현실에서 실행 가능하게 만든 비모수적 근사 규칙이다.</p>
<p>거리와 이웃 정의</p>
<p>이웃 집합의 정의</p>
<p>훈련표본 <span class="math inline">\(\{(x_{i},y_{i})\}_{i = 1}^{n},x_{i} \in \mathbb{R}^{p}\)</span>을 정의하자. 새 관측치 <span class="math inline">\(x_{0}\)</span>에 대해 거리 <span class="math inline">\(d(x_{0},x_{i})\)</span>가 작은 순서로 k개를 선택하여 이웃 집합을 정의한다:</p>
<p><span class="math inline">\(N_{k}(x_{0}) = \{ i_{1},\ldots,i_{k}\},d(x_{0},x_{i_{1}}) \leq \cdots \leq d(x_{0},x_{i_{k}})\)</span>, 여기서 <span class="math inline">\(N_{k}(x_{0})\)</span>는 <span dir="rtl">”</span>이웃 인덱스 집합”이다(이웃 점 자체가 아니라 인덱스)아다.</p>
<p>대표 거리(연속형 변수)</p>
<p>가장 흔한 선택은 유클리드 거리보다 일반적으로는 Minkowski 거리(<span class="math inline">\(q \geq 1\)</span>)를 사용한다.</p>
<p><span class="math inline">\(d_{q}(x,z) = (\overset{p}{\sum_{j = 1}}|x_{j} - z_{j}|^{q})^{\frac{1}{q}}\)</span>, 여기서 q=1이면 Manhattan, q=2는 Euclidean 거리이다.</p>
<p>변수 스케일 문제와 표준화</p>
<p>변수의 단위/분산이 다르면 거리 계산이 특정 변수에 의해 지배되어 이웃 선택이 왜곡된다. 따라서 보통 표준화 후 거리 계산을 수행한다.</p>
<p><span class="math display">\[x_{ij}^{(std)} = \frac{x_{ij} - {\overline{x}}_{j}}{s_{j}}\]</span></p>
<p><span class="math inline">\({\overline{x}}_{j},s_{j}\)</span>는 반드시 훈련 데이터에서 계산한 값을 사용하고, 테스트 데이터에도 같은 값으로 변환해야 한다. 테스트 데이터의 평균/표준편차로 표준화하면 정보 누수(leakage)가 발생한다.</p>
<p>범주형 변수가 있을 때</p>
<p>거리는 연속형에 자연스럽다. 범주형이 포함되면 다음 중 하나를 고려한다.</p>
<p>원-핫 인코딩 후 거리 계산(차원 증가 주의)</p>
<p>Gower distance 등 혼합형 거리(연속+범주)</p>
<p>도메인 맞춤 거리(예: 매칭 불일치 수)</p>
<p>동률 처리</p>
<p><span class="math inline">\(\widehat{p}(c \mid x_{0})\)</span>가 같은 클래스가 나오거나, 거리 동률로 k번째 이웃이 애매한 경우가 있다. 일반적으로는 (i) 무작위 tie-break, (ii) 더 작은 거리 이웃 우선, (iii) 가중 k-NN 사용 등으로 처리한다.</p>
<p>분류 규칙 (다중분류 포함)</p>
<p>클래스 집합이 <span class="math inline">\(\{ 1,\ldots,K\}\)</span>일 때, k-NN은 x_0의 이웃들에서 클래스 비율로 조건부확률을 추정한다.</p>
<p><span class="math inline">\(\widehat{p}(c \mid x_{0}) = \frac{1}{k}\sum_{i \in N_{k}(x_{0})}\mathbf{1}(y_{i} = c),c = 1,\ldots,K\)</span>, 여기서 <span class="math inline">\(\mathbf{1}( \cdot )\)</span>는 지시함수(indicator)이다.</p>
<p>예측은 최대 사후확률(MAP) 규칙, 즉 다수결과 동일한 원리로 결정된다:</p>
<p><span class="math display">\[\widehat{y}(x_{0}) = \arg\max_{c \in \{ 1,\ldots,K\}}\widehat{p}(c \mid x_{0})\]</span></p>
<p>이 식은 <span dir="rtl">”</span>다중분류”에서도 그대로 성립한다. 이진분류라면 <span class="math inline">\(\widehat{p}(1 \mid x_{0}) &gt; 0.5\)</span>와 같은 임계값 규칙으로도 표현 가능.</p>
<p>가중 k-NN (거리 가중, Weighted k-NN)</p>
<p>왜 가중을 주나?</p>
<p>기본 k-NN은 이웃 k개를 모두 동일 가중치로 취급한다. 하지만 직관적으로는 더 가까운 이웃이 더 큰 정보를 가지므로, 거리 기반 가중치를 부여하면 성능이 개선되는 경우가 많다.</p>
<p>가중치 정의</p>
<p>가까운 이웃에 더 큰 가중치를 준다. <span class="math inline">\(w_{i}(x_{0}) = \frac{1}{d(x_{0},x_{i})^{r} + \varepsilon},r &gt; 0,\varepsilon &gt; 0\)</span>, 여기서 <span class="math inline">\(\varepsilon\)</span>는 d=0일 때 발산을 막기 위한 작은 값(수치 안정화)이며, r가 클수록 <span dir="rtl">”</span>가까운 이웃”을 더 강하게 강조(유연성 증가)한다.</p>
<p>가중 확률 추정과 예측</p>
<p><span class="math display">\[\widehat{p}(c \mid x_{0}) = \frac{\sum_{i \in N_{k}(x_{0})}w_{i}(x_{0})\mathbf{1}(y_{i} = c)}{\sum_{i \in N_{k}(x_{0})}w_{i}(x_{0})}\widehat{y}(x_{0}) = \arg\max_{c}\widehat{p}(c \mid x_{0})\]</span></p>
<p>이 방식은 동률 문제를 완화하고, 경계 근처에서 더 자연스러운 확률 추정을 제공한다.</p>
<p>커널 가중(대안)</p>
<p>거리 가중치를 커널 형태로 두기도 한다:</p>
<p><span class="math inline">\(w_{i}(x_{0}) = \exp( - \gamma d(x_{0},x_{i})^{2})\)</span>, 여기서 <span class="math inline">\(\gamma\)</span>가 클수록 가까운 점에 더 집중(국소성 강화)하게 된다.</p>
<p>k와 Bias–Variance</p>
<p>k-NN에서 k는 모델의 유연성(flexibility)을 직접 결정하는 핵심 튜닝 파라미터이다. k가 작으면 예측에 사용되는 이웃의 범위가 매우 좁아져, 각 점 주변의 국소적 패턴(심지어 노이즈까지)도 그대로 따라가게 된다. 그 결과 결정경계는 매우 구불구불해지고, 훈련 데이터에는 잘 맞지만 새로운 데이터에서는 성능이 떨어질 수 있는 저편향·고분산(과적합) 상태로 가기 쉽다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/classification_.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:60.0%"></p>
</figure>
</div>
<p>반대로 k가 커지면 더 넓은 이웃을 평균내어 판단하므로 우연한 변동이 상쇄되어 경계가 매끈해지고 변동성이 줄어든다. 하지만 이 경우 지역적 구조까지 과도하게 평활화되어 실제로 필요한 비선형 경계를 놓칠 수 있어 고편향·저분산(과소적합) 위험이 커진다.</p>
<p>따라서 k는 <span dir="rtl">”</span>훈련 성능”이 아니라 <span dir="rtl">”</span>일반화 성능”을 기준으로 정해야 하며, 실무적으로는 교차검증을 통해 테스트 오차(또는 AUC/F1 등)가 최소가 되는 k를 선택하는 것이 표준적 절차이다.</p>
<p>다음 그림은 k-NN에서 이웃의 수 K를 바꾸면 분류기의 유연성(복잡도)이 어떻게 달라지고, 그에 따라 훈련오차와 테스트오차가 서로 다른 방식으로 변한다는 점을 보여준다. 가로축은 1/K로 표시되어 있는데, 이는 K가 작아질수록 1/K가 커져 오른쪽으로 갈수록 분류기가 더 유연해진다는 뜻이다. 즉, 오른쪽으로 갈수록 결정경계가 더 구불구불해져 훈련 데이터의 국소적 패턴을 더 적극적으로 따라가게 된다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image4.png" style="width:4.5in;height:3.39055in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<p>먼저 훈련오차(파란색)는 K가 작아질수록 꾸준히 감소한다. 이는 더 유연한 모델일수록 훈련 데이터에 맞춰 경계를 세밀하게 조정할 수 있기 때문이다. 극단적으로 K=1에 가까워지면 각 관측치가 사실상 자기 자신과 가장 가까운 이웃이 되어 훈련 데이터는 거의 완벽하게 분류되므로, 훈련오차가 0에 근접할 수도 있다. 따라서 훈련오차만 보면 K를 계속 줄이는 것이 좋아 보이지만, 이 판단은 일반화 성능을 보장하지 않는다.</p>
<p>반면 테스트오차(주황색)는 같은 방식으로 움직이지 않는다. K를 어느 정도 줄여 유연성을 키우면 처음에는 테스트오차가 감소하는데, 이는 너무 단순했던 결정경계가 실제 클래스 구조를 더 잘 반영하기 시작하기 때문이다. 그러나 K가 지나치게 작아지면 모델이 신호뿐 아니라 우연한 변동(노이즈)까지 따라가면서 과적합이 발생하고, 그 결과 테스트오차가 다시 증가한다. 즉 테스트오차는 일반적으로 처음에는 내려가다가 어느 지점 이후 다시 올라가는 U자 형태를 띠며, 이 U자 곡선의 최저점이 <span dir="rtl">”</span>가장 적절한 K”에 해당한다.</p>
<p>그림의 검은 점선은 베이즈 오류율을 나타내며, 이는 주어진 문제에서 어떤 분류기를 쓰더라도 이론적으로 완전히 없앨 수 없는 최소 오류(불가약 오차)의 기준선이다. 적절한 K를 선택하면 테스트오차가 이 기준선에 가까워질 수 있지만, K가 너무 크거나 너무 작으면 각각 과소적합 또는 과적합으로 인해 테스트오차가 커져 베이즈 오류율과의 차이가 벌어진다. 또한 곡선이 매끈하지 않고 들쭉날쭉한 것은 훈련 데이터가 비교적 작아, K가 조금만 바뀌어도 이웃 구성과 결정경계가 민감하게 변하는 표본 변동의 영향이 나타나기 때문이다.</p>
<p>결론적으로 이 그림은 <span dir="rtl">”</span>훈련오차를 최소화하는 방향으로 모델을 복잡하게 만드는 것”이 곧 <span dir="rtl">”</span>좋은 예측모형”을 의미하지 않으며, 실제로는 테스트오차가 최소가 되는 적절한 유연성 수준(즉 적절한 K)이 존재한다는 사실을 강조한다. 따라서 k-NN에서 K는 훈련 성능이 아니라 일반화 성능을 기준으로, 보통 교차검증을 통해 선택해야 한다.</p>
<p>장단점</p>
<p>k-NN의 가장 큰 장점은 방법이 직관적이고 구현이 간단하다는 점이다. 별도의 복잡한 모수 추정 없이도 데이터의 국소 구조를 이용해 분류를 수행하므로, 선형 가정에 묶이지 않고 매우 유연한 비선형 결정경계를 자연스럽게 만들 수 있다. 반면 단점도 분명하다. k-NN은 학습 단계가 가벼운 대신, 새로운 관측치가 들어올 때마다 전체 훈련 데이터와의 거리를 계산해 이웃을 찾아야 하므로 예측 비용이 커지며(대략 O(np)), 데이터가 커질수록 실시간 예측이 부담될 수 있다. 또한 차원이 커질수록 거리의 상대적 차이가 희미해져 <span dir="rtl">”</span>가까움” 자체가 의미를 잃는 차원의 저주 문제가 나타나 성능이 악화되기 쉽다. 마지막으로 거리 기반 방법이기 때문에 변수 스케일에 매우 민감하고(표준화가 필수에 가까움), 이상치가 있으면 거리 계산이 왜곡되어 이웃 선택이 불안정해질 수 있다는 점도 중요한 한계로 고려해야 한다.</p>
<p>3. 마진 기반(SVM)</p>
<p>개념</p>
<p>SVM은 1990년대 컴퓨터 과학 분야에서 개발된 분류 방법으로, 이후 그 인기가 꾸준히 증가해 왔다. SVM은 다양한 상황에서 좋은 성능을 보이는 것으로 알려져 있으며, 종종 별다른 특별한 조정 없이도 잘 작동하는(<span dir="rtl">”</span>out of the box”) 분류기 중 하나로 여겨진다.</p>
<p>서포트 벡터 머신은 최대 마진 분류기(maximal margin classifier)라고 불리는 단순하고 직관적인 분류기의 일반화 형태이다. 이 분류기는 우아하고 단순하지만, 클래스들이 선형 경계로 완전히 분리 가능(separable)해야 한다는 조건을 필요로 하므로, 안타깝게도 대부분의 데이터셋에는 적용할 수 없다는 것을 보게 될 것이다.</p>
<p>최대 마진 분류기를 확장하여 더 넓은 범위의 경우에 적용할 수 있는 서포트 벡터 분류기(support vector classifier)를 소개한다. 비선형 클래스 경계를 수용하기 위해 서포트 벡터 분류기를 한 단계 더 확장한 서포트 벡터 머신을 소개한다. 서포트 벡터 머신은 기본적으로 두 개의 클래스가 존재하는 이진 분류 설정을 대상으로 한다.</p>
<p>최대 마진 분류기 (Maximal Margin Classifier)</p>
<p>초평면이란?</p>
<p>p차원 공간에서 초평면(hyperplane)은 차원이 p-1인 평평한(평탄한) 아핀 부분공간이다. 예를 들어 2차원에서 초평면은 1차원 평평한 부분공간, 즉 직선이다. 3차원에서 초평면은 2차원 평평한 부분공간, 즉 평면이다. p&gt;3인 경우 초평면을 시각화하기는 어렵지만, <span dir="rtl">”</span>차원이 p-1인 평평한 부분공간”이라는 개념은 그대로 적용된다.</p>
<p>초평면의 수학적 정의는 매우 간단하다. p-차원에서 초평면은 다음 방정식으로 정의된다.</p>
<p><span class="math inline">\(\beta_{0} + \beta_{1}X_{1} + \beta_{2}X_{2} + \cdots + \beta_{p}X_{p} = 0\)</span>. p차원 공간(즉 길이가 p인 벡터)에 있는 점 <span class="math inline">\(X = (X_{1},X_{2},\ldots,X_{p})^{\top}\)</span>가 위를 만족하면, 그 점은 초평면 위에 놓인다.</p>
<p>이제 X가 위의 식을 만족하지 않는다고 하자. 대신 <span class="math inline">\(\beta_{0} + \beta_{1}X_{1} + \beta_{2}X_{2} + \cdots + \beta_{p}X_{p} &gt; 0\)</span> 라면, 이는 X가 초평면의 한쪽에 놓여 있음을 뜻한다. 반대인 경우에는 X는 초평면의 다른 쪽에 놓인다. 따라서 초평면은 p차원 공간을 두 개의 부분으로 나누는 경계로 생각할 수 있다. 점이 초평면의 어느 쪽에 있는지는 부호(sign)를 계산하는 것만으로 쉽게 판별할 수 있다.</p>
<p>이 그림은 초평면(hyperplane)이 차원에 따라 어떻게 나타나는지를 보여주는데, 2차원 <span class="math inline">\(\mathbb{R}^{2}\)</span>에서는 초평면이 한 차원 낮은 1차원 경계이므로 직선으로 나타나 평면을 두 영역으로 나누고(왼쪽), 3차원 <span class="math inline">\(\mathbb{R}^{3}\)</span>에서는 한 차원 낮은 2차원 경계이므로 평면으로 나타나 공간을 두 반공간으로 분할한다(오른쪽); 따라서 빨간 점과 초록 점처럼 서로 다른 클래스의 관측치들은 이 직선/평면의 서로 다른 쪽에 위치하게 되며, 어떤 점 x가 <span class="math inline">\(\beta_{0} + \beta_{1}x_{1} + \cdots + \beta_{p}x_{p}\)</span>의 부호에 따라 초평면의 어느 편에 놓이는지가 분류 결과를 결정한다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image5.png" style="width:4.5in;height:1.90435in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<p>분리 초평면을 이용한 분류</p>
<p>이제 p차원 공간에 있는 n개의 훈련 관측치로 이루어진 <span class="math inline">\(n \times p\)</span> 데이터 행렬 X, <span class="math inline">\(x_{1} = \left( \begin{array}{r}
x_{11} \\
\vdots \\
x_{1p}
\end{array} \right),\ldots,x_{n} = \left( \begin{array}{r}
x_{n1} \\
\vdots \\
x_{np}
\end{array} \right)\)</span>가 있다고 하자. 또한 이 관측치들이 두 클래스에 속한다고 하자. 즉, <span class="math inline">\(y_{1},\ldots,y_{n} \in \{ - 1,1\}\)</span>이며, -1은 한 클래스를, 1은 다른 클래스를 나타낸다.</p>
<p>아울러 관측될 특성 벡터가 p차원인 테스트 관측치 <span class="math inline">\(x^{*} = (x_{1}^{*},\ldots,x_{p}^{*})^{\top}\)</span>도 하나 존재한다고 하자. 우리의 목표는 훈련 데이터에 기반하여, 테스트 관측치의 특성 측정값을 이용해 이를 올바르게 분류하는 분류기를 개발하는 것이다.</p>
<p>훈련 관측치들이 클래스 라벨에 따라 완벽히 분리되도록 하는 초평면이 존재한다고 하자. 이때 분리 초평면은 모든 훈련표본에 대해 다음 성질을 만족한다:</p>
<p><span class="math inline">\(y_{i}(\beta_{0} + \beta^{\top}x_{i}) &gt; 0,i = 1,\ldots,n\)</span> 만약 분리 초평면이 존재한다면 이를 이용해 매우 자연스러운 분류 규칙을 구성할 수 있다. 즉, 결정함수 <span class="math inline">\(f(x) = \beta_{0} + \beta^{\top}x\)</span>의 부호에 따라 테스트 관측치 <span class="math inline">\(x^{*}\)</span>를 분류하며, <span class="math inline">\(\widehat{y}(x^{*}) = sign(f(x^{*}))\)</span>로 정의된다. 다시 말해 <span class="math inline">\(f(x^{*}) &gt; 0\)</span>이면 클래스 +1, <span class="math inline">\(f(x^{*}) &lt; 0\)</span>이면 클래스 -1로 할당한다.</p>
<p>또한 <span class="math inline">\(y(x^{*})\)</span>의 크기도 활용할 수 있다. <span class="math inline">\(y(x^{*})\)</span>가 0에서 멀면, <span class="math inline">\(x^{*}\)</span>가 초평면에서 멀리 떨어져 있다는 뜻이므로 분류에 대한 확신이 커진다. 반대로 0에 가까우면 <span class="math inline">\(x^{*}\)</span>는 초평면 근처에 위치하므로 분류 확신이 낮아진다. 분리 초평면에 기반한 분류기는 선형 결정경계(linear decision boundary)를 만든다.</p>
<p>최대 마진 분류기 (The Maximal Margin Classifier)</p>
<p>일반적으로 데이터가 초평면으로 완벽히 분리될 수 있다면, 실제로 그런 초평면은 무한히 많이 존재한다. 이는 어떤 분리 초평면이라도 관측치들과 접촉하지 않는 한, 약간 위아래로 평행 이동하거나 회전시킬 수 있기 때문이다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image6.png" style="width:2.09183in;height:1.78394in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<p>자연스러운 선택은 최대 마진 초평면(maximal margin hyperplane)(또는 최적 분리 초평면(optimal separating hyperplane))이다. 이는 훈련 관측치들로부터 가장 멀리 떨어진 분리 초평면을 말한다.</p>
<p>구체적으로, 각 분리 초평면에 대해 각 훈련 관측치로부터 그 초평면까지의 (수직) 거리를 계산할 수 있으며, 그 거리들 중 가장 작은 값이 <span dir="rtl">”</span>관측치에서 초평면까지의 최소거리”가 된다.</p>
<p>이 최소거리를 마진(margin)이라 부른다. 최대 마진 초평면은 이 마진이 가장 큰 분리 초평면, 즉 훈련 관측치들로부터의 최소거리가 최대가 되는 초평면이다.</p>
<p>몇몇 훈련 관측치가 최대 마진 초평면과 동일한 최소 거리를 가지며 마진 경계(점선) 위에 놓여, 결과적으로 마진의 폭과 초평면의 위치를 결정하고 있음을 볼 수 있는데, 이러한 관측치들을 서포트 벡터(support vectors)라고 한다.</p>
<p>서포트 벡터는 p차원 특성공간의 점으로서, 이 점들이 조금만 이동해도 <span dir="rtl">”</span>가장 가까운 점”이 바뀌기 때문에 최대 마진 초평면 역시 함께 이동하게 된다는 의미에서 초평면을 <span dir="rtl">’</span>지지(support)<span dir="rtl">’</span>한다.</p>
<p>최대 마진 초평면이 전체 데이터에 의해 정해지는 것이 아니라 오직 서포트 벡터들에 의해 직접적으로 결정된다는 사실이며, 다른 관측치들은 마진 경계 안쪽으로 들어오지만 않는 한(즉 마진을 침범하지 않는 한) 위치가 다소 변해도 초평면에 영향을 주지 않는다. 이러한 <span dir="rtl">”</span>경계 근처의 소수 관측치만이 결정경계를 규정한다”는 성질은 이후 서포트 벡터 분류기와 서포트 벡터 머신의 핵심 원리로 다시 등장한다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image7.png" style="width:4.5in;height:3in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<p>이제 테스트 관측치가 최대 마진 초평면의 어느 쪽에 위치하는지를 기준으로 분류할 수 있고, 이를 최대 마진 분류기(maximal margin classifier)라 한다.</p>
<p>훈련 데이터에서 마진이 큰 분류기는 테스트 데이터에서도 마진이 클 것이며, 따라서 테스트 관측치도 올바르게 분류할 것이라고 기대한다. 최대 마진 분류기는 종종 성공적이지만, p가 클 때는 과적합을 유발할 수도 있다.</p>
<p>만약 <span class="math inline">\(\beta_{0},\beta_{1},\ldots,\beta_{p}\)</span>가 최대 마진 초평면의 계수라면, 최대 마진 분류기는 <span class="math inline">\(f(x^{*}) = \beta_{0} + \beta_{1}x_{1}^{*} + \beta_{2}x_{2}^{*} + \cdots + \beta_{p}x_{p}^{*}\)</span>의 부호에 따라 테스트 관측치 <span class="math inline">\(x^{*}\)</span>를 분류한다.</p>
<p>최대 마진 분류기의 구성</p>
<p>이제 n개의 훈련 관측치 <span class="math inline">\(x_{1},\ldots,x_{n} \in \mathbb{R}^{p}\)</span>와 클래스 라벨 <span class="math inline">\(y_{1},\ldots,y_{n} \in \{ - 1,1\}\)</span>가 주어졌을 때, 최대 마진 초평면을 구성하는 문제를 생각하자. 간단히 말해, 최대 마진 초평면은 다음 최적화 문제의 해이다.</p>
<p><span class="math display">\[\begin{matrix}
\underset{\beta_{0},\beta_{1},\ldots,\beta_{p},M}{\text{maximize}} &amp; M \\
\text{subject to} &amp; \overset{p}{\sum_{j = 1}}\beta_{j}^{2} = 1, \\
&amp; y_{i}(\beta_{0} + \beta_{1}x_{i1} + \beta_{2}x_{i2} + \cdots + \beta_{p}x_{ip}) \geq M,i = 1,\ldots,n.
\end{matrix}\]</span></p>
<p>M이 양수일 때 각 관측치가 초평면의 올바른 쪽에 놓이도록 보장한다. 사실 각 관측치가 올바른 쪽에 있기 위해서는 <span class="math inline">\(y_{i}(\beta_{0} + \beta_{1}x_{i1} + \cdots + \beta_{p}x_{ip}) &gt; 0\)</span>이면 충분하다. 따라서 위 식의 제약은, M&gt;0인 경우 각 관측치가 <span dir="rtl">”</span>여유(cushion”를 갖고 올바른 쪽에 위치하도록 더 강하게 요구하는 것이다.</p>
<p>둘째로, <span class="math inline">\(\overset{p}{\sum_{j = 1}}\beta_{j}^{2} = 1\)</span> 은 초평면 자체에 대한 제약이라기보다는 스케일을 고정하기 위한 조건이다. 왜냐하면 <span class="math inline">\(\beta_{0} + \beta_{1}x_{i1} + \cdots + \beta_{p}x_{ip} = 0\)</span>이 어떤 초평면을 정의한다면, <span class="math inline">\(k \neq 0\)</span>인 임의의 상수 k에 대해 <span class="math inline">\(k(\beta_{0} + \beta_{1}x_{i1} + \cdots + \beta_{p}x_{ip}) = 0\)</span>도 동일한 초평면을 정의하기 때문이다.</p>
<p>이 제약하에서 i번째 관측치가 초평면까지 갖는 수직거리는 <span class="math inline">\(y_{i}(\beta_{0} + \beta_{1}x_{i1} + \beta_{2}x_{i2} + \cdots + \beta_{p}x_{ip})\)</span>로 주어진다는 것을 보일 수 있다.</p>
<p>따라서 제약식은 각 관측치가 초평면의 올바른 쪽에 놓이면서 동시에 초평면으로부터 최소한 M만큼 떨어져 있도록 보장한다. 그러므로 M은 우리 초평면의 마진을 나타내며, 최적화 문제는 M을 최대화하는 <span class="math inline">\(\beta_{0},\beta_{1},\ldots,\beta_{p}\)</span>를 선택한다.</p>
<p>비분리인 경우: 하드 마진의 실패와 소프트 마진의 필요성</p>
<p>최대 마진 분류기(하드 마진)는 두 클래스가 어떤 초평면에 의해 완벽히 분리(linearly separable)될 수 있다는 가정 하에서 정의된다. 즉, 모든 훈련 표본이 올바른 쪽에 놓이면서 동시에 일정한 여유(마진)를 갖도록 <span class="math inline">\(y_{i}(\beta_{0} + \beta^{\top}x_{i}) \geq M,i = 1,\ldots,n,(M &gt; 0)\)</span>를 만족하는 초평면을 찾고, 그중 M을 최대화하는 해를 선택한다.</p>
<p>그러나 실제 데이터에서는 두 클래스가 서로 섞여 있어 어떤 직선(2차원) 또는 초평면(고차원)으로도 모든 관측치를 완전히 분리할 수 없는 비분리(non-separable) 상황이 빈번하다. 이 경우에는 모든 i에 대해 <span class="math inline">\(y_{i}(\beta_{0} + \beta^{\top}x_{i}) &gt; 0\)</span>을 동시에 만족하는 분리 초평면 자체가 존재하지 않으므로, 하드 마진 최적화 문제는 M&gt;0 인 해를 갖지 못하고, 결과적으로 최대 마진 분류기 또한 정의될 수 없다.<img src="media/image8.png" style="width:4.5in;height:3.23061in" alt="붙여넣은 동영상.png">이를 그림으로 이해하면 더 명확하다. 그림(비분리 + 마진)에서 실선은 후보 초평면 <span class="math inline">\(f(x) = \beta_{0} + \beta^{\top}x = 0\)</span>이고, 점선 두 개는 마진 경계 <span class="math inline">\(f(x) = \pm 1\)</span>을 나타낸다(이때 기하학적 마진 폭은 <span class="math inline">\(1/ \parallel \beta \parallel\)</span>) 이상적인 하드 마진 분류기라면 모든 파란 점(+1)은 <span class="math inline">\(f(x) \geq + 1\)</span> 쪽에, 모든 주황 점(-1)은 <span class="math inline">\(f(x) \leq - 1\)</span> 쪽에 위치해야 한다. 하지만 실제로는 일부 점들이 마진 내부로 들어오거나(마진 침범), 심지어 반대편으로 넘어가기도(오분류) 하며, 그림에서는 이러한 점들을 테두리로 강조해 표시했다. 즉, 어떤 초평면을 선택하더라도 <span dir="rtl">”</span>모든 점을 마진 밖으로 밀어내는” 하드 마진 조건을 만족시키기 어렵기 때문에, 하드 마진은 현실 데이터에 그대로 적용될 수 없다.</p>
<p>따라서 비분리 상황에서는 <span dir="rtl">”</span>정확히(exactly) 분리”를 포기하고, 일부 위반을 허용하는 방식으로 문제를 확장해야 한다. 이것이 소프트 마진(soft margin)이며, 각 관측치가 마진 조건을 얼마나 위반했는지를 나타내는 슬랙 변수 <span class="math inline">\(\xi_{i} \geq 0\)</span>를 도입하여 <span class="math inline">\(y_{i}(\beta_{0} + \beta^{\top}x_{i}) \geq 1 - \xi_{i},i = 1,\ldots,n\)</span>처럼 제약을 완화한다. 그리고 <span dir="rtl">”</span>마진을 크게(단순한 경계)” 유지하려는 목표와 <span dir="rtl">”</span>위반을 작게(오분류/침범 최소화)” 하려는 목표를 동시에 고려하여<span class="math inline">\(\min_{\beta_{0},\beta,\xi}\frac{1}{2} \parallel \beta \parallel^{2} + C\overset{n}{\sum_{i = 1}}\xi_{i}\text{s.t.}y_{i}(\beta_{0} + \beta^{\top}x_{i}) \geq 1 - \xi_{i},\xi_{i} \geq 0\)</span>를 푼다.</p>
<p>이때 C는 위반을 얼마나 강하게 벌점할지(즉, 오분류 허용 vs 마진 확보의 균형)를 조절하는 튜닝 파라미터이며, 이러한 소프트 마진 최대 마진 방법을 서포트 벡터 분류기(support vector classifier)라고 부른다. 이후 커널을 도입해 비선형 경계까지 확장한 것이 서포트 벡터 머신(SVM)이다.</p>
<p>서포트 벡터 분류기</p>
<p>개념</p>
<p>두 클래스의 관측치가 특성공간에서 서로 섞여 있는 경우에는, 어떤 초평면을 그어도 모든 점을 완벽하게 양쪽으로 나누는 것이 불가능하다.</p>
<p>따라서 최대 마진 분류기가 요구하는 것처럼 <span dir="rtl">”</span>모든 훈련점이 올바른 쪽에 있으면서 동시에 마진 바깥에 위치”하도록 만드는 조건을 만족시킬 수 없고, 그 결과 최대 마진 분류기 자체가 성립하지 않거나 적용될 수 없다.</p>
<p>현실의 데이터는 잡음, 측정오차, 클래스 중첩 등으로 인해 이러한 비분리 상황이 흔하므로, 완벽한 분리를 전제로 하는 접근은 근본적으로 적용 범위에 한계를 갖는다.</p>
<p>더 나아가, 데이터가 우연히 선형적으로 분리 가능한 경우라 하더라도 <span dir="rtl">”</span>완벽 분리”가 항상 바람직한 목표는 아니다. 아래 그림이 보여주듯, 단 하나의 관측치가 추가되거나 위치가 조금만 바뀌어도 최대 마진 초평면이 크게 이동할 수 있는데, 이는 최대 마진 해가 특정 관측치(특히 경계 근처의 점이나 이상치)에 매우 민감하다는 뜻이다.</p>
<p>이런 민감성은 결과적으로 마진을 지나치게 작게 만들어 분류 경계 주변에서의 판단을 불안정하게 하고(즉, 예측 확신을 떨어뜨리고), 데이터의 작은 변동에 따라 결정경계가 크게 요동치게 하여 일반화 성능을 해치는 과적합 위험을 증가시킨다.</p>
<p>따라서 <span dir="rtl">”</span>훈련 데이터를 완벽히 맞추는 분리 초평면”이 존재한다는 사실만으로 그 분류기가 좋은 모델이라고 결론내릴 수는 없으며, 오히려 일정 수준의 위반을 허용하는 더 강건한 접근이 필요해진다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image9.png" style="width:2.88028in;height:2.47865in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<p>소프트 마진의 직관</p>
<p>소프트 마진의 핵심 직관은 <span dir="rtl">”</span>훈련 데이터를 한 점도 틀리지 않게 맞추는 것”을 절대 목표로 삼기보다, 약간의 오류를 허용하더라도 전체적으로 더 안정적이고 일반화가 잘 되는 분류기를 만들자는 데 있다.</p>
<p>현실 데이터에서는 경계 근처의 애매한 점이나 이상치 하나가 결정경계를 크게 흔들 수 있는데, 완벽 분리를 강제하면 이러한 개별 관측치에 과도하게 끌려가면서 모델이 불안정해지기 쉽다.</p>
<p>따라서 소프트 마진은 일부 관측치가 마진을 침범하거나 심지어 오분류되는 것을 제한적으로 허용함으로써, 특정 몇 점에 대한 민감도를 낮추고 분류기를 더 강건하게 만든다.</p>
<p>그 결과 모든 훈련 표본을 완벽히 맞추는 대신, 훈련 데이터의 <span dir="rtl">”</span>대부분”을 더 잘 설명하고 새로운 데이터에서도 성능이 유지되는 방향으로 균형을 잡게 된다. 이런 철학을 수학적으로 구현한 방법이 바로 서포트 벡터 분류기이며, 마진 위반을 허용한다는 의미에서 소프트 마진 분류기라고도 부른다.</p>
<p>서포트 벡터 분류기의 수식</p>
<p>목표: 마진 M을 크게 하되, 위반을 허용한다.</p>
<p><span class="math inline">\(\begin{matrix}
\text{maximize} &amp; M \\
\text{subject to} &amp; \parallel \beta \parallel^{2} = 1 \\
&amp; y_{i}(\beta_{0} + \beta^{\top}x_{i}) \geq M(1 - \varepsilon_{i}),i = 1,\ldots,n \\
&amp; \varepsilon_{i} \geq 0,\overset{n}{\sum_{i = 1}}\varepsilon_{i} \leq C
\end{matrix}\)</span>, 여기서 핵심은 슬랙 변수 <span class="math inline">\(\varepsilon_{i}\)</span>와 튜닝 파라미터 C이다.</p>
<p>슬랙변수</p>
<p>슬랙 변수 <span class="math inline">\(\varepsilon_{i}\)</span>는 각 관측치 i가 다음 제약을 얼마나 위반하는지를 나타낸다. <span class="math inline">\(y_{i}f(x_{i}) \geq M(1 - \varepsilon_{i})\)</span> 또는 표준화 하면</p>
<p><span class="math inline">\(y_{i}f(x_{i}) \geq 1 - \varepsilon_{i}\text{)}\)</span>이다. 즉, <span class="math inline">\(\varepsilon_{i}\)</span>는 <span dir="rtl">”</span>그 점이 얼마나 문제를 일으키는지(마진 침범/오분류)“를 정량화한다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image10.png" style="width:4.5in;height:1.88538in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<p>이 그림은 실선으로 표시된 초평면(결정경계)과 점선으로 표시된 마진 경계를 기준으로, 슬랙 변수 <span class="math inline">\(\varepsilon_{i}\)</span>가 각 관측치의 <span dir="rtl">”</span>마진/경계 위반 정도”를 어떻게 의미하는지를 기하학적으로 설명한다.</p>
<p>어떤 관측치가 자신의 클래스에 해당하는 마진 바깥쪽(점선 밖)에 위치하면 충분한 여유를 두고 올바르게 분류된 것이므로 <span class="math inline">\(\varepsilon_{i} = 0\)</span>으로 해석된다.</p>
<p>반대로 관측치가 초평면의 올바른 쪽에 있기는 하지만 점선과 실선 사이의 마진 내부로 들어오면 분류는 맞지만 여유가 부족한 상태이므로 <span class="math inline">\(0 &lt; \varepsilon_{i} &lt; 1\)</span>로, 즉 마진을 침범한 것으로 해석된다.</p>
<p>더 나아가 관측치가 실선을 넘어 초평면의 반대쪽에 놓이면 이는 오분류에 해당하며, 마진 위반을 넘어 경계 자체를 위반한 상황이므로 <span class="math inline">\(\varepsilon_{i} &gt; 1\)</span>로 해석된다.</p>
<p>이러한 관점에서 왼쪽 패널은 대부분의 점들이 <span class="math inline">\(\varepsilon_{i} = 0\)</span>인 상태로 마진 바깥에 있으나 일부 점이 <span class="math inline">\(0 &lt; \varepsilon_{i} &lt; 1\)</span>처럼 마진을 위반할 수 있음을 보여주고, 오른쪽 패널은 점이 추가되면 일부가 초평면의 반대편으로 넘어가 <span class="math inline">\(\varepsilon_{i} &gt; 1\)</span>인 오분류까지 제한적으로 허용해야 할 수도 있음을 보여준다.</p>
<p>따라서 이 그림은 소프트 마진 분류기에서 슬랙 변수의 값이 0, 양수, 그리고 1을 초과할 때 각각이 어떤 기하학적 상황을 뜻하는지를 대표적으로 시각화한 예시라고 정리할 수 있다.</p>
<p>튜닝 파라미터 C</p>
<p>C는 서포트 벡터 분류기(소프트 마진 SVM)에서 사용자가 정하는 튜닝 파라미터(hyperparameter)이다. C는 슬랙 변수 <span class="math inline">\(\varepsilon_{i}\)</span>를 통해 마진 위반(및 오분류)을 얼마나 허용할지를 조절하며, 그 결과 결정경계의 위치와 마진 폭이 달라져 일반화 성능에 큰 영향을 준다.</p>
<p>따라서 C는 보통 교차검증으로 여러 후보값을 비교해 검증(테스트) 성능이 가장 좋은 값으로 선택한다.</p>
<p>이 그림은 동일한 데이터에 대해 서포트 벡터 분류기(소프트 마진)를 적합할 때, 튜닝 파라미터 C 값을 달리하면 결정경계(실선)와 마진(점선)이 어떻게 달라지는지를 4개의 패널로 비교한 것이다. 각 패널에서 굵은 실선은 분류 초평면 <span class="math inline">\(f(x) = 0\)</span>이고, 양쪽의 점선은 마진 경계(예: <span class="math inline">\(f(x) = \pm M\)</span> 또는 표준화된 <span class="math inline">\(\pm 1\)</span>)를 나타낸다.</p>
<p>제약식 <span class="math inline">\(\sum_{i}\varepsilon_{i} \leq C\)</span>에서 C는 마진 위반을 허용하는 총량(예산)이므로, C가 클수록 마진 위반(마진 안쪽 진입, 심지어 오분류까지)에 대해 더 관대해진다.</p>
<p>그 결과, 모델은 <span dir="rtl">”</span>모든 점을 마진 밖에 두려고 애쓰는” 대신 더 넓은 마진을 확보하는 방향으로 초평면을 선택할 수 있으며, 실제로 그림에서도 C가 큰 패널일수록 점선(마진)이 더 넓게 벌어지는 경향이 나타난다.</p>
<p>반대로 C가 작아지면 위반 예산이 줄어들어, 마진을 크게 잡으면 곧바로 많은 점들이 마진을 침범해 <span class="math inline">\(\sum\varepsilon_{i}\)</span>가 커지기 때문에, 모델은 마진을 좁히는 쪽(점선 간격 축소)으로 조정하게 된다. 즉, <span class="math inline">\(C \downarrow\)</span>일수록 마진이 점점 좁아지고, 결정경계는 <span dir="rtl">”</span>마진 위반을 최소화”하는 쪽으로 재배치된다.<img src="media/image11.png" style="width:4.5in;height:4.37475in" alt="붙여넣은 동영상.png">결론적으로 이 그림은 C가 <span dir="rtl">”</span>위반 허용 정도”를 조절하며, C의 변화가 마진 폭(복잡도)과 경계 위치를 바꾸어 일반화 성능에 영향을 준다는 점을 시각적으로 보여준다.</p>
<p>SVM support vector machine</p>
<p>서포트 벡터 분류기(소프트 마진)는 본질적으로 선형 결정경계를 만든다. 그러나 실제 데이터에서는 클래스 경계가 선형이 아닌 경우가 많으며, 이때 선형 분류기는 구조적으로 성능 한계를 가진다. 여기서는 <span dir="rtl">”</span>선형 분류기 → 비선형 결정경계”로 확장하는 일반 메커니즘을 먼저 설명한 뒤, 이를 커널을 통해 계산적으로 효율적으로 구현하는 서포트 벡터 머신(SVM)을 소개한다.</p>
<p>비선형 결정경계가 필요한 이유와 특성공간 확장 아이디어</p>
<p>서포트 벡터 분류기는 두 클래스의 경계가 선형이면 매우 자연스럽고 강력하다. 하지만 실제로는 경계가 비선형인 경우가 있으며, 이때는 어떤 선형 분류기(서포트 벡터 분류기 포함)도 적절한 분류를 수행하기 어렵다.</p>
<p>아래 그림은 두 클래스의 경계가 곡선 형태(비선형)임을 보여주므로(왼쪽) 서포트 벡터 분류기는 선형 경계만 찾으므로, 최선의 직선을 그어도 경계를 제대로 따라가지 못해 성능이 매우 나빠진다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image12.png" style="width:4.5in;height:2.25455in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<p>회귀에서의 비선형성 처리와의 유사성</p>
<p>회귀분류에서도 X–Y 관계가 비선형이면 선형회귀가 성능이 떨어지고, 이를 해결하기 위해 <span class="math inline">\(X^{2},X^{3}\)</span> 같은 비선형 변환(기저함수)을 추가해 특성공간을 확장한다.</p>
<p>분류에서도 동일한 전략이 가능하다. 즉, 원래 입력변수 <span class="math inline">\(X_{1},\ldots,X_{p}\)</span>만 쓰지 말고, 제곱항/세제곱항/상호작용항 등을 추가한 새로운 특성들로 분류기를 학습하면, 원래 공간에서는 비선형 경계를 만들 수 있다.</p>
<p>원래 p개 특성 <span class="math inline">\(X_{1},X_{2},\ldots,X_{p}\)</span> 대신, 제곱항을 포함한 2p개 특성 <span class="math inline">\(X_{1},X_{1}^{2},X_{2},X_{2}^{2},\ldots,X_{p},X_{p}^{2}\)</span>로 서포트 벡터 분류기를 적합할 수 있다.</p>
<p>왜 비선형 경계가 생기는가?</p>
<p>확장된 특성공간에서는 결정경계가 여전히 선형이다. 하지만 원래 입력공간으로 되돌아오면 그 경계는 x에 대한 2차식(또는 더 높은 차수)이 되어 일반적으로 비선형 곡선이 된다. 원문 표현을 따르면, 원래 공간에서 결정경계는 <span class="math inline">\(q(x) = 0\)</span>꼴(여기서 q는 2차 다항식)이며, 해집합은 보통 비선형이다.</p>
<p>문제점: 특성 수 폭발</p>
<p>이 접근은 이론적으로 간단하지만, 다항차수를 올리거나 상호작용항 <span class="math inline">\(X_{j}X_{j'}(j \neq j')\)</span>까지 추가하면 특성 수가 매우 커진다. 그러면 계산이 급격히 어려워져 <span dir="rtl">”</span>특성을 확장하는 방식”만으로는 실용성이 떨어질 수 있다. 이를 효율적으로 구현하는 장치가 커널이며, 이것이 SVM의 핵심이다.</p>
<p><span dir="rtl">”</span>내적만 쓰는 해”와 커널 트릭</p>
<p>해는 관측치의 <span dir="rtl">”</span>내적(inner product)“만으로 표현된다 서포트 벡터 분류기 해를 직접 푸는 계산은 기술적으로 복잡해 생략하지만, 놀랍게도 그 해는 관측치 자체가 아니라 내적만으로 구성된다는 점을 강조한다.</p>
<p>두 벡터 <span class="math inline">\(a,b \in \mathbb{R}^{p}\)</span>의 내적은 <span class="math inline">\(\langle a,b\rangle = \overset{p}{\sum_{j = 1}}a_{j}b_{j}\)</span>이다. 두 관측치 <span class="math inline">\(x_{i},x_{i'}\)</span>의 내적은 <span class="math inline">\(\langle x_{i},x_{i'}\rangle = \overset{p}{\sum_{j = 1}}x_{ij}x_{i'j}\)</span>이다.</p>
<p>그리고 선형 서포트 벡터 분류기의 결정함수는 다음과 같은 형태로 쓸 수 있다. <span class="math inline">\(f(x) = \beta_{0} + \overset{n}{\sum_{i = 1}}\alpha_{i}\langle x,x_{i}\rangle\)</span>. 즉, 새로운 점 x를 분류하려면 훈련점들과의 내적 \langle x, x_i\rangle만 계산하면 된다.</p>
<p>서포트 벡터만 남는다(희소성)</p>
<p>또 하나의 핵심 성질은 <span class="math inline">\(\alpha_{i}\)</span>가 서포트 벡터에 대해서만 0이 아니다라는 점이다. 서포트 벡터 인덱스 집합을 S라 두면, <span class="math inline">\(f(x) = \beta_{0} + \sum_{i \in S}\alpha_{i}\langle x,x_{i}\rangle\)</span>이다. 즉, 실제 예측에는 소수의 점(서포트 벡터)만 관여하므로 계산이 효율적이고, 경계 근처의 핵심 표본만이 결정경계를 규정한다.</p>
<p>커널의 도입: 내적을 <span class="math inline">\(K( \cdot , \cdot )\)</span>로 바꿔치기</p>
<p>내적이 등장하는 모든 곳에서 <span class="math inline">\(\langle x_{i},x_{i'}\rangle \rightarrow K(x_{i},x_{i'})\)</span>로 바꾸면, 마치 <span dir="rtl">”</span>확장된 특성공간에서 선형분류”를 한 것과 같은 효과를 얻으면서도, 실제로는 그 공간으로 명시적으로 가지 않아도 된다.</p>
<p>이때 K를 커널이라 부르며, <span dir="rtl">”</span>두 관측치의 유사도”를 수치로 제공하는 함수다.</p>
<p>선형 커널: <span class="math inline">\(K(x_{i},x_{i'}) = \overset{p}{\sum_{j = 1}}x_{ij}x_{i'j}\)</span> → 이 경우는 결국 선형 서포트 벡터 분류기로 돌아간다.</p>
<p>다항 커널: <span class="math inline">\(K(x,x') = (1 + x^{\top}x')^{d}\)</span>, 여기서 d는 다항 차수. d&gt;1이면 훨씬 유연한(비선형) 결정경계를 만들 수 있다. 이는 <span dir="rtl">”</span>고차원 다항 특성공간에서 선형분류를 한 것”과 같은 효과다.</p>
<p>방사형(Radial, RBF) 커널: , <span class="math inline">\(K(x_{i},x_{i'}) = \exp\left( - \gamma\overset{p}{\sum_{j = 1}}(x_{ij} - x_{i'j})^{2} \right)\)</span>, 여기서 <span class="math inline">\(\gamma &gt; 0\)</span>. 두 점이 가까우면 K가 1에 가깝고, 멀면 0에 가까워진다. 즉, <span dir="rtl">”</span>가까운 점만 영향력이 있다”는 지역적 특성을 갖는다.</p>
<p>커널을 쓰는 SVM의 결정함수는 다음과 같이 쓴다:</p>
<p><span class="math inline">\(f(x) = \beta_{0} + \sum_{i \in S}\alpha_{i}K(x,x_{i})\)</span>. 이 식은 <span dir="rtl">”</span>비선형 SVM의 예측이 결국 서포트 벡터들과의 커널 유사도 합”으로 이루어진다는 의미다.</p>
<p>RBF 커널의 직관</p>
<p>RBF 커널에서 어떤 테스트 점 <span class="math inline">\(x^{*}\)</span>가 훈련점 <span class="math inline">\(x_{i}\)</span>와 매우 멀면 <span class="math inline">\(\parallel x^{*} - x_{i} \parallel^{2}\)</span>가 커져 <span class="math inline">\(K(x^{*},x_{i}) \approx 0\)</span>이 된다. 그러면 해당 <span class="math inline">\(x_{i}\)</span>의 기여는 거의 사라진다. 즉, 멀리 있는 훈련점은 예측에 거의 영향을 주지 않고, 가까운 점들만 영향력을 갖는다. 이것이 RBF 커널이 매우 유연한 비선형 경계를 만들 수 있는 이유 중 하나다.</p>
<p>아래 그림은 선형 결정경계로는 잘 분리되지 않는 비선형 데이터에 대해, 커널 SVM이 어떻게 비선형 결정경계를 학습하는지를 두 가지 커널로 비교해 보여준다.</p>
<p>왼쪽 패널은 3차 다항 커널을 사용한 SVM 결과로, 원래 입력공간에서는 곡선 형태로 나타나는 결정경계를 만들어 중심부의 보라색 군집과 주변의 파란 점들을 비교적 자연스럽게 구분한다.</p>
<p>즉, 다항 커널이 고차 다항 특성공간에서의 선형 분리를 암묵적으로 수행한 결과, 원래 공간에서는 <span dir="rtl">’</span>휘어진<span dir="rtl">’</span> 경계가 형성된 것이다. 오른쪽 패널은 방사형(RBF, radial) 커널을 사용한 SVM 결과로, 보라색 군집을 둘러싸는 폐곡선 형태의 경계가 나타나며, 이는 RBF 커널이 거리 기반의 국소적 유사도를 이용해 매우 유연한 비선형 경계를 만들 수 있음을 보여준다.</p>
<p>두 패널 모두 배경의 색/격자는 해당 위치의 점이 어느 클래스로 분류되는지를 나타내며, 결과적으로 이 예시에서는 다항 커널과 RBF 커널 모두 비선형 경계를 성공적으로 포착하여 선형 분류기에서 발생했던 성능 저하를 크게 개선할 수 있음을 시각적으로 확인할 수 있다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image13.png" style="width:4.5in;height:2.23636in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<p><span class="math inline">\(\gamma\)</span>와 C: 결정경계 복잡도와 Bias–Variance</p>
<p>C: 마진 위반(오분류/침범) 허용 정도</p>
<p>소프트 마진 SVM은 <span dir="rtl">”</span>마진을 크게 유지하려는 목표”와 <span dir="rtl">”</span>훈련 데이터의 위반(슬랙)을 줄이려는 목표”를 균형 있게 조절한다. 일반적인 표준 형태(hinge loss 관점)로는 <span class="math inline">\(\min_{\beta_{0},\beta}\frac{1}{2} \parallel \beta \parallel^{2} + C\overset{n}{\sum_{i = 1}}\max\{ 0,1 - y_{i}f(x_{i})\}\)</span>로 쓸 수 있으며, 여기서 C가 클수록 위반을 더 강하게 벌점하여 훈련오차를 줄이려는 압력이 커진다.</p>
<p>그 결과 경계는 데이터에 더 민감해져 유연성이 증가(분산 증가)할 수 있고, C가 작을수록 마진을 넓게 두고 위반을 더 허용하는 방향으로 경계가 매끈해져 과적합을 완화(분산 감소)하는 경향이 있다. (교재에서 C를 \sum \varepsilon_i\le C 형태의 <span dir="rtl">”</span>예산”으로 소개하는 경우는 표기상 방향이 달라 보일 수 있으나, 핵심은 <span dir="rtl">”</span>C가 마진-오분류의 절충을 조절한다”는 점이다.)</p>
<p><span class="math inline">\(\gamma\)</span>: RBF 커널의 국소성(곡률) 조절</p>
<p><span class="math inline">\(\gamma\)</span>는 RBF 커널에서 거리 <span class="math inline">\(\parallel x - x' \parallel^{2}\)</span>에 대한 민감도를 정한다.</p>
<p><span class="math inline">\(\gamma\)</span>가 작으면, 커널이 완만하게 감소하여 넓은 범위의 점들이 서로 영향을 주고, 결정경계가 비교적 매끈해진다(고편향·저분산 방향).</p>
<p><span class="math inline">\(\gamma\)</span>가 크면, 아주 가까운 점만 영향을 주어 경계가 국소적으로 급격히 휘어질 수 있다(저편향·고분산 방향).</p>
<p><span class="math inline">\(\gamma\)</span>를 크게 하면 훈련 ROC는 거의 완벽해질 수 있지만, 테스트에서는 오히려 성능이 악화될 수 있다. 즉, <span class="math inline">\(\gamma\)</span>는 <span dir="rtl">”</span>훈련 성능을 극대화”하기보다 <span dir="rtl">”</span>일반화 성능을 최적화”하는 관점에서 선택되어야 한다.</p>
<p>결합 효과: C–<span class="math inline">\(\gamma\)</span>의 상호작용</p>
<p>RBF SVM에서 유연성은 C와 <span class="math inline">\(\gamma\)</span>의 조합으로 결정된다.</p>
<p>C가 크고 <span class="math inline">\(\gamma\)</span>도 크면: 훈련 데이터를 매우 강하게 맞추는 방향(복잡한 경계) → 과적합 위험 최고.</p>
<p>C가 작고 <span class="math inline">\(\gamma\)</span>도 작으면: 경계가 매우 매끈(단순) → 과소적합 위험.</p>
<p>따라서 두 파라미터는 함께 튜닝해야 하며, 어느 하나만 조절하면 <span dir="rtl">”</span>복잡도 통제가 불완전”할 수 있다.</p>
<p>C와 <span class="math inline">\(\gamma\)</span>를 어떻게 선택하는가?</p>
<p>(1) 스케일링(표준화)은 사실상 필수</p>
<p>특히 RBF 커널은 <span class="math inline">\(\parallel x - x' \parallel^{2}\)</span>에 직접 의존하므로, 변수 스케일이 다르면 특정 변수에 의해 거리가 지배되어 \gamma 해석과 최적화가 왜곡된다. 따라서 SVM을 적용할 때는 보통 <span class="math inline">\(x_{ij}^{(std)} = \frac{x_{ij} - {\overline{x}}_{j}}{s_{j}}\)</span>로 표준화한 뒤 모델을 학습한다(훈련 기준으로 변환).</p>
<p>(2) 그리드 탐색 + 교차검증이 기본</p>
<p>가장 널리 쓰이는 방법은 로그 스케일의 후보 집합을 두고 교차검증으로 최적 조합을 찾는 것이다.</p>
<p><span class="math inline">\(C \in \{ 2^{- 5}{,2}^{- 3},\ldots{,2}^{15}\},\gamma \in \{ 2^{- 15}{,2}^{- 13},\ldots{,2}^{3}\}\)</span>처럼 잡고, 각 조합에 대해 교차검증 성능(Accuracy/F1/AUC 등)을 평가하여 최고 성능 조합을 선택한다. 성능이 비슷한 조합이 여러 개면, 일반적으로 더 단순한(더 매끈한) 경계 쪽을 택해 과적합 위험을 줄인다.</p>
<p>(3) 평가 지표 선택</p>
<p>불균형 데이터에서는 Accuracy가 오해를 만들 수 있으므로 AUC, F1, PR-AUC, 민감도/특이도 균형 등 과제에 맞는 지표로 튜닝해야 한다. 특히 ROC 곡선은 임계값 변화에 따른 성능을 한눈에 보여주지만, 그림 9.10–9.11처럼 훈련 ROC만으로는 과적합을 판별할 수 없으므로 반드시 검증/테스트 ROC를 함께 확인해야 한다.</p>
<p>(4) 요약: <span dir="rtl">”</span>훈련 성능 ↑“가 목표가 아니라 <span dir="rtl">”</span>일반화 성능 최적화”</p>
<p>SVM은 커널과 튜닝 파라미터에 따라 매우 유연해져 훈련 성능을 거의 완벽하게 만들 수 있다. 그러나 이는 곧 과적합 가능성을 의미한다. 따라서 C와 <span class="math inline">\(\gamma\)</span>는 훈련 성능이 아니라 교차검증 기반 일반화 성능으로 선택해야 하며, 최종적으로는 독립된 테스트 셋에서 성능을 확인하는 절차가 필요하다.</p>
<p>두 개보다 많은 클래스에서의 SVM</p>
<p>지금까지의 논의는 이진 분류, 즉 두 클래스 상황에서의 분류에 한정되어 있었다. 그렇다면 클래스 수가 임의의 개수인 더 일반적인 경우(다중 분류)로 SVM을 어떻게 확장할 수 있을까?</p>
<p>SVM의 기반이 되는 분리 초평면이라는 개념은 두 개를 초과하는 클래스에 대해 자연스럽게 확장되지는 않는다. SVM을 K개 클래스의 경우로 확장하기 위한 여러 제안이 존재하지만, 그중 가장 널리 사용되는 두 가지 방법은 일대일 방식과 일대다 방식이다.</p>
<p>일대일 분류</p>
<p>SVM을 사용해 분류를 수행하려고 하는데 클래스가 K&gt;2개라고 하자. 일대일 또는 모든 쌍(all-pairs) 접근법은 각 클래스 쌍을 비교하는 SVM을 <span class="math inline">\(\binom{K}{2}\)</span>개 구축한다. 예를 들어, 어떤 SVM은 k번째 클래스를 +1로, k'번째 클래스를 -1로 코딩하여 두 클래스를 비교할 수 있다. 테스트 관측치 하나에 대해 <span class="math inline">\(\binom{K}{2}\)</span>개의 분류기를 모두 적용한 뒤, 그 테스트 관측치가 각 K개 클래스에 할당된 횟수를 집계한다. 최종 분류는 이러한 <span class="math inline">\(\binom{K}{2}\)</span>개의 쌍대 분류 결과에서 가장 자주 할당된 클래스로 테스트 관측치를 배정하는 방식으로 수행된다.</p>
<p>일대다 분류</p>
<p>일대다 접근법은 <span class="math inline">\(K &gt; 2\)</span>개 클래스 상황에서 SVM을 적용하는 또 다른 절차이다. 이 방법에서는 K개의 SVM을 적합시키는데, 매번 한 클래스를 나머지 <span class="math inline">\(K - 1\)</span>개 클래스와 비교한다. k번째 클래스를 +1로, 나머지 모든 클래스를 -1로 코딩하여 학습한 SVM에서 얻어지는 모수를 <span class="math inline">\(\beta_{0k},\beta_{1k},\ldots,\beta_{pk}\)</span>로 나타내자. 테스트 관측치를 <span class="math inline">\(x^{*}\)</span>라 하면, 우리는</p>
<p><span class="math inline">\(\beta_{0k} + \beta_{1k}x_{1}^{*} + \beta_{2k}x_{2}^{*} + \cdots + \beta_{pk}x_{p}^{*}\)</span> 값이 가장 큰 클래스로 그 관측치를 할당한다. 이는 해당 값이 클수록 테스트 관측치가 다른 어떤 클래스보다 k번째 클래스에 속한다는 확신이 높다는 것을 의미하기 때문이다.</p>
<p>로지스틱 회귀와의 관계</p>
<p>SVM이 1990년대 중반 처음 소개되었을 때, 통계학 및 머신러닝 커뮤니티에서 상당한 반향을 일으켰다. 이는 부분적으로 SVM의 좋은 성능과 효과적인 마케팅 덕분이기도 했고, 또한 그 기반 접근법이 새롭고도 신비롭게 보였기 때문이기도 하다.</p>
<p>즉, 어느 정도의 분리 위반을 허용하면서도 데이터를 가능한 한 잘 분리하는 초평면을 찾는다는 발상은 로지스틱 회귀나 선형판별분석 같은 고전적 분류 접근법과는 확연히 다른 것처럼 보였다. 더 나아가 비선형 클래스 경계를 수용하기 위해 커널을 사용하여 특성공간을 확장하는 아이디어는 독특하고 가치 있는 특징으로 여겨졌다.</p>
<p>그러나 그 이후로 SVM과 보다 고전적인 통계적 방법들 사이에 깊은 연결고리가 존재함이 드러났다. 실제로 서포트 벡터 분류기 <span class="math inline">\(f(X) = \beta_{0} + \beta_{1}X_{1} + \cdots + \beta_{p}X_{p}\)</span>를 적합하기 위한 기준식은 다음과 같이 다시 쓸 수 있다:</p>
<p><span class="math inline">\(\min_{\beta_{0},\beta_{1},\ldots,\beta_{p}}\left\{ \overset{n}{\sum_{i = 1}}\max\lbrack 0,1 - y_{i}f(x_{i})\rbrack + \lambda\overset{p}{\sum_{j = 1}}\beta_{j}^{2} \right\}\)</span>, 여기서 <span class="math inline">\(\lambda\)</span>는 0 이상의 튜닝 파라미터이다. <span class="math inline">\(\lambda\)</span>가 크면 <span class="math inline">\(\beta_{1},\ldots,\beta_{p}\)</span>는 작아지고, 마진에 대한 위반이 더 많이 허용되며, 그 결과 분산은 낮고 편향은 높은 분류기가 된다.</p>
<p>반대로 <span class="math inline">\(\lambda\)</span>가 작으면 마진 위반이 거의 발생하지 않게 되며, 이는 분산은 높고 편향은 낮은 분류기에 해당한다. 따라서 <span class="math inline">\(\lambda\)</span>가 작다는 것은 C가 작다는 것과 대응한다. 또한 <span class="math inline">\(\lambda\overset{p}{\sum_{j = 1}}\beta_{j}^{2}\)</span>항은 규제회귀의 릿지(ridge) 페널티 항이며, 서포트 벡터 분류기에서 편향–분산 절충을 조절하는 역할도 유사하게 수행한다.</p>
<p><span class="math inline">\(\min_{\beta_{0},\beta_{1},\ldots,\beta_{p}}\{ L(X,y,\beta) + \lambda P(\beta)\}\)</span>, 여기서 <span class="math inline">\(L(X,y,\beta)\)</span>는 모수 <span class="math inline">\(\beta\)</span>로 매개화된 모형이 데이터 (X,y)에 얼마나 잘 맞는지를 정량화하는 손실 함수이며, <span class="math inline">\(P(\beta)\)</span>는 모수 벡터 <span class="math inline">\(\beta\)</span>에 대한 페널티 함수로서 그 효과는 0 이상의 튜닝 파라미터 <span class="math inline">\(\lambda\)</span>에 의해 조절된다. 예를 들어 릿지 회귀와 라쏘는 각각 다음 형태를 취한다:</p>
<p><span class="math inline">\(L(X,y,\beta) = \overset{n}{\sum_{i = 1}}\left( y_{i} - \beta_{0} - \overset{p}{\sum_{j = 1}}x_{ij}\beta_{j} \right)^{2}\)</span>. 그리고 릿지 회귀에서는 <span class="math inline">\(P(\beta) = \overset{p}{\sum_{j = 1}}\beta_{j}^{2}\)</span>, 라쏘에서는 <span class="math inline">\(P(\beta) = \overset{p}{\sum_{j = 1}}|\beta_{j}|\)</span>이다.</p>
<p>손실 함수는 다음 형태를 갖는다:</p>
<p><span class="math display">\[L(X,y,\beta) = \overset{n}{\sum_{i = 1}}\max\lbrack 0,1 - y_{i}(\beta_{0} + \beta_{1}x_{i1} + \cdots + \beta_{p}x_{ip})\rbrack\]</span></p>
<p>이는 힌지 손실(hinge loss)이라 불리며, 힌지 손실은 로지스틱 회귀에서 사용되는 손실 함수와 밀접하게 관련되어 있음이 알려져 있다.</p>
<p>서포트 벡터 분류기의 흥미로운 특징은 서포트 벡터만이 최종 분류기에 영향을 준다는 점이다. 마진의 올바른 쪽에 있는 관측치들은 분류기에 영향을 주지 않는데, 이는 손실 함수가 <span class="math inline">\(y_{i}(\beta_{0} + \beta_{1}x_{i1} + \cdots + \beta_{p}x_{ip}) \geq 1\)</span>인 관측치에 대해 정확히 0이 되기 때문이다.</p>
<p>로지스틱 회귀 손실 함수는 어느 지점에서도 정확히 0이 되지는 않는다. 다만 결정경계에서 멀리 떨어진 관측치들에 대해서는 그 값이 매우 작아진다.</p>
<p>이러한 두 손실 함수의 유사성 때문에, 로지스틱 회귀와 서포트 벡터 분류기는 종종 매우 비슷한 결과를 낸다. 클래스들이 잘 분리되어 있을 때는 SVM이 로지스틱 회귀보다 더 잘 작동하는 경향이 있고, 클래스가 많이 겹치는 영역에서는 로지스틱 회귀가 종종 더 선호된다.</p>
<p>서포트 벡터 분류기와 SVM이 처음 소개되었을 때는 튜닝 파라미터 C가 중요하지 않은 <span dir="rtl">’</span>사소한(nuisance)<span dir="rtl">’</span> 파라미터로 여겨져, 어떤 기본값(예: 1)으로 설정해도 된다고 생각되곤 했다.</p>
<p>그러나 서포트 벡터 분류기의 <span dir="rtl">”</span>손실 + 페널티” 표현은 이것이 사실이 아님을 보여준다. 튜닝 파라미터의 선택은 매우 중요하며, 모형이 데이터에 과소적합 또는 과적합하는 정도를 결정한다.</p>
<p>우리는 서포트 벡터 분류기가 로지스틱 회귀 및 다른 기존 통계적 방법들과 밀접하게 관련되어 있음을 확인했다. 그렇다면 비선형 클래스 경계를 수용하기 위해 특성공간을 커널로 확장하는 측면에서 SVM은 독특한가? 이 질문에 대한 답은 <span dir="rtl">”</span>아니다”이다.</p>
<p>로지스틱 회귀나 이 책에서 다룬 다른 분류 방법들에도 비선형 커널을 적용해 특성공간을 확장하는 것을 충분히 할 수 있으며, 이는 비선형 방법들과 밀접한 관련이 있다. 다만 역사적 이유로, 비선형 커널은 로지스틱 회귀나 다른 방법들보다 SVM 맥락에서 훨씬 더 널리 사용되어 왔다.</p>
<p>4. 분할 기반(Tree) 분류 [예측모형 강의노트 참고]</p>
<p>분할 기반 분류모형(분류나무, Classification Tree)은 입력공간을 여러 개의 영역으로 나누고, 각 영역에서 가장 우세한 클래스를 예측하는 방식이다. 핵심 아이디어는 <span dir="rtl">”</span>어떤 변수의 임계값(또는 범주)으로 데이터를 반복적으로 쪼개면, 클래스가 비교적 균질한 구간을 만들 수 있다”는 것이다. 즉, 트리는 선형 결합으로 하나의 경계를 만드는 대신, 규칙의 조합으로 비선형·상호작용 구조를 자연스럽게 포착한다.</p>
<p>방법론적으로는 예측(회귀)나무와 동일한 절차를 따르되, 분할 기준만 <span dir="rtl">”</span>연속형 오차(MSE)“가 아니라 <span dir="rtl">”</span>분류 순도”를 개선하는 방향으로 바뀐다. 대표적으로 노드 t에서 클래스 비율을 <span class="math inline">\(p_{k}(t)\)</span>라 할 때,</p>
<p>지니 불순도(Gini): <span class="math inline">\(G(t) = \overset{K}{\sum_{k = 1}}p_{k}(t)(1 - p_{k}(t)) = 1 - \overset{K}{\sum_{k = 1}}p_{k}(t)^{2}\)</span></p>
<p>엔트로피(Entropy): <span class="math inline">\(H(t) = - \overset{K}{\sum_{k = 1}}p_{k}(t)\log p_{k}(t)\)</span></p>
<p>같은 기준을 사용하여 분할 전후의 불순도 감소가 최대가 되도록 분할을 선택한다.</p>
<p>최종 예측은 새 관측치 x가 도달한 말단노드(leaf)에서의 다수결(또는 클래스 확률 <span class="math inline">\({\widehat{p}}_{k}\)</span>)로 결정된다. 과적합을 막기 위해 최대 깊이 제한, 최소 노드 크기, 비용-복잡도 가지치기(pruning) 등의 규제는 회귀나무와 동일한 논리로 적용된다.</p>
<p>정리하면, 분할 기반(Tree) 분류는 예측모형(트리 기반 예측)에서 다룬 트리 방법론과 구조·학습 절차는 동일하며, 손실/분할 기준만 분류용 불순도 척도로 바뀐다는 점만 강조하면 된다.</p>
<p>5. 결합 기반(Ensemble) 분류 [예측모형 강의노트 참고]</p>
<p>결합 기반 분류모형(앙상블, Ensemble)은 단일 분류나무(또는 약한 학습기)의 불안정성(분산 큼)과 한계를 보완하기 위해, 여러 개의 모형을 학습한 뒤 결합하여 예측 성능과 안정성을 높이는 방법이다. 기본 철학은 <span dir="rtl">”</span>여러 개의 다소 불완전한 분류기를 적절히 합치면, 단일 모델보다 일반화 성능이 좋아진다”는 것이다.</p>
<p>예측(회귀)에서의 앙상블과 동일하게, 분류에서도 대표적으로 다음 두 흐름이 핵심이다.</p>
<p>1. 배깅/랜덤포레스트(Bagging/Random Forest)</p>
<p>부트스트랩 표본으로 여러 트리를 학습하고, 분류에서는 각 트리의 예측을 다수결(voting)로 결합한다. <span class="math inline">\(\widehat{y}(x) = \arg\max_{k}\overset{B}{\sum_{b = 1}}\mathbf{1}({\widehat{y}}_{b}(x) = k)\)</span></p>
<p>랜덤포레스트는 여기에 분할 시 후보 변수의 무작위 선택을 추가하여 트리 간 상관을 줄이고 분산 감소 효과를 강화한다. (확률이 필요하면 트리들의 클래스확률 평균을 사용하고, 필요시 calibration을 고려한다.)</p>
<p>2. 부스팅(Boosting: AdaBoost/GBM/XGBoost 등)</p>
<p>이전 모델이 틀린 관측치(오분류/손실이 큰 표본)에 더 집중하도록 순차적으로 모델을 추가하여, 편향을 줄이면서 성능을 끌어올린다. 분류에서는 로지스틱 손실, 지수손실 등 분류용 손실함수를 최소화하는 형태로 전개되며, 최종 예측은 여러 약한 학습기의 가중 결합으로 얻는다.</p>
<p>정리하면, 결합 기반(Ensemble) 분류는 예측모형(앙상블)에서 다룬 배깅·랜덤포레스트·부스팅의 방법론적 틀과 동일하며, 결합 규칙이 평균(회귀) 대신 다수결/확률 평균(분류)로 바뀐다는 점과, 성능평가 지표가 분류용(Accuracy/F1/AUC 등)으로 바뀐다는 정도만 덧붙이면 충분하다.</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>