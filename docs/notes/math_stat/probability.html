<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>probability – 세상의 모든 통계 이야기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">세상의 모든 통계 이야기</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">|기초수학|</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-">    
        <li>
    <a class="dropdown-item" href="../../notes/math/function.html">
 <span class="dropdown-text">함수</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math/derivate_integral.html">
 <span class="dropdown-text">미분적분</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math/vector.html">
 <span class="dropdown-text">벡터</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math/matrix.html">
 <span class="dropdown-text">행렬</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--1" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">|수리통계|</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--1">    
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/probability.html">
 <span class="dropdown-text">확률</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/random_variable.html">
 <span class="dropdown-text">확률변수</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/famous_distribution.html">
 <span class="dropdown-text">유명한분포</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/multi_variate.html">
 <span class="dropdown-text">다변량확률변수</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/random_sample.html">
 <span class="dropdown-text">확률표본</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/inference.html">
 <span class="dropdown-text">추정과검정</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--2" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">|조사방법|</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--2">    
        <li>
    <a class="dropdown-item" href="../../notes/survey/survey_intro.html">
 <span class="dropdown-text">조사방법 기초</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/sample_design.html">
 <span class="dropdown-text">표본설계</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/questionnaire.html">
 <span class="dropdown-text">설문지</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/nonresponse.html">
 <span class="dropdown-text">무응답 대체</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/data_process.html">
 <span class="dropdown-text">데이터 처리</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/survey_scale.html">
 <span class="dropdown-text">조사지 척도</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/delphi_ahp_conjoint.html">
 <span class="dropdown-text">델파이 AHP 컨조인트</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../cardnews/index.html"> 
<span class="menu-text">| 카드뉴스 |</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../consult.html"> 
<span class="menu-text">| 통계상담 |</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--3" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">📡 스트리밍</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--3">    
        <li>
    <a class="dropdown-item" href="https://by-sekwonappio-esqshnv7wueapp4da6jrizn.streamlit.app">
 <span class="dropdown-text">실시간주가[5대종목]</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://by-sekwonappio-k5e5n7wasvj3kveyqbwmgc.streamlit.app/">
 <span class="dropdown-text">대전유성구 일기예보</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<p><img src="media/image1.png" style="width:4.07621in;height:2.98414in" alt="myself.png">확률론은 통계학의 모든 기초가 되는 주제로, 모집단, 실험, 혹은 무작위 현상으로 간주될 수 있는 거의 모든 것을 모델링할 수 있는 수단을 제공합니다. 이러한 모델을 통해 통계학자들은 모집단에 대해 추론을 수행할 수 있으며, 이는 전체 중 일부만을 관찰한 결과를 기반으로 이루어집니다. 확률론의 역사는 매우 오래되고 풍부하며, 적어도 17세기까지 거슬러 올라갑니다. 당시, 그들의 친구들의 요청에 따라 파스칼 Pascal과 페르마 Fermat가 도박 확률의 수학적 공식을<img src="media/image1.jpeg" style="width:2.50582in;height:1.80198in" alt="폰트, 원, 디자인, 타이포그래피이(가) 표시된 사진 자동 생성된 설명"> 개발하였습니다.</p>
<p>vol 2. 추론통계</p>
<p>section 1. 확률론</p>
<p>wolfpack se kwon</p>
<p><a href="https://sites.google.com/view/wolfpack61" class="uri">https://sites.google.com/view/wolfpack61</a></p>
<p>권세혁교수 통계노트시리즈</p>
<p>파스칼의 삼각형은 숫자를 삼각형 형태로 배열한 도형으로, 이항 계수를 나타냅니다. 프랑스의 수학자 블레즈 파스칼의 이름을 따왔으나, 그 이전에도 여러 문명에서 이미 알려져 있었습니다.</p>
<p>이항전개 계수 : <span class="math inline">\((a + b)^{n} = \overset{n}{\sum_{k = 0}}\binom{n}{k}a^{n - k}b^{k}\)</span></p>
<p><span class="math display">\[(a + b)^{4} = a^{4} + 4a^{3}b + 6a^{2}b^{2} + 4ab^{3} + b^{4}\]</span></p>
<p><span class="math inline">\(11^{n}\)</span>의 값: <span class="math inline">\(11^{3} = 1331\)</span></p>
<p>7번 하는 경기에서 4번 먼저 이기는 게임에서 실력이 동등한 두 선수 중 A는 1번, B는 2번 이긴 상태에서 게임이 끝났다. 상금을 어떻게 배분하면 되는가? A는 3번, B는 2번 더 승리해야 하므로 5번째 행을 합 16을 A는 첫 2개 열의 합 5, B는 마지막 3개 열 11을 배분하여 A는 상금의 5/16, B는 상금의 11/16을 갖는다.</p>
<p>Chapter 1. 집합론</p>
<p>통계분석의 목표 중 하나는 실험을 통해 특정 집단에 대한 결론을 도출하는 것이다. 이를 위한 첫 번째 단계는 가능한 결과, 표본공간을 식별하는 것이다.</p>
<p>1표본공간과 사건</p>
<p>표본공간 정의</p>
<p>특정 실험의 가능한 모든 결과를 포함하는 집합 <span class="math inline">\(S\)</span>를 표본공간 sample space이라고 한다.</p>
<p>표본공간 정의</p>
<ul>
<li><p>실험이 동전을 던지는 것으로 구성되어 있다면, 표본공간은 앞면과 뒷면의 두 가지 결과를 포함한다. 따라서, <span class="math inline">\(S = \{ H,T\}\)</span></p></li>
<li><p>실험이 특정 대학에서 무작위로 선택된 학생들의 수능 점수를 관찰하는 것이라면, 표본공간은 <span class="math inline">\(S = \{ 100,110,...,505\}\)</span>(10점 단위)이다.</p></li>
<li><p>특정 자극에 대한 반응 시간을 관찰하는 실험에서는 <span class="math inline">\(S = (0,\infty)\)</span>가 표본공간이다.</p>
<p>표본공간의 유형</p></li>
</ul>
<p>표본공간은 그 안에 포함된 원소의 수에 따라 가산 countable 표본공간과 비가산 uncountable 표본공간으로 나뉜다.</p>
<ul>
<li><p>표본공간의 원소가 정수 집합의 부분집합과 1:1 대응을 이룰 수 있으면, 그 표본공간은 가산이다. 예를 들어, 동전 던지기나 SAT 점수의 표본공간은 가산 표본공간이다(사실, 유한한 집합이다)</p></li>
<li><p>반응 시간 표본공간은 비가산 표본공간이다. 이는 양의 실수들이 정수와 1:1 대응을 이룰 수 없기 때문이다. 하지만 반응 시간을 가장 가까운 초 단위로 측정한다면, 표본공간은 다음과 같이 표현될 수 있다. <span class="math inline">\(S = \{ 0,1,2,3,\ldots\}\)</span></p></li>
<li><p>가산 표본공간과 비가산 표본공간의 구분의 중요성은 확률을 할당하는 방식에 영향을 미치기 때문입니다.</p></li>
</ul>
<ol type="1">
<li>사건</li>
</ol>
<p>사건 event이란 실험에서 발생 가능한 결과들의 모임, 즉 <span class="math inline">\(S\)</span>의 임의의 부분집합을 말한다 <span class="math inline">\(S\)</span> 자체도 포함).</p>
<p>사건 정의</p>
<p>어떤 사건 A가 집합 <span class="math inline">\(S\)</span>의 부분집합이라고 하자. 만약 실험의 결과가 A 집합에 속한다면, 사건 A가 발생했다고 말한다. 확률에 대해 이야기할 때, 일반적으로 집합 대신 사건의 확률에 대해 언급하며 이 두 용어는 상호 교환적으로 사용할 수 있다.</p>
<ul>
<li><p>포함 관계, 부분집합: <span class="math inline">\(A \subseteq B \Longleftrightarrow x \in A \Longrightarrow x \in B\)</span></p></li>
<li><p>동일성: <span class="math inline">\(A = B \Longleftrightarrow A \subseteq B\text{and}B \subseteq A\)</span></p></li>
</ul>
<p>2집합 연산</p>
<ul>
<li><p>집합 <span class="math inline">\(A\)</span>의 모든 원소를 셀 수 있다면 가산 countable 집합이다.</p></li>
<li><p>만약 집합 <span class="math inline">\(A\)</span>의 모든 원소가 집합 <span class="math inline">\(B\)</span>에 포함되어 있다면 <span class="math inline">\(A\)</span>는 <span class="math inline">\(B\)</span>의 부분 subset 집합이다.</p></li>
<li><p><span class="math inline">\(\phi\)</span>는 공집합(null or empty set)을 의미하며 원소가 하나도 없는 집합이다.</p></li>
<li><p><span class="math inline">\(A \subset B\)</span> : 집합 A의 모든 원소가 집합 B에 있는 경우 집합 A는 집합 B의 부분집합 subset</p></li>
<li><p><span class="math inline">\(A^{C}or\overline{A}\)</span> : 집합 A의 여집합 complement로 집합 A에 있는 원소를 제외한 모든 표본공간 원소의 모임 ⇔ NOT</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image2.png" style="width:3.73288in;height:2.07353in" class="figure-img"></p>
<figcaption>pasted-image.png</figcaption>
</figure>
</div>
<p>어떤 두 사건 A와 B가 주어졌을 때, 다음과 같은 기본적인 집합 연산이 성립한다:</p>
<ul>
<li><p><span class="math inline">\(A \cup B\)</span> 합집합 union: A 또는 B 또는 둘 다에 속하는 원소들로 구성된 집합이다. <span class="math inline">\(A \cup B = \{ x:x \in A\text{또는}x \in B\}\)</span></p></li>
<li><p><span class="math inline">\(A \cap B\)</span> 교집합 intersection: A와 B 모두에 속하는 원소들로 구성된 집합이다. <span class="math inline">\(A \cap B = \{ x:x \in A\text{그리고}x \in B\}\)</span></p></li>
</ul>
<p>표본공간 <span class="math inline">\(S\)</span>에서 정의된 임의의 세 사건 <span class="math inline">\(A,B,C\)</span>에 대해 다음이 성립합니다.</p>
<p>정리</p>
<ul>
<li><p>교환법칙 commutativity: <span class="math inline">\(A \cup B = B \cup A\)</span>, <span class="math inline">\(A \cap B = B \cap A\)</span></p></li>
<li><p>결합법칙 associativity: <span class="math inline">\(A \cup (B \cup C) = (A \cup B) \cup C\)</span>,<span class="math inline">\(A \cap (B \cap C) = (A \cap B) \cap C\)</span></p></li>
<li><p>분배법칙 distributive Laws: <span class="math inline">\(A \cap (B \cup C) = (A \cap B) \cup (A \cap C)\)</span>, <span class="math inline">\(A \cup (B \cap C) = (A \cup B) \cap (A \cup C)\)</span></p></li>
<li><p>드모르간 법칙 DeMorgan<span dir="rtl">’</span>s Laws: <span class="math inline">\((A \cup B)^{c} = A^{c} \cap B^{c}\)</span>, <span class="math inline">\((A \cap B)^{c} = A^{c} \cup B^{c}\)</span></p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image1.tif" style="width:2.99647in;height:1.63623in" class="figure-img"></p>
<figcaption>pasted-image.tiff</figcaption>
</figure>
</div>
<p>만약 <span class="math inline">\(A_{1},A_{2},A_{3},\ldots\)</span>가 표본공간 <span class="math inline">\(S\)</span>위에 정의된 집합이라면,</p>
<p><span class="math inline">\(\overset{\infty}{\bigcup_{i = 1}}A_{i} = \{ x \in S:x \in A_{i}\text{for some}i\}\)</span>: 무한 합집합을 나타내며 <span class="math inline">\(x\)</span>는 <span class="math inline">\(A_{i}\)</span> 중 적어도 하나의 집합에 포함되면 합집합에 포함된다.</p>
<p><span class="math inline">\(\overset{\infty}{\bigcap_{i = 1}}A_{i} = \{ x \in S:x \in A_{i}\text{for all}i\}\)</span>: 무한 교집합을 나타내며 <span class="math inline">\(x\)</span>는 모든 <span class="math inline">\(A_{i}\)</span> 포함되어야 교집합에 포함된다.</p>
<p>【예제】 주사위를 한번씩 두 번 던져 나타난 결과를 적는다. 모든 가능한 쌍(pair)을 표본공간이라 정의하자. 집합 A={두 번째 주사위 눈금이 짝수}, B={두 주사위 눈금의 합이 짝수}, C={두 주사위 눈금 중 적어도 하나가 홀수}라 정의할 때 다음을 구하라.</p>
<p><span class="math inline">\(B^{C},A \cup B,A \cap B^{C},A^{C} \cap C\)</span></p>
<p><span class="math inline">\(A = \{ 3,456,7,8,9,10,11\}\)</span>, <span class="math inline">\(B = \{ 2,4,6,8,10,12\}\)</span>, <span class="math inline">\(C = \{ 23,4,5,6,7,8,9,10,11\}\)</span></p>
<p>【풀이】 <span class="math inline">\(S = \{ 2,3,4,5,6,7,8,9,10,11,12\}\)</span>, <span class="math inline">\(A^{c} = \{ 2,12\}\)</span>, <span class="math inline">\(B^{c} = \{ 3,5,7,9,11\}\)</span>, <span class="math inline">\(A \cup B = \left\{ 2,3,4,5,6,7,8,9,10,11,12 \right\} = S\)</span>, <span class="math inline">\(A \cap B^{c} = \{ 3,5,7,9,11\}\)</span>, <span class="math inline">\(A^{C} \cap C = \{ 2\}\)</span>.</p>
<p>3상호 배타적 사건</p>
<p>만약 <span class="math inline">\(A \cap B = \varnothing\)</span>이면, 두 사건 A와 B는 서로소 disjoint, 또는 상호 배타적 mutually exclusive 라고 한다.</p>
<p>상호배타 정의</p>
<p>만약 <span class="math inline">\(A_{i} \cap A_{j} = \varnothing foralli \neq j\)</span>이면 사건 <span class="math inline">\(A_{1},A_{2},\ldots\)</span>는 쌍별로 서로소 또는 상호 배타적라고 한다.</p>
<p>만약 <span class="math inline">\(A_{1},A_{2},\ldots\)</span>가 쌍별로 서로소이고 <span class="math inline">\(\overset{\infty}{\bigcup_{i = 1}}A_{i} = S\)</span>라면, 이 집합 모음 <span class="math inline">\(A_{1},A_{2},\ldots\)</span>는 <span class="math inline">\(S\)</span>의 분할 partition을 이룬다.</p>
<p>【유용한 사례】 집합 <span class="math inline">\(A_{i} = \lbrack i,i + 1)\)</span>는 <span class="math inline">\(\lbrack 0,\infty)\)</span>의 분할을 이룬다.</p>
<p>Chapter 2. 확률론 기초</p>
<p>확률실험이 수행되면, 그 결과는 표본 공간에 속하는 하나의 결과로 나타난다. 만약 동일한 실험이 여러 번 수행된다면, 다양한 결과가 나타날 수도 있고 일부 결과는 반복될 수도 있다. 이때 결과의 <span dir="rtl">”</span>발생 빈도<span dir="rtl">”</span>는 확률로 이해할 수 있다. 더 높은 확률을 가지는 결과는 더 자주 나타나며, 실험의 결과를 확률적으로 설명할 수 있다면, 이를 통계적으로 분석하는 과정으로 나아가게 된다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 97%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;">확률 실험 probability experiment: 특정 조건 하에서 수행되며, 결과가 미리 확정되지 않은 실험을 말한다. 확률 실험은 동일한 조건에서 여러 번 반복될 수 있으며, 각 실험의 결과는 표본 공간의 원소로 표현된다. (불확정적, 반복가능성, 확률적 설명가능)</td>
</tr>
</tbody>
</table>
<p>확률은 미래에 발생할 사건에 대한 믿음에 대한 측정값이다. 확률 개념은 물리, 화학, 사회 과학 등에서 발생하는 관심 현상의 측정값을 불확실성에 의해 예측할 수 없는 경우 사용된다. 예를 들면 향후 1분간 당신 맥박 수, 다리가 무너지기 전 최대 하중 등은 정확한 값을 알 수 없다. 이런 상황을 랜덤이라 한다. 랜덤상황이더라도 이 사건에 대한 상대 빈도 정보가 있다면 예측이 가능하다.</p>
<p>확률은 관심 사건이 일어날 가능성 (chance or likelihood)을 숫자로 표현한 것으로 확률의 0 (일어날 가능성 없음)과 1(항상 일어남) 사이의 값(0% TO 100%)이다.</p>
<p>1확률 측정</p>
<p>확률은 관심 사건이 일어날 가능성 chance or likelihood을 숫자로 표현한 것으로 확률의 0 (일어날 가능성 없음)과 1(항상 일어남) 사이의 값으로 나타낸다.</p>
<p>확률 정의</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image3.png" style="width:4.49986in;height:1.33844in" class="figure-img"></p>
<figcaption>텍스트, 스크린샷, 라인, 번호이(가) 표시된 사진 자동 생성된 설명</figcaption>
</figure>
</div>
<p>상대 빈도 relative frequency</p>
<p>동전을 던지는 경우 {앞 면이 나올 사건}에 관심이 있어 실험을 한다고 하자. 10번을 던지니 6번이 앞 면이었다면 상대빈도는 0.6이다. 계속 100번 던지니 52번이 앞 면이 나왔다면 상대 빈도는 0.52이다. 1000번을 던지니 515번이 앞면이었다면 상대 빈도는 0.515이다.</p>
<p><span class="math inline">\(P(A) = \lim_{n \rightarrow \infty}\frac{f}{n}\)</span>, <span class="math inline">\(n\)</span>=실험 횟수, <span class="math inline">\(f\)</span>=사건 A가 발생한 횟수, 무한히 많은 시행 후에는 관심 사건의 나타날 가능성을 예상-확률은 무한 실험 후에 관심사건이 발생한 횟수(상대 빈도)를 확률이라 정의한다.</p>
<ul>
<li><p>Count Buffon (1707-1788): 4040번 동전 던지기 실험 앞면 2048회, P(앞면)= 0.5069</p></li>
<li><p>Karl Pearson (1900): 24, 000 던지기 앞면 12,012, P(앞면)=0.5005</p></li>
<li><p>John Kerrich : 10,000 던지기, 앞면 5067 heads, P(앞면)=0.5067.</p></li>
</ul>
<p>예 : 공정 생산 제품의 불량률(확률)에 대한 모형을 위해서는 제품 검사(확률실험)를 통하여 검사 제품 개수 중 불량품의 개수(상대 빈도)를 계산하면 된다.</p>
<p>Laplace 확률</p>
<p>표본공간의 각 원소들이 일어날 가능성이 같다고 equally likely 가정하여 확률을 정의하는 것을 Laplace 확률(고전적 정의)이라 한다. 주사위를 던지는 실험에서 짝수가 나올 확률은 3/6=1/2으로 정의한다. 표본공간의 원소 개수는 6개이고 짝수 사건의 원소는 3개이므로 짝수가 발생할 확률은 0.5이다. 고전적 정의의 가정은 각 원소(주사위 눈금)가 나타날 확률과 동일(1/6)하다는 것이다. 다음에서 설명하는 공리적 기반의 확률 정의와 동일한 접근이다.</p>
<p>공리적기반</p>
<p>표본 공간 <span class="math inline">\(S\)</span> 내의 사건 <span class="math inline">\(A\)</span>에 대해 <span class="math inline">\(A\)</span>에 0과 1 사이의 숫자를 연관시키고 이를 <span class="math inline">\(A\)</span>의 확률 probability 이라 부르며 <span class="math inline">\(P(A)\)</span>로 표기한다. <span class="math inline">\(P\)</span> 함수의 정의역을 <span class="math inline">\(S\)</span>의 모든 부분 집합으로 정의하는 것이 자연스러울 것이다. 즉, <span class="math inline">\(A \subseteq S\)</span>인 각 사건에 대해 <span class="math inline">\(P(A)\)</span>를 정의할 수 있다.</p>
<p>집합 <span class="math inline">\(S\)</span>의 부분집합 모음 <span class="math inline">\(\mathcal{B}\)</span>가 다음 세 가지 성질을 만족하면 시그마 대수 sigma algebra, 또는 Borel field라고 한다.</p>
<p>시그마 필드</p>
<ol type="1">
<li><p><span class="math inline">\(\varnothing \in \mathcal{B}\)</span> (공집합은 <span class="math inline">\(\mathcal{B}\)</span>에 포함된다).</p></li>
<li><p><span class="math inline">\(A \in \mathcal{B}\)</span>라면 <span class="math inline">\(A^{c} \in \mathcal{B}\)</span> (보수 연산에 대해 닫혀 있다).</p></li>
<li><p><span class="math inline">\(A_{1},A_{2},\ldots \in \mathcal{B}\)</span>라면 <span class="math inline">\(\overset{\infty}{\bigcup_{i = 1}}A_{i} \in \mathcal{B}\)</span> (가산 합집합에 대해 닫혀 있다).</p></li>
</ol>
<p>가장 간단한 시그마 대수는 <span class="math inline">\(\{\varnothing,S\}\)</span> 이다.</p>
<p>표본공간 <span class="math inline">\(S\)</span>와 이에 연관된 시그마 대수 <span class="math inline">\(\mathcal{B}\)</span>가 주어졌을 때, 확률함수 <span class="math inline">\(P\)</span>는 다음 세 가지 조건을 만족하는 <span class="math inline">\(\mathcal{B}\)</span> 상의 함수이다.</p>
<p>확률함수 정의</p>
<ol type="1">
<li>비음성 조건: <span class="math inline">\(P(A) \geq 0\text{for all}A \in \mathcal{B}\)</span>. (모든 사건 A 에 대해 확률은 0 이상이다.)</li>
</ol>
<!-- -->
<ol start="4" type="1">
<li><p>정규화 조건: <span class="math inline">\(P(S) = 1\)</span>. (전체 표본 공간 S 의 확률은 항상 1이다.)</p></li>
<li><p>가산 가법성 조건: 만약 <span class="math inline">\(A_{1},A_{2},\ldots \in \mathcal{B}\)</span>가 쌍별로 상호배타적이라면, <span class="math inline">\(P\left( \bigcup_{i = 1}^{\infty}A_{i} \right) = \overset{\infty}{\sum_{i = 1}}P(A_{i})\)</span>. (가산 합집합의 확률은 개별 사건들의 확률 합과 같습니다.)</p></li>
</ol>
<p>위 정의는 Kolmogorov 공리로 잘 알려져 있습니다. 이 공리적 정의는 확률을 직관적으로 정의하려는 시도(예: 빈도적 정의)와 달리, 수학적으로 엄격하고 보편적인 방식으로 확률을 설명합니다. 이 공리를 만족하는 함수는 모두 확률 함수로 간주됩니다.</p>
<ul>
<li><p>확률 공간 probability space: 확률함수는 <span class="math inline">\((S,\mathcal{B},P)\)</span>로 정의되는 확률 공간의 일부입니다. 여기서 <span class="math inline">\(S\)</span>는 표본 공간, <span class="math inline">\(\mathcal{B}\)</span>는 사건의 집합(시그마 대수), <span class="math inline">\(P\)</span>는 확률 함수입니다.</p></li>
<li><p>확률 함수의 다양성: 동일한 표본 공간에서도 여러 가지 확률 함수가 정의될 수 있습니다. 예를 들어, 공정한 동전과 편향된 동전은 서로 다른 확률 함수를 가질 수 있습니다.</p></li>
</ul>
<p>2확률정의 방법</p>
<p>확률정의 방법)</p>
<p><span class="math display">\[S = \{\text{앞면, 뒷면}\},\mathcal{B} = \{ S,\varnothing,\{\text{앞면}\},\{\text{뒷면}\}\},P(\{\text{앞면}\}) = 0.5\]</span></p>
<ol type="1">
<li>표본공간: 공정한 동전을 던지는 실험 <span class="math inline">\(S = \{\text{H},\text{T}\}\)</span></li>
</ol>
<!-- -->
<ol start="6" type="1">
<li>공정한 동전의 정의: 공정한 동전은 앞면과 뒷면이 나올 확률이 동일한 동전을 의미합니다. 따라서 <span class="math inline">\(P(\{\text{H}\}) = P(\{\text{T}\})\)</span>.</li>
</ol>
<p>이 관계는직관에 의해 설정된 것이며 Kolmogorov 공리에서 직접적으로 도출된 것은 아닙니다.</p>
<ol start="7" type="1">
<li>Kolmogorov 공리 적용: Kolmogorov 공리에 따라, 표본 공간 S 의 확률은 <span class="math inline">\(P(S) = 1\)</span>.</li>
</ol>
<ul>
<li><p><span class="math inline">\(S = \{\text{H}\} \cup \{\text{T}\}\)</span>이고, 앞면과 뒷면은 상호배타적이므로, 가산 가법성에 의해 <span class="math inline">\(P(\{\text{H}\} \cup \{\text{T}\}) = P(\{\text{H}\}) + P(\{\text{T}\})\)</span>.</p></li>
<li><p>이를 통해 <span class="math inline">\(P(\{\text{H}\}) + P(\{\text{T}\}) = 1\)</span>이 성립합니다.</p></li>
</ul>
<ol start="8" type="1">
<li>결론: 앞면과 뒷면의 확률이 동일하므로 <span class="math inline">\(P(\{\text{H}\}) = P(\{\text{T}\}) = 0.5\)</span>.</li>
</ol>
<p>다음 정리는 확률함수 <span class="math inline">\(P\)</span>를 정의하는 구체적인 방법을 설명합니다. 이 정리는 유한 또는 가산 표본 공간에서 Kolmogorov 공리를 만족하는 확률함수를 체계적으로 정의하는 데 사용됩니다.</p>
<p>주어진 조건:</p>
<p>정리</p>
<p>표본공간 <span class="math inline">\(S = \{ s_{1},s_{2},\ldots,s_{n}\}\)</span>는 유한 집합입니다.</p>
<p><span class="math inline">\(\mathcal{B}\)</span>는 <span class="math inline">\(S\)</span>의 부분집합들로 이루어진 시그마 대수입니다.</p>
<p><span class="math inline">\(p_{1},p_{2},\ldots,p_{n}\)</span>은 0 이상의 숫자로 이들의 합은 1입니다 <span class="math inline">\(\overset{n}{\sum_{i = 1}}p_{i} = 1\)</span>.</p>
<p><span class="math inline">\(A \in \mathcal{B}\)</span>에 대해 확률 함수 P(A) 는 다음과 같이 정의됩니다.</p>
<p><span class="math display">\[P(A) = \sum_{\{ i:s_{i} \in A\}}p_{i}\]</span></p>
<p>공집합에 대한 합은 0으로 정의됩니다. <span class="math inline">\(P(\varnothing) = 0\)</span>.</p>
<p>가산 집합 확장: <span class="math inline">\(S = \{ s_{1},s_{2},\ldots\}\)</span>가 가산 집합인 경우에도 위 방식으로 <span class="math inline">\(P\)</span>를 정의할 수 있습니다. 이 경우에도 Kolmogorov 공리를 만족합니다.</p>
<p>확률정의 방법</p>
<p>다트 게임을 통해 확률을 정의하는 방법으로 표본공간에서 영역의 크기에 비례하여 확률을 정의하는 방법을 보여줍니다.</p>
<p>【문제 설정】</p>
<ul>
<li><p>다트 게임에서는 다트를 던져 특정 영역에 맞추었을 때, 그 영역에 해당하는 점수를 얻습니다.</p></li>
<li><p>초보 플레이어를 대상으로, 다트가 특정 영역에 맞을 확률이 영역의 면적에 비례한다고 가정합니다.</p></li>
<li><p>따라서, 더 큰 영역은 맞을 확률이 더 높습니다.</p></li>
</ul>
<p>【가정】</p>
<ul>
<li><p>다트 보드의 반지름은 <span class="math inline">\(r\)</span>입니다.</p></li>
<li><p>다트 보드에는 여러 개의 원형 영역이 있으며, 각 영역의 반지름은 일정 간격으로 나뉩니다.</p></li>
<li><p>다트가 반드시 보드에 맞는다고 가정합니다.</p></li>
</ul>
<p>【특정점수 <span class="math inline">\(i\)</span>를 얻을 확률】</p>
<p><span class="math inline">\(P(\text{scoring}i\text{points}) = \frac{\text{Area of region}i}{\text{Area of dart board}}\)</span>.</p>
<p>【계산 과정】</p>
<ul>
<li>점수 1을 얻을 확률: 영역 1은 중심 영역으로, 면적은 보드 전체 면적에서 두 번째 원까지의 영역을 뺀 값입니다.</li>
</ul>
<p><span class="math display">\[P(\text{scoring 1 point}) = \frac{\pi r^{2} - \pi(4r/5)^{2}}{\pi r^{2}} = 1 - \left( \frac{4}{5} \right)^{2}\]</span></p>
<ul>
<li>영역 i 의 면적은 두 원 사이의 차이로 계산됩니다.</li>
</ul>
<p><span class="math display">\[P(\text{scoring}i\text{points}) = \frac{(6 - i)^{2} - (5 - i)^{2}}{5^{2}},i = 1,2,\ldots,5\]</span></p>
<p>【특징】</p>
<ul>
<li><p><span class="math inline">\(\pi\)</span>와 <span class="math inline">\(r\)</span>은 최종 확률 계산에서 상쇄되므로, 확률은 반지름과 독립적입니다.</p></li>
<li><p>각 영역의 면적 합이 전체 보드 면적과 같으므로, 확률의 총합은 1이 됩니다.</p></li>
<li><p>이 정의는 위 정리에 의해 올바른 확률 함수로 간주됩니다.</p></li>
</ul>
<p>Chapter 3. 확률 계산</p>
<p>1확률계산 관련 정리</p>
<p>확률공리를 기반으로 확률 함수의 여러 성질을 유도하고, 이를 복잡한 확률 계산에 적용하는 방법을 설명합니다. 이러한 성질들은 단일 사건뿐만 아니라 결합 사건의 확률을 계산하는 데 매우 유용합니다.</p>
<p><span class="math inline">\(P\)</span>가 확률 함수이고 <span class="math inline">\(A\)</span>가 <span class="math inline">\(\mathcal{B}\)</span>에 속하는 임의의 집합일 때, 다음이 성립합니다.</p>
<p>정리</p>
<ol type="1">
<li><span class="math inline">\(P(\varnothing) = 0\)</span>: 공집합의 확률은 항상 0입니다. 이는 직관적으로 공집합에는 발생할 수 있는 사건이 없기 때문입니다.</li>
</ol>
<!-- -->
<ol start="9" type="1">
<li><p><span class="math inline">\(P(A) \leq 1\)</span>: 임의 사건 <span class="math inline">\(A\)</span>의 확률은 1을 초과할 수 없습니다. 이는 확률이 0에서 1 사이에 있어야 한다는 공리에서 유도됩니다.</p></li>
<li><p><span class="math inline">\(P(A^{c}) = 1 - P(A)\)</span>: 여집합의 확률은 A 의 확률을 전체 확률1에서 뺀 값입니다.</p></li>
</ol>
<p><span class="math inline">\(P\)</span>가 확률 함수이고, A 와 B가 <span class="math inline">\(\mathcal{B}\)</span>에 속하는 임의의 집합일 때, 다음이 성립합니다.</p>
<p>정리</p>
<ol type="1">
<li><span class="math inline">\(P(B \cap A^{c}) = P(B) - P(A \cap B)\)</span>.</li>
</ol>
<!-- -->
<ol start="11" type="1">
<li><p><span class="math inline">\(P(A \cup B) = P(A) + P(B) - P(A \cap B)\)</span>.</p></li>
<li><p><span class="math inline">\(A \subseteq B\)</span>라면 <span class="math inline">\(P(A) \leq P(B)\)</span>.</p></li>
</ol>
<p><span class="math inline">\(P(A \cup B) \leq 1\)</span> 이므로 정리 2)를 다음과 쓸 수 있다.</p>
<p>Bonferroni<span dir="rtl">’</span>s Inequality: <span class="math inline">\(P(A \cap B) \geq P(A) + P(B) - 1\)</span></p>
<p><span class="math inline">\(P\)</span>가 확률 함수이고, A 와 B가 <span class="math inline">\(\mathcal{B}\)</span>에 속하는 임의의 집합일 때, 다음이 성립합니다.</p>
<p>정리</p>
<ol type="1">
<li><span class="math inline">\(P(A) = \overset{\infty}{\sum_{i = 1}}P(A \cap C_{i})\)</span>, 각 <span class="math inline">\(C_{i}\)</span>는 상호배타적이고 <span class="math inline">\(\overset{\infty}{\bigcup_{i = 1}}C_{i} = S\)</span>.</li>
</ol>
<!-- -->
<ol start="13" type="1">
<li>(Boole<span dir="rtl">’</span>s Inequality) <span class="math inline">\(P\left( \bigcup_{i = 1}^{\infty}A_{i} \right) \leq \overset{\infty}{\sum_{i = 1}}P(A_{i})\)</span>, 모든 <span class="math inline">\(A_{i}\)</span>는 임의의 집합입니다.</li>
</ol>
<p>2확률계산</p>
<p>sample-point 방법</p>
<p>이산형(표본공간의 원소의 수가 한정적일 경우, 헤아릴 수 있는 경우) 확률실험에서 사건 A에 대한 확률 계산 방법이다.</p>
<ol type="1">
<li>실험을 정의하고 표본공간을 정의한다. 표본공간의 원소 개수(<span class="math inline">\(N\)</span>)를 카운트한다.</li>
</ol>
<!-- -->
<ol start="14" type="1">
<li><p>표본공간의 각 원소에 확률 공리를 만족하도록 하여 적절한 확률 값을 할당한다. 라플라스 동등성 가정에 의해 각 원소의 활당 확률은 <img src="media/image4.png" style="width:0.25085in;height:0.11517in" alt="equation.pdf">이다.</p></li>
<li><p>사건A에 대한 원소를 정의하고 원소의 개수(<span class="math inline">\(n\)</span>)를 카운트 한다.</p></li>
<li><p>사건 A의 원소들의 확률을 더해 사건 A의 확률로 정의한다. <img src="media/image5.png" style="width:0.70381in;height:0.3185in" alt="equation.pdf"></p></li>
</ol>
<p>곱의 법칙</p>
<p>r번의 실험, 각 실험의 결과 수가 <img src="media/image6.png" style="width:0.83906in;height:0.11517in" alt="equation.pdf">이라 하면 실험 전체 결과 수는 <span class="math inline">\(n_{1} \times n_{2}... \times n_{r}\)</span> 이다.</p>
<p>【예제】 컴퓨터 비번을 만들려고 한다. 총 7자리 중 첫 2자리는 소문자, 3번째는 대문자, 남은 4자리는 0~9까지 숫자로 나열하여 만들 때 총 비번 개수는? <span class="math inline">\(26 \times 26 \times 26 \times 10^{4}\)</span></p>
<p>반복있고 순서 고려</p>
<p>실험의 결과 수가 <img src="media/image7.png" alt="equation.pdf">이고 실험을 <img src="media/image8.png" alt="equation.pdf">번 반복할 때 나타날 수 있는 결과(경우) 수는 <img src="media/image9.png" style="width:0.13842in;height:0.11535in" alt="equation.pdf"> 이다.</p>
<p>4자리로 숫자로 구성된 비밀번호을 잊었다. 반복이 가능하다면, 최악의 경우 몇 번이나 시도해야 맞출 수 있나? <span class="math inline">\(10^{4}\)</span></p>
<p>반복없이 나열</p>
<p>실험의 결과 수가 <img src="media/image10.png" alt="equation.pdf">이고 이를 나열하여 만들 수 있는 총 결과 수는 <span class="math inline">\(n! = n \times (n - 1) \times ... \times 1\)</span> 이다.</p>
<p>【예제】 4자리로 숫자로 구성된 비밀번호을 잊었다. 첫 번호에 0을 사용할 수 없고 반복이 불가능하다면, 최악의 경우 몇 번이나 시도해야 맞출 수 있나? <span class="math inline">\(9 \times 9 \times 8 \times 7\)</span></p>
<p>반복없고 순서 고려</p>
<p>n개의 서로 다른 원소들 중 r개를 뽑아 순서대로 배열할 경우 발생하는 총 결과 수는 <span class="math inline">\(nP_{r} = \frac{n!}{(n - r)!}\)</span> 이다.</p>
<p>【예제】 4자리로 숫자로 구성된 비밀번호을 잊었다. 반복이 불가능하다면, 최악의 경우 몇 번이나 시도해야 맞출 수 있나? <span class="math inline">\({}_{10}P_{4} = 10 \times 9 \times 8 \times 7\)</span></p>
<p>【예제】 주머니에 6개의 칩이 있거 칩에는 E, E, P, P, P, R이 각각 적혀있다. (1) 복원 추출(with replacement) (2) 비복원 추출(without replacement)로 하나씩 차례로 6개를 뽑아 영어 단어 PEPPER를 만들 확률을 구하시오. <span class="math inline">\((1)P(\text{“PEPPER”}) = \frac{1}{2} \times \frac{1}{3} \times \frac{1}{2} \times \frac{1}{2} \times \frac{1}{3} \times \frac{1}{6}\)</span></p>
<p><span class="math inline">\((2)\frac{6!}{3! \times 2! \times 1!} = \frac{720}{6 \times 2 \times 1} = 60\)</span> /720=1/12</p>
<p>반복, 순서 모두 없는 경우</p>
<p>n개의 서로 다른 원소들 중 r개를 뽑아 순서없이 배열할 경우 발생하는 총 결과 수 <span class="math inline">\({}_{n}C_{r} = \frac{n!}{(n - r)!r!}\)</span> 이다.</p>
<p>【예제】 5명의 대학원생과 3명의 학부생이 공무원 시험에 응시하였다. 여기서 4명을 선발할 경우 대학원 생이 3명 포함되어 있을 확률을 구하시오. <span class="math inline">\(\frac{{}_{5}C_{3} \times_{3}C_{1}}{{}_{8}C_{4}}\)</span></p>
<p>Enumerating Outcomes</p>
<p>유한 표본공간에서 가능한 결과를 나열하고, 이를 통해 확률을 계산하는 방법이다.</p>
<ol type="1">
<li>유한 표본공간 <span class="math inline">\(S = \{ s_{1},s_{2},\ldots,s_{N}\}\)</span>을 정의한다.</li>
</ol>
<!-- -->
<ol start="17" type="1">
<li><p>각 결과 <span class="math inline">\(s_{j}\)</span>의 발생 가능성은 동일하다. <span class="math inline">\(P(s_{j}) = \frac{1}{N}\)</span></p></li>
<li><p>사건 A 의 확률 계산: <span class="math inline">\(P(A) = \sum_{s_{i} \in A}P(\{ s_{i}\}) = \sum_{s_{i} \in A}\frac{1}{N}\)</span> 이는 사건 A 에 속한 원소의 개수를 전체 표본 공간의 원소 수로 나눈 값과 같습니다. <span class="math inline">\(P(A) = \frac{\text{no. of elements in}A}{\text{no. of elements in}S}\)</span>.</p></li>
</ol>
<p>Chapter 4. 조건부 확률과 독립</p>
<p>1조건부 확률</p>
<p>만약 사건 A 와 B는 표본공간 <span class="math inline">\(S\)</span>에서 정의더되고 <span class="math inline">\(P(B) &gt; 0\)</span>이라면, B가 발생했을 때 A가 발생할 조건부 확률은 다음과 같이 정의된다. <span class="math inline">\(P(A|B) = \frac{P(A \cap B)}{P(B)}\)</span></p>
<p>조건부 확률 정의</p>
<p>【재표현】 <span class="math inline">\(P(A \cap B) = P(A|B)P(B)\)</span></p>
<p>조건부 확률은 사건 B가 발생했다고 가정하므로 B가 새로운 표본 공간 역할을 합니다. 상호 배타적인 사건 A와 B는 공통된 원소를 가지지 않으므로 조건부 확률은 0입니다.</p>
<p>【예제】 잘 섞인 52장의 카드 중에서 4장을 뽑을 때, 뽑은 4장이 모두 에이스일 확률을 계산 하시오.</p>
<p>(방법1) <span class="math inline">\(P(\text{4 aces}) = 1/\binom{52}{4}\)</span></p>
<p>(방법2) <span class="math inline">\(P(\text{4 aces}) = \frac{4}{52} \times \frac{3}{51} \times \frac{2}{50} \times \frac{1}{49} = \frac{1}{270,725}\)</span></p>
<p>【예제】 뽑힌 <span class="math inline">\(i\)</span> 장 카드 중 에이스가 <span class="math inline">\(i\)</span> 개 있다면, 뽑은 4장이 모두 에이스일 확률을 계산 하시오.</p>
<p><span class="math display">\[P(\text{4 aces in 4 cards | i aces in i cards}) = \frac{P(\text{4 aces in 4 cards})}{P(\text{i aces in i cards})}\]</span></p>
<p><span class="math display">\[P(\text{4 aces in 4 cards}) = 1/\binom{52}{4}\]</span></p>
<p><span class="math display">\[P(\text{i aces in i cards}) = \frac{\binom{4}{i}}{\binom{52}{i}}\]</span></p>
<p><span class="math display">\[P(\text{4 aces in 4 cards | i aces in i cards}) = \frac{\binom{52}{i} \cdot \binom{4}{4}}{\binom{52}{4} \cdot \binom{4}{i}} = \frac{1}{\binom{52 - i}{4 - i}}\]</span></p>
<p>【Monte Hall Show】 몬티 홀 딜레마는 미국 TV 게임쇼 <span dir="rtl">”</span>Let<span dir="rtl">’</span>s Make a Deal”에서 유래한 퀴즈 게임으로, 진행자 몬티 홀의 이름을 따왔습니다. 이 게임에서 참가자는 세 개의 문 중 하나를 선택해, 문 뒤에 숨겨진 선물을 받을 기회를 갖습니다. 세 문 중 하나 뒤에는 자동차가, 나머지 두 문 뒤에는 염소가 있습니다.</p>
<p>예를 들어, 한 참가자가 1번 문을 선택했다고 가정해봅시다. 이때 진행자는 3번 문을 열어 염소가 있음을 보여준 후, 참가자에게 처음 선택한 1번 문 대신 2번 문으로 바꿀 기회를 제안합니다. 이 상황에서, 참가자가 자동차를 받을 확률을 최대화하려면 처음 선택을 유지하는 것이 좋을까요, 아니면 선택을 바꾸는 것이 유리할까요? 몬티 홀 문제는 이러한 질문을 통해 선택의 전략과 확률을 탐구하는 흥미로운 사례로, 단순한 직관에 반하는 결과를 보여줍니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image11.png" style="width:2.45162in;height:1.35953in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<p>선택을 바꾸지 않을 경우 자동차에 당첨될 확률은 <span class="math inline">\(\frac{1}{3}\)</span>이지만, 선택을 바꿀 경우 확률은 <span class="math inline">\(\frac{2}{3}\)</span>로 증가합니다. 그럼에도 불구하고, 대부분의 참가자는 처음 선택을 고수하는 경향을 보입니다. 이는 인간이 항상 합리적 선택을 한다는 전통 경제학의 가정에 반하는 사례로, 몬티 홀 딜레마는 이러한 점에서 매우 유명합니다. 전통 경제학에 따르면 인간은 합리적이고 이성적인 존재로, 언제나 자신의 이익을 극대화하기 위해 행동한다고 가정합니다. 따라서 전통 경제학의 관점에서 보면, 몬티 홀 문제를 푸는 합리적인 인간은 선택을 바꾸는 것이 당연한 전략이 될 것입니다.</p>
<p>【죄수 3인의 딜레마】 세 명의 수감자 A, B, C는 각각 별도의 감방에 수감되어 사형을 선고받았고, 주지사는 이들 중 무작위로 한 명을 사면하기로 결정하였습니다. 소장은 누가 사면 대상인지 알고 있지만, 이를 직접적으로 밝힐 수는 없습니다.</p>
<p>이 상황에서, 수감자 A는 교도관에게 처형될 두 사람 중 한 사람의 이름을 알려달라고 요청합니다. A는 다음과 같은 제안을 합니다: <span dir="rtl">”</span>B가 사면 대상이라면 C의 이름을, C가 사면 대상이라면 B의 이름을 알려주세요. 만약 제가 사면 대상이라면 동전을 던져 B 또는 C 중 하나의 이름을 알려주세요.” 이 요청에 따라 교도관은 A에게 B가 처형될 것이라고 말합니다.</p>
<p>이 말을 들은 A는 자신이 사면될 확률이 원래의 <span class="math inline">\(\frac{1}{3}\)</span>에서 <span class="math inline">\(\frac{1}{2}\)</span>로 높아졌다고 믿고 기뻐합니다. 반면, 수감자 C는 A와 다르게 자신이 사면될 확률이 <span class="math inline">\(\frac{2}{3}\)</span>로 증가했다고 생각하며 안도합니다. 이 상황에서 누가 옳은 것일까요?</p>
<p><span class="math display">\[P(A|P) = \frac{P(AP)}{P(P)} = \frac{P(A)P(P|A)}{P(A)P(P|A) + P(B)P(P|B) + P(C)P(P|C)}\]</span></p>
<p><span class="math inline">\(= \frac{1/3 \times 1/2}{1/3 \times 1/2 + 1/3 \times 0 + 1/3 \times 1} = 1/3\)</span>.</p>
<p><span class="math display">\[P(C|P) = \frac{P(CP)}{P(P)} = \frac{P(C)P(P|C)}{P(A)P(P|A) + P(B)P(P|B) + P(C)P(P|C)}\]</span></p>
<p><span class="math inline">\(= \frac{1/3 \times 1}{1/3 \times 1/2 + 1/3 \times 0 + 1/3 \times 1} = 2/3\)</span>.</p>
<p>2독립</p>
<p>두 사건 A와 B가 독립적이면 아래와 같은 조건을 만족한다. <span class="math inline">\(P(A \cap B) = P(A)P(B\)</span></p>
<p>독립 정의</p>
<p>사건 <span class="math inline">\(E_{1},E_{2},{\ldots,E}_{k}\)</span>가 다음 조건을 만족하면 서로 독립 mutually independent 이라 한다.</p>
<p>서로독립 정의</p>
<p><span class="math display">\[P(E_{1}E_{2}...E_{k}) = P(E_{1})P(E_{2})...P(E_{k})\]</span></p>
<p>【사례】 도박사 Chevalier de Meré가 던진 질문을 다룬다. 그는 주사위를 4번 던졌을 때, 최소한 한 번 <span dir="rtl">’</span>6<span dir="rtl">’</span>이 나올 확률에 관심을 가졌다.</p>
<p><span class="math display">\[P(\text{at leat 1 six in 4 rolls}) = 1 - P(\text{no six in 4 rolls}) = 1 - (5/6)^{4}\]</span></p>
<p>【사례】 <span class="math inline">\(P(A) = 0.5,P(B) = 0.3,P(AB) = 0.1\)</span>이다. 다음을 구하라.</p>
<ol type="1">
<li><p><span class="math display">\[P(A|B) = P(AB)/P(B) = 0.1/0.3 = 1/3\]</span></p></li>
<li><p><span class="math display">\[P(A|A \cup B) = \frac{P(A \cap (A \cup B))}{P(A \cup B)} = \frac{0.5}{0.5 + 0.3 - 0.1} = 5/7\]</span></p></li>
<li><p><span class="math display">\[P(A|A \cap B) = \frac{P(A \cap (A \cap B))}{P(A \cap B)} = \frac{0.1}{0.1} = 1\]</span></p></li>
</ol>
<p>【사례】 <span class="math inline">\(P(A) &gt; 0,P(B) &gt; 0\)</span>이고 사건 A, B는 상호 배반이다. 서로 독립인가? 증명하라.</p>
<p>【풀이】 상호 배반이면 <span class="math inline">\(A \cap B = \phi\)</span>이므로 <span class="math inline">\(P(A \cap B) = 0\)</span>이므로 독립<span class="math inline">\((P(AB) \neq P(A)P(B))\)</span>은 아니다.</p>
<p>【사례】 만약 <span class="math inline">\(P(A) &gt; 0,P(B) &gt; 0\)</span>, <span class="math inline">\(P(A) &lt; P(A|B)\)</span>이면 <span class="math inline">\(P(B) &lt; P(B|A)\)</span>임을 증명하라.</p>
<p>【풀이】 <span class="math inline">\(P(A) &lt; \frac{P(AB)}{P(B)}\)</span>이므로 <span class="math inline">\(P(A)P(B) &lt; P(AB)\)</span>이다. 그러므로 <span class="math inline">\(P(B) &lt; P(AB)/P(A) = P(B|A)\)</span>이다.</p>
<p>【사례】 두 사건 A, B는 서로 독립이다. 사건 <span class="math inline">\(A,B^{c}\)</span>는 서로 독립인가?</p>
<p>【풀이】 두 사건 A, B는 서로 독립이면 <span class="math inline">\(P(AB) = P(A)P(B)\)</span>, <span class="math inline">\(P(AB^{C}) = P(A) - P(AB) = P(A) - P(A)P(B) = P(A)(1 - P(B)) = P(A)P(B^{C})\)</span>이므로 독립이다.</p>
<p>동일한 방법으로 <span class="math inline">\((A^{c},B^{c}),(A^{c},B)\)</span>도 독립임을 보일 수 있다.</p>
<p>【사례】 동전을 세 번 던지는 실험의 표본공간은 다음과 같다.<span class="math inline">\(S = \{ HHH,HHT,HTH,THH,TTH,THT,HTT,TTT\}\)</span>사건 <span class="math inline">\(H_{i},i = 1,2,3\)</span>를 “i번째 던짐에서 앞면이 나오는 사건”으로 정의한다면 <span class="math inline">\(H_{i}\)</span>는 서로 독립이다.</p>
<p>Chapter 5. 베이즈 확률</p>
<p>베이즈 규칙은 영국의 수학자이자 장로교 목사였던 토마스 베이즈(Thomas Bayes, 1702–1761)가 발견했습니다. 그는 사후에 발표된 논문 *<span dir="rtl">”</span>An Essay Towards Solving a Problem in the Doctrine of Chances”*에서 베이즈 정리를 처음으로 제시했습니다.</p>
<p>베이즈는 확률 이론을 사용하여 어떤 사건이 발생했을 때, 그 원인에 대해 추론하는 문제를 해결하려고 했습니다. 특히 그는 다음과 같은 상황을 다루고자 했습니다.</p>
<ul>
<li><p>역추론 문제: 특정 결과가 관측되었을 때, 그 결과를 발생시킨 원인을 역으로 추정하는 방법을 연구했습니다. 이는 주어진 데이터를 바탕으로 사건의 사전 확률을 업데이트하는 과정으로, 오늘날 베이즈 통계학의 기초가 됩니다.</p></li>
<li><p>불확실한 상황에서 의사결정: 특정한 사건이 발생할 가능성을 계산하고, 주어진 추가 정보가 있을 때 확률을 어떻게 갱신할지를 이해하려는 노력이었습니다.이는 확률을 동적으로 갱신하고 불확실성을 줄이는 데 사용됩니다.</p></li>
</ul>
<p>1전확률 법칙</p>
<p><span class="math inline">\(S = \bigcup_{i = 1}^{k}B_{i},B_{i}B_{j} = \phi fori \neq j,P\left( B_{i} \right) &gt; 0\)</span>, 즉 <span class="math inline">\(B_{1},B_{2},\ldots,B_{k}\)</span> 상호 배타적 합이 표본공간인 mutually exclusive and collectively exhausted 사건이라 하자. 임의의 사건 <span class="math inline">\(A\)</span>에 대하여 다음이 성립하는데 이를 전확률 법칙이라 한다.</p>
<p><span class="math display">\[P(A) = \sum_{i = 1}^{k}{P(AB_{i})} = \sum_{i = 1}^{k}{P(B_{i})P({A|B}_{i})}\]</span></p>
<p><strong>B<sub>1</sub></strong></p>
<p><strong>B<sub>k</sub></strong></p>
<p><strong>A</strong></p>
<p><strong>B<sub>4</sub>…</strong></p>
<p><strong>B<sub>3</sub></strong></p>
<p><strong>B<sub>2</sub></strong></p>
<p>2베이지 규칙 Bayes Rule</p>
<p>영국 철학자 Thomas Bayes의 이름에서 유래된 것으로 사건 H(가설)의 확률을 새로운 사건 D(데이터)에 의해 조건부 확률을 계산하는 개념이다. <span class="math inline">\(P\left( H \middle| D \right) = \frac{P(D|H)P(H)}{P(D)}\)</span>.</p>
<p><span class="math inline">\(B_{1},B_{2},\ldots,B_{k}\)</span> 상호 배타적 합이 표본공간인 mutually exclusive and collectively exhausted 사건인 경우 다음이 성립하는데 이를 베이지 규칙이라 한다.</p>
<p><span class="math display">\[P\left( B_{j} \middle| A \right) = \frac{P(B_{j}A)}{P(A)} = \frac{P\left( B_{j} \right)P(A|B_{j})}{\sum_{i = 1}^{k}{P\left( B_{i} \right)P(A|B_{i})}}\]</span></p>
<p>【예제】 노랑 주머니에는 3개 빨강 구슬, 7개 파랑 구슬이 있고 초록 주머니에는 8개 빨강 구슬, 2개 파랑 구슬이 있다. 주사위를 굴려 5 이상 수가 나오면 노랑 주머니에서 4이하 수가 나오면 초록 주머니에서 구슬을 뽑는다고 하자. 뽑은 구슬이 빨강이었다면 그 구슬이 노랑 주머니에서 나왔을 확률은? (답) 1/3</p>
<blockquote class="blockquote">
<p>3/30</p>
<p>7/30</p>
<p>16/30</p>
<p>4/30</p>
</blockquote>
<p>3특이도와 민감도</p>
<blockquote class="blockquote">
<p>3/30</p>
<p>7/30</p>
<p>16/30</p>
<p>4/30</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image13.png" style="width:4.10616in;height:2.75897in" class="figure-img"></p>
<figcaption>텍스트, 스크린샷, 번호, 폰트이(가) 표시된 사진 자동 생성된 설명</figcaption>
</figure>
</div>
</blockquote>
<ul>
<li><p>민감도 sensitivity : 양성(감염)을 양성으로 진단할 확률, 실제 양성 중에서 모델이 양성으로 올바르게 예측한 비율.</p></li>
<li><p>특이도 specificity : 음성(정상)을 음성으로 진단할 확률</p></li>
<li><p>양성 예측율 positive predicted Value, 정밀도 precision: 양성 진단자 중 참 양성 확률, 실제 음성 중에서 모델이 음성으로 올바르게 예측한 비율.</p></li>
<li><p>음성 예측율 negative predicted Value : 음성 진단자 중 참 음성 확률</p></li>
<li><p>감염율 prevalence : 전체 검사자 중 양성 비율</p></li>
<li><p>정확도 accuracy : 전체 예측 중에서 올바르게 예측한 비율.</p></li>
<li><p><span class="math inline">\(\text{F1 Score} = 2 \cdot \frac{\text{Precision} \cdot \text{Recall}}{\text{Precision} + \text{Recall}}\)</span>: 정밀도와 민감도의 조화 평균. 불균형 데이터셋에서 정밀도와 민감도를 함께 고려.</p></li>
</ul>
<p>저자 정보</p>
<ul>
<li><p>1982. 성균관대학교 통계학 학사</p></li>
<li><p>1985. 성균관대학교 통계학 석사</p></li>
<li><p>1992. 미국 North Carolina State University 통계학 박사</p></li>
<li><p>1993-1995. 전자통신연구원 선임연구원</p></li>
<li><p>1995-2026. 한남대학교 통계학과 교수</p></li>
</ul>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>