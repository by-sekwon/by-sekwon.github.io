<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>MLDL 불학실성 – 세상의 모든 통계 이야기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-44962e3d41ec9ccc254fd50f1af5efbe.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">세상의 모든 통계 이야기</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../notes/math_stat/index.html"> 
<span class="menu-text">기초수학·수리통계</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/intro_stat/index.html"> 
<span class="menu-text">기초통계·조사방법</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/linear_model/index.html"> 
<span class="menu-text">회귀·다변량</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../notes/mldl_intro/index.html" aria-current="page"> 
<span class="menu-text">MLDL개념</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl_prediction/index.html"> 
<span class="menu-text">MLDL예측</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl_classification/index.html"> 
<span class="menu-text">MLDL분류</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cardnews/index.html"> 
<span class="menu-text">카드뉴스</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../consult.html"> 
<span class="menu-text">통계상담</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../notes/mldl_intro/mldl_uncertainty.html">📄 불확실성</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_intro/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">【머신·딥러닝 개념】</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_intro/mldl_concepts.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 개요</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_intro/mldl_concepts01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 MLDL 개념 1</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_intro/mldl_concepts02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 MLDL 개념 2</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_intro/mldl_supervised.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 지도학습</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_intro/mldl_unsupervised.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 비지도학습</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_intro/mldl_evaluation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 MLDL 평가</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_intro/mldl_uncertainty.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">📄 불확실성</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_intro/method_intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 MLDL 기초</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_intro/mldl_deep_concepts.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 딥러닝 기초</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#chapter-1.-ml-예측에는-왜-신뢰구간이-없는가" id="toc-chapter-1.-ml-예측에는-왜-신뢰구간이-없는가" class="nav-link active" data-scroll-target="#chapter-1.-ml-예측에는-왜-신뢰구간이-없는가">Chapter 1. ML 예측에는 왜 신뢰구간이 없는가</a>
  <ul>
  <li><a href="#전통적-신뢰구간의-전제" id="toc-전통적-신뢰구간의-전제" class="nav-link" data-scroll-target="#전통적-신뢰구간의-전제">1. 전통적 신뢰구간의 전제</a></li>
  <li><a href="#ml-예측과-불확실성의-차이" id="toc-ml-예측과-불확실성의-차이" class="nav-link" data-scroll-target="#ml-예측과-불확실성의-차이">2. ML 예측과 불확실성의 차이</a></li>
  <li><a href="#ml에서-불확실성을-다루는-다른-방식들" id="toc-ml에서-불확실성을-다루는-다른-방식들" class="nav-link" data-scroll-target="#ml에서-불확실성을-다루는-다른-방식들">3. ML에서 불확실성을 다루는 다른 방식들</a></li>
  <li><a href="#흔한-오해-정리" id="toc-흔한-오해-정리" class="nav-link" data-scroll-target="#흔한-오해-정리">4. 흔한 오해 정리</a></li>
  </ul></li>
  <li><a href="#chapter-2.-불확실성-추정-방법" id="toc-chapter-2.-불확실성-추정-방법" class="nav-link" data-scroll-target="#chapter-2.-불확실성-추정-방법">Chapter 2. 불확실성 추정 방법</a>
  <ul>
  <li><a href="#bootstrap-기반-접근" id="toc-bootstrap-기반-접근" class="nav-link" data-scroll-target="#bootstrap-기반-접근">1. Bootstrap 기반 접근</a></li>
  <li><a href="#ensemble-기반-불확실성" id="toc-ensemble-기반-불확실성" class="nav-link" data-scroll-target="#ensemble-기반-불확실성">2. Ensemble 기반 불확실성</a></li>
  <li><a href="#예측-분포-해석" id="toc-예측-분포-해석" class="nav-link" data-scroll-target="#예측-분포-해석">3. 예측 분포 해석</a></li>
  <li><a href="#방법-간-비교와-통합적-관점" id="toc-방법-간-비교와-통합적-관점" class="nav-link" data-scroll-target="#방법-간-비교와-통합적-관점">4. 방법 간 비교와 통합적 관점</a></li>
  </ul></li>
  <li><a href="#chapter-3.-explainable-ai와-통계의-역할" id="toc-chapter-3.-explainable-ai와-통계의-역할" class="nav-link" data-scroll-target="#chapter-3.-explainable-ai와-통계의-역할">Chapter 3. Explainable AI와 통계의 역할</a>
  <ul>
  <li><a href="#설명가능성의-필요성" id="toc-설명가능성의-필요성" class="nav-link" data-scroll-target="#설명가능성의-필요성">1. 설명가능성의 필요성</a></li>
  <li><a href="#통계적-해석과-기계적-설명의-차이" id="toc-통계적-해석과-기계적-설명의-차이" class="nav-link" data-scroll-target="#통계적-해석과-기계적-설명의-차이">2. 통계적 해석과 기계적 설명의 차이</a></li>
  <li><a href="#ml-시대-통계학의-역할" id="toc-ml-시대-통계학의-역할" class="nav-link" data-scroll-target="#ml-시대-통계학의-역할">3. ML 시대 통계학의 역할</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-body" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">MLDL 불학실성</h1>
</div>



<div class="quarto-title-meta column-body">

    
  
    
  </div>
  


</header>


<section id="chapter-1.-ml-예측에는-왜-신뢰구간이-없는가" class="level3">
<h3 class="anchored" data-anchor-id="chapter-1.-ml-예측에는-왜-신뢰구간이-없는가">Chapter 1. ML 예측에는 왜 신뢰구간이 없는가</h3>
<p>머신러닝 예측 결과에는 보통 신뢰구간이 함께 제시되지 않는다. 이는 머신러닝이 불완전해서가 아니라, 전통적 신뢰구간이 성립하는 통계적 전제와 머신러닝 예측의 목적이 서로 다르기 때문이다. 신뢰구간은 모수 추론을 위한 도구인 반면, 머신러닝은 모수보다 예측 함수와 그 성능을 목표로 한다.</p>
<p>이 장에서는 전통적 신뢰구간이 어떤 전제 위에서 정의되는지 정리하고, 머신러닝 예측에서 다루는 불확실성의 성격이 왜 근본적으로 다른지를 명확히 구분한다. 이를 통해 머신러닝 예측에 신뢰구간이 붙지 않는 이유를 결핍이 아닌 설계 철학의 차이로 이해한다.</p>
<ul>
<li>전통적 신뢰구간은 모수 추론을 위한 장치이다.</li>
<li>머신러닝 예측은 모수가 아니라 함수와 성능을 목표로 한다.</li>
<li>따라서 머신러닝 예측에는 전통적 의미의 신뢰구간이 붙지 않는다.</li>
<li>머신러닝의 불확실성은 데이터·모델·절차의 결합으로 나타난다.</li>
<li>불확실성 표현은 신뢰구간이 아닌 다른 도구로 이루어진다.</li>
</ul>
<section id="전통적-신뢰구간의-전제" class="level4">
<h4 class="anchored" data-anchor-id="전통적-신뢰구간의-전제">1. 전통적 신뢰구간의 전제</h4>
<section id="신뢰구간은-무엇에-대한-구간인가" class="level5">
<h5 class="anchored" data-anchor-id="신뢰구간은-무엇에-대한-구간인가">신뢰구간은 무엇에 대한 구간인가</h5>
<p>전통적 신뢰구간은 모수에 대한 구간이다. 예를 들어 선형회귀에서 관심 대상은 회귀계수 \beta이며, 신뢰구간은 다음 질문에 답한다.</p>
<p>같은 표본추출과 추정 절차를 무한히 반복했을 때, 이 구간이 참값 <span class="math inline">\(\beta\)</span>를 포함할 장기적 빈도는 얼마인가.</p>
<p>즉, 신뢰구간은 단일 데이터셋에 대한 불확실성 진술이 아니라, 반복 표본추출이라는 가상의 실험을 전제로 한 확률적 진술이다.</p>
</section>
<section id="신뢰구간이-성립하기-위한-핵심-전제" class="level5">
<h5 class="anchored" data-anchor-id="신뢰구간이-성립하기-위한-핵심-전제">신뢰구간이 성립하기 위한 핵심 전제</h5>
<p>신뢰구간이 통계적으로 정당하려면 다음 전제들이 필요하다.</p>
<p>첫째, 명시적 확률모형이 존재해야 한다.</p>
<p>둘째, 모수는 고정된 상수이며 확률적 대상은 추정량이다.</p>
<p>셋째, 추정량의 분포 이론이 확보되어야 한다. 정규근사, 점근성, 분산 추정 가능성이 여기에 포함된다.</p>
<p>넷째, 표본 설계가 독립성 가정을 만족해야 한다. 일반적으로 i.i.d. 혹은 그에 준하는 구조가 요구된다.</p>
<p>이 전제들이 충족될 때에만 \hat{\beta}의 표본분포가 정의되고, 그 위에서 신뢰구간이 구성된다.</p>
</section>
<section id="예측구간과의-구분" class="level5">
<h5 class="anchored" data-anchor-id="예측구간과의-구분">예측구간과의 구분</h5>
<p>전통 통계에서도 신뢰구간과 예측구간은 구분된다. 신뢰구간은 모수의 불확실성을 다루는 반면, 예측구간은 새로운 관측값의 불확실성을 다룬다. 그러나 예측구간 역시 명시적 오차분포와 모형 적합의 정당성을 전제로 한다는 점에서, 전통적 확률모형의 틀 안에 있다.</p>
</section>
</section>
<section id="ml-예측과-불확실성의-차이" class="level4">
<h4 class="anchored" data-anchor-id="ml-예측과-불확실성의-차이">2. ML 예측과 불확실성의 차이</h4>
<section id="머신러닝의-1차-목표는-모수가-아니다" class="level5">
<h5 class="anchored" data-anchor-id="머신러닝의-1차-목표는-모수가-아니다">머신러닝의 1차 목표는 모수가 아니다</h5>
<p>머신러닝의 학습 목표는 다음과 같이 표현된다.</p>
<p><span class="math display">\[\min_{f}\mathbb{E}\lbrack L(Y,f(X))\rbrack\]</span></p>
<p>여기서 관심 대상은 특정 모수가 아니라 예측 함수 f의 일반화 성능이다. 즉, 머신러닝은 추론보다 예측을 우선하며, 모수 해석은 부차적이거나 존재하지 않는다.</p>
</section>
<section id="머신러닝에서-확률적-대상이-달라지는-이유" class="level5">
<h5 class="anchored" data-anchor-id="머신러닝에서-확률적-대상이-달라지는-이유">머신러닝에서 확률적 대상이 달라지는 이유</h5>
<p>전통 통계에서는 모수를 고정하고 추정량을 확률변수로 다룬다. 반면 머신러닝에서는 예측 함수 자체가 데이터, 알고리즘, 초기값, 미니배치, 최적화 경로에 의존한다. 학습 절차 전체가 비선형이고 비볼록이기 때문에, 함수 f의 표본분포를 정의하는 것은 어렵거나 의미가 없다.</p>
<p>따라서 전통적 의미의 추정량 분포라는 개념이 성립하지 않는다.</p>
</section>
<section id="머신러닝에서의-불확실성-구성-요소" class="level5">
<h5 class="anchored" data-anchor-id="머신러닝에서의-불확실성-구성-요소">머신러닝에서의 불확실성 구성 요소</h5>
<p>머신러닝에서의 불확실성은 다음 세 가지로 나누어 이해할 수 있다.</p>
<p>첫째, 데이터 불확실성은 관측 잡음이나 내재적 변동성에 해당한다.</p>
<p>둘째, 모델 불확실성은 데이터 부족이나 함수 선택의 불확실성에서 비롯된다.</p>
<p>셋째, 절차 불확실성은 초기값, 미니배치 구성, 최적화 경로의 차이로 인해 발생한다.</p>
<p>전통적 신뢰구간은 이 중 일부를 모수 분포로 흡수하지만, 머신러닝에서는 이 모든 요소가 하나의 함수 출력에 복합적으로 반영된다.</p>
</section>
<section id="왜-신뢰구간을-붙이지-않는가가-아니라-붙일-수-없는가" class="level5">
<h5 class="anchored" data-anchor-id="왜-신뢰구간을-붙이지-않는가가-아니라-붙일-수-없는가">왜 신뢰구간을 붙이지 않는가가 아니라 붙일 수 없는가</h5>
<p>머신러닝 예측에 신뢰구간이 없는 이유는 다음과 같다.</p>
<p>모수 중심의 확률 진술이 아니며, 추정량 분포를 정의할 공통 전제가 없고, 알고리즘 의존성이 커서 반복 표본추출 개념이 모호하다.</p>
<p>이는 머신러닝의 결함이 아니라, 문제 설정과 목표의 차이에서 비롯된 필연적 결과이다.</p>
</section>
</section>
<section id="ml에서-불확실성을-다루는-다른-방식들" class="level4">
<h4 class="anchored" data-anchor-id="ml에서-불확실성을-다루는-다른-방식들">3. ML에서 불확실성을 다루는 다른 방식들</h4>
<section id="재표본-기반-접근" class="level5">
<h5 class="anchored" data-anchor-id="재표본-기반-접근">재표본 기반 접근</h5>
<p>부트스트랩을 통해 예측의 변동성을 경험적으로 근사할 수 있다. 이는 데이터 민감도를 평가하고 표본 변동성에 따른 예측 분산을 추정하는 방식이다.</p>
</section>
<section id="베이즈적-접근" class="level5">
<h5 class="anchored" data-anchor-id="베이즈적-접근">베이즈적 접근</h5>
<p>베이즈 신경망이나 사후 예측분포를 사용하면, 확률적 예측 구간을 구성할 수 있다. 이는 전통적 신뢰구간과 유사한 형태를 제공하지만, 강한 가정과 높은 계산 비용을 수반한다.</p>
</section>
<section id="실무적-대안" class="level5">
<h5 class="anchored" data-anchor-id="실무적-대안">실무적 대안</h5>
<p>실무에서는 예측 분위수, 보정된 확률 출력, 신뢰 점수, 구간 예측 등이 활용된다. 이들은 신뢰구간이 아니라 의사결정을 보조하기 위한 불확실성 표현 수단이다.</p>
</section>
</section>
<section id="흔한-오해-정리" class="level4">
<h4 class="anchored" data-anchor-id="흔한-오해-정리">4. 흔한 오해 정리</h4>
<p>머신러닝은 불확실성을 무시하지 않는다. 다만 전통적 신뢰구간이 전제하는 불확실성과는 다른 종류의 불확실성을 다룬다. 신뢰구간은 특정 통계적 전제하에서만 의미가 있으며, 그 전제를 벗어난 문제에 적용되지 않을 뿐이다.</p>
</section>
</section>
<section id="chapter-2.-불확실성-추정-방법" class="level3">
<h3 class="anchored" data-anchor-id="chapter-2.-불확실성-추정-방법">Chapter 2. 불확실성 추정 방법</h3>
<p>전통적 신뢰구간이 성립하지 않는다고 해서, 머신러닝 예측에서 불확실성을 전혀 다룰 수 없는 것은 아니다. 다만 머신러닝에서는 불확실성을 모수의 분포가 아니라, 예측의 변동성·민감도·분포 형태로 접근한다. 이는 추론을 위한 확률 진술이 아니라, 예측 결과를 어떻게 사용할 것인가에 대한 정보 제공이라는 점에서 성격이 다르다.</p>
<p>이 장에서는 실무와 연구에서 가장 널리 사용되는 세 가지 접근, 즉 Bootstrap, Ensemble, 예측 분포 해석을 통계적으로 정리한다. 각 방법이 어떤 종류의 불확실성을 반영하며, 어디까지가 가능하고 어디부터가 한계인지를 명확히 구분한다.</p>
<ul>
<li>머신러닝에서는 전통적 신뢰구간 대신 다양한 불확실성 추정 방법을 사용한다.</li>
<li>Bootstrap은 데이터 민감도를, Ensemble은 모델 불확실성을 반영한다.</li>
<li>예측 분포는 점 예측이 숨기는 위험 구조를 드러낸다.</li>
<li>불확실성 추정은 하나의 수치가 아니라 다층적 해석 문제이다.</li>
<li>머신러닝의 불확실성은 통계적 진술이 아니라 의사결정 지원 수단이다.</li>
</ul>
<section id="bootstrap-기반-접근" class="level4">
<h4 class="anchored" data-anchor-id="bootstrap-기반-접근">1. Bootstrap 기반 접근</h4>
<section id="bootstrap의-기본-아이디어" class="level5">
<h5 class="anchored" data-anchor-id="bootstrap의-기본-아이디어">Bootstrap의 기본 아이디어</h5>
<p>Bootstrap은 다음 질문에서 출발한다. 우리가 가진 이 데이터가 모집단의 유일한 근사라면, 다시 표본을 뽑는다면 결과는 얼마나 달라질까. 절차는 단순하다. 원 데이터에서 복원추출로 여러 표본을 만들고, 각 표본마다 동일한 학습 절차를 적용한 뒤, 예측 결과의 분포를 관찰한다.</p>
</section>
<section id="머신러닝-예측에서의-bootstrap" class="level5">
<h5 class="anchored" data-anchor-id="머신러닝-예측에서의-bootstrap">머신러닝 예측에서의 Bootstrap</h5>
<p>관측치 <span class="math inline">\(x_{0}\)</span>에 대한 예측값 <span class="math inline">\(\widehat{f}(x_{0})\)</span>를 생각하자. Bootstrap은 재표본별 예측 <span class="math inline">\({\widehat{f}}^{*(b)}(x_{0})\)</span>의 분포를 통해 예측의 분산, 분위수, 범위를 제공한다. 이는 표본 변동성에 대한 경험적 추정으로, 데이터가 달라질 때 예측이 얼마나 흔들리는지를 보여준다.</p>
</section>
<section id="통계적-의미와-한계" class="level5">
<h5 class="anchored" data-anchor-id="통계적-의미와-한계">통계적 의미와 한계</h5>
<p>Bootstrap이 반영하는 것은 주로 데이터 불확실성과 표본 변동성이다. 반면 모델 구조의 불확실성이나 데이터 생성 과정의 오가정은 반영하지 못한다. 또한 계산 비용이 크고, 고차원이나 딥러닝 환경에서는 불안정해질 수 있다. 즉, Bootstrap은 데이터 민감도를 측정하는 도구이지, 모든 불확실성을 포괄하는 해법은 아니다.</p>
</section>
</section>
<section id="ensemble-기반-불확실성" class="level4">
<h4 class="anchored" data-anchor-id="ensemble-기반-불확실성">2. Ensemble 기반 불확실성</h4>
<section id="ensemble의-핵심-원리" class="level5">
<h5 class="anchored" data-anchor-id="ensemble의-핵심-원리">Ensemble의 핵심 원리</h5>
<p>Ensemble은 여러 개의 합리적인 모델이 존재할 때, 그들의 예측 차이 자체를 불확실성으로 해석한다. 이는 데이터뿐 아니라 모델 선택과 학습 절차의 불확실성까지 포함한다는 점에서 Bootstrap과 구별된다.</p>
</section>
<section id="대표적-ensemble-방식" class="level5">
<h5 class="anchored" data-anchor-id="대표적-ensemble-방식">대표적 Ensemble 방식</h5>
<p>서로 다른 초기값을 가진 동일 모델, 서로 다른 하이퍼파라미터 설정, 혹은 서로 다른 서브모델을 결합하는 방식이 대표적이다. 관측치 <span class="math inline">\(x_{0}\)</span>에 대해, <span class="math inline">\({\widehat{y}}^{(m)}(x_{0}),m = 1,\ldots,M\)</span>의 분산을 계산한다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/mldl_uncertainty_ensemble.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
</section>
<section id="통계적-해석" class="level5">
<h5 class="anchored" data-anchor-id="통계적-해석">통계적 해석</h5>
<p>Ensemble 분산은 주로 모델 불확실성과 최적화·초기값 의존성을 반영한다. 데이터가 적을수록 분산은 커지고, 데이터가 충분해질수록 줄어든다. 이는 더 많은 데이터가 주어질수록 모델 선택의 불확실성이 감소한다는 직관과 일치한다. 다만 데이터 불확실성은 간접적으로만 반영된다.</p>
</section>
</section>
<section id="예측-분포-해석" class="level4">
<h4 class="anchored" data-anchor-id="예측-분포-해석">3. 예측 분포 해석</h4>
<section id="점-예측에서-분포-예측으로" class="level5">
<h5 class="anchored" data-anchor-id="점-예측에서-분포-예측으로">점 예측에서 분포 예측으로</h5>
<p>머신러닝 예측을 하나의 값이 아니라 조건부 분포 전체로 확장할 수 있다. 즉, 목표는 <span class="math inline">\(\widehat{y}\)</span>가 아니라 <span class="math inline">\(p(y \mid x)\)</span> 혹은 그 근사이다. 이는 예측의 불확실성을 직접적으로 표현한다.</p>
</section>
<section id="분포-기반-접근의-예" class="level5">
<h5 class="anchored" data-anchor-id="분포-기반-접근의-예">분포 기반 접근의 예</h5>
<p>분위수 회귀는 특정 분위수의 예측을 제공하여 비대칭적 위험을 드러낸다. 분포 회귀는 평균과 분산을 동시에 예측한다. 베이즈 신경망은 사후 예측분포를 통해 예측의 변동성을 확률적으로 표현한다. 이들은 전통적 신뢰구간과 달리, 예측이 얼마나 흔들릴 수 있는지를 직접 보여준다.</p>
</section>
<section id="예측-분포-해석의-원칙" class="level5">
<h5 class="anchored" data-anchor-id="예측-분포-해석의-원칙">예측 분포 해석의 원칙</h5>
<p>예측 분포를 해석할 때는 다음을 구분해야 한다. 분포의 폭은 불확실성의 크기를 의미하지만, 참값 포함 확률을 보장하지 않는다. 분포의 형태는 위험의 비대칭성을 드러내지만, 모델 가정에 의존한다. 또한 분포 예측은 의사결정 비용 구조와 결합될 때 의미를 갖는다. 즉, 예측 분포는 해석의 종착점이 아니라 판단의 입력이다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 48%">
<col style="width: 48%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">구분</td>
<td style="text-align: center;">의미</td>
</tr>
<tr class="even">
<td style="text-align: center;">분산이 큼</td>
<td style="text-align: center;">예측 불확실성 높음</td>
</tr>
<tr class="odd">
<td style="text-align: center;">꼬리가 김</td>
<td style="text-align: center;">극단값 가능성</td>
</tr>
<tr class="even">
<td style="text-align: center;">비대칭</td>
<td style="text-align: center;">위험의 방향성</td>
</tr>
<tr class="odd">
<td style="text-align: center;">다봉</td>
<td style="text-align: center;">이질적 패턴 공존</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="방법-간-비교와-통합적-관점" class="level4">
<h4 class="anchored" data-anchor-id="방법-간-비교와-통합적-관점">4. 방법 간 비교와 통합적 관점</h4>
<section id="불확실성-종류별-대응" class="level5">
<h5 class="anchored" data-anchor-id="불확실성-종류별-대응">불확실성 종류별 대응</h5>
<p>Bootstrap은 데이터 민감도와 표본 변동성에 강하며, Ensemble은 모델 선택과 학습 절차의 불확실성을 반영한다. 예측 분포 접근은 위험의 형태와 크기를 직접 표현한다. 어느 하나가 모든 불확실성을 포괄하지는 않는다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 48%">
<col style="width: 48%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;">불확실성</td>
<td style="text-align: left;">대응 방법</td>
</tr>
<tr class="even">
<td style="text-align: left;">표본 변동성</td>
<td style="text-align: left;">Bootstrap</td>
</tr>
<tr class="odd">
<td style="text-align: left;">모델 선택</td>
<td style="text-align: left;">Ensemble</td>
</tr>
<tr class="even">
<td style="text-align: left;">예측 결과</td>
<td style="text-align: left;">분포 예측</td>
</tr>
</tbody>
</table>
</section>
<section id="통합적-사용의-원칙" class="level5">
<h5 class="anchored" data-anchor-id="통합적-사용의-원칙">통합적 사용의 원칙</h5>
<p>실무에서는 이들 방법을 배타적으로 선택하기보다 보완적으로 사용한다. 예를 들어, Ensemble로 모델 불확실성을 평가하고, 그 위에 예측 분포를 해석하여 의사결정 규칙을 설계할 수 있다. Bootstrap은 데이터 변경에 대한 민감도 점검에 활용된다.</p>
</section>
<section id="실무적-해석의-핵심" class="level5">
<h5 class="anchored" data-anchor-id="실무적-해석의-핵심">실무적 해석의 핵심</h5>
<p>머신러닝에서의 불확실성 추정은 참값을 포함할 확률을 말하는 것이 아니다. 이는 이 예측을 어느 정도 신뢰해도 되는지, 그리고 어떤 위험을 감수하는지를 판단하기 위한 정보이다. 불확실성은 추론의 결과가 아니라, 의사결정을 위한 입력이다.</p>
</section>
</section>
</section>
<section id="chapter-3.-explainable-ai와-통계의-역할" class="level3">
<h3 class="anchored" data-anchor-id="chapter-3.-explainable-ai와-통계의-역할">Chapter 3. Explainable AI와 통계의 역할</h3>
<p>머신러닝 모델, 특히 딥러닝은 뛰어난 예측 성능을 보이지만, 그 결과가 왜 그렇게 나왔는지에 대해서는 종종 침묵한다. 이로 인해 최근 AI 분야에서는 설명가능 인공지능, 즉 Explainable AI(XAI)가 중요한 연구 및 실무 주제로 부상하였다. 그러나 XAI가 요구하는 설명은 통계학에서 전통적으로 다루어 온 설명과 동일하지 않다.</p>
<p>이 장에서는 설명가능성이 왜 필요한지, 통계적 해석과 기계적 설명의 차이는 무엇인지, 그리고 머신러닝 시대에 통계학이 수행해야 할 역할을 정리한다. 이를 통해 XAI를 과대평가하거나 오해하지 않고, 통계적 사고와 어떻게 결합해야 하는지를 분명히 한다.</p>
<ul>
<li>Explainable AI는 성능 이후의 필수 요구이다.</li>
<li>XAI의 설명은 기계적이고 국소적인 설명이다.</li>
<li>통계적 해석은 불확실성과 구조를 전제로 한 설명이다.</li>
<li>두 설명은 목적과 수준이 다르며, 대체 관계가 아니다.</li>
<li>머신러닝 시대 통계학의 역할은 설명을 비판적으로 해석하고 검증하는 기준을 제공하는 것이다.</li>
</ul>
<section id="설명가능성의-필요성" class="level4">
<h4 class="anchored" data-anchor-id="설명가능성의-필요성">1. 설명가능성의 필요성</h4>
<section id="왜-예측만으로는-충분하지-않은가" class="level5">
<h5 class="anchored" data-anchor-id="왜-예측만으로는-충분하지-않은가">왜 예측만으로는 충분하지 않은가</h5>
<p>많은 머신러닝 시스템은 단순한 예측기를 넘어 의사결정 시스템으로 사용된다. 신용평가, 의료 진단, 정책 대상자 선정, 위험 탐지와 같은 영역에서는 예측 결과 자체보다 그 결과가 사용되는 방식이 더 중요해진다.</p>
<p>이러한 상황에서는 다음 질문이 필수적으로 제기된다. 이 결과를 신뢰해도 되는가, 어떤 요인이 이 결정을 이끌었는가, 다른 상황에서도 같은 판단이 나올 것인가. 즉, 설명가능성은 성능의 문제가 아니라 책임성과 신뢰성의 문제이다.</p>
</section>
<section id="규제와-윤리적-요구" class="level5">
<h5 class="anchored" data-anchor-id="규제와-윤리적-요구">규제와 윤리적 요구</h5>
<p>설명가능성은 기술적 요구를 넘어 제도적 요구이기도 하다. 차별과 편향의 검증, 결정에 대한 이의 제기 가능성, 정책과 법적 정당성 확보는 모두 설명을 전제로 한다. 이때 설명은 단순한 시각화나 중요도 나열이 아니라, 논리적으로 납득 가능한 근거 제시를 의미한다.</p>
</section>
</section>
<section id="통계적-해석과-기계적-설명의-차이" class="level4">
<h4 class="anchored" data-anchor-id="통계적-해석과-기계적-설명의-차이">2. 통계적 해석과 기계적 설명의 차이</h4>
<section id="통계적-해석이란-무엇인가" class="level5">
<h5 class="anchored" data-anchor-id="통계적-해석이란-무엇인가">통계적 해석이란 무엇인가</h5>
<p>통계학에서의 해석은 다음 질문에 답한다. 어떤 변수가 결과에 체계적으로 관련되어 있는가, 그 관계는 어떤 방향과 크기를 가지는가, 이 관계는 우연이 아닌가. 즉, 통계적 해석은 불확실성을 전제로 한 구조적 설명이다.</p>
<p>회귀계수, 신뢰구간, 효과 크기, 가설검정은 모두 관계의 안정성과 재현성을 묻는 도구이다. 통계적 해석은 단일 사례가 아니라, 데이터 생성 구조 전반에 대한 진술을 목표로 한다.</p>
</section>
<section id="xai에서의-기계적-설명" class="level5">
<h5 class="anchored" data-anchor-id="xai에서의-기계적-설명">XAI에서의 기계적 설명</h5>
<p>많은 XAI 기법은 다른 질문에 답한다. 이 예측에서 어떤 입력이 얼마나 기여했는가, 특정 입력을 바꾸면 출력은 어떻게 변하는가. SHAP, LIME, feature importance와 같은 방법들은 개별 예측 또는 국소 영역에서의 기여도를 설명한다.</p>
<p>이러한 설명은 모델 내부 작동을 이해하는 데 유용하지만, 그 자체로 구조적 해석이나 인과적 설명을 제공하지는 않는다.</p>
</section>
<section id="근본적-차이" class="level5">
<h5 class="anchored" data-anchor-id="근본적-차이">근본적 차이</h5>
<p>통계적 해석은 관계의 안정성과 우연성을 묻는 반면, XAI의 기계적 설명은 특정 모델과 특정 입력에 조건부로 정의된다. 따라서 XAI의 설명은 데이터 생성 구조에 대한 진술이 아니라, 모델 내부에서의 계산 결과에 대한 설명이다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 32%">
<col style="width: 32%">
<col style="width: 32%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">구분</td>
<td style="text-align: center;">통계적 해석</td>
<td style="text-align: center;">기계적 설명</td>
</tr>
<tr class="even">
<td style="text-align: center;">대상</td>
<td style="text-align: center;">구조·관계</td>
<td style="text-align: center;">개별 예측</td>
</tr>
<tr class="odd">
<td style="text-align: center;">관점</td>
<td style="text-align: center;">모집단</td>
<td style="text-align: center;">특정 관측</td>
</tr>
<tr class="even">
<td style="text-align: center;">불확실성</td>
<td style="text-align: center;">명시적으로 고려</td>
<td style="text-align: center;">대개 미고려</td>
</tr>
<tr class="odd">
<td style="text-align: center;">질문</td>
<td style="text-align: center;">왜 이런 관계가 존재하는가</td>
<td style="text-align: center;">왜 이 값이 나왔는가</td>
</tr>
</tbody>
</table>
</section>
<section id="흔한-오해" class="level5">
<h5 class="anchored" data-anchor-id="흔한-오해">흔한 오해</h5>
<p>이 차이를 혼동하면 다음과 같은 오해가 발생한다. 기여도가 크면 원인이라는 해석, 중요도가 높으면 인과적이라는 주장이다. 그러나 이는 모델 내부에서의 상대적 기여를 보여줄 뿐, 현실 세계의 인과 구조를 보장하지 않는다.</p>
</section>
</section>
<section id="ml-시대-통계학의-역할" class="level4">
<h4 class="anchored" data-anchor-id="ml-시대-통계학의-역할">3. ML 시대 통계학의 역할</h4>
<section id="설명을-검증하는-학문" class="level5">
<h5 class="anchored" data-anchor-id="설명을-검증하는-학문">설명을 검증하는 학문</h5>
<p>머신러닝 시대에 통계학의 첫 번째 역할은 모델이 제시한 설명을 검증하는 것이다. 설명 결과가 표본 변화에 얼마나 민감한지, 재표본을 통해 얼마나 안정적인지, 데이터 분포가 바뀌어도 유지되는지를 평가한다. 이는 예측이 아니라 설명 자체에 대한 통계적 검증이다.</p>
</section>
<section id="구조적-사고의-제공" class="level5">
<h5 class="anchored" data-anchor-id="구조적-사고의-제공">구조적 사고의 제공</h5>
<p>통계학은 설명에 대해 끊임없이 구조적 질문을 던진다. 이 설명은 어떤 가정 위에 서 있는가, 데이터 생성 과정이 달라지면 유지되는가, 다른 설명도 가능한가. 이는 머신러닝이 종종 간과하는 모형 외부의 사고이며, 설명의 남용을 막는 안전장치이다.</p>
</section>
<section id="xai와-통계의-바람직한-관계" class="level5">
<h5 class="anchored" data-anchor-id="xai와-통계의-바람직한-관계">XAI와 통계의 바람직한 관계</h5>
<p>XAI와 통계는 경쟁 관계가 아니다. XAI는 모델 내부를 들여다보는 도구이고, 통계학은 그 결과를 해석하고 검증하며 일반화하는 틀이다. XAI는 설명을 만들어내고, 통계는 그 설명이 얼마나 믿을 만한지를 판단한다.</p>
</section>
<section id="통계학의-재정의" class="level5">
<h5 class="anchored" data-anchor-id="통계학의-재정의">통계학의 재정의</h5>
<p>머신러닝 시대의 통계학은 단순한 회귀 기법의 집합도 아니고, 과거의 추론 도구에 머물지도 않는다. 통계학의 핵심 역할은 불확실성의 언어를 제공하고, 구조와 우연을 구분하며, 설명의 정당성을 검증하고, 의사결정의 합리성을 확보하는 데 있다.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>