<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>MLDL 지도학습 – 세상의 모든 통계 이야기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-2757cfadcc89ddbfb9e61569f8c3689f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">세상의 모든 통계 이야기</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../notes/math/index.html"> 
<span class="menu-text">기초수학</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/math_stat/index.html"> 
<span class="menu-text">수리통계</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/intro_stat/index.html"> 
<span class="menu-text">기초통계</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/survey/index.html"> 
<span class="menu-text">조사방법론</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/linear_model/index.html"> 
<span class="menu-text">회귀분석</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mda/index.html"> 
<span class="menu-text">다변량분석</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../notes/mldl/index.html" aria-current="page"> 
<span class="menu-text">머신·딥러닝 개념 w/GPT</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl_method/index.html"> 
<span class="menu-text">머신·딥러닝 방법론 w/GPT</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cardnews/index.html"> 
<span class="menu-text">카드뉴스</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../consult.html"> 
<span class="menu-text">통계상담</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../notes/mldl/mldl_supervised.html">📄 지도학습</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">【HOME】</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_concepts.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 개요</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_concepts01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 MLDL 개념 1</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_concepts02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 MLDL 개념 2</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_supervised.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">📄 지도학습</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_unsupervised.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 비지도학습</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_evaluation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 평가</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_uncertainty.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 불확실성</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_deeplearning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 딥러닝</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#chapter-1.-선형회귀-ml의-시작" id="toc-chapter-1.-선형회귀-ml의-시작" class="nav-link active" data-scroll-target="#chapter-1.-선형회귀-ml의-시작">Chapter 1. 선형회귀 ≠ ML의 시작</a>
  <ul>
  <li><a href="#설명모형과-예측모형의-차이" id="toc-설명모형과-예측모형의-차이" class="nav-link" data-scroll-target="#설명모형과-예측모형의-차이">1. 설명모형과 예측모형의 차이</a></li>
  <li><a href="#ml은-회귀에서-출발하나-회귀는-아니다" id="toc-ml은-회귀에서-출발하나-회귀는-아니다" class="nav-link" data-scroll-target="#ml은-회귀에서-출발하나-회귀는-아니다">2. ML은 회귀에서 출발하나 회귀는 아니다</a></li>
  </ul></li>
  <li><a href="#chapter-2.-손실함수와-확률모형" id="toc-chapter-2.-손실함수와-확률모형" class="nav-link" data-scroll-target="#chapter-2.-손실함수와-확률모형">Chapter 2. 손실함수와 확률모형</a>
  <ul>
  <li><a href="#손실함수의-역할과-의미" id="toc-손실함수의-역할과-의미" class="nav-link" data-scroll-target="#손실함수의-역할과-의미">1. 손실함수의 역할과 의미</a></li>
  <li><a href="#경험적-위험-최소화empirical-risk-minimization" id="toc-경험적-위험-최소화empirical-risk-minimization" class="nav-link" data-scroll-target="#경험적-위험-최소화empirical-risk-minimization">2. 경험적 위험 최소화(Empirical Risk Minimization)</a></li>
  <li><a href="#대표적-손실함수의-통계적-해석" id="toc-대표적-손실함수의-통계적-해석" class="nav-link" data-scroll-target="#대표적-손실함수의-통계적-해석">3. 대표적 손실함수의 통계적 해석</a></li>
  <li><a href="#손실함수-선택이-내포하는-확률-가정" id="toc-손실함수-선택이-내포하는-확률-가정" class="nav-link" data-scroll-target="#손실함수-선택이-내포하는-확률-가정">4. 손실함수 선택이 내포하는 확률 가정</a></li>
  </ul></li>
  <li><a href="#chapter-3.-로지스틱-회귀를-분류기로-다시-보기" id="toc-chapter-3.-로지스틱-회귀를-분류기로-다시-보기" class="nav-link" data-scroll-target="#chapter-3.-로지스틱-회귀를-분류기로-다시-보기">Chapter 3. 로지스틱 회귀를 분류기로 다시 보기</a>
  <ul>
  <li><a href="#로지스틱-회귀의-통계적-구조" id="toc-로지스틱-회귀의-통계적-구조" class="nav-link" data-scroll-target="#로지스틱-회귀의-통계적-구조">1. 로지스틱 회귀의 통계적 구조</a></li>
  <li><a href="#확률-예측과-분류-결정의-차이" id="toc-확률-예측과-분류-결정의-차이" class="nav-link" data-scroll-target="#확률-예측과-분류-결정의-차이">2. 확률 예측과 분류 결정의 차이</a></li>
  <li><a href="#분류-성능지표와-손실함수의-불일치" id="toc-분류-성능지표와-손실함수의-불일치" class="nav-link" data-scroll-target="#분류-성능지표와-손실함수의-불일치">3. 분류 성능지표와 손실함수의 불일치</a></li>
  <li><a href="#임계값-선택-비용-민감-분류-그리고-roc-곡선" id="toc-임계값-선택-비용-민감-분류-그리고-roc-곡선" class="nav-link" data-scroll-target="#임계값-선택-비용-민감-분류-그리고-roc-곡선">4. 임계값 선택, 비용 민감 분류, 그리고 ROC 곡선</a></li>
  </ul></li>
  <li><a href="#chapter-4.-머신러닝-정규화" id="toc-chapter-4.-머신러닝-정규화" class="nav-link" data-scroll-target="#chapter-4.-머신러닝-정규화">Chapter 4. 머신러닝 정규화</a>
  <ul>
  <li><a href="#과적합을-막는다는-말의-정확한-의미" id="toc-과적합을-막는다는-말의-정확한-의미" class="nav-link" data-scroll-target="#과적합을-막는다는-말의-정확한-의미">1. <span dir="rtl">”</span>과적합을 막는다”는 말의 정확한 의미</a></li>
  <li><a href="#l2-정규화ridge의-통계적-해석" id="toc-l2-정규화ridge의-통계적-해석" class="nav-link" data-scroll-target="#l2-정규화ridge의-통계적-해석">2. L2 정규화(Ridge)의 통계적 해석</a></li>
  <li><a href="#l1-정규화lasso의-통계적-해석" id="toc-l1-정규화lasso의-통계적-해석" class="nav-link" data-scroll-target="#l1-정규화lasso의-통계적-해석">3. L1 정규화(Lasso)의 통계적 해석</a></li>
  <li><a href="#정규화와-사전분포prior의-연결" id="toc-정규화와-사전분포prior의-연결" class="nav-link" data-scroll-target="#정규화와-사전분포prior의-연결">4. 정규화와 사전분포(prior)의 연결</a></li>
  <li><a href="#biasvariance-관점에서의-정규화" id="toc-biasvariance-관점에서의-정규화" class="nav-link" data-scroll-target="#biasvariance-관점에서의-정규화">5. Bias–Variance 관점에서의 정규화</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">MLDL 지도학습</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="chapter-1.-선형회귀-ml의-시작" class="level3">
<h3 class="anchored" data-anchor-id="chapter-1.-선형회귀-ml의-시작">Chapter 1. 선형회귀 ≠ ML의 시작</h3>
<p>지도학습은 흔히 선형회귀에서 출발한다고 설명되지만, 선형회귀 자체를 머신러닝의 출발점으로 동일시하는 것은 정확하지 않다.</p>
<p>이 장에서는 설명모형과 예측모형의 근본적인 차이를 출발점으로 삼아, 머신러닝이 회귀분석에서 출발하지만 왜 그 틀에 머물지 않는지를 살펴본다. 나아가 선형모형을 머신러닝 관점에서 어떻게 재해석할 수 있는지를 통계적 구조와 목표의 차이를 중심으로 정리한다.</p>
<p>선형회귀는 전통적으로 설명모형의 대표적인 도구이다. 반면 머신러닝은 동일한 수학적 형태에서 출발하더라도, 목표와 철학이 본질적으로 다르다.</p>
<p>머신러닝의 관점에서 선형회귀는 가장 단순한 예측기에 해당하며, 규제와 검증을 통해 보다 복잡한 예측 방법으로 확장된다. 따라서 <span dir="rtl">”</span>선형회귀는 ML의 시작이다”라는 표현은 형식적으로는 옳을 수 있으나, 개념적으로는 불완전한 설명이다.</p>
<section id="설명모형과-예측모형의-차이" class="level4">
<h4 class="anchored" data-anchor-id="설명모형과-예측모형의-차이">1. 설명모형과 예측모형의 차이</h4>
<section id="설명모형-왜-그런가에-대한-질문" class="level5">
<h5 class="anchored" data-anchor-id="설명모형-왜-그런가에-대한-질문">설명모형: <span dir="rtl">”</span>왜 그런가?“에 대한 질문</h5>
<p>전통적인 선형회귀는 설명을 주목적으로 하는 모형이다. 이때 분석의 관심은 주로 다음과 같은 요소에 놓인다.</p>
<ul>
<li>회귀계수 <span class="math inline">\(\beta_{j}\)</span>의 부호와 크기</li>
<li>통계적 유의성 (t-test, p-value)</li>
<li>모형의 해석 가능성</li>
</ul>
<p>고전적 선형회귀는 다음과 같은 데이터 생성과정을 전제로 한다.</p>
<p><span class="math inline">\(Y = X\beta + \varepsilon,\mathbb{E}(\varepsilon \mid X) = 0,Var(\varepsilon) = \sigma^{2}\)</span></p>
<p>이 가정하에서 회귀계수 <span class="math inline">\(\beta\)</span>는 모집단 수준에서의 구조적 관계로 해석된다. 즉, 회귀분석은 단순히 관측값을 맞추는 것이 아니라, 데이터 뒤에 존재하는 생성 메커니즘을 추론하기 위한 통계적 도구이다.</p>
</section>
<section id="예측모형-얼마나-잘-맞추는가에-대한-질문" class="level5">
<h5 class="anchored" data-anchor-id="예측모형-얼마나-잘-맞추는가에-대한-질문">예측모형: <span dir="rtl">”</span>얼마나 잘 맞추는가?“에 대한 질문</h5>
<p>반면, 머신러닝에서의 지도학습은 예측을 핵심 목표로 한다. 이때 관심의 대상은 다음과 같이 달라진다.</p>
<ul>
<li>새로운 데이터 <span class="math inline">\(x_{\text{new}}\)</span>에 대한 예측 정확도</li>
<li>일반화 오차 (generalization error)</li>
<li>테스트 데이터에서의 성능</li>
</ul>
<p>이 관점에서 중요한 것은 개별 회귀계수의 해석이 아니라, 입력 X로부터 출력 Y를 얼마나 잘 예측하는 함수 <span class="math inline">\(f\)</span> 자체의 성능이다.</p>
<p><span class="math inline">\(\widehat{Y} = f(X)\)</span>, 여기서 <span class="math inline">\(f\)</span>는 함수 공간에 속하며, 반드시 선형일 필요는 없다. 머신러닝은 특정 계수의 의미보다는, 훈련 데이터에서 학습된 함수가 보지 못한 데이터에서도 얼마나 잘 작동하는가에 초점을 둔다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 32%">
<col style="width: 32%">
<col style="width: 32%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">구분</td>
<td style="text-align: center;">설명모형</td>
<td style="text-align: center;">예측모형</td>
</tr>
<tr class="even">
<td style="text-align: center;">관심 질문</td>
<td style="text-align: center;">왜 그런가</td>
<td style="text-align: center;">얼마나 잘 맞추는가</td>
</tr>
<tr class="odd">
<td style="text-align: center;">핵심 대상</td>
<td style="text-align: center;">모수 <span class="math inline">\(\beta\)</span></td>
<td style="text-align: center;">예측함수 <span class="math inline">\(f\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">평가 기준</td>
<td style="text-align: center;">유의성, 해석</td>
<td style="text-align: center;">테스트 오차</td>
</tr>
<tr class="odd">
<td style="text-align: center;">데이터 관점</td>
<td style="text-align: center;">데이터 생성과정 복원</td>
<td style="text-align: center;">미지 데이터 적합</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="ml은-회귀에서-출발하나-회귀는-아니다" class="level4">
<h4 class="anchored" data-anchor-id="ml은-회귀에서-출발하나-회귀는-아니다">2. ML은 회귀에서 출발하나 회귀는 아니다</h4>
<section id="공통-출발점-손실함수-최소화" class="level5">
<h5 class="anchored" data-anchor-id="공통-출발점-손실함수-최소화">공통 출발점: 손실함수 최소화</h5>
<p>선형회귀와 머신러닝은 표면적으로 서로 다른 학문 영역처럼 보이지만, 수학적으로는 동일한 출발점을 공유한다. 두 방법 모두 관측된 데이터에서 예측 오차를 최소화하는 문제로 기술될 수 있다.</p>
<p>선형회귀는 다음과 같은 제곱손실 최소화 문제로 표현된다.</p>
<p><span class="math display">\[\widehat{\beta} = \arg\min_{\beta}\overset{n}{\sum_{i = 1}}(y_{i} - x_{i}^{\top}\beta)^{2}\]</span></p>
<p>이 식은 반응변수 <span class="math inline">\(y_{i}\)</span>와 설명변수 <span class="math inline">\(x_{i}\)</span>로부터 계산된 예측값 <span class="math inline">\(x_{i}^{\top}\beta\)</span>사이의 차이를 제곱한 값을 최소화하는 최적화 문제이다. 이 관점에서 선형회귀는 통계적 추론 이전에 이미 하나의 최적화 문제로 해석될 수 있다.</p>
<p>머신러닝 역시 기본적으로는 손실함수의 최소화를 목표로 한다. 일반적인 지도학습 문제는 다음과 같이 표현된다.</p>
<p><span class="math display">\[\widehat{f} = \arg\min_{f \in \mathcal{F}}\frac{1}{n}\overset{n}{\sum_{i = 1}}L(y_{i},f(x_{i}))\]</span></p>
<p>여기서 <span class="math inline">\(L( \cdot , \cdot )\)</span>는 손실함수이며, <span class="math inline">\(\mathcal{F}\)</span>는 고려하는 함수 공간을 의미한다. 선형회귀는 이 일반적인 틀에서 손실함수로 제곱손실을 사용하고, 함수 공간을 선형 함수로 제한한 특수한 경우에 해당한다.</p>
<p>이러한 이유로 선형회귀는 머신러닝의 자연스러운 출발점이 된다. 그러나 이 공통점은 손실함수 최소화라는 형식적 측면에 국한된다. 이후의 차이는 손실함수를 최소화하는 과정에서 어떤 가정을 유지하고, 어떤 제약을 완화하는가에 따라 결정된다.</p>
<p>이 지점에서 선형회귀와 머신러닝은 같은 문제에서 출발하지만, 서로 다른 방향으로 분기하게 된다.</p>
</section>
<section id="결정적-분기점-무엇을-고정하고-무엇을-유연하게-둘-것인가" class="level5">
<h5 class="anchored" data-anchor-id="결정적-분기점-무엇을-고정하고-무엇을-유연하게-둘-것인가">결정적 분기점: <span dir="rtl">”</span>무엇을 고정하고 무엇을 유연하게 둘 것인가”</h5>
<p>전통적인 선형회귀에서는 모형 구조가 사전에 고정된다. 설명변수와 반응변수 사이의 관계는 선형으로 가정되며, 분석의 불확실성은 오차항을 통해 확률적으로 모델링된다. 이때 관심의 중심은 회귀계수 자체이며, 추정된 계수는 모집단 수준의 구조적 관계를 반영하는 것으로 해석된다. 따라서 회귀분석의 목적은 모형의 적합 그 자체보다는, 계수에 대한 추론과 해석에 놓인다.</p>
<p>반면 머신러닝에서는 모형 구조를 고정된 전제로 두지 않는다. 함수의 형태는 데이터에 따라 유연하게 변화할 수 있으며, 오차항의 분포에 대한 명시적 가정은 필수가 아니다. 분석의 목표 역시 모수 추론이 아니라, 관측되지 않은 새로운 데이터에 대한 예측 성능에 있다. 이 관점에서 중요한 것은 특정 계수의 통계적 유의성이 아니라, 학습된 함수가 얼마나 안정적으로 일반화되는가이다.</p>
<p>이 차이로 인해 머신러닝은 모형 해석의 명확성을 일부 포기하는 대신, 복잡한 구조와 비선형 관계를 포착할 수 있는 자유도를 확보한다.</p>
<p>회귀가 ML의 시작일 수는 있으나, ML 자체는 아닌 이유</p>
<p>선형회귀는 머신러닝의 출발점으로 활용될 수는 있으나, 그 자체로 머신러닝이라고 보기는 어렵다. 그 이유는 다음과 같다.</p>
<p>첫째, 선형회귀는 일반화 성능을 직접적으로 최적화하지 않는다. 전통적인 회귀분석에서의 적합 기준은 주로 학습 데이터에서의 오차 최소화이며, 새로운 데이터에서의 성능은 부차적인 고려 대상이다.</p>
<p>둘째, 모델 복잡도에 대한 통제가 제한적이다. 설명변수의 수가 증가하거나 변수 간 상관성이 커질 경우, 추정된 계수의 분산이 급격히 증가할 수 있다.</p>
<p>셋째, 고차원 자료나 비선형 구조에 취약하다. 선형회귀는 구조적으로 선형 관계에 의존하므로, 복잡한 패턴을 직접적으로 학습하기 어렵다.</p>
<p>머신러닝은 이러한 한계를 극복하기 위해 규제, 비선형 변환, 앙상블 기법, 신경망과 같은 방법들을 도입해 왔다. 이 과정에서 핵심은 특정 알고리즘이 아니라, 모델 선택과 평가를 중심으로 한 학습의 틀이다.</p>
</section>
<section id="선형모형의-재해석-ml-관점에서의-선형회귀" class="level5">
<h5 class="anchored" data-anchor-id="선형모형의-재해석-ml-관점에서의-선형회귀">선형모형의 재해석: ML 관점에서의 선형회귀</h5>
<p>1. 선형회귀를 가장 단순한 예측기로 보기</p>
<p>머신러닝의 관점에서 선형회귀는 설명을 위한 종착점이 아니라, 예측 성능 비교를 위한 기준선 모형으로 재해석된다. 선형회귀는 함수 공간을 선형 함수로 제한한 가장 단순한 예측모형에 해당한다.</p>
<p>복잡도 관점에서 보면, 선형회귀는 높은 편향과 낮은 분산을 갖는 모형으로 이해할 수 있으며, 이는 이후에 등장하는 보다 유연한 모델들과의 비교 기준을 제공한다.</p>
<p>2. 규제를 통한 ML적 확장</p>
<p>선형회귀는 규제를 도입하는 순간, 통계적 추론 도구에서 머신러닝 모델로 성격이 전환된다. 규제를 포함한 목적함수는 다음과 같이 표현된다.</p>
<p><span class="math display">\[\widehat{\beta} = \arg\min_{\beta}\left\{ \overset{n}{\sum_{i = 1}}(y_{i} - x_{i}^{\top}\beta)^{2} + \lambda \parallel \beta \parallel_{q} \right\}\]</span></p>
<ul>
<li>q = 2: Ridge 회귀는 계수 크기를 제어하여 분산을 감소시킨다</li>
<li>q = 1: Lasso 회귀는 변수 선택 효과를 통해 모형을 단순화한다</li>
</ul>
<p>이때 규제 강도 <span class="math inline">\(\lambda\)</span>는 해석의 대상이 아니라, 교차검증을 통해 선택되는 튜닝 파라미터이다. 이는 전통적 회귀분석과 머신러닝 사이의 중요한 관점 전환을 보여준다.</p>
<p>3. 중요한 관점 전환</p>
<p>머신러닝 관점에서 선형회귀를 사용할 때 핵심은 회귀계수의 개별적 의미가 아니다. 대신 다음과 같은 질문이 중심이 된다.</p>
<ul>
<li>이 모형은 전체 함수 공간에서 어느 수준의 복잡도를 갖는가</li>
<li>다른 예측모형들과 비교했을 때 성능은 어떠한가</li>
<li>교차검증을 통해 선택될 수 있는 합리적인 기준선인가</li>
</ul>
<p>이 관점에서 선형회귀는 설명을 위한 최종 모델이 아니라, 더 복잡한 예측모형으로 나아가기 위한 출발점이자 기준선으로 기능한다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 48%">
<col style="width: 48%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">전통 회귀</td>
<td style="text-align: center;">ML 관점</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\beta\)</span> 해석</td>
<td style="text-align: center;"><span class="math inline">\(\widehat{y}\)</span> 정확도</td>
</tr>
<tr class="odd">
<td style="text-align: center;">모수 추론</td>
<td style="text-align: center;">함수 선택</td>
</tr>
<tr class="even">
<td style="text-align: center;">가정 중심</td>
<td style="text-align: center;">검증 중심</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="chapter-2.-손실함수와-확률모형" class="level3">
<h3 class="anchored" data-anchor-id="chapter-2.-손실함수와-확률모형">Chapter 2. 손실함수와 확률모형</h3>
<p>머신러닝에서 학습이란 궁극적으로 손실함수를 최소화하는 문제로 귀결된다. 그러나 손실함수는 단순한 계산 도구가 아니라, 데이터 생성 과정에 대한 암묵적인 확률 가정을 내포한다.</p>
<p>이 장에서는 손실함수가 수행하는 통계적 역할을 정리하고, 대표적인 손실함수들이 각각 어떤 확률모형을 전제하는지를 체계적으로 살펴본다. 이를 통해 손실함수 선택이 단순한 기술적 문제가 아니라, 데이터를 어떤 확률 구조로 이해할 것인가에 대한 선택임을 분명히 한다.</p>
<ul>
<li>손실함수는 단순한 계산 도구가 아니라 통계적 가정의 집합이다.</li>
<li>ERM(경험적 위험 최소화)은 기대 위험을 표본 기반으로 근사하는 통계적 원리이다.</li>
<li>MSE, MAE, Cross-Entropy는 각각 서로 다른 확률모형을 전제한다.</li>
<li>손실함수 선택은 곧 <span dir="rtl">”</span>데이터를 어떤 확률 구조로 이해할 것인가”에 대한 선택이다.</li>
</ul>
<section id="손실함수의-역할과-의미" class="level4">
<h4 class="anchored" data-anchor-id="손실함수의-역할과-의미">1. 손실함수의 역할과 의미</h4>
<section id="손실함수란-무엇을-측정하는가" class="level5">
<h5 class="anchored" data-anchor-id="손실함수란-무엇을-측정하는가">손실함수란 무엇을 측정하는가</h5>
<p>손실함수는 관측값 y와 예측값 \hat{y} 사이의 불일치 정도를 수치화한 함수이다. 지도학습에서의 학습 문제는 일반적으로 다음과 같이 정식화된다.</p>
<p><span class="math inline">\(\widehat{f} = \arg\min_{f \in \mathcal{F}}\frac{1}{n}\overset{n}{\sum_{i = 1}}L(y_{i},f(x_{i}))\)</span>, 여기서 <span class="math inline">\(L( \cdot , \cdot )\)</span>는 손실함수이며, <span class="math inline">\(\mathcal{F}\)</span>는 고려하는 함수 공간이다.</p>
<p>이 식에서 중요한 점은 두 가지이다. 첫째, 손실함수는 모델 선택의 기준이 된다. 둘째, 손실함수는 무엇이 좋은 예측인가를 정의한다. 즉, 손실함수는 단순한 평가 지표가 아니라 학습의 목표 자체를 규정한다.</p>
</section>
<section id="손실함수와-평가지표의-차이" class="level5">
<h5 class="anchored" data-anchor-id="손실함수와-평가지표의-차이">손실함수와 평가지표의 차이</h5>
<p>평가 지표(metric)는 학습이 끝난 후 모델의 성능을 비교하거나 보고하기 위한 수단이다. 반면 손실함수는 학습 과정에서 직접 최소화되는 대상이다. 두 개념은 밀접하게 연결되어 있지만, 목적과 역할은 다르다.</p>
<p>통계적 관점에서 손실함수는 위험을 정의하는 핵심 요소이며, 학습 문제의 성격을 결정한다.</p>
</section>
</section>
<section id="경험적-위험-최소화empirical-risk-minimization" class="level4">
<h4 class="anchored" data-anchor-id="경험적-위험-최소화empirical-risk-minimization">2. 경험적 위험 최소화(Empirical Risk Minimization)</h4>
<section id="기대-위험과-경험적-위험" class="level5">
<h5 class="anchored" data-anchor-id="기대-위험과-경험적-위험">기대 위험과 경험적 위험</h5>
<p>이론적으로 이상적인 학습 목표는 모집단 분포 하에서의 평균 손실을 최소화하는 것이다.</p>
<p><span class="math display">\[R(f) = \mathbb{E}\lbrack L(Y,f(X))\rbrack\]</span></p>
<p>이를 기대 위험(expected risk)이라 한다. 그러나 실제로는 데이터 생성 분포를 알 수 없으므로, 다음과 같은 표본 기반 문제를 풀게 된다.</p>
<p><span class="math display">\[\widehat{R}(f) = \frac{1}{n}\overset{n}{\sum_{i = 1}}L(y_{i},f(x_{i}))\]</span></p>
<p>이를 경험적 위험(empirical risk)이라 한다.</p>
</section>
<section id="erm의-통계적-의미" class="level5">
<h5 class="anchored" data-anchor-id="erm의-통계적-의미">ERM의 통계적 의미</h5>
<p>경험적 위험 최소화는 다음과 같은 가정을 전제로 한다. 관측 데이터는 모집단에서 독립적이고 동일한 분포로 추출되며, 표본 평균은 기대값의 일관된 추정량이라는 가정이다.</p>
<p>즉, ERM은 대수의 법칙에 기반한 통계적 추론 절차이다. 머신러닝이 흔히 확률 가정을 하지 않는다고 설명되지만, ERM 자체는 이미 확률적 사고 위에 서 있다.</p>
</section>
</section>
<section id="대표적-손실함수의-통계적-해석" class="level4">
<h4 class="anchored" data-anchor-id="대표적-손실함수의-통계적-해석">3. 대표적 손실함수의 통계적 해석</h4>
<p>1. MSE (Mean Squared Error) <span class="math inline">\(L(y,\widehat{y}) = (y - \widehat{y})^{2}\)</span></p>
<p>MSE를 최소화하는 것은 다음 확률모형을 암묵적으로 가정한다.</p>
<p><span class="math display">\[Y \mid X = x \sim \mathcal{N}(f(x),\sigma^{2})\]</span></p>
<p>즉, 오차는 정규분포, 분산은 상수, 조건부 평균이 예측 목표이다. 따라서 MSE 최소화는 **정규오차 가정 하의 최대우도추정(MLE)**과 동치이다.</p>
<p>2. MAE (Mean Absolute Error) <span class="math inline">\(L(y,\widehat{y}) = |y - \widehat{y}|\)</span></p>
<p>MAE는 다음 분포를 전제한다.</p>
<p><span class="math display">\[Y \mid X = x \sim \text{Laplace}(f(x),b)\]</span></p>
<p>이 경우 예측 목표는 조건부 평균이 아니라 조건부 중앙값이다. 따라서 MAE는 이상치에 대해 더 강건한 성질을 갖는다.</p>
<p>3. Cross-Entropy (Log Loss)</p>
<p>이진 분류의 경우 손실함수는 다음과 같다.</p>
<p><span class="math display">\[L(y,p) = - \lbrack y\log p + (1 - y)\log(1 - p)\rbrack\]</span></p>
<p>이는 다음 확률모형과 정확히 대응된다.</p>
<p><span class="math display">\[Y \mid X = x \sim \text{Bernoulli}(p(x))\]</span></p>
<p>즉, Cross-Entropy 최소화는 베르누이 분포에 대한 로그우도 최대화이다. 로지스틱 회귀, 신경망 분류 모두 이 구조를 공유한다.</p>
</section>
<section id="손실함수-선택이-내포하는-확률-가정" class="level4">
<h4 class="anchored" data-anchor-id="손실함수-선택이-내포하는-확률-가정">4. 손실함수 선택이 내포하는 확률 가정</h4>
<section id="손실함수와-분포-선택" class="level5">
<h5 class="anchored" data-anchor-id="손실함수와-분포-선택">손실함수와 분포 선택</h5>
<p>손실함수를 선택한다는 것은 단순히 계산 규칙을 정하는 것이 아니라, 데이터의 오차 구조를 어떻게 이해할 것인가를 결정하는 행위이다. 이는 오차가 어떤 분포를 따른다고 볼 것인지, 예측의 기준을 조건부 평균으로 둘 것인지, 중앙값이나 확률로 둘 것인지를 함께 선택하는 것을 의미한다.</p>
<p>또한 손실함수에 따라 이상치에 얼마나 민감하게 반응할 것인지도 자연스럽게 결정된다. 이러한 점에서 손실함수의 선택은 통계모형에서 확률분포를 선택하는 행위와 본질적으로 동일한 의미를 갖는다.</p>
</section>
<section id="머신러닝은-확률-가정을-하지-않는다는-오해" class="level5">
<h5 class="anchored" data-anchor-id="머신러닝은-확률-가정을-하지-않는다는-오해"><span dir="rtl">”</span>머신러닝은 확률 가정을 하지 않는다”는 오해</h5>
<p>머신러닝은 오차항의 분포를 명시적으로 기술하지 않으며, 모수의 신뢰구간을 제시하지 않는 경우가 많다. 그러나 손실함수를 통해 확률모형을 암묵적으로 채택한다.</p>
<p>따라서 손실함수는 머신러닝에서 가장 중요한 통계적 가정이 위치하는 지점이며, 학습 알고리즘의 성격을 결정하는 핵심 요소이다.</p>
</section>
</section>
</section>
<section id="chapter-3.-로지스틱-회귀를-분류기로-다시-보기" class="level3">
<h3 class="anchored" data-anchor-id="chapter-3.-로지스틱-회귀를-분류기로-다시-보기">Chapter 3. 로지스틱 회귀를 분류기로 다시 보기</h3>
<p>로지스틱 회귀는 오랫동안 분류 문제의 대표적인 방법으로 소개되어 왔다. 그러나 통계적 관점에서 로지스틱 회귀는 본질적으로 분류기라기보다는, 이진 반응변수에 대한 조건부 확률을 추정하는 확률모형이다. 즉, 로지스틱 회귀의 1차적 목적은 개별 관측치가 특정 범주에 속할 확률을 추정하는 데 있으며, 분류는 그 이후에 수행되는 의사결정의 결과이다.</p>
<p>이 장에서는 로지스틱 회귀의 통계적 구조를 다시 정리하고, 확률 예측과 분류 결정을 명확히 구분하여 이해한다. 이를 통해 로지스틱 회귀 학습에서 사용되는 손실함수와, 실제 분류 성능을 평가할 때 사용하는 지표 사이에 왜 불일치가 발생하는지를 설명한다. 이러한 불일치는 모형의 결함이 아니라, 확률 추정과 의사결정이 서로 다른 단계에 속하기 때문에 발생하는 구조적 현상이다.</p>
<p>로지스틱 회귀는 본질적으로 이진 반응변수에 대한 확률모형이며, 학습의 목적은 분류 정확도를 직접적으로 극대화하는 것이 아니라 조건부 확률을 일관되게 추정하는 데 있다. 분류는 추정된 확률값에 임계값을 적용함으로써 이루어지며, 이 임계값의 선택은 분석 목적이나 비용 구조에 따라 달라질 수 있다.</p>
<p>이러한 관점에서 보면, 분류 성능지표와 손실함수 사이의 불일치는 자연스럽고 정상적인 결과이다. 손실함수는 확률 추정의 정확성을 평가하는 기준인 반면, 분류 성능지표는 확률값에 기반한 의사결정의 결과를 평가하기 때문이다. 따라서 로지스틱 회귀를 분류기로 이해하기 위해서는 확률모형과 분류 규칙을 명확히 분리하여 사고할 필요가 있다.</p>
<p>이 구분을 통해 로지스틱 회귀는 단순한 분류 알고리즘이 아니라, 확률 예측을 중심으로 한 통계적 모델이라는 본래의 성격을 보다 분명하게 이해할 수 있다.</p>
<section id="로지스틱-회귀의-통계적-구조" class="level4">
<h4 class="anchored" data-anchor-id="로지스틱-회귀의-통계적-구조">1. 로지스틱 회귀의 통계적 구조</h4>
<section id="기본-모형" class="level5">
<h5 class="anchored" data-anchor-id="기본-모형">기본 모형</h5>
<p>이진 반응변수 <span class="math inline">\(Y \in \{ 0,1\}\)</span>에 대해 로지스틱 회귀는 다음을 가정한다.</p>
<p><span class="math inline">\(Y \mid X = x \sim \text{Bernoulli}(p(x))\)</span>, <span class="math inline">\(\log\frac{p(x)}{1 - p(x)} = x^{\top}\beta\)</span></p>
<p>즉, 반응변수는 베르누이 분포를 따르며, 설명변수는 성공확률의 로그 오즈에 선형적으로 작용한다. 이때 <span class="math inline">\(p(X) = \mathbb{P}(Y = 1 \mid X)\)</span>는 조건부 확률로 해석된다. 이 구조는 처음부터 끝까지 확률모형으로 구성되어 있으며, 로지스틱 회귀는 분류 규칙이 아니라 확률 생성 메커니즘을 명시적으로 모델링한다.</p>
</section>
<section id="학습-최대우도추정" class="level5">
<h5 class="anchored" data-anchor-id="학습-최대우도추정">학습 = 최대우도추정</h5>
<p>로지스틱 회귀의 학습은 다음과 같은 로그우도를 최대화하는 문제로 정의된다.</p>
<p><span class="math display">\[\ell(\beta) = \overset{n}{\sum_{i = 1}}\lbrack y_{i}\log p_{i} + (1 - y_{i})\log(1 - p_{i})\rbrack\]</span></p>
<p>이는 곧 Cross-Entropy 손실을 최소화하는 문제와 동치이다. 따라서 로지스틱 회귀는 분류 정확도를 직접적으로 최적화하는 모형이 아니라, 조건부 확률 <span class="math inline">\(p(X)\)</span>를 일관되게 추정하도록 설계된 확률모형이다.</p>
</section>
</section>
<section id="확률-예측과-분류-결정의-차이" class="level4">
<h4 class="anchored" data-anchor-id="확률-예측과-분류-결정의-차이">2. 확률 예측과 분류 결정의 차이</h4>
<section id="확률-예측-통계적-산출물" class="level5">
<h5 class="anchored" data-anchor-id="확률-예측-통계적-산출물">확률 예측: 통계적 산출물</h5>
<p>로지스틱 회귀의 직접적인 결과는 각 관측치에 대해 추정된 조건부 확률이다.</p>
<p><span class="math display">\[\widehat{p}(X) = \mathbb{P}(Y = 1 \mid X)\]</span></p>
<p>이 확률값은 단순한 분류 결과 이상의 정보를 담고 있다. 확률 예측은 개별 관측치에 대한 불확실성의 정도를 표현하며, 결정 경계 근처에 위치한 관측치가 얼마나 애매한지를 보여준다. 또한 손실이나 비용이 비대칭적인 상황에서는 위험 기반 의사결정을 가능하게 한다. 이처럼 확률 예측은 연속적이며 정보가 풍부한 통계적 산출물이다.</p>
</section>
<section id="분류-결정-추가-규칙의-도입" class="level5">
<h5 class="anchored" data-anchor-id="분류-결정-추가-규칙의-도입">분류 결정: 추가 규칙의 도입</h5>
<p>분류는 확률 예측 위에 결정 규칙을 추가함으로써 이루어진다. 일반적으로는 다음과 같은 임계값 기반 규칙이 사용된다.</p>
<p><span class="math inline">\(\widehat{y} = \{\begin{matrix}
1 &amp; \text{if}\widehat{p}(x) \geq c \\
0 &amp; \text{otherwise}
\end{matrix}\)</span>, 여기서 임계값 <span class="math inline">\(c\)</span>는 통계적으로 자동 결정되지 않으며, 오류 비용, 위험 선호, 문제의 목적에 따라 외생적으로 정해진다. 즉, 로지스틱 회귀는 분류기를 직접 만들어내지 않으며, 분류기는 로지스틱 회귀가 제공한 확률 예측 위에서 별도의 규칙을 통해 구성된다.</p>
<p>이 점을 혼동할 경우, 로지스틱 회귀가 곧 분류 규칙을 학습한다고 오해하기 쉽다.</p>
</section>
<section id="흔한-오해" class="level5">
<h5 class="anchored" data-anchor-id="흔한-오해">흔한 오해</h5>
<table class="caption-top table">
<colgroup>
<col style="width: 48%">
<col style="width: 48%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">오해</td>
<td style="text-align: center;">정확한 해석</td>
</tr>
<tr class="even">
<td style="text-align: center;">로지스틱 회귀는 분류모형이다</td>
<td style="text-align: center;">확률모형이다</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0/1을 예측한다</td>
<td style="text-align: center;">확률을 예측한다</td>
</tr>
<tr class="even">
<td style="text-align: center;">정확도가 목적이다</td>
<td style="text-align: center;">로그우도가 목적이다</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="분류-성능지표와-손실함수의-불일치" class="level4">
<h4 class="anchored" data-anchor-id="분류-성능지표와-손실함수의-불일치">3. 분류 성능지표와 손실함수의 불일치</h4>
<section id="손실함수와-평가-지표의-차원-차이" class="level5">
<h5 class="anchored" data-anchor-id="손실함수와-평가-지표의-차원-차이">손실함수와 평가 지표의 차원 차이</h5>
<p>로지스틱 회귀의 학습 과정에서 최소화되는 대상은 Cross-Entropy, 즉 로그손실이다. 이는 확률 예측의 정합성을 평가하는 손실함수이다. 반면 실제 분류 성능 평가는 정확도, Precision과 Recall, F1-score, ROC–AUC와 같은 지표를 사용한다.</p>
<p>이 두 종류의 기준은 서로 다른 대상을 측정한다. 손실함수는 연속적인 확률 예측의 품질을 평가하는 반면, 분류 성능지표는 임계값 이후의 이산적인 결정 결과만을 평가한다.</p>
</section>
<section id="불일치가-발생하는-이유" class="level5">
<h5 class="anchored" data-anchor-id="불일치가-발생하는-이유">불일치가 발생하는 이유</h5>
<p>이로 인해 다음과 같은 현상이 자연스럽게 발생할 수 있다. 로그손실은 지속적으로 개선되지만 분류 정확도는 변하지 않을 수 있으며, 반대로 정확도는 높지만 확률 예측이 심하게 왜곡된 모델도 존재할 수 있다.</p>
<p>통계적 관점에서 보면 이는 모형의 결함이 아니라, 확률 추정과 의사결정이 서로 다른 단계에 속하기 때문에 발생하는 구조적 결과이다. 로지스틱 회귀는 확률모형으로서의 역할을 충실히 수행하고 있으며, 분류 성능은 그 위에 얹힌 결정 규칙과 평가 기준에 의해 추가적으로 결정된다.</p>
</section>
<section id="통계적-관점에서의-해석" class="level5">
<h5 class="anchored" data-anchor-id="통계적-관점에서의-해석">통계적 관점에서의 해석</h5>
<table class="caption-top table">
<colgroup>
<col style="width: 48%">
<col style="width: 48%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">단계</td>
<td style="text-align: center;">역할</td>
</tr>
<tr class="even">
<td style="text-align: center;">로지스틱 회귀</td>
<td style="text-align: center;">조건부 확률 추정</td>
</tr>
<tr class="odd">
<td style="text-align: center;">손실함수</td>
<td style="text-align: center;">확률모형의 적합도 평가</td>
</tr>
<tr class="even">
<td style="text-align: center;">분류 규칙</td>
<td style="text-align: center;">의사결정 기준 반영</td>
</tr>
<tr class="odd">
<td style="text-align: center;">성능지표</td>
<td style="text-align: center;">결정 결과 평가</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="임계값-선택-비용-민감-분류-그리고-roc-곡선" class="level4">
<h4 class="anchored" data-anchor-id="임계값-선택-비용-민감-분류-그리고-roc-곡선">4. 임계값 선택, 비용 민감 분류, 그리고 ROC 곡선</h4>
<p>로지스틱 회귀에서 분류는 확률 예측 이후에 수행되는 의사결정 단계이다. 따라서 분류 결과는 확률 추정의 정확성뿐만 아니라, 예측 확률에 적용되는 임계값의 선택에 의해 결정된다. 이 임계값은 통계적으로 자동 결정되는 값이 아니며, 문제의 목적과 오류 비용 구조에 따라 외생적으로 설정된다.</p>
<section id="임계값-선택과-분류-성능의-변화" class="level5">
<h5 class="anchored" data-anchor-id="임계값-선택과-분류-성능의-변화">임계값 선택과 분류 성능의 변화</h5>
<p>이진 분류에서 흔히 사용되는 임계값 0.5는 두 범주의 오류 비용이 동일하다는 강한 가정을 전제로 한다. 그러나 실제 문제에서는 이 가정이 성립하지 않는 경우가 대부분이다. 임계값을 낮추면 양성으로 분류되는 관측치가 증가하여 재현율은 높아지지만, 위양성 오류도 함께 증가한다. 반대로 임계값을 높이면 정밀도는 향상되지만, 양성을 놓칠 가능성이 커진다.</p>
<p>이처럼 임계값은 분류 성능지표 간의 균형을 조절하는 핵심적인 결정 변수이다.</p>
</section>
<section id="비용-민감-분류와-최적-임계값" class="level5">
<h5 class="anchored" data-anchor-id="비용-민감-분류와-최적-임계값">비용 민감 분류와 최적 임계값</h5>
<p>비용 민감 분류에서는 오류의 유형에 따라 서로 다른 비용을 부여한다. 양성을 놓치는 오류의 비용을 C_{FN}, 음성을 잘못 양성으로 분류하는 오류의 비용을 C_{FP}라고 하면, 기대 비용을 최소화하는 분류 규칙은 다음과 같이 표현될 수 있다.</p>
<p><span class="math display">\[\widehat{y} = 1\text{if}\widehat{p}(X) \geq \frac{C_{FP}}{C_{FP} + C_{FN}}\]</span></p>
<p>이 식은 최적의 임계값이 데이터로부터 자동 추정되는 값이 아니라, 오류 비용의 상대적 크기에 의해 결정된다는 점을 보여준다. 즉, 임계값 선택은 통계적 추정의 문제가 아니라 의사결정의 문제이다.</p>
</section>
<section id="roc-곡선의-역할" class="level5">
<h5 class="anchored" data-anchor-id="roc-곡선의-역할">ROC 곡선의 역할</h5>
<p>ROC 곡선은 임계값을 변화시키면서 얻어지는 참양성률과 위양성률의 관계를 시각화한 도구이다. ROC 곡선은 특정 임계값에서의 분류 성능을 제시하지 않으며, 가능한 모든 임계값에 대해 분류 성능이 어떻게 변화하는지를 전체적으로 보여준다.</p>
<p>이 점에서 ROC 곡선은 하나의 최적 분류기를 제안하는 도구가 아니라, 임계값 선택에 따른 성능 변화의 범위를 제시하는 탐색 도구로 이해하는 것이 타당하다.</p>
</section>
<section id="roc와-확률-예측의-관계" class="level5">
<h5 class="anchored" data-anchor-id="roc와-확률-예측의-관계">ROC와 확률 예측의 관계</h5>
<p>ROC 분석은 예측 확률의 절대적인 크기보다는, 양성과 음성을 얼마나 잘 구분하여 순위화할 수 있는지를 평가한다. 따라서 ROC–AUC는 확률 예측의 보정 상태나 정확성을 직접적으로 반영하지 않으며, 확률 예측의 분리 능력을 요약한 지표로 해석되어야 한다.</p>
<p>동일한 ROC–AUC 값을 갖는 모델이라 하더라도, 예측 확률의 해석 가능성이나 신뢰성은 크게 다를 수 있다.</p>
</section>
<section id="통합적-해석" class="level5">
<h5 class="anchored" data-anchor-id="통합적-해석">통합적 해석</h5>
<p>로지스틱 회귀에서 분류 성능은 확률 예측, 임계값 선택, 오류 비용 구조가 결합된 결과이다. ROC 곡선은 이 관계를 한눈에 보여주는 도구이며, 비용 민감 분류는 ROC 곡선 위의 특정 지점을 선택하는 문제로 해석할 수 있다.</p>
<p>이러한 관점에서 로지스틱 회귀는 단순한 분류 알고리즘이 아니라, 확률 예측을 중심으로 한 통계적 의사결정 프레임워크로 이해되어야 한다.</p>
</section>
</section>
</section>
<section id="chapter-4.-머신러닝-정규화" class="level3">
<h3 class="anchored" data-anchor-id="chapter-4.-머신러닝-정규화">Chapter 4. 머신러닝 정규화</h3>
<p>머신러닝에서 정규화(regularization)는 흔히 과적합을 막기 위한 기술적 장치로 소개된다. 그러나 통계적 관점에서 정규화는 단순한 테크닉이 아니라, 모형 파라미터에 대한 사전적 믿음(prior belief)을 수식으로 구현한 것이다. 즉, 정규화는 데이터를 어떻게 해석할 것인가에 대한 통계적 선택을 명시적으로 반영한다.</p>
<p>정규화는 단순한 과적합 방지 기법이 아니다. 이는 계수에 대한 사전적 믿음을 수식으로 표현한 것이며, L2 정규화는 정규분포 prior, L1 정규화는 Laplace 분포 prior에 대응한다. 이러한 정규화된 학습은 본질적으로 최대사후확률(MAP) 추정 문제로 이해할 수 있다. 이 관점에서 머신러닝은 확률을 배제한 통계가 아니라, 확률을 다른 언어로 표현한 통계라고 볼 수 있다.</p>
<section id="과적합을-막는다는-말의-정확한-의미" class="level4">
<h4 class="anchored" data-anchor-id="과적합을-막는다는-말의-정확한-의미">1. <span dir="rtl">”</span>과적합을 막는다”는 말의 정확한 의미</h4>
<section id="과적합의-통계적-의미" class="level5">
<h5 class="anchored" data-anchor-id="과적합의-통계적-의미">과적합의 통계적 의미</h5>
<p>과적합이란 학습 데이터에서는 손실이 매우 작지만, 새로운 데이터에서는 예측 오차가 급격히 증가하는 상태를 의미한다. 이는 추정량의 분산이 지나치게 커진 상황으로 해석할 수 있다. 즉, 데이터에 과도하게 적합된 모형은 작은 데이터 변동에도 민감하게 반응하며, 일반화 성능이 저하된다.</p>
<p>정규화는 이러한 문제를 해결하기 위해 분산을 의도적으로 줄이는 개입이다. 일부 편향을 허용하는 대신, 전체적인 예측 안정성을 확보하는 것이 정규화의 핵심 목적이다.</p>
</section>
<section id="정규화의-본질-모형을-덜-믿게-만드는-장치" class="level5">
<h5 class="anchored" data-anchor-id="정규화의-본질-모형을-덜-믿게-만드는-장치">정규화의 본질: 모형을 덜 믿게 만드는 장치</h5>
<p>정규화의 도입은 데이터가 말하는 것을 100% 신뢰하지 않겠다는 선언에 가깝다. 이는 회귀계수의 크기가 과도하게 커지는 것을 허용하지 않고, 불필요하게 복잡한 해를 피하며, 적당히 단순한 모형을 선호하겠다는 의미이다. 이러한 선호가 수식으로 표현된 것이 정규화 항이다.</p>
</section>
</section>
<section id="l2-정규화ridge의-통계적-해석" class="level4">
<h4 class="anchored" data-anchor-id="l2-정규화ridge의-통계적-해석">2. L2 정규화(Ridge)의 통계적 해석</h4>
<p>L2 정규화를 포함한 학습 문제는 다음과 같이 표현된다.</p>
<p><span class="math display">\[\widehat{\beta} = \arg\min_{\beta}\left\{ \overset{n}{\sum_{i = 1}}(y_{i} - x_{i}^{\top}\beta)^{2} + \lambda \parallel \beta \parallel_{2}^{2} \right\}\]</span></p>
<p>이 목적함수에서 두 항은 서로 다른 역할을 수행한다. 첫 번째 항은 데이터에 대한 적합도를 나타내며, 두 번째 항은 회귀계수의 크기에 대한 제약을 의미한다.</p>
<section id="l2-정규화ridge의-확률모형-관점" class="level5">
<h5 class="anchored" data-anchor-id="l2-정규화ridge의-확률모형-관점">L2 정규화(Ridge)의 확률모형 관점</h5>
<p><span class="math display">\[(y_{i} - x_{i}^{\top}\beta)^{2} \leftrightarrow \varepsilon_{i} \sim \mathcal{N}(0,\sigma^{2})\]</span></p>
<p>이제 정규화 항을 확률적으로 해석하면, <span class="math inline">\(\parallel \beta \parallel_{2}^{2} \leftrightarrow \beta_{j} \sim \mathcal{N}(0,\tau^{2})\)</span></p>
<p>정규화 항을 확률적으로 해석하면, 이는 회귀계수에 대해 평균이 0이고 분산이 제한된 정규분포 prior를 부여한 것과 동일하다. 즉, Ridge 회귀는 오차항이 정규분포를 따른다는 가정과 함께, 회귀계수 역시 0을 중심으로 분포한다는 사전적 믿음을 전제한다.</p>
</section>
<section id="결론-ridge-map-추정" class="level5">
<h5 class="anchored" data-anchor-id="결론-ridge-map-추정">결론: Ridge = MAP 추정</h5>
<p>Ridge 회귀는 다음 문제와 동치이다.</p>
<p><span class="math display">\[{\widehat{\beta}}_{\text{MAP}} = \arg\max_{\beta}\{\log p(y \mid X,\beta) + \log p(\beta)\}\]</span></p>
<p>즉, 정규 prior를 둔 베이즈 회귀의 최대사후확률(MAP) 추정량이다. 이러한 설정 하에서 Ridge 회귀는 정규 prior를 둔 베이즈 회귀모형의 최대사후확률 추정량과 동치이다. 따라서 Ridge 회귀는 빈번도적 기법처럼 보이지만, 본질적으로는 MAP 추정 문제로 해석할 수 있다.</p>
</section>
</section>
<section id="l1-정규화lasso의-통계적-해석" class="level4">
<h4 class="anchored" data-anchor-id="l1-정규화lasso의-통계적-해석">3. L1 정규화(Lasso)의 통계적 해석</h4>
<p><span class="math display">\[\widehat{\beta} = \arg\min_{\beta}\left\{ \overset{n}{\sum_{i = 1}}(y_{i} - x_{i}^{\top}\beta)^{2} + \lambda \parallel \beta \parallel_{1} \right\}\]</span></p>
<p>L1 정규화의 가장 중요한 특징은 일부 회귀계수를 정확히 0으로 만들어 변수 선택 효과를 발생시킨다는 점이다. 이는 Ridge 회귀와 구별되는 Lasso의 핵심적인 성질이다.</p>
<section id="확률모형-관점에서의-lasso" class="level5">
<h5 class="anchored" data-anchor-id="확률모형-관점에서의-lasso">확률모형 관점에서의 Lasso</h5>
<p><span class="math display">\[\parallel \beta \parallel_{1} \leftrightarrow \beta_{j} \sim \text{Laplace}(0,b)\]</span></p>
<p>Laplace 분포는 0 근처에 확률 질량이 매우 크고 꼬리가 뾰족한 분포이다 이는 다음과 같은 사전 믿음을 반영한다. <span dir="rtl">”</span>대부분의 변수는 중요하지 않고, 소수만 중요할 것이다.”</p>
</section>
<section id="lasso의-통계적-의미" class="level5">
<h5 class="anchored" data-anchor-id="lasso의-통계적-의미">Lasso의 통계적 의미</h5>
<p>이러한 이유로 Lasso는 단순한 변수 선택 기법이 아니라, 희소성(sparsity)에 대한 강한 prior와 구조적 단순성에 대한 신념을 수식으로 구현한 결과로 이해할 수 있다.</p>
</section>
</section>
<section id="정규화와-사전분포prior의-연결" class="level4">
<h4 class="anchored" data-anchor-id="정규화와-사전분포prior의-연결">4. 정규화와 사전분포(prior)의 연결</h4>
<p>정규화된 학습 문제는 일반적으로 다음과 같은 형태로 표현할 수 있다.</p>
<p><span class="math display">\[\arg\min_{\theta}\{ - \log p(y \mid X,\theta) - \log p(\theta)\}\]</span></p>
<table class="caption-top table">
<colgroup>
<col style="width: 48%">
<col style="width: 48%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">ML 표현</td>
<td style="text-align: center;">통계적 해석</td>
</tr>
<tr class="even">
<td style="text-align: center;">손실함수</td>
<td style="text-align: center;">로그우도</td>
</tr>
<tr class="odd">
<td style="text-align: center;">정규화 항</td>
<td style="text-align: center;">로그 사전분포</td>
</tr>
<tr class="even">
<td style="text-align: center;">학습</td>
<td style="text-align: center;">MAP 추정</td>
</tr>
</tbody>
</table>
<p>이 구조는 정규화가 단순히 prior처럼 보이는 것이 아니라, prior를 명시적으로 쓰지 않은 베이즈 추론의 또 다른 표현임을 보여준다. 머신러닝에서는 prior라는 용어를 사용하지 않을 뿐, 정규화를 통해 모형에 대한 믿음을 명확히 반영한다.</p>
<p>이 관점에서 정규화는 머신러닝과 베이즈 통계 사이의 연결 고리이며, 두 접근법이 서로 다른 언어를 사용해 동일한 통계적 아이디어를 표현하고 있음을 드러낸다.</p>
</section>
<section id="biasvariance-관점에서의-정규화" class="level4">
<h4 class="anchored" data-anchor-id="biasvariance-관점에서의-정규화">5. Bias–Variance 관점에서의 정규화</h4>
<p>정규화의 효과는 단순히 과적합을 막는다는 표현만으로는 충분히 설명되지 않는다. 정규화는 추정량의 편향과 분산 사이의 균형을 의도적으로 조정하는 통계적 개입으로 이해하는 것이 보다 정확하다.</p>
<section id="biasvariance-분해와-일반화-오차" class="level5">
<h5 class="anchored" data-anchor-id="biasvariance-분해와-일반화-오차">Bias–Variance 분해와 일반화 오차</h5>
<p>예측 오차는 일반적으로 편향, 분산, 그리고 제거할 수 없는 잡음으로 분해할 수 있다. 이 중 모델 선택과 학습 방법에 의해 영향을 받는 요소는 편향과 분산이다. 분산이 큰 모델은 학습 데이터의 작은 변동에도 예측 결과가 크게 달라지며, 이는 일반화 성능 저하로 이어진다. 반대로 편향이 큰 모델은 구조적으로 단순하여 복잡한 패턴을 충분히 포착하지 못한다.</p>
<p>정규화는 이 중 분산을 줄이는 방향으로 작용한다. 회귀계수의 크기를 제한함으로써, 추정량이 데이터에 과도하게 적합되는 것을 방지하고 예측의 안정성을 높인다. 이 과정에서 일정 수준의 편향이 새롭게 도입되지만, 전체적인 일반화 오차는 오히려 감소할 수 있다.</p>
</section>
<section id="정규화-강도와-biasvariance-절충" class="level5">
<h5 class="anchored" data-anchor-id="정규화-강도와-biasvariance-절충">정규화 강도와 Bias–Variance 절충</h5>
<p>정규화의 강도는 편향과 분산의 균형을 조절하는 핵심 매개변수이다. 정규화가 약할수록 모델은 데이터에 더 자유롭게 적합되어 분산이 커지고, 정규화가 강할수록 모델은 제약을 받아 분산은 줄어들지만 편향은 증가한다.</p>
<p>이러한 절충 관계는 단일한 최적값이 존재하지 않으며, 데이터의 크기, 잡음 수준, 모형의 복잡도에 따라 달라진다. 따라서 정규화 강도의 선택은 이론적으로 결정되기보다는, 교차검증과 같은 데이터 기반 방법을 통해 경험적으로 이루어진다.</p>
</section>
<section id="l2-정규화와-분산-감소" class="level5">
<h5 class="anchored" data-anchor-id="l2-정규화와-분산-감소">L2 정규화와 분산 감소</h5>
<p>L2 정규화는 회귀계수 전체를 부드럽게 축소함으로써 분산을 줄이는 효과를 가진다. 이는 계수 추정의 불확실성을 완화하고, 공선성이 존재하는 상황에서도 보다 안정적인 예측을 가능하게 한다. 이러한 특성으로 인해 L2 정규화는 예측 정확성을 중시하는 상황에서 널리 사용된다.</p>
</section>
<section id="l1-정규화와-구조적-단순화" class="level5">
<h5 class="anchored" data-anchor-id="l1-정규화와-구조적-단순화">L1 정규화와 구조적 단순화</h5>
<p>L1 정규화는 일부 계수를 정확히 0으로 만들며, 모형 구조 자체를 단순화한다. 이는 단순한 분산 감소를 넘어, 모델의 자유도를 직접적으로 줄이는 효과를 갖는다. 이로 인해 L1 정규화는 고차원 문제나 변수 선택이 중요한 상황에서 강력한 도구로 작용한다.</p>
</section>
<section id="정규화의-통계적-위치" class="level5">
<h5 class="anchored" data-anchor-id="정규화의-통계적-위치">정규화의 통계적 위치</h5>
<p>Bias–Variance 관점에서 정규화는 최적의 균형점을 찾기 위한 도구이다. 이는 정규화가 만능 해결책이 아님을 의미하며, 정규화의 효과는 데이터와 문제 설정에 따라 달라진다. 그러나 분산을 제어하고 일반화 성능을 안정화한다는 점에서, 정규화는 머신러닝 학습 과정에서 핵심적인 통계적 역할을 수행한다.</p>
<p>이러한 관점에서 정규화는 단순한 기술적 트릭이 아니라, 불확실한 데이터 환경에서 합리적인 예측을 가능하게 하는 통계적 절충의 구현으로 이해할 수 있다.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>