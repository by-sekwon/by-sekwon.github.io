<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>MLDL 딥러닝 – 세상의 모든 통계 이야기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-2757cfadcc89ddbfb9e61569f8c3689f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">세상의 모든 통계 이야기</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../notes/math/index.html"> 
<span class="menu-text">기초수학</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/math_stat/index.html"> 
<span class="menu-text">수리통계</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/intro_stat/index.html"> 
<span class="menu-text">기초통계</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/survey/index.html"> 
<span class="menu-text">조사방법론</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/linear_model/index.html"> 
<span class="menu-text">회귀분석</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mda/index.html"> 
<span class="menu-text">다변량분석</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../notes/mldl/index.html" aria-current="page"> 
<span class="menu-text">머신·딥러닝 개념 w/GPT</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl_method/index.html"> 
<span class="menu-text">머신·딥러닝 방법론 w/GPT</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cardnews/index.html"> 
<span class="menu-text">카드뉴스</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../consult.html"> 
<span class="menu-text">통계상담</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../notes/mldl/mldl_deeplearning.html">📄 딥러닝</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">【HOME】</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_concepts.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 개요</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_concepts01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 MLDL 개념 1</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_concepts02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 MLDL 개념 2</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_supervised.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 지도학습</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_unsupervised.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 비지도학습</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_evaluation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 평가</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_uncertainty.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 불확실성</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_deeplearning.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">📄 딥러닝</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">MLDL 딥러닝</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="chapter-1.-신경망은-왜-overfit이-잘-되는가" class="level3">
<h3 class="anchored" data-anchor-id="chapter-1.-신경망은-왜-overfit이-잘-되는가">Chapter 1. 신경망은 왜 overfit이 잘 되는가</h3>
<p>딥러닝 모델은 놀라울 정도로 높은 표현력을 가지며, 동시에 매우 쉽게 과적합된다. 이 현상은 단순히 데이터가 적어서이거나 모델이 복잡해서라는 설명만으로는 충분하지 않다. 실제로 신경망은 데이터가 충분해 보이는 상황에서도 과적합과 일반화 실패를 반복적으로 보여준다.</p>
<p>이 장에서는 신경망이 구조적으로 과적합되기 쉬운 이유를 파라미터 수와 자유도, 고차원 통계 환경, 그리고 암묵적 정규화라는 관점에서 통계적으로 해석한다. 이를 통해 딥러닝에서의 과적합을 <span dir="rtl">”</span>훈련오차가 작다”는 현상이 아니라, 어떤 함수를 선택했는가의 문제로 재정의한다.</p>
<ul>
<li>신경망은 구조적으로 과적합되기 쉬운 모델이다.</li>
<li>이는 파라미터 수, 자유도, 고차원 통계 환경의 결합된 결과이다.</li>
<li>딥러닝의 일반화는 명시적 정규화보다 암묵적 정규화에 크게 의존한다.</li>
<li>과적합은 적합의 문제가 아니라 함수 선택의 문제이다.</li>
</ul>
<section id="파라미터-수와-자유도" class="level4">
<h4 class="anchored" data-anchor-id="파라미터-수와-자유도">1. 파라미터 수와 자유도</h4>
<section id="신경망의-파라미터-규모" class="level5">
<h5 class="anchored" data-anchor-id="신경망의-파라미터-규모">신경망의 파라미터 규모</h5>
<p>완전연결 신경망에서 파라미터 수는 층 수와 노드 수에 따라 급격히 증가한다. 입력 차원이 p, 은닉층 노드 수가 h, 출력 차원이 1인 단일 은닉층 신경망의 경우, 파라미터 수는 대략 <span class="math inline">\((p + 1)h + (h + 1)\)</span>로 주어진다.</p>
<p>실제 딥러닝 모델에서는 이 값이 표본 크기 n보다 훨씬 커지는 경우가 일반적이며, 이는 과잉 매개변수화(overparameterization)의 전형적인 특징이다.</p>
</section>
<section id="자유도의-통계적-의미" class="level5">
<h5 class="anchored" data-anchor-id="자유도의-통계적-의미">자유도의 통계적 의미</h5>
<p>통계학에서 자유도는 데이터에 얼마나 독립적으로 적응할 수 있는지를 나타낸다. 선형회귀에서는 자유도가 파라미터 수와 거의 일치한다. 그러나 신경망에서는 파라미터 수와 유효 자유도가 일치하지 않는다. 활성화 함수, 네트워크 구조, 가중치 공유, 학습 알고리즘 등이 자유도를 왜곡한다.</p>
<p>그럼에도 불구하고 신경망은 극도로 높은 표현 자유도를 갖는다. 이는 신경망이 매우 다양한 함수들을 실현할 수 있음을 의미한다.</p>
</section>
<section id="왜-훈련오차는-쉽게-0이-되는가" class="level5">
<h5 class="anchored" data-anchor-id="왜-훈련오차는-쉽게-0이-되는가">왜 훈련오차는 쉽게 0이 되는가</h5>
<p>신경망은 임의의 레이블 할당에도 완벽히 적합할 수 있으며, 노이즈를 포함한 데이터까지 그대로 기억할 수 있다. 이는 신경망이 단순히 좋은 함수 근사기이기 때문이 아니라, 과잉 매개변수화된 구조를 갖기 때문이다. 즉, 훈련오차가 0이 되는 현상 자체는 딥러닝에서 특별한 일이 아니다.</p>
</section>
</section>
<section id="고차원-통계-관점의-딥러닝" class="level4">
<h4 class="anchored" data-anchor-id="고차원-통계-관점의-딥러닝">2. 고차원 통계 관점의 딥러닝</h4>
<section id="고차원-영역의-통계적-특성" class="level5">
<h5 class="anchored" data-anchor-id="고차원-영역의-통계적-특성">고차원 영역의 통계적 특성</h5>
<p>딥러닝은 전형적으로 표본 수 n보다 파라미터 수 p가 훨씬 큰 영역에서 작동한다.</p>
<p><span class="math display">\[p \gg n\]</span></p>
<p>이 영역에서는 고전적 통계 직관이 붕괴한다. 추정량의 일관성은 보장되지 않으며, 분산은 매우 커지고, 훈련 성능과 일반화 성능 사이의 괴리는 커진다. 즉, 딥러닝은 고차원 통계의 극단적인 영역에서 작동하는 학습 체계이다.</p>
</section>
<section id="보간interpolation-영역과-double-descent" class="level5">
<h5 class="anchored" data-anchor-id="보간interpolation-영역과-double-descent">보간(interpolation) 영역과 double descent</h5>
<p>최근 이론은 모델 복잡도가 증가함에 따라 테스트오차가 감소했다가 증가한 뒤, 다시 감소하는 현상을 설명한다. 이를 double descent 현상이라 한다. 딥러닝 모델은 종종 훈련오차가 거의 0이 되는 보간 영역에서 학습된다.</p>
<p>이는 전통적 통계에서 기대했던 <span dir="rtl">”</span>과적합 이후 성능 악화”라는 단순한 직관과 충돌한다. 즉, 훈련오차가 0이라는 사실만으로 일반화 실패를 단정할 수 없다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/mldl_deep_train.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
</section>
<section id="고차원에서의-직관적-설명" class="level5">
<h5 class="anchored" data-anchor-id="고차원에서의-직관적-설명">고차원에서의 직관적 설명</h5>
<p>고차원 공간에서는 동일한 훈련 데이터에 완벽히 적합하는 함수가 매우 많다. 그러나 이들 함수의 일반화 성능은 크게 다를 수 있다. 신경망 학습은 이 중 하나의 함수를 선택하는 과정이며, 과적합은 적합 실패가 아니라 잘못된 함수 선택의 결과로 이해해야 한다.</p>
</section>
</section>
<section id="암묵적-정규화-implicit-regularization" class="level4">
<h4 class="anchored" data-anchor-id="암묵적-정규화-implicit-regularization">3. 암묵적 정규화 (Implicit Regularization)</h4>
<section id="명시적-정규화-없이도-일반화가-되는-이유" class="level5">
<h5 class="anchored" data-anchor-id="명시적-정규화-없이도-일반화가-되는-이유">명시적 정규화 없이도 일반화가 되는 이유</h5>
<p>실제 딥러닝에서는 L1이나 L2 정규화를 강하게 사용하지 않아도 테스트 성능이 상당히 우수한 경우가 많다. 이는 학습 과정 자체가 암묵적인 정규화 역할을 수행하기 때문이다.</p>
</section>
<section id="암묵적-정규화의-원천" class="level5">
<h5 class="anchored" data-anchor-id="암묵적-정규화의-원천">암묵적 정규화의 원천</h5>
<p>신경망 학습 과정에는 여러 암묵적 제약이 존재한다. 확률적 경사하강법(SGD)은 특정한 해, 특히 노름이 작은 해를 선호하는 경향이 있다. 초기화 방식은 함수 공간에서의 출발점을 제한하며, 조기 종료는 L2 정규화와 유사한 효과를 낸다. 또한 배치 크기는 학습 과정의 잡음을 조절함으로써 탐색 가능한 해의 영역을 제한한다.</p>
<p>이러한 요소들은 모두 가능한 해 중에서 상대적으로 덜 복잡한 해를 선택하도록 유도한다.</p>
</section>
<section id="통계적-해석" class="level5">
<h5 class="anchored" data-anchor-id="통계적-해석">통계적 해석</h5>
<p>암묵적 정규화는 명시적인 prior를 두지 않더라도, 학습 알고리즘 자체가 prior의 역할을 수행한다는 의미로 해석할 수 있다. 즉, 딥러닝에서의 학습은 손실함수와 최적화 알고리즘의 결합으로 정의되며, 정규화는 이 중 최적화 과정에 숨어 있다.</p>
</section>
</section>
<section id="왜-overfit이-잘-되는가의-정리" class="level4">
<h4 class="anchored" data-anchor-id="왜-overfit이-잘-되는가의-정리">4. <span dir="rtl">”</span>왜 overfit이 잘 되는가”의 정리</h4>
<p>신경망이 과적합되기 쉬운 이유는 다음 요인들이 동시에 작동하기 때문이다. 첫째, 과잉 매개변수화로 인해 매우 큰 자유도를 가진다. 둘째, 고차원 통계 영역에서 작동하여 고전적 일반화 직관이 성립하지 않는다. 셋째, 명시적 제약이 약한 상태에서는 데이터가 조금만 부족해도 즉시 과적합이 발생한다. 넷째, 암묵적 정규화는 설정과 학습 조건에 따라 일반화 성능이 크게 달라질 수 있다.</p>
<p>이러한 관점에서 과적합은 <span dir="rtl">”</span>훈련오차가 작다”는 현상이 아니라, 어떤 함수를 선택했는가에 대한 문제이다. 딥러닝의 일반화는 적합 자체보다, 방대한 함수 공간 중 어떤 해를 선택하도록 유도했는가에 의해 결정된다.</p>
</section>
</section>
<section id="chapter-2.-cross-entropy와-mle의-연결" class="level3">
<h3 class="anchored" data-anchor-id="chapter-2.-cross-entropy와-mle의-연결">Chapter 2. Cross-Entropy와 MLE의 연결</h3>
<p>딥러닝 분류에서 가장 널리 사용되는 손실함수는 Cross-Entropy이다. 이 손실은 흔히 분류용 손실로 소개되지만, 통계적으로는 확률모형의 최대우도추정과 정확히 대응된다. 즉, 딥러닝 분류 학습은 본질적으로 조건부 확률모형의 추정 문제이다.</p>
<p>이 장에서는 딥러닝 분류 손실의 구조를 확률모형 관점에서 해석하고, 신경망 출력이 의미하는 바를 통계적으로 정리한다. 이를 통해 손실함수, 확률 출력, 분류 결정, 성능지표의 역할을 명확히 분리한다.</p>
<ul>
<li>딥러닝 분류 손실은 Cross-Entropy이며, 이는 로그우도의 음수이다.</li>
<li>Cross-Entropy 최소화는 확률모형의 최대우도추정과 동치이다.</li>
<li>신경망의 출력은 분류 결과가 아니라 확률 예측이다.</li>
<li>분류 결정, 성능지표, 손실함수는 서로 다른 역할을 가진다.</li>
<li>딥러닝 분류는 본질적으로 통계적 추정 문제이다.</li>
</ul>
<section id="딥러닝-분류-손실의-구조" class="level4">
<h4 class="anchored" data-anchor-id="딥러닝-분류-손실의-구조">1. 딥러닝 분류 손실의 구조</h4>
<section id="다중-분류의-설정" class="level5">
<h5 class="anchored" data-anchor-id="다중-분류의-설정">다중 분류의 설정</h5>
<p>입력 x에 대해 클래스 <span class="math inline">\(y \in \{ 1,\ldots,K\}\)</span>를 예측하는 문제를 고려하자. 신경망은 마지막 층에서 점수 벡터 <span class="math inline">\(z(x) = (z_{1},\ldots,z_{K})\)</span>를 출력한다. 이 점수는 softmax 함수를 통해 확률로 변환된다.</p>
<p><span class="math display">\[p_{k}(x) = \frac{\exp(z_{k})}{\sum_{j = 1}^{K}\exp(z_{j})}\]</span></p>
<p>이때 <span class="math inline">\(p_{k}(x)\)</span>는 <span class="math inline">\(P(Y = k \mid X = x)\)</span>로 해석된다.</p>
</section>
<section id="cross-entropy-손실" class="level5">
<h5 class="anchored" data-anchor-id="cross-entropy-손실">Cross-Entropy 손실</h5>
<p>원-핫 레이블 y에 대해 단일 관측치의 Cross-Entropy 손실은 다음과 같다. <span class="math inline">\(\ell(y,p(x)) = - \overset{K}{\sum_{k = 1}}1(y = k)\log p_{k}(x)\)</span>. 표본 전체에 대해 평균을 취한 값이 학습의 목표 함수가 된다.</p>
</section>
</section>
<section id="cross-entropy-음의-로그우도" class="level4">
<h4 class="anchored" data-anchor-id="cross-entropy-음의-로그우도">2. Cross-Entropy = 음의 로그우도</h4>
<section id="범주형-분포와-우도" class="level5">
<h5 class="anchored" data-anchor-id="범주형-분포와-우도">범주형 분포와 우도</h5>
<p>다중 분류는 다음 확률모형을 전제한다.</p>
<p><span class="math display">\[Y \mid X = x \sim \text{Categorical}(p_{1}(x),\ldots,p_{K}(x))\]</span></p>
<p>이때 단일 관측치의 로그우도는<span class="math inline">\(\log p(Y = y \mid X = x) = \overset{K}{\sum_{k = 1}}y_{k}\log p_{k}(x)\)</span>이다.</p>
</section>
<section id="mle와-손실-최소화의-동치성" class="level5">
<h5 class="anchored" data-anchor-id="mle와-손실-최소화의-동치성">MLE와 손실 최소화의 동치성</h5>
<p>표본 전체의 로그우도를 최대화하는 문제는 <span class="math inline">\(\max_{\theta}\overset{n}{\sum_{i = 1}}\log p(y_{i} \mid x_{i};\theta)\)</span>와 같으며, 이는 곧 Cross-Entropy 손실의 합을 최소화하는 문제와 동일하다. 즉, Cross-Entropy 최소화는 범주형 확률모형에 대한 최대우도추정이다.</p>
</section>
</section>
<section id="확률-출력의-의미" class="level4">
<h4 class="anchored" data-anchor-id="확률-출력의-의미">3. 확률 출력의 의미</h4>
<section id="신경망-출력은-점수가-아니라-확률이다" class="level5">
<h5 class="anchored" data-anchor-id="신경망-출력은-점수가-아니라-확률이다">신경망 출력은 점수가 아니라 확률이다</h5>
<p>Softmax 출력 <span class="math inline">\(p_{k}(x)\)</span>는 단순한 점수가 아니라, 클래스에 대한 불확실성을 정량화한 확률적 산출물이다. 이는 경계 근처 관측치의 애매함을 표현하고, 비용 민감 의사결정의 기반을 제공한다.</p>
</section>
<section id="분류-결정과의-분리" class="level5">
<h5 class="anchored" data-anchor-id="분류-결정과의-분리">분류 결정과의 분리</h5>
<p>분류는 확률 예측 위에 추가 규칙을 얹어 이루어진다. 예를 들어<span class="math inline">\(\widehat{y} = \arg\max_{k}p_{k}(x)\)</span> 또는 비용을 고려한 임계값 규칙을 사용할 수 있다. 중요한 점은 Cross-Entropy가 확률을 학습하고, 분류 규칙은 그 확률을 사용하는 단계라는 사실이다. 이 둘을 혼동하면 성능지표 해석 오류가 발생한다.</p>
</section>
<section id="calibration과의-연결" class="level5">
<h5 class="anchored" data-anchor-id="calibration과의-연결">Calibration과의 연결</h5>
<p>Cross-Entropy는 확률의 정합성, 즉 calibration에 민감하다. 잘못된 예측에 대해 과신할수록 큰 페널티를 부과하며, 과신을 강하게 억제한다. 이 점에서 Cross-Entropy는 순위만을 평가하는 AUC와 다른 정보를 제공한다.</p>
</section>
</section>
<section id="신경망의-통계적-해석" class="level4">
<h4 class="anchored" data-anchor-id="신경망의-통계적-해석">4. 신경망의 통계적 해석</h4>
<p>신경망은 유연한 확률모형이다 딥러닝 분류기는 다음과 같이 해석할 수 있다. <span class="math inline">\(p(y \mid x) = \text{Softmax}(f_{\theta}(x))\)</span> 즉, 신경망은 규칙 기반 분류기가 아니라, 매우 유연한 조건부 확률모형이다.</p>
<section id="로지스틱-회귀의-일반화" class="level5">
<h5 class="anchored" data-anchor-id="로지스틱-회귀의-일반화">로지스틱 회귀의 일반화</h5>
<p>이진 분류에서 Cross-Entropy는 로지스틱 회귀의 손실과 동일하다. 다중 분류에서 softmax와 Cross-Entropy는 다항 로지스틱 회귀에 해당한다. 신경망은 이 구조를 비선형 함수 공간으로 확장한 것이다.</p>
</section>
<section id="정규화와-베이즈-관점의-연결" class="level5">
<h5 class="anchored" data-anchor-id="정규화와-베이즈-관점의-연결">정규화와 베이즈 관점의 연결</h5>
<p>명시적·암묵적 정규화는 파라미터에 대한 사전적 제약으로 해석할 수 있으며, 이는 최대사후확률 추정의 흔적이다. 이 관점에서 딥러닝 학습은 손실함수와 최적화 과정의 결합으로 정의된다.</p>
</section>
</section>
<section id="흔한-오해-정리" class="level4">
<h4 class="anchored" data-anchor-id="흔한-오해-정리">5. 흔한 오해 정리</h4>
<p>Cross-Entropy는 단순한 분류 손실이 아니다. 이는 로그우도의 음수이며, 확률모형의 추정 기준이다. Softmax 출력은 점수가 아니라 조건부 확률이다. 분류 성능은 이 확률을 어떻게 사용하는지에 따라 달라지며, 손실함수, 지표, 임계값은 서로 다른 역할을 수행한다.</p>
</section>
</section>
<section id="chapter-3.-dropout과-batch-normalization-통계적-해석" class="level3">
<h3 class="anchored" data-anchor-id="chapter-3.-dropout과-batch-normalization-통계적-해석">Chapter 3. Dropout과 Batch Normalization 통계적 해석</h3>
<p>딥러닝에서 Dropout과 Batch Normalization(BatchNorm)은 거의 표준처럼 사용된다. 그러나 이 기법들은 흔히 학습을 잘 되게 하는 요령이나 성능을 올려주는 테크닉으로만 소개된다. 통계적 관점에서 보면, Dropout과 BatchNorm은 불확실성과 분포 안정성을 다루는 확률적 장치이며, 신경망의 일반화 성능을 설명하는 핵심 요소이다.</p>
<p>이 장에서는 Dropout과 BatchNorm을 각각 불확실성 주입과 분포 안정화라는 관점에서 해석하고, 이들이 어떻게 암묵적 정규화로 작동하는지를 통계적으로 정리한다. 이를 통해 딥러닝의 성능이 네트워크 구조뿐 아니라 확률적 학습 장치의 결과임을 분명히 한다.</p>
<ul>
<li>Dropout은 확률적 뉴런 제거를 통해 불확실성을 학습에 주입한다.</li>
<li>이는 모델 평균화 및 암묵적 베이즈 추론으로 해석할 수 있다.</li>
<li>BatchNorm은 활성값 분포를 안정화하여 학습 과정을 통계적으로 제어한다.</li>
<li>두 기법 모두 일반화 성능을 높이는 암묵적 정규화 메커니즘이다.</li>
<li>딥러닝의 성능은 구조뿐 아니라 확률적 학습 장치의 결과이다.</li>
</ul>
<section id="dropout의-불확실성-해석" class="level4">
<h4 class="anchored" data-anchor-id="dropout의-불확실성-해석">1. Dropout의 불확실성 해석</h4>
<p>Dropout은 학습 과정에서 각 뉴런을 확률적으로 제거한다. 은닉층의 출력 h에 대해, 학습 시에는 다음과 같은 연산이 적용된다.</p>
<p><span class="math inline">\(\overset{˜}{h} = m \odot h,m_{j} \sim \text{Bernoulli}(1 - p)\)</span>. 즉, 각 뉴런은 확률 p로 비활성화되며, 테스트 시에는 전체 뉴런을 사용하되 스케일 보정을 통해 기대값을 맞춘다. 이 과정은 의도적인 무작위성을 학습에 도입한다.</p>
<section id="단순한-규제가-아닌-이유" class="level5">
<h5 class="anchored" data-anchor-id="단순한-규제가-아닌-이유">단순한 규제가 아닌 이유</h5>
<p>Dropout을 단순한 과적합 방지 기법으로 설명하면 핵심을 놓친다. Dropout의 본질은 파라미터와 표현에 대한 불확실성을 학습 과정에 주입하는 데 있다. 이는 파라미터를 하나의 값으로 고정하지 않고, 여러 가능한 모델을 평균내는 효과를 만든다.</p>
</section>
<section id="모델-평균화-관점" class="level5">
<h5 class="anchored" data-anchor-id="모델-평균화-관점">모델 평균화 관점</h5>
<p>Dropout 학습은 서로 다른 서브네트워크를 반복적으로 학습하는 과정으로 해석할 수 있다. 테스트 시의 예측은 이들 서브네트워크의 평균 예측을 근사한다. 이 관점에서 Dropout은 앙상블의 확률적 근사이며, 베이즈 관점에서는 사후 예측 평균과 유사한 역할을 한다.</p>
</section>
<section id="dropout과-불확실성" class="level5">
<h5 class="anchored" data-anchor-id="dropout과-불확실성">Dropout과 불확실성</h5>
<p>Dropout은 표현 수준의 불확실성을 반영하고, 특정 뉴런이나 경로에 대한 과도한 의존을 억제하며, 함수 선택의 다양성을 확보한다. 따라서 Dropout은 암묵적 베이즈 추론의 흔적으로 해석할 수 있다.</p>
</section>
</section>
<section id="batch-normalization과-분포-안정화" class="level4">
<h4 class="anchored" data-anchor-id="batch-normalization과-분포-안정화">2. Batch Normalization과 분포 안정화</h4>
<section id="batchnorm의-기본-연산" class="level5">
<h5 class="anchored" data-anchor-id="batchnorm의-기본-연산">BatchNorm의 기본 연산</h5>
<p>BatchNorm은 각 미니배치에서 활성값을 정규화한다.</p>
<p><span class="math inline">\(\widehat{h} = \frac{h - \mu_{B}}{\sqrt{\sigma_{B}^{2} + \epsilon}},y = \gamma\widehat{h} + \beta\)</span>, 여기서 <span class="math inline">\(\mu_{B}\)</span>와 <span class="math inline">\(\sigma_{B}^{2}\)</span>는 미니배치 평균과 분산이며, <span class="math inline">\(\gamma\)</span>와 <span class="math inline">\(\beta\)</span>는 학습 가능한 재조정 파라미터이다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/mldl_deep_batch.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
</section>
<section id="내부-공변량-변화의-통계적-의미" class="level5">
<h5 class="anchored" data-anchor-id="내부-공변량-변화의-통계적-의미">내부 공변량 변화의 통계적 의미</h5>
<p>BatchNorm의 동기는 흔히 내부 공변량 변화의 감소로 설명된다. 통계적으로 이는 각 층 입력 분포의 위치와 스케일 변동을 억제하고, 학습 과정에서의 분포 불안정성을 줄이는 것을 의미한다. 즉, BatchNorm은 조건부 분포를 강제로 안정화시키는 장치이다.</p>
</section>
<section id="batchnorm은-왜-정규화인가" class="level5">
<h5 class="anchored" data-anchor-id="batchnorm은-왜-정규화인가">BatchNorm은 왜 정규화인가</h5>
<p>BatchNorm은 L1이나 L2 정규화처럼 파라미터 크기를 직접 제한하지 않는다. 대신 활성값의 분포를 제어함으로써 기울기 폭주와 소실을 완화하고, 최적화 경로를 안정화하며, 학습률에 대한 민감도를 감소시킨다.</p>
</section>
<section id="확률적-효과" class="level5">
<h5 class="anchored" data-anchor-id="확률적-효과">확률적 효과</h5>
<p>미니배치 평균과 분산은 표본 추정량이므로, BatchNorm은 본질적으로 확률적 잡음을 학습에 주입한다. 이로 인해 BatchNorm은 Dropout과 유사한 정규화 효과를 갖게 된다.</p>
</section>
</section>
<section id="일반화-성능과의-관계" class="level4">
<h4 class="anchored" data-anchor-id="일반화-성능과의-관계">3. 일반화 성능과의 관계</h4>
<section id="dropout과-일반화" class="level5">
<h5 class="anchored" data-anchor-id="dropout과-일반화">Dropout과 일반화</h5>
<p>Dropout은 특정 경로에 대한 의존을 줄이고, 표현의 분산을 증가시키며, 과도한 신뢰를 억제함으로써 일반화를 돕는다. 이는 앞서 논의한 암묵적 정규화의 전형적인 사례이다.</p>
</section>
<section id="batchnorm과-일반화" class="level5">
<h5 class="anchored" data-anchor-id="batchnorm과-일반화">BatchNorm과 일반화</h5>
<p>BatchNorm의 일반화 효과는 간접적이다. 최적화가 쉬워지면서 더 나은 해에 도달할 가능성이 커지고, 분포 안정화를 통해 학습 불안정성이 감소하며, 배치 기반 잡음으로 인해 규제 효과가 발생한다. 즉, BatchNorm은 일반화를 직접 강제하기보다 일반화 가능한 해를 찾기 쉽게 만든다.</p>
</section>
<section id="dropout과-batchnorm의-대비" class="level5">
<h5 class="anchored" data-anchor-id="dropout과-batchnorm의-대비">Dropout과 BatchNorm의 대비</h5>
<p>Dropout은 불확실성을 통해 함수 공간을 넓게 탐색하도록 유도하는 반면, BatchNorm은 학습 경로를 안정화하여 탐색을 효율적으로 만든다. 두 기법은 서로 다른 방식으로 일반화를 지원한다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 32%">
<col style="width: 32%">
<col style="width: 32%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">관점</td>
<td style="text-align: center;">Dropout</td>
<td style="text-align: center;">BatchNorm</td>
</tr>
<tr class="even">
<td style="text-align: center;">핵심 역할</td>
<td style="text-align: center;">불확실성 주입</td>
<td style="text-align: center;">분포 안정화</td>
</tr>
<tr class="odd">
<td style="text-align: center;">통계적 성격</td>
<td style="text-align: center;">모델 평균 근사</td>
<td style="text-align: center;">조건부 분포 제어</td>
</tr>
<tr class="even">
<td style="text-align: center;">규제 방식</td>
<td style="text-align: center;">표현 제거</td>
<td style="text-align: center;">스케일·위치 조정</td>
</tr>
<tr class="odd">
<td style="text-align: center;">일반화 효과</td>
<td style="text-align: center;">직접적</td>
<td style="text-align: center;">간접적</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="통합적-해석" class="level4">
<h4 class="anchored" data-anchor-id="통합적-해석">4. 통합적 해석</h4>
<p>Dropout과 BatchNorm은 고차원·과잉매개변수화된 신경망에서 어떤 함수가 선택되는가라는 동일한 문제를 서로 다른 방식으로 해결한다. Dropout은 확률적 제거를 통해 함수 공간을 넓게 탐색하고, BatchNorm은 분포 안정화를 통해 탐색 경로를 제어한다.</p>
<p>이 둘은 모두 명시적 정규화 항이 없는 상태에서도 일반화 성능을 개선하는 통계적 장치이다. 이 관점에서 딥러닝의 일반화는 구조적 설계뿐 아니라, 학습 과정에 내재된 확률적 메커니즘의 결과로 이해할 수 있다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>