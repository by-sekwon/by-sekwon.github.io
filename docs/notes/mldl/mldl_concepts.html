<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>MLDL. 1. 머신러닝과 통계적 사고 – 세상의 모든 통계 이야기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-2757cfadcc89ddbfb9e61569f8c3689f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">세상의 모든 통계 이야기</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../notes/math/index.html"> 
<span class="menu-text">기초수학</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/math_stat/index.html"> 
<span class="menu-text">수리통계</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/intro_stat/index.html"> 
<span class="menu-text">기초통계</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/survey/index.html"> 
<span class="menu-text">조사방법론</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/linear_model/index.html"> 
<span class="menu-text">회귀분석</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mda/index.html"> 
<span class="menu-text">다변량분석</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../notes/mldl/index.html" aria-current="page"> 
<span class="menu-text">머신·딥러닝 개념 w/GPT</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl_method/index.html"> 
<span class="menu-text">머신·딥러닝 방법론 w/GPT</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cardnews/index.html"> 
<span class="menu-text">카드뉴스</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../consult.html"> 
<span class="menu-text">통계상담</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../notes/mldl/mldl_concepts.html">📄 개요</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">【HOME】</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_concepts.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">📄 개요</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_concepts01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 MLDL 개념 1</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_concepts02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 MLDL 개념 2</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_supervised.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 지도학습</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_unsupervised.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 비지도학습</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_evaluation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 평가</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_uncertainty.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 불확실성</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl/mldl_deeplearning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 딥러닝</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#chapter-1.-ml은-왜-추정이-아니라일반화-문제인가" id="toc-chapter-1.-ml은-왜-추정이-아니라일반화-문제인가" class="nav-link active" data-scroll-target="#chapter-1.-ml은-왜-추정이-아니라일반화-문제인가">Chapter 1. ML은 왜 <span dir="rtl">’</span>추정<span dir="rtl">’</span>이 아니라<span dir="rtl">’</span>일반화<span dir="rtl">’</span> 문제인가</a></li>
  <li><a href="#chapter-2.-데이터-생성-관점과-알고리즘-관점" id="toc-chapter-2.-데이터-생성-관점과-알고리즘-관점" class="nav-link" data-scroll-target="#chapter-2.-데이터-생성-관점과-알고리즘-관점">Chapter 2. 데이터 생성 관점과 알고리즘 관점</a></li>
  <li><a href="#chapter-3.-편향과-분산-해석" id="toc-chapter-3.-편향과-분산-해석" class="nav-link" data-scroll-target="#chapter-3.-편향과-분산-해석">Chapter 3. 편향과 분산 해석</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">MLDL. 1. 머신러닝과 통계적 사고</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="chapter-1.-ml은-왜-추정이-아니라일반화-문제인가" class="level3">
<h3 class="anchored" data-anchor-id="chapter-1.-ml은-왜-추정이-아니라일반화-문제인가">Chapter 1. ML은 왜 <span dir="rtl">’</span>추정<span dir="rtl">’</span>이 아니라<span dir="rtl">’</span>일반화<span dir="rtl">’</span> 문제인가</h3>
<section id="통계적-추정과-예측-문제의-차이" class="level4">
<h4 class="anchored" data-anchor-id="통계적-추정과-예측-문제의-차이">1. 통계적 추정과 예측 문제의 차이</h4>
<p>전통적인 통계학에서 가장 핵심적인 목표는 모수의 추정이다. 모집단이 존재하고, 표본은 그 모집단으로부터 무작위로 추출되었다고 가정한다. 이때 통계 분석의 관심사는 표본을 통해 모집단의 특성을 얼마나 정확하게 추정할 수 있는가에 있다. 평균, 분산, 회귀계수와 같은 모수들은 그 자체가 분석의 최종 산출물이다.</p>
<p>반면 머신러닝에서의 주된 관심사는 예측이다. 여기서 중요한 점은 예측 대상이 이미 관측된 데이터가 아니라, 아직 관측되지 않은 미래 데이터라는 사실이다. 따라서 머신러닝에서는 모수의 해석 가능성보다, 새로운 데이터에 대해 얼마나 잘 작동하는지가 성공의 기준이 된다.</p>
<p>이 차이는 단순한 용어상의 차이가 아니다. 통계적 추정은 <span dir="rtl">”</span>현재 우리가 가진 데이터로 모집단을 얼마나 잘 설명하는가”의 문제인 반면, 머신러닝의 예측은 <span dir="rtl">”</span>현재 데이터로 미래 데이터를 얼마나 잘 맞출 수 있는가”의 문제이다. 이로 인해 두 분야는 동일한 수학적 도구를 사용하더라도, 문제 설정과 평가 기준에서 근본적인 차이를 보인다.</p>
</section>
<section id="학습-데이터와-미래-데이터의-단절" class="level4">
<h4 class="anchored" data-anchor-id="학습-데이터와-미래-데이터의-단절">2. 학습 데이터와 미래 데이터의 단절</h4>
<p>머신러닝에서 가장 자주 간과되는 사실 중 하나는 학습 데이터와 미래 데이터는 본질적으로 다를 수 있다는 점이다. 통계학에서는 표본이 모집단을 대표한다는 가정을 비교적 강하게 두지만, 머신러닝에서는 이 가정이 쉽게 깨진다.</p>
<p>현실의 데이터는 시간에 따라 변하고, 수집 과정 또한 일정하지 않다. 학습 데이터는 과거의 특정 시점과 조건에서 수집된 결과이며, 미래 데이터는 다른 환경과 조건에서 생성될 수 있다. 이로 인해 학습 데이터에서 성능이 우수한 모델이 미래 데이터에서는 전혀 다른 성능을 보이는 현상이 발생한다.</p>
<p>이러한 단절은 머신러닝 문제를 단순한 추정 문제가 아니라 일반화 문제로 만든다. 즉, 중요한 것은 학습 데이터에 대한 적합도가 아니라, 보지 못한 데이터에 대해 성능을 유지할 수 있는 능력이다.</p>
</section>
<section id="ml에서의-성공-기준" class="level4">
<h4 class="anchored" data-anchor-id="ml에서의-성공-기준">3. ML에서의 성공 기준</h4>
<p>통계 분석에서 성공의 기준은 보통 다음과 같이 요약된다.</p>
<ul>
<li>추정량이 불편(unbiased)한가</li>
<li>분산이 충분히 작은가</li>
<li>가설검정에서 유의미한 결과를 보이는가</li>
</ul>
<p>반면 머신러닝에서는 성공의 기준이 훨씬 단순하면서도 냉정하다. “미래 데이터에서 성능이 좋은가?” 이 질문에 대한 답은 보통 훈련 오차가 아니라 테스트 오차로 평가된다. 머신러닝에서 널리 사용되는 교차검증 역시 이 테스트 오차를 추정하기 위한 도구이다.</p>
<p>이러한 관점에서는 모형의 해석 가능성이나 통계적 유의성보다, 예측 정확도가 우선시된다. 이 때문에 머신러닝에서는 통계학에서 중요하게 다루어졌던 p-value나 신뢰구간이 상대적으로 덜 강조된다.</p>
</section>
<section id="통계학과-ml의-공통-기반과-분기점" class="level4">
<h4 class="anchored" data-anchor-id="통계학과-ml의-공통-기반과-분기점">4. 통계학과 ML의 공통 기반과 분기점</h4>
<p>머신러닝은 통계학과 완전히 다른 분야가 아니다. 실제로 많은 머신러닝 알고리즘은 통계적 개념에 뿌리를 두고 있다. 회귀분석, 로지스틱 회귀, 판별분석, 주성분분석 등은 통계학에서 먼저 정립된 방법들이다.</p>
<p>그러나 두 분야는 다음 지점에서 분기한다.</p>
<ul>
<li>통계학: 모형 가정 → 추정 → 해석</li>
<li>머신러닝: 손실함수 → 최적화 → 일반화 성능</li>
</ul>
<p>통계학은 데이터 생성 과정에 대한 명시적인 확률모형을 가정하고, 그 모형이 현실을 얼마나 잘 설명하는지를 중시한다. 반면 머신러닝은 모형 가정의 정확성보다는, 주어진 손실함수를 최소화하는 방향으로 학습을 진행하며, 그 결과가 미래 데이터에서도 유지되는지를 평가한다.</p>
<p>이러한 차이로 인해 머신러닝에서는 과적합 문제가 핵심적인 관심사가 되며, 이를 제어하기 위한 정규화(regularization), 교차검증, 앙상블과 같은 기법들이 발전하게 된다.</p>
</section>
<section id="통계적-학습이란-무엇인가" class="level4">
<h4 class="anchored" data-anchor-id="통계적-학습이란-무엇인가">5. 통계적 학습이란 무엇인가?</h4>
<p>통계적 학습에 대한 논의를 시작하기에 앞서, 간단한 예제를 통해 그 동기를 설명해 보자. 어떤 병원의 경영진이 환자의 재원 기간을 예측하고자 하여 통계 컨설턴트에게 분석을 의뢰했다고 가정하자. 병원은 환자의 재원 기간을 직접적으로 조절할 수는 없지만, 환자의 연령, 진단 정보, 검사 결과, 치료 방식과 같은 다양한 정보를 사전에 관측할 수 있다.</p>
<p>만약 이러한 정보들과 재원 기간 사이에 체계적인 관계가 존재한다면, 병원은 환자가 입원했을 때 해당 정보를 바탕으로 향후 재원 기간을 예측할 수 있을 것이다. 이는 병상 배정, 의료 인력 운영, 비용 관리 측면에서 매우 중요한 의사결정 자료가 된다. 다시 말해, 우리의 목표는 여러 환자 특성 정보를 이용하여 재원 기간을 예측할 수 있는 정확한 모형을 구축하는 데 있다.</p>
<p>이러한 설정에서 환자의 연령, 진단 코드, 검사 수치 등은 입력 변수이고, 재원 기간은 출력 변수이다. 입력 변수들은 일반적으로 기호 X로 표시되며, 아래첨자를 사용해 구분한다. 예를 들어 <span class="math inline">\(X_{1}\)</span>은 환자의 연령, <span class="math inline">\(X_{2}\)</span>는 특정 검사 결과, <span class="math inline">\(X_{3}\)</span>는 치료 유형을 의미할 수 있다.</p>
<p>입력 변수들은 문맥에 따라 설명변수, 독립변수, 예측변수, 특징, 혹은 단순히 변수라고 불리기도 한다. 출력 변수 이 경우에는 재원 기간—는 흔히 반응변수, 종속변수, 또는 목표뵨수라고 하며, 일반적으로 기호 Y로 표시한다.</p>
<p>보다 일반적으로, 하나의 정량적 반응변수 Y와 p개의 서로 다른 설명변수 <span class="math inline">\(X_{1},X_{2},\ldots,X_{p}\)</span>가 관측된 상황을 가정하자. 이때 반응변수와 설명변수들 사이에는 어떤 형태의 관계가 존재한다고 볼 수 있으며, 이러한 관계는 매우 일반적인 형태로 다음과 같이 표현할 수 있다.</p>
<p><span class="math inline">\(Y = f(X) + \varepsilon\)</span>, 여기서 <span class="math inline">\(X = (X_{1},X_{2},\ldots,X_{p})\)</span>는 관측된 입력 변수들의 벡터이고, <span class="math inline">\(f\)</span>는 이 입력 변수들이 반응변수에 대해 제공하는 체계적인 정보를 요약하는 함수이다. 중요한 점은 이 함수 <span class="math inline">\(f\)</span>가 고정되어 있으나 알려져 있지 않다는 사실이다. 즉, 데이터 생성 과정에는 분명한 구조가 존재하지만, 우리는 그 구조를 직접 관측할 수 없으며 오직 데이터를 통해 간접적으로 추론할 수 있을 뿐이다.</p>
<p>식에 포함된 <span class="math inline">\(\varepsilon\)</span>은 확률적 오차항으로, 설명변수 <span class="math inline">\(X\)</span>로는 설명되지 않는 우연적 변동을 나타낸다. 일반적으로 이 오차항은 입력 변수와 독립이며 평균이 0이라고 가정한다. 이 가정은 모든 변동을 설명하려는 것이 아니라, 설명 가능한 부분과 설명 불가능한 부분을 구분하기 위한 최소한의 전제라고 이해할 수 있다.</p>
<p>이러한 표현은 통계적 학습 문제의 핵심을 잘 드러낸다. 우리의 목적은 관측된 데이터로부터 오차항 \varepsilon 자체를 설명하는 것이 아니라, 미지의 함수 f를 가능한 한 잘 근사하는 것이다. 다시 말해, 통계적 학습이란 데이터에 내재된 체계적인 구조를 추출하는 과정이라고 볼 수 있다.</p>
<p>만약 데이터가 모의 데이터라면, 함수 <span class="math inline">\(f\)</span>의 실제 형태를 알고 있을 수도 있다. 이 경우 관측값들은 이 함수 주변에 분포하게 되며, 각 관측치와 함수 사이의 차이는 오차항 <span class="math inline">\(\varepsilon\)</span>로 해석할 수 있다. 일부 관측값은 함수보다 크고, 일부는 작을 수 있지만, 전체적으로 보면 오차는 특정 방향으로 치우치지 않고 평균이 0에 가까운 값을 갖는다.</p>
</section>
<section id="왜-함수-f를-추정하는가" class="level4">
<h4 class="anchored" data-anchor-id="왜-함수-f를-추정하는가">6. 왜 함수 <span class="math inline">\(f\)</span>를 추정하는가?</h4>
<section id="일반화와-함수-f-추정" class="level5">
<h5 class="anchored" data-anchor-id="일반화와-함수-f-추정">(1) 일반화와 함수 <span class="math inline">\(f\)</span> 추정</h5>
<p>통계적 학습에서 함수 <span class="math inline">\(f\)</span>를 추정하는 주요 목적 중 하나는 입력 변수 X를 이용해 출력 변수 Y를 정확하게 예측하는 데 있다. 이때 예측 오차는 감소 가능한 오차와 감소 불가능한 오차로 분해되며, 통계적 학습 기법의 역할은 본질적으로 감소 가능한 오차를 최소화하는 것이라고 할 수 있다.</p>
<p>이 사실은 머신러닝 문제가 왜 단순한 추정 문제가 아닌지를 분명하게 보여준다. 전통적인 통계적 추정에서는 모수의 불편성이나 분산과 같은 성질이 분석의 중심에 놓인다. 그러나 머신러닝에서는 설령 어떤 추정량이 통계적으로 바람직한 성질을 갖더라도, 그것이 미래 데이터에 대해 작은 예측 오차를 보장하지는 않는다. 다시 말해, 좋은 추정량이 반드시 좋은 예측기를 의미하지는 않는다.</p>
<p>머신러닝에서 핵심적인 질문은 다음과 같이 바뀐다.</p>
<p>주어진 데이터에서 추정한 함수 <span class="math inline">\(\widehat{f}\)</span>가, 아직 관측되지 않은 새로운 데이터에 대해서도 작은 예측 오차를 유지할 수 있는가? 이 질문은 곧 일반화의 문제이다. 감소 가능한 오차는 학습 방법과 모형 선택에 따라 달라지며, 이는 훈련 데이터에 대한 적합 정도뿐만 아니라 데이터 밖에서의 성능에 의해 평가되어야 한다. 이 때문에 머신러닝에서는 훈련 오차가 아니라 테스트 오차, 교차검증 오차와 같은 개념이 중심적인 역할을 하게 된다.</p>
<p>요컨대, 함수 <span class="math inline">\(f\)</span>를 추정한다는 행위 자체는 통계학과 머신러닝 모두에서 공통적이지만, 어떤 기준으로 그 추정의 품질을 판단하는가에 있어 두 분야는 명확히 갈라진다. 머신러닝에서의 학습은 모형을 데이터에 맞추는 과정이 아니라, 미래 데이터에 대해 오차를 최소화하도록 일반화 능력을 조정하는 과정이며, 이것이 바로 본 장에서 말하는 <span dir="rtl">’</span>일반화 문제<span dir="rtl">’</span>의 핵심이다.</p>
</section>
<section id="예측-prediction-추론-inference" class="level5">
<h5 class="anchored" data-anchor-id="예측-prediction-추론-inference">(2) 예측 prediction 추론 inference</h5>
<p>우리가 함수 f를 추정하고자 하는 데에는 두 가지 주요한 이유가 있다. 하나는 예측이고, 다른 하나는 추론이다. 여기서는 이 두 가지를 차례로 살펴본다.</p>
</section>
<section id="예측-prediction" class="level5">
<h5 class="anchored" data-anchor-id="예측-prediction">예측 (Prediction)</h5>
<p>많은 상황에서 입력 변수 X는 비교적 쉽게 관측할 수 있지만, 출력 변수 Y는 쉽게 얻기 어렵다. 이러한 경우, 오차항의 평균이 0이라고 가정할 수 있다면, 우리는 다음과 같이 Y를 예측할 수 있다.</p>
<p><span class="math inline">\(\widehat{Y} = \widehat{f}(X)\)</span>, 여기서 <span class="math inline">\(\widehat{f}\)</span>는 미지의 함수 f에 대한 우리의 추정치를 의미하며, <span class="math inline">\(\widehat{Y}\)</span>는 그로부터 얻어진 예측값이다. 이와 같은 설정에서 <span class="math inline">\(\widehat{f}\)</span>는 종종 블랙박스로 취급된다. 즉, <span class="math inline">\(\widehat{f}\)</span>의 정확한 형태가 무엇인지는 크게 중요하지 않으며, 출력 Y를 얼마나 정확하게 예측하는가가 핵심적인 관심사가 된다.</p>
<p>예를 들어, <span class="math inline">\(X_{1},\ldots,X_{p}\)</span>가 실험실에서 쉽게 측정할 수 있는 환자의 혈액 샘플 특성들이고, <span class="math inline">\(Y\)</span>가 특정 약물에 대해 환자가 심각한 부작용을 겪을 위험도를 나타내는 변수라고 가정하자. 이 경우 X를 이용해 Y를 예측할 수 있다면, 부작용 위험이 높은 환자에게 해당 약물을 투여하지 않음으로써 위험을 피할 수 있다.</p>
</section>
<section id="예측-오차의-두-가지-구성-요소" class="level5">
<h5 class="anchored" data-anchor-id="예측-오차의-두-가지-구성-요소">예측 오차의 두 가지 구성 요소</h5>
<p>예측값 <span class="math inline">\(\widehat{Y}\)</span>가 실제 값 <span class="math inline">\(Y\)</span>를 얼마나 잘 예측하는지는 두 가지 요인에 의해 결정되며, 이를 각각 감소 가능한 오차와 감소 불가능한 오차라고 부른다.</p>
<p>일반적으로 <span class="math inline">\(\widehat{f}\)</span>는 f의 완전한 추정치가 될 수 없으며, 이로 인해 예측에는 필연적으로 오차가 발생한다. 이러한 오차는 감소 가능한데, 이는 더 적절한 통계적 학습 기법을 사용함으로써 <span class="math inline">\(\widehat{f}\)</span>의 정확도를 개선할 수 있기 때문이다.</p>
<p>그러나 설령 우리가 완벽하게 <span class="math inline">\(f\)</span>를 추정하여 <span class="math inline">\(\widehat{Y} = f(X)\)</span>라는 형태의 예측을 할 수 있다고 하더라도, 예측 오차는 여전히 0이 되지 않는다. 이는 <span class="math inline">\(Y\)</span>가 오차항 <span class="math inline">\(\varepsilon\)</span>에도 의존하기 때문이다. 오차항 <span class="math inline">\(\varepsilon\)</span>은 정의상 X로부터 예측할 수 없으므로, 이로 인해 발생하는 변동성은 예측 정확도에 항상 영향을 미친다. 이러한 오차를 감소 불가능한 오차라고 한다.</p>
<p>감소 불가능한 오차는 왜 0이 될 수 없는가? 감소 불가능한 오차가 0보다 큰 이유는 여러 가지가 있다. 오차항 <span class="math inline">\(\varepsilon\)</span>에는 <span class="math inline">\(Y\)</span>를 예측하는 데 유용하지만 우리가 측정하지 못한 변수들이 포함될 수 있다. 이러한 변수들이 관측되지 않는 한, 함수 f는 이를 이용해 예측할 수 없다.</p>
<p>또한 <span class="math inline">\(\varepsilon\)</span>에는 본질적으로 측정 불가능한 무작위 변동도 포함될 수 있다. 예를 들어, 특정 환자가 어떤 날에 약물에 대해 보이는 부작용 위험은 약물 자체의 미세한 제조 차이나, 그날 환자의 전반적인 컨디션과 같은 요인에 따라 달라질 수 있다.</p>
</section>
<section id="예측-오차의-분해" class="level5">
<h5 class="anchored" data-anchor-id="예측-오차의-분해">예측 오차의 분해</h5>
<p>이제 하나의 추정된 함수 \hat{f}와 설명변수 집합 X가 주어져 있고, 이를 통해 \hat{Y} = \hat{f}(X)라는 예측을 한다고 가정하자. 이때 \hat{f}와 X는 고정되어 있으며, 오직 변동성은 오차항 \varepsilon에서만 발생한다고 가정하면, 다음과 같은 결과를 쉽게 도출할 수 있다.</p>
<p><span class="math display">\[\mathbb{E}(Y - \widehat{Y})^{2} = \mathbb{E}\lbrack f(X) + \varepsilon - \widehat{f}(X)\rbrack^{2} = \underset{\text{감소 가능한 오차}}{\underbrace{\lbrack f(X) - \widehat{f}(X)\rbrack^{2}}} + \underset{\text{감소 불가능한 오차}}{\underbrace{Var(\varepsilon)}}\]</span></p>
<p>여기서 <span class="math inline">\(\mathbb{E}(Y - \widehat{Y})^{2}\)</span>는 예측값과 실제 값 사이의 제곱 오차의 기댓값을 의미하며, <span class="math inline">\(Var(\varepsilon)\)</span>는 오차항 <span class="math inline">\(\varepsilon\)</span>에 수반된 분산을 나타낸다.</p>
<p>ML 방법론의 초점은 함수 <span class="math inline">\(f\)</span>를 추정하는 다양한 기법을 통해 감소 가능한 오차를 최소화하는 것에 있다. 다만, 감소 불가능한 오차는 예측 정확도가 도달할 수 있는 상한선을 항상 결정한다는 점을 기억해야 한다. 이 상한선은 실제 문제에서는 거의 항상 알려져 있지 않다.</p>
</section>
<section id="추론-inference" class="level5">
<h5 class="anchored" data-anchor-id="추론-inference">추론 (Inference)</h5>
<p>우리는 종종 반응변수 <span class="math inline">\(Y\)</span>와 설명변수 <span class="math inline">\(X_{1},\ldots,X_{p}\)</span>사이의 연관성을 이해하는 데 관심을 가진다. 이러한 상황에서도 함수 <span class="math inline">\(f\)</span>를 추정하고자 하지만, 우리의 목적은 반드시 <span class="math inline">\(Y\)</span>를 예측하는 데 있는 것은 아니다. 이 경우에는 <span class="math inline">\(\widehat{f}\)</span>를 더 이상 블랙박스로 취급할 수 없는데, 그 이유는 함수의 정확한 형태 자체를 이해할 필요가 있기 때문이다. 이러한 설정에서 우리는 다음과 같은 질문들에 관심을 갖게 된다.</p>
<p>어떤 설명변수들이 반응변수와 연관되어 있는가? 많은 경우, 사용 가능한 설명변수들 중 실제로 <span class="math inline">\(Y\)</span>와 실질적인 연관성을 가지는 변수는 소수에 불과하다. 가능한 변수들이 매우 많은 상황에서, 그중 중요한 변수들을 식별하는 일은 응용 분야에 따라 매우 유용할 수 있다.</p>
<p>각 설명변수와 반응변수 사이의 관계는 어떠한가? 어떤 설명변수는 값이 증가할수록 <span class="math inline">\(Y\)</span>도 증가하는 양의 관계를 가질 수 있으며, 다른 변수는 그 반대의 관계를 가질 수도 있다. 또한 함수 <span class="math inline">\(f\)</span>의 복잡성에 따라, 특정 설명변수와 <span class="math inline">\(Y\)</span> 사이의 관계는 다른 설명변수들의 값에 의존할 수도 있다.</p>
<p>각 설명변수와 <span class="math inline">\(Y\)</span> 사이의 관계를 선형식으로 충분히 요약할 수 있는가, 아니면 더 복잡한 구조가 필요한가? 역사적으로 함수 <span class="math inline">\(f\)</span>를 추정하기 위한 많은 방법들은 선형 형태를 취해 왔다. 어떤 상황에서는 이러한 가정이 합리적이거나 심지어 바람직할 수도 있다. 그러나 실제 관계가 더 복잡한 경우에는, 선형 모형이 입력 변수와 출력 변수 사이의 관계를 정확히 표현하지 못할 수 있다.</p>
<p>고객이 구매할 가능성이 있는 제품 브랜드를 가격, 매장 위치, 할인 수준, 경쟁 제품의 가격 등과 같은 변수들을 이용해 모형화하는 상황을 생각해 보자. 이 경우에는 각 변수와 구매 확률 사이의 연관성 자체가 핵심 관심사가 된다. 예를 들어, *제품의 가격은 판매량과 어느 정도 연관되어 있는가?*와 같은 질문이 이에 해당하며, 이는 추론을 위한 모형화의 예이다.</p>
<p>어떤 문제들은 예측과 추론을 동시에 목적으로 삼을 수도 있다. 예를 들어 부동산 시장에서 주택 가격을 범죄율, 용도 지역 강과의 거리, 대기질, 학군, 지역 소득 수준, 주택 크기 등의 입력 변수들과 연관 짓는 상황을 생각해 보자. 이 경우에는 각 개별 변수와 주택 가격 사이의 연관성—예를 들어 강이 보이는 집은 그렇지 않은 집보다 얼마나 더 비싼가?—에 관심을 가질 수도 있으며, 이는 추론 문제이다. 반대로, 주어진 특성들을 바탕으로 특정 주택의 가치를 예측하는 것—이 집은 과대평가되었는가, 아니면 과소평가되었는가?—에 관심을 둘 수도 있는데, 이는 예측 문제에 해당한다.</p>
<p>궁극적인 목표가 예측인지, 추론인지, 혹은 이 둘의 결합인지에 따라 함수 <span class="math inline">\(f\)</span>를 추정하기 위한 적절한 방법은 달라질 수 있다. 예를 들어 선형 모형은 비교적 단순하고 해석 가능한 추론을 가능하게 하지만, 다른 방법들에 비해 예측 정확도는 떨어질 수 있다. 반면, 강한 비선형 모형들은 매우 정확한 예측을 제공할 수 있지만, 그 대가로 모형의 해석 가능성이 낮아져 추론이 훨씬 어려워진다.</p>
</section>
</section>
</section>
<section id="chapter-2.-데이터-생성-관점과-알고리즘-관점" class="level3">
<h3 class="anchored" data-anchor-id="chapter-2.-데이터-생성-관점과-알고리즘-관점">Chapter 2. 데이터 생성 관점과 알고리즘 관점</h3>
<p>머신러닝과 통계학의 가장 중요한 차이는 사용되는 알고리즘의 종류가 아니라, 데이터를 바라보는 관점에 있다.</p>
<p>여기서는 데이터를 어떻게 생성된 결과로 이해할 것인가라는 관점, 즉 데이터 생성 과정(Data Generating Process,)과, 데이터를 알고리즘의 입력값으로만 취급하는 관점 사이의 차이를 살펴본다. 이러한 관점의 차이는 일반화 문제, 과적합, 불확실성 해석에 직접적인 영향을 미친다.</p>
<section id="데이터는-어떻게-생성되는가" class="level4">
<h4 class="anchored" data-anchor-id="데이터는-어떻게-생성되는가">1. 데이터는 어떻게 생성되는가</h4>
<p>전통적인 통계학에서는 데이터가 확률적 생성 과정을 통해 생성된 결과라고 가정한다. 즉, 관측된 데이터는 우연의 결과가 아니라, 어떤 확률모형에 의해 생성된 실현값이다. 일반적인 회귀 설정에서 이는 다음과 같이 표현된다.</p>
<p><span class="math inline">\(Y = f(X) + \varepsilon\)</span>, 여기서 <span class="math inline">\(f(X)\)</span>는 체계적인 구조를, <span class="math inline">\(\varepsilon\)</span>은 설명되지 않는 확률적 변동을 나타낸다. 이 식은 단순한 수식이 아니라, 데이터에 대한 철학적 선언에 가깝다. 즉, 데이터에는 설명 가능한 부분과 설명 불가능한 부분이 동시에 존재한다는 가정이다.</p>
<p>데이터 생성 과정 관점에서 보면, 우리가 관측하는 데이터는 항상 다음과 같은 특징을 갖는다.</p>
<p>동일한 조건에서도 결과는 반복 측정 시 달라질 수 있다.</p>
<p>일부 변동성은 어떤 모델로도 제거할 수 없다.</p>
<p>관측되지 않은 변수의 영향이 항상 존재한다.</p>
<p>이러한 전제는 통계적 추론, 신뢰구간, 가설검정의 논리적 기반을 이룬다.</p>
</section>
<section id="확률모형을-가정하지-않는-학습의-한계" class="level4">
<h4 class="anchored" data-anchor-id="확률모형을-가정하지-않는-학습의-한계">2. 확률모형을 가정하지 않는 학습의 한계</h4>
<p>머신러닝에서는 종종 데이터 생성 과정을 명시적으로 가정하지 않는다. 대신, 입력 X와 출력 Y 사이의 관계를 함수 근사 문제로 다룬다. 이 관점에서는 다음과 같은 표현이 암묵적으로 사용된다.</p>
<p><span class="math inline">\(\widehat{Y} = \widehat{f}(X)\)</span>, 여기서 중요한 것은 <span class="math inline">\(\widehat{f}\)</span>가 어떤 확률모형에서 나왔는지가 아니라, 손실함수를 얼마나 잘 최소화하는가이다. 이 접근은 계산적으로 매우 강력하지만, 다음과 같은 한계를 내포한다.</p>
<p>첫째, 오차의 성격을 분리할 수 없다. 확률모형이 없으면, 관측된 오차가 모델의 부적합 때문인지, 본질적으로 제거 불가능한 변동성 때문인지 구분할 수 없다.</p>
<p>둘째, 불확실성에 대한 해석이 불가능해진다. 예측값은 제공할 수 있지만, 그 예측이 얼마나 신뢰할 수 있는지는 알기 어렵다.</p>
<p>셋째, 일반화 실패의 원인을 설명하기 어렵다. 테스트 성능이 나쁜 이유가 데이터 분포 변화 때문인지, 과적합 때문인지 명확히 구분되지 않는다.</p>
<p>이러한 이유로, 확률모형을 전혀 고려하지 않는 학습은 예측 정확도는 높을 수 있으나, 해석과 진단에는 취약하다.</p>
</section>
<section id="알고리즘-중심-사고의-위험" class="level4">
<h4 class="anchored" data-anchor-id="알고리즘-중심-사고의-위험">3. 알고리즘 중심 사고의 위험</h4>
<p>알고리즘 중심 사고란, 데이터를 고정된 입력으로 보고 “어떤 알고리즘이 성능이 좋은가?” 만을 기준으로 학습 방법을 선택하는 태도를 의미한다. 이 관점에서는 다음과 같은 질문이 중심이 된다.</p>
<p>어떤 모델이 정확도가 가장 높은가?</p>
<p>어떤 하이퍼파라미터 조합이 최적인가?</p>
<p>그러나 이러한 사고방식에는 몇 가지 위험이 따른다.</p>
<p>첫째, 데이터가 바뀌면 알고리즘의 성능도 바뀐다. 훈련 데이터 분포와 테스트 데이터 분포가 다를 경우, 알고리즘의 우수성은 쉽게 무너진다.</p>
<p>둘째, 과적합을 구조적으로 이해하지 못한다. 알고리즘은 과적합을 <span dir="rtl">”</span>성능 저하”로만 드러내지만, 데이터 생성 과정 관점에서는 이를 모형 복잡도와 오차 구조의 불일치로 해석할 수 있다.</p>
<p>셋째, 재현성과 외삽에 취약하다. 데이터 생성 구조를 이해하지 못한 채 학습된 모델은, 새로운 환경에서 쉽게 실패한다.</p>
<p>알고리즘은 도구이지, 데이터의 본질을 설명해 주지는 않는다.</p>
</section>
<section id="데이터-생성-과정-관점에서-본-학습-데이터의-불완전성" class="level4">
<h4 class="anchored" data-anchor-id="데이터-생성-과정-관점에서-본-학습-데이터의-불완전성">4. 데이터 생성 과정 관점에서 본 학습 데이터의 불완전성</h4>
<p>데이터 생성 과정 관점에서 보면, 학습 데이터는 결코 완전하지 않다. 학습 데이터는 항상 다음과 같은 제약을 갖는다.</p>
<p>특정 시점과 조건에서만 수집된 표본이다.</p>
<p>관측되지 않은 변수의 영향을 포함한다.</p>
<p>표본 크기는 유한하다.</p>
<p>이로 인해 학습 데이터에서 잘 작동하는 모델이 진짜 데이터 생성 과정을 잘 반영한다고 보장할 수는 없다. 다시 말해,</p>
<p>학습 데이터에 잘 맞는 모델 ##### ≠##### 데이터 생성 과정을 잘 반영한 모델</p>
<p>이러한 불완전성 때문에 머신러닝에서는 일반화 성능이 핵심 평가 기준이 된다. 교차검증, 정규화, 앙상블 기법 등은 모두 DGP를 직접 알 수 없는 상황에서, 그 영향을 간접적으로 통제하기 위한 장치라고 볼 수 있다.</p>
</section>
</section>
<section id="chapter-3.-편향과-분산-해석" class="level3">
<h3 class="anchored" data-anchor-id="chapter-3.-편향과-분산-해석">Chapter 3. 편향과 분산 해석</h3>
<p>머신러닝과 통계학을 연결하는 가장 중요한 개념 중 하나는 편향–분산(Bias–Variance)의 구분이다. 이 개념은 단순히 오차를 분해하는 기술적 장치가 아니라, 일반화 성능이 왜 제한될 수밖에 없는지를 설명해 주는 핵심 논리이다. 이 장에서는 편향과 분산을 전통적인 정의에서 벗어나, 데이터 생성 관점과 일반화 관점에서 다시 해석한다.</p>
<section id="편향과-분산" class="level4">
<h4 class="anchored" data-anchor-id="편향과-분산">1. 편향과 분산</h4>
<section id="편향과-분산-정의" class="level5">
<h5 class="anchored" data-anchor-id="편향과-분산-정의">편향과 분산 정의</h5>
<p>어떤 입력값 <span class="math inline">\(X = x\)</span>에 대해 반응변수 <span class="math inline">\(Y\)</span>가 생성된다고 하자. 우리는 이를 다음과 같이 표현해 왔다.</p>
<p><span class="math inline">\(Y = f(x) + \varepsilon\)</span>, 여기서 <span class="math inline">\(f(x)\)</span>는 데이터 생성 과정에 내재된 참 함수이며, <span class="math inline">\(\varepsilon\)</span>는 평균이 0인 확률적 오차항이다. 이제 동일한 데이터 생성 과정을 여러 번 반복하여, 서로 다른 학습 데이터셋을 얻고, 그로부터 예측 함수 <span class="math inline">\(\widehat{f}(x)\)</span>를 추정한다고 가정하자.</p>
<p>이때 예측 오차의 기댓값은 다음과 같이 분해될 수 있다.</p>
<p><span class="math display">\[\mathbb{E}\lbrack(Y - \widehat{f}(x))^{2}\rbrack = \underset{\text{편향(Bias)}^{2}}{\underbrace{(\mathbb{E}\lbrack\widehat{f}(x)\rbrack - f(x))^{2}}} + \underset{\text{분산(Variance)}}{\underbrace{\mathbb{E}\lbrack(\widehat{f}(x) - \mathbb{E}\lbrack\widehat{f}(x)\rbrack)^{2}\rbrack}} + \underset{\text{감소 불가능한 오차}}{\underbrace{Var(\varepsilon)}}\]</span></p>
<p>이 분해는 중요한 사실을 보여준다. 예측 오차는 단일한 원인으로 발생하는 것이 아니라, 모형의 평균적 오차(편향), 데이터 샘플에 대한 민감도(분산), 그리고 본질적으로 제거할 수 없는 변동성의 결합으로 나타난다.</p>
<p>통계학에서 편향은 주로 <span dir="rtl">”</span>추정량이 참값을 평균적으로 얼마나 잘 맞추는가”의 문제로 이해된다. 반면 머신러닝에서는 편향이 모형이 데이터 생성 구조를 얼마나 단순화해서 가정하는가를 반영한다.</p>
</section>
<section id="편향분산-상충관계" class="level5">
<h5 class="anchored" data-anchor-id="편향분산-상충관계">편향–분산 상충관계</h5>
<p>테스트 MSE(Mean Squared Error, 평균제곱오차) <span class="math inline">\(\mathbb{E}(y_{0} - \widehat{f}(x_{0}))^{2}\)</span>는 점 <span class="math inline">\(x_{0}\)</span>에서의 기대 테스트 MSE를 의미하며, 이는 서로 다른 훈련 데이터 집합을 사용해 반복적으로 <span class="math inline">\(f\)</span>를 추정하고, 각각을 <span class="math inline">\(x_{0}\)</span>에서 평가했을 때 얻어지는 테스트 MSE의 평균을 뜻한다. 전체 기대 MSE는 테스트 집합에 포함된 모든 가능한 <span class="math inline">\(x_{0}\)</span>값에 대해 이 값을 평균함으로써 계산할 수 있다.</p>
<p>기대 테스트 오차를 최소화하기 위해서는 낮은 분산과 낮은 편향을 동시에 달성하는 통계적 학습 방법을 선택해야 함을 알려준다. 그렇다면 통계적 학습 방법에서 말하는 분산과 편향이란 무엇인가?</p>
<p>분산은 서로 다른 훈련 데이터 집합을 사용해 <span class="math inline">\(\widehat{f}\)</span>를 추정했을 때, 그 추정치가 얼마나 크게 변하는지를 의미한다. 훈련 데이터는 학습 방법을 적합시키는 데 사용되므로, 훈련 데이터가 달라지면 서로 다른 <span class="math inline">\(\widehat{f}\)</span>가 생성된다. 이상적으로는 훈련 데이터가 달라지더라도 f의 추정치는 크게 변하지 않아야 한다. 그러나 어떤 방법이 높은 분산을 가진다면, 훈련 데이터의 작은 변화가 <span class="math inline">\(\widehat{f}\)</span>에 큰 변화를 초래할 수 있다.</p>
<p>한편 편향은 매우 복잡할 수 있는 현실 문제를 지나치게 단순한 모형으로 근사함으로써 발생하는 오차를 의미한다. 예를 들어 선형회귀는 <span class="math inline">\(Y\)</span>와 <span class="math inline">\(X_{1},X_{2},\ldots,X_{p}\)</span>사이에 선형 관계가 존재한다고 가정한다. 그러나 실제 문제에서 이러한 단순한 선형 관계가 정확히 성립하는 경우는 드물다. 따라서 선형회귀를 적용하면 f의 추정에 일정한 편향이 발생하게 된다.</p>
<p>참함수 <span class="math inline">\(f\)</span>가 비선형적인 경우 훈련 관측치의 수가 아무리 많아도 선형회귀를 통해서는 정확한 추정을 할 수 없다. 즉, 이 경우 선형회귀는 높은 편향을 가진다. 반면 참함수가 선형에 가까우면, 충분한 데이터가 주어진다면 선형회귀는 정확한 추정을 제공할 수 있다.</p>
<p>일반적인 규칙으로, 더 유연한 방법을 사용할수록 분산은 증가하고 편향은 감소한다. 이 두 양이 변화하는 상대적인 속도에 따라 테스트 MSE가 증가할지 감소할지가 결정된다. 방법의 유연성이 증가함에 따라 초기에는 편향이 분산보다 더 빠르게 감소하므로, 기대 테스트 MSE는 감소한다. 그러나 어느 시점 이후에는 유연성을 더 높여도 편향은 거의 줄지 않는 반면, 분산은 급격히 증가하기 시작한다. 이 경우 테스트 MSE는 다시 증가한다.</p>
<p>편향–분산–테스트 MSE 간의 관계를 편향–분산 상충관계라고 부른다. 통계적 학습 방법에서 좋은 테스트 성능을 얻기 위해서는 낮은 분산과 낮은 제곱 편향이 모두 필요하다. 이를 상충관계라 부르는 이유는, 매우 낮은 편향과 높은 분산을 가진 방법(예: 모든 훈련 데이터를 정확히 통과하는 곡선)이나, 매우 낮은 분산과 높은 편향을 가진 방법(예: 수평선 적합)은 쉽게 얻을 수 있기 때문이다. 진정한 어려움은 편향과 분산이 모두 낮은 방법을 찾는 데 있다.</p>
<p>현실에서는 참함수 <span class="math inline">\(f\)</span>가 관측되지 않으므로, 특정 학습 방법에 대한 테스트 MSE, 편향, 분산을 명시적으로 계산하는 것은 일반적으로 불가능하다. 그럼에도 불구하고, 분석 과정 전반에서 편향–분산 상충관계를 항상 염두에 두어야 한다. 본서에서는 편향을 거의 제거할 수 있을 정도로 매우 유연한 방법들도 다루지만, 이러한 방법이 항상 단순한 선형회귀보다 우수한 성능을 보장하는 것은 아니다. 예를 들어 참함수 <span class="math inline">\(f\)</span>가 실제로 선형이라면, 선형회귀는 편향이 0이 되므로 더 유연한 방법이 이를 능가하기는 매우 어렵다. 반대로 참함수 <span class="math inline">\(f\)</span>가 강하게 비선형이고 충분한 훈련 데이터가 주어진다면, 매우 유연한 방법이 더 나은 성능을 보일 수 있다.</p>
</section>
<section id="유연한-학습방법이란" class="level5">
<h5 class="anchored" data-anchor-id="유연한-학습방법이란">유연한 학습방법이란?</h5>
<p>데이터가 보여주는 형태에 맞추어 함수 f의 모양을 자유롭게 변화시킬 수 있는 정도가 큰 학습 방법을 유연한 학습 방법이라 한다. 이는 단순히 <span dir="rtl">”</span>복잡한 모델”이라는 뜻이 아니라, 함수 공간에서 허용되는 자유도의 크기를 가리키는 개념이다.</p>
<p>통계적 학습에서 방법의 유연성(flexibility) 이란 훈련 데이터의 작은 변화에도 추정된 함수 <span class="math inline">\(\widehat{f}\)</span>가 얼마나 크게 변할 수 있는가, 또는 <span class="math inline">\(\widehat{f}\)</span>가 가질 수 있는 형태의 범위가 얼마나 넓은가를 의미한다.</p>
<p>즉, 유연한 방법일수록 다양한 비선형 구조를 표현할 수 있고, 데이터에 더 밀착된 적합이 가능하다.</p>
<p>비유연한 방법은 함수 형태가 강하게 제한되고 데이터의 전체적인 경향만 반영되며 편향은 크고, 분산은 작다. 예를 들면, 단순 평균 모델, 선형회귀, 낮은 차수의 다항회귀 등 이다.</p>
<p>유연한 방법은 함수 형태에 대한 제약이 약하며, 국소적 패턴까지 포착 가능하며 편향은 작고, 분산은 크다. 예를 들면, 고차 다항회귀, k-NN, 스플라인(자유도 큰 경우), 결정트리(깊은 트리), 신경망(은닉층·노드 많을수록)</p>
</section>
<section id="유연성과-편향-분산의-연결" class="level5">
<h5 class="anchored" data-anchor-id="유연성과-편향-분산의-연결">유연성과 편향-분산의 연결</h5>
<p>유연성 ↑ → Bias ↓ (참함수에 더 가까워질 수 있음) → Variance ↑ (데이터 변화에 민감)</p>
<p>유연성 ↓ → Bias ↑ → Variance ↓</p>
<p>따라서 유연한 방법은 <span dir="rtl">”</span>잘 맞출 수 있지만, 불안정할 수 있는 방법” 이라고 요약할 수 있다.</p>
</section>
</section>
<section id="ml-모델-선택" class="level4">
<h4 class="anchored" data-anchor-id="ml-모델-선택">2. ML 모델 선택</h4>
<section id="유연성과-복잡도-개념" class="level5">
<h5 class="anchored" data-anchor-id="유연성과-복잡도-개념">유연성과 복잡도 개념</h5>
<p>통계적 학습에서 흔히 유연성과 복잡도를 같은 의미로 사용하지만, 엄밀히 말하면 두 개념은 동일하지 않다. 복잡도는 모형의 구조적 특성을 설명하는 개념인 반면, 유연성은 그 구조가 데이터에 어떻게 반응하는가를 설명하는 개념이다. 즉, 복잡도는 모형의 설계 차원에 속하고, 유연성은 학습 결과의 행동 차원에 속한다.</p>
<p>복잡도는 모형이 사전에 허용하는 구조의 크기나 풍부함을 의미한다. 이는 보통 모형이 갖는 형식적 자유도로 표현된다. 예를 들어 모수의 개수, 다항식의 차수, 결정트리의 깊이, 신경망의 층 수와 노드 수와 같은 요소들은 모두 모형의 복잡도를 증가시킨다. 복잡도는 모델을 설계하는 단계에서 비교적 명확하게 정의할 수 있으며, 데이터와 무관하게 기술되는 경우가 많다.</p>
<p>이 관점에서 복잡도는 <span dir="rtl">”</span>이 모형이 이론적으로 얼마나 복잡한 함수를 표현할 수 있는가”를 나타낸다.</p>
<p>유연성은 복잡도보다 한 단계 더 나아간 개념으로, 실제로 학습된 모형이 데이터의 변화에 얼마나 민감하게 반응하는가를 의미한다. 즉, 동일한 모형 구조를 사용하더라도 훈련 데이터가 조금만 달라졌을 때 추정된 함수 \hat f가 얼마나 크게 달라지는지가 유연성의 핵심이다.</p>
<p>따라서 유연성은 단순히 모수의 개수로 결정되지 않는다. 동일한 구조의 모형이라 하더라도 규제(regularization)의 강도, 학습 방법, 하이퍼파라미터 설정에 따라 유연성은 크게 달라질 수 있다.</p>
<p>복잡도 → *<span dir="rtl">”</span>얼마나 복잡한 모형을 설계했는가”*에 대한 개념이다.</p>
<p>유연성 → *<span dir="rtl">”</span>그 모형이 데이터에 얼마나 민감하게 반응하는가”*에 대한 개념이다.</p>
<p>복잡도는 유연성의 잠재적 상한선을 제공하지만, 유연성 그 자체는 아니다.</p>
</section>
<section id="과적합과-과소적합의-본질" class="level5">
<h5 class="anchored" data-anchor-id="과적합과-과소적합의-본질">과적합과 과소적합의 본질</h5>
<p>편향과 분산의 관점에서 보면, 과소적합(underfitting)과 과적합(overfitting)은 매우 명확하게 구분된다. 과소적합은 모형이 지나치게 단순하여 데이터 생성 과정의 구조를 충분히 포착하지 못하는 경우이다. 이때 모형은 높은 편향을 가지며, 학습 데이터와 테스트 데이터 모두에서 성능이 좋지 않다.</p>
<p>반대로 과적합은 모형이 학습 데이터의 우연적 변동까지 학습해 버린 경우이다. 이때 모형은 편향은 작을 수 있으나, 분산이 매우 커진다. 학습 데이터에서는 성능이 우수하지만, 새로운 데이터에서는 성능이 급격히 저하된다.</p>
<p>중요한 점은 과적합이 <span dir="rtl">”</span>모형이 너무 복잡하다”는 직관적 설명만으로는 충분히 이해되지 않는다는 것이다. 보다 정확히 말하면, 과적합은 모형의 복잡도와 데이터 생성 과정의 불확실성 사이의 불균형에서 발생한다.</p>
</section>
<section id="모델-복잡도와-일반화-성능" class="level5">
<h5 class="anchored" data-anchor-id="모델-복잡도와-일반화-성능">모델 복잡도와 일반화 성능</h5>
<p>모형의 복잡도가 증가하면 일반적으로 편향은 감소하고, 분산은 증가한다. 이는 거의 모든 학습 방법에서 관측되는 현상이다. 따라서 일반화 성능은 다음과 같은 절충의 결과로 결정된다.</p>
<ul>
<li>단순한 모형: 높은 편향, 낮은 분산</li>
<li>복잡한 모형: 낮은 편향, 높은 분산</li>
</ul>
<p>이 관계는 <span dir="rtl">”</span>복잡한 모델이 항상 나쁘다”거나 <span dir="rtl">”</span>단순한 모델이 항상 좋다”는 식의 결론을 허용하지 않는다. 중요한 것은 데이터 생성 과정의 복잡도에 비해 모형이 얼마나 적절한가이다.</p>
<p>데이터 생성 과정 관점에서 보면, 최적의 모델 복잡도란 참 함수 <span class="math inline">\(f\)</span>의 구조와 표본 크기, 그리고 오차항의 분산이 결합된 결과이다. 즉, 데이터가 적거나 노이즈가 큰 상황에서는 복잡한 모형이 오히려 일반화 성능을 악화시킬 수 있다.</p>
</section>
<section id="ml-모델-선택의-통계적-기준" class="level5">
<h5 class="anchored" data-anchor-id="ml-모델-선택의-통계적-기준">ML 모델 선택의 통계적 기준</h5>
<p>머신러닝에서 모델 선택은 흔히 <span dir="rtl">”</span>어떤 모델이 가장 정확한가”라는 질문으로 요약된다. 그러나 이 정확도는 반드시 일반화 성능을 기준으로 평가되어야 한다.</p>
<p>통계적 관점에서 보면, 모델 선택이란 결국 편향과 분산 사이의 균형점을 찾는 문제이다. 교차검증은 바로 이 균형을 데이터로부터 추정하기 위한 도구이며, 정규화는 분산을 인위적으로 제어하는 장치이다.</p>
<p>이러한 맥락에서 머신러닝의 다양한 기법들은 서로 다른 방식으로 동일한 문제를 해결하고 있다고 볼 수 있다.</p>
<ul>
<li>정규화: 분산을 줄이기 위해 편향을 일부 허용</li>
<li>앙상블: 분산을 평균화하여 일반화 성능 개선</li>
<li>조기 종료: 학습 과정에서 과적합을 사전에 차단</li>
</ul>
<p>즉, ML 모델 선택은 단순한 알고리즘 경쟁이 아니라, 통계적 오차 구조에 대한 선택이다.</p>
</section>
</section>
<section id="우리는-함수-f를-어떻게-추정하는가" class="level4">
<h4 class="anchored" data-anchor-id="우리는-함수-f를-어떻게-추정하는가">3. 우리는 함수 <span class="math inline">\(f\)</span>를 어떻게 추정하는가?</h4>
<p>여기서는 함수 <span class="math inline">\(f\)</span>를 추정하기 위한 다양한 선형 및 비선형 방법들을 살펴본다. 그러나 이러한 방법들은 일반적으로 몇 가지 공통된 특성을 공유한다.</p>
<p>항상 서로 다른 <span class="math inline">\(n\)</span>개의 데이터 포인트가 관측되었다고 가정한다. 이러한 관측값들을 훈련 데이터라고 부르는데, 이는 이 관측값들을 사용하여 f를 추정하는 방법을 학습(또는 훈련)시키기 때문이다.</p>
<p>관측치 <span class="math inline">\(i\)</span>에 대해 <span class="math inline">\(j\)</span>번째 설명변수(또는 입력 변수)의 값을 <span class="math inline">\(x_{ij}\)</span>라고 하자. 여기서 <span class="math inline">\(i = 1,2,\ldots,n,j = 1,2,\ldots,p\)</span>이다. 이에 대응하여 <span class="math inline">\(y_{i}\)</span>는 <span class="math inline">\(i\)</span>번째 관측치의 반응변수를 나타낸다. 그러면 우리의 훈련 데이터는 <span class="math inline">\(\{(x_{1},y_{1}),(x_{2},y_{2}),\ldots,(x_{n},y_{n})\}\)</span>로 구성되며, 여기서 <span class="math inline">\(x_{i} = (x_{i1},x_{i2},\ldots,x_{ip})^{T}\)</span>이다.</p>
<p>통계분석 목표는 훈련 데이터를 이용해 미지의 함수 <span class="math inline">\(f\)</span>를 추정하는 통계적 학습 방법을 적용하는 것이다. 다시 말해, 임의의 관측치 <span class="math inline">\((X,Y)\)</span>에 대해 <span class="math inline">\(Y \approx \widehat{f}(X)\)</span>를 만족하는 함수 <span class="math inline">\(\widehat{f}\)</span>를 찾고자 한다.</p>
<p>일반적으로 이러한 과제를 수행하는 대부분의 통계적 학습 방법은 모수적 방법과 비모수적 방법으로 구분할 수 있다.</p>
<section id="모수적-방법" class="level5">
<h5 class="anchored" data-anchor-id="모수적-방법">(1) 모수적 방법</h5>
<p>모수적 방법은 두 단계로 이루어진 모형 기반 접근법이다.</p>
<p>1. 첫 번째 단계: 함수 <span class="math inline">\(f\)</span>의 함수적 형태, 즉 구조나 모양에 대해 가정을 한다. 예를 들어, 가장 단순한 가정 중 하나는 <span class="math inline">\(f\)</span>가 <span class="math inline">\(X\)</span>에 대해 선형이라는 것이다.</p>
<p><span class="math display">\[f(X) = \beta_{0} + \beta_{1}X_{1} + \beta_{2}X_{2} + \cdots + \beta_{p}X_{p}\]</span></p>
<p><span class="math inline">\(f\)</span>가 선형이라는 가정을 하면 <span class="math inline">\(f\)</span>를 추정하는 문제는 크게 단순화된다. 즉, 임의의 <span class="math inline">\(p\)</span>차원 함수 <span class="math inline">\(f(X)\)</span> 전체를 추정할 필요 없이, <span class="math inline">\((p + 1)\)</span>개의 계수 <span class="math inline">\(\beta_{0},\beta_{1},\ldots,\beta_{p}\)</span>만 추정하면 된다.</p>
<p>2. 두 번째 단계: 모형이 선택되면, 훈련 데이터를 이용해 모형을 적합하거나 학습시키는 절차가 필요하다. 즉, <span class="math inline">\(Y \approx {\widehat{\beta}}_{0} + {\widehat{\beta}}_{1}X_{1} + {\widehat{\beta}}_{2}X_{2} + \cdots + {\widehat{\beta}}_{p}X_{p}\)</span>을 가장 잘 만족하는 계수값들을 찾는 것이 목적이다.</p>
<p>가장 일반적인 방법은 (일반) 최소제곱법이다. 다만 최소제곱법은 선형모형을 적합시키는 여러 방법 중 하나일 뿐이다.</p>
</section>
<section id="비모수적-방법" class="level5">
<h5 class="anchored" data-anchor-id="비모수적-방법">(2) 비모수적 방법</h5>
<p>모형 기반 접근법은 모수적 접근법이라 불린다. 이 방법은 함수 <span class="math inline">\(f\)</span>를 추정하는 문제를, 하나의 함수를 직접 추정하는 문제가 아니라 일정한 수의 모수를 추정하는 문제로 환원시킨다.</p>
<p>함수 <span class="math inline">\(f\)</span>에 대해 모수적 형태를 가정하면, 완전히 임의적인 함수 <span class="math inline">\(f\)</span> 전체를 적합시키는 것보다 <span class="math inline">\(\beta_{0},\beta_{1},\ldots,\beta_{p}\)</span>와 같은 모수들의 집합을 추정하는 것이 일반적으로 훨씬 쉽기 때문에, <span class="math inline">\(f\)</span>의 추정 문제가 크게 단순화된다.</p>
<p>하지만 모수적 접근법의 잠재적인 단점은, 우리가 선택한 모형이 실제로 존재하는 미지의 참함수 f의 형태와 대부분 일치하지 않는다는 점이다. 만약 선택한 모형이 참함수 <span class="math inline">\(f\)</span>와 크게 다르다면, 그에 따른 추정 결과 역시 부정확해질 수밖에 없다.</p>
<p>이 문제를 완화하기 위한 한 가지 방법은, <span class="math inline">\(f\)</span>의 다양한 가능한 함수 형태를 잘 적합할 수 있는 유연한 모형을 선택하는 것이다. 그러나 일반적으로 더 유연한 모형을 적합시키기 위해서는 더 많은 수의 모수를 추정해야 한다. 이러한 복잡한 모형들은 종종 과적합 이라 불리는 현상을 초래하는데, 이는 본질적으로 모형이 데이터에 포함된 오차, 즉 잡음을 지나치게 충실히 따라가게 된다는 것을 의미한다.</p>
</section>
<section id="비모수적-방법-정의" class="level5">
<h5 class="anchored" data-anchor-id="비모수적-방법-정의">비모수적 방법 정의</h5>
<p><span class="math inline">\(Y = f(X) + \varepsilon\)</span>에서 <span class="math inline">\(f\)</span>의 형태(선형, 다항식 등)를 사전에 규정하지 않는다. 대신 관측된 데이터에 최대한 가깝게 적합하면서도, 지나치게 요동치지 않도록 제약을 두어 <span class="math inline">\(f\)</span>를 추정한다.</p>
<p>즉, 문제를 <span dir="rtl">”</span>몇 개의 모수 <span class="math inline">\(\beta\)</span>를 추정한다”로 바꾸지 않고, <span dir="rtl">”</span>함수 <span class="math inline">\(f\)</span> 자체를 데이터로부터 학습한다”는 관점에서 접근한다.</p>
</section>
<section id="비모수적-방법-특징" class="level5">
<h5 class="anchored" data-anchor-id="비모수적-방법-특징">비모수적 방법 특징</h5>
<p>1. 함수 형태에 대한 가정이 없다. → 선형성, 특정 다항 차수 등 모형 가정을 두지 않으며 다양한 곡률과 비선형 구조를 자연스럽게 표현할 수 있다.</p>
<p>2. 유연성이 매우 높다. → 데이터가 보여주는 구조를 그대로 반영할 수 있고 참함수 <span class="math inline">\(f\)</span>가 복잡한 형태일수록 장점이 커진다.</p>
<p>3. 많은 데이터가 필요하다. → 소수의 모수로 요약되지 않기 때문에 안정적인 추정을 위해 관측치 수가 충분히 커야 한다.</p>
<p>4. 과적합 위험이 존재한다. → 유연성이 큰 만큼, 잡음까지 학습할 가능성이 있고 매끄러움, 이웃 크기, 규제가 핵심이다.</p>
</section>
<section id="대표적인-비모수적-방법-예시" class="level5">
<h5 class="anchored" data-anchor-id="대표적인-비모수적-방법-예시">대표적인 비모수적 방법 예시</h5>
<ul>
<li>커널 회귀(Kernel Regression)</li>
<li>k-최근접 이웃(k-NN)</li>
<li>스플라인 회귀(Splines, thin-plate spline)</li>
<li>로컬 회귀(LOESS, LOWESS)</li>
<li>회귀 트리 및 랜덤 포레스트</li>
<li>가우시안 프로세스 회귀</li>
</ul>
</section>
</section>
<section id="지도학습-비지도학습-준지도학습" class="level4">
<h4 class="anchored" data-anchor-id="지도학습-비지도학습-준지도학습">4. 지도학습 · 비지도학습 · 준지도학습</h4>
<p>통계적 학습 문제는 관측된 데이터의 형태에 따라 크게 지도학습과 비지도학습으로 구분된다. 이 구분의 기준은 각 관측치에 대해 반응변수가 함께 관측되었는지 여부이다. 분석 목적과 사용 가능한 방법은 이 구분에 의해 근본적으로 달라진다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 24%">
<col style="width: 24%">
<col style="width: 24%">
<col style="width: 24%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">구분</td>
<td style="text-align: center;">지도학습</td>
<td style="text-align: center;">비지도학습</td>
<td style="text-align: center;">준지도학습</td>
</tr>
<tr class="even">
<td style="text-align: center;">반응변수 Y</td>
<td style="text-align: center;">있음</td>
<td style="text-align: center;">없음</td>
<td style="text-align: center;">일부만 있음</td>
</tr>
<tr class="odd">
<td style="text-align: center;">주요 목적</td>
<td style="text-align: center;">예측·추론</td>
<td style="text-align: center;">구조·패턴 발견</td>
<td style="text-align: center;">예측 성능 향상</td>
</tr>
<tr class="even">
<td style="text-align: center;">데이터 요구</td>
<td style="text-align: center;">라벨 필수</td>
<td style="text-align: center;">라벨 불필요</td>
<td style="text-align: center;">라벨 일부</td>
</tr>
<tr class="odd">
<td style="text-align: center;">대표 기법</td>
<td style="text-align: center;">회귀, 분류</td>
<td style="text-align: center;">군집, PCA</td>
<td style="text-align: center;">라벨 전파, 혼합모형</td>
</tr>
</tbody>
</table>
<p>지도학습은 반응변수가 존재하는 상황에서 예측과 추론을 수행하는 방법이며, 비지도학습은 반응변수가 없는 상황에서 데이터의 구조를 탐색하는 방법이다. 준지도학습은 이 두 접근법의 중간 영역으로, 제한된 라벨 정보를 최대한 활용하려는 현실적인 학습 전략이라 할 수 있다.</p>
<section id="지도학습-supervised-learning" class="level5">
<h5 class="anchored" data-anchor-id="지도학습-supervised-learning">지도학습 (Supervised Learning)</h5>
<p>각 관측치마다 설명변수 <span class="math inline">\(X\)</span>와 이에 대응하는 반응변수 <span class="math inline">\(Y\)</span>가 함께 주어진 상황을 다룬다. 이 경우 분석의 목적은 새로운 관측치에 대한 반응변수를 정확하게 예측하거나, 설명변수와 반응변수 사이의 관계를 해석하는 데 있다. 다시 말해, 지도학습은 <span dir="rtl">”</span>입력이 주어졌을 때 출력은 무엇인가”라는 질문에 답하고자 한다. 선형회귀와 로지스틱 회귀와 같은 전통적인 통계 모형뿐 아니라, 일반화 가법모형(GAM), 부스팅, 서포트 벡터 머신 등 대부분의 현대적 예측 방법들 역시 지도학습의 범주에 속한다.</p>
</section>
<section id="비지도학습-unsupervised-learning" class="level5">
<h5 class="anchored" data-anchor-id="비지도학습-unsupervised-learning">비지도학습 (Unsupervised Learning)</h5>
<p>각 관측치에 대해 설명변수 <span class="math inline">\(X\)</span>만 관측되고, 반응변수 <span class="math inline">\(Y\)</span>는 존재하지 않는 경우를 다룬다. 예측해야 할 대상이 없기 때문에 회귀나 분류와 같은 지도학습 모형을 적용할 수 없으며, 분석의 목표 또한 다르다. 비지도학습의 목적은 데이터에 내재된 구조를 탐색하고, 변수들 간 또는 관측치들 간의 관계를 이해하는 데 있다. 이 과정은 분석을 지도해 줄 반응변수가 없다는 점에서 본질적으로 더 어렵다.</p>
<p>비지도학습의 대표적인 예가 군집분석이다. 군집분석은 관측된 변수들을 바탕으로 관측치들이 몇 개의 서로 구별되는 그룹으로 나뉘는지를 규명하는 것을 목표로 한다. 예를 들어 시장 세분화 연구에서는 고객의 소득, 거주 지역, 소비 성향과 같은 여러 특성을 관측할 수 있지만, 각 고객이 어떤 유형의 소비자에 속하는지는 사전에 알 수 없는 경우가 많다. 이때 군집분석을 통해 유사한 특성을 가진 고객들을 하나의 그룹으로 묶음으로써, 잠재적인 고객 유형을 식별할 수 있다. 이러한 그룹화는 이후 마케팅 전략이나 정책 설계의 기초 자료로 활용될 수 있다.</p>
<p>비지도학습 문제는 변수의 수가 많아질수록 더욱 복잡해진다. 변수가 두 개일 경우에는 산점도를 통해 직관적으로 구조를 파악할 수 있지만, 실제 데이터에서는 수십 개 이상의 변수가 포함되는 경우가 일반적이다. 이 경우 가능한 산점도의 수는 급격히 증가하며, 시각적 탐색만으로는 구조를 파악하기 어렵다. 따라서 자동화된 군집화 기법과 차원축소 방법이 비지도학습에서 중요한 역할을 한다.</p>
</section>
<section id="준지도학습-semi-supervised-learning" class="level5">
<h5 class="anchored" data-anchor-id="준지도학습-semi-supervised-learning">준지도학습 (Semi-Supervised Learning)</h5>
<p>현실의 데이터 분석에서는 지도학습과 비지도학습이 명확히 구분되지 않는 경우도 존재한다. 예를 들어 전체 관측치 중 일부에 대해서만 반응변수가 관측되고, 나머지 관측치에는 설명변수만 존재하는 상황을 생각해 볼 수 있다. 이러한 상황은 설명변수는 비교적 저렴하게 측정할 수 있지만, 반응변수는 비용이나 시간 문제로 인해 제한적으로만 수집 가능한 경우에 자주 발생한다.</p>
<p>이와 같은 설정을 준지도학습이라 한다. 준지도학습의 목적은 반응변수가 관측된 소수의 데이터와, 반응변수가 없는 다수의 데이터를 동시에 활용하여 학습 성능을 향상시키는 데 있다. 즉, 지도학습의 정보와 비지도학습의 구조 정보를 결합하여 보다 효율적인 학습을 수행하고자 하는 접근법이다.</p>
</section>
</section>
<section id="지도학습에서의-예측과-추론" class="level4">
<h4 class="anchored" data-anchor-id="지도학습에서의-예측과-추론">4. 지도학습에서의 예측과 추론</h4>
<p>지도학습은 각 관측치에 대해 설명변수 <span class="math inline">\(X\)</span>와 반응변수 <span class="math inline">\(Y\)</span>가 함께 관측된 상황에서, 두 변수 간의 관계를 학습하는 통계적 방법이다. 그러나 지도학습의 목적은 하나로 고정되어 있지 않으며, 크게 예측과 추론이라는 두 가지 상이한 관점으로 구분할 수 있다. 이 두 관점의 차이는 단순한 용어상의 구분이 아니라, 분석의 목표, 모형 선택, 그리고 결과 해석 방식 전반에 영향을 미친다.</p>
<p>먼저 예측 관점에서의 지도학습은 새로운 설명변수 <span class="math inline">\(X_{\text{new}}\)</span>가 주어졌을 때, 이에 대응하는 반응변수 <span class="math inline">\(Y_{\text{new}}\)</span>를 가능한 한 정확하게 예측하는 것을 목표로 한다. 이때 핵심 관심사는 예측 오차의 크기이며, 모형이 어떤 구조를 갖는지는 상대적으로 덜 중요하다. 예측 정확도를 높일 수 있다면, 모형이 복잡하더라도, 또는 해석이 어렵더라도 문제가 되지 않는다. 이러한 관점에서는 교차검증을 통한 예측 오차 최소화, 규제(parameter tuning), 앙상블 기법과 같은 방법들이 자연스럽게 강조된다. 부스팅, 랜덤 포레스트, 서포트 벡터 머신과 같은 기법들이 예측 중심 지도학습의 대표적인 예라 할 수 있다.</p>
<p>이에 반해 추론 관점에서의 지도학습은 설명변수와 반응변수 사이의 관계를 이해하고 해석하는 데 초점을 둔다. 이 경우 분석의 목적은 <span dir="rtl">”</span>어떤 변수가 중요한가?“, <span dir="rtl">”</span>설명변수의 변화가 반응변수에 어떤 영향을 미치는가?”와 같은 질문에 답하는 것이다. 따라서 모형의 해석 가능성이 매우 중요하며, 각 설명변수의 효과를 명확하게 표현할 수 있는 모형이 선호된다. 선형회귀나 로지스틱 회귀와 같은 비교적 단순한 모형이 오랫동안 널리 사용되어 온 이유도 여기에 있다. 추론 중심 분석에서는 모수 추정치의 크기와 부호, 신뢰구간, 가설검정과 같은 통계적 해석 도구가 핵심적인 역할을 한다.</p>
<p>예측과 추론의 관점 차이는 모형의 복잡도 선택에서도 뚜렷하게 나타난다. 예측을 목적으로 하는 경우에는 데이터가 허용하는 범위 내에서 보다 유연한 모형을 선택하는 것이 일반적이며, 다소의 과적합 위험도 감수할 수 있다. 반면 추론을 목적으로 할 경우에는 과도한 유연성이 오히려 해석을 방해하고 불안정한 결론을 초래할 수 있으므로, 상대적으로 단순하고 구조가 명확한 모형이 바람직하다.</p>
<p>또한 두 관점은 <span dir="rtl">”</span>좋은 모형”에 대한 기준에서도 차이를 보인다. 예측 관점에서는 보이지 않는 새로운 데이터에 대한 성능이 가장 중요한 평가 기준이 된다. 반면 추론 관점에서는 모형이 데이터 생성 과정에 대해 합리적인 가정을 하고 있는지, 추정된 관계가 통계적으로 의미 있는지, 그리고 결과가 해석 가능한지를 중시한다.</p>
<p>현실의 데이터 분석에서는 예측과 추론이 완전히 분리되는 경우는 드물다. 많은 경우 두 목적이 동시에 존재하며, 분석가는 어느 쪽에 더 무게를 둘 것인지 명확히 인식한 상태에서 모형을 선택해야 한다. 지도학습에서 예측과 추론을 구분하는 것은 단순한 분류가 아니라, 이후 분석 전반의 방향을 결정하는 출발점이라 할 수 있다.</p>
</section>
<section id="편향분산-관점에서-본-예측과-추론의-차이" class="level4">
<h4 class="anchored" data-anchor-id="편향분산-관점에서-본-예측과-추론의-차이">5. 편향–분산 관점에서 본 예측과 추론의 차이</h4>
<p>지도학습에서 예측과 추론의 차이는 흔히 목적의 차이로 설명되지만, 보다 근본적으로는 편향-분산 상충관계를 어떻게 받아들이는가의 차이로 이해할 수 있다. 동일한 데이터와 동일한 학습 문제라 하더라도, 분석의 목적이 예측인지 추론인지에 따라 허용 가능한 편향과 분산의 수준은 달라진다.</p>
<p>먼저 예측 관점에서의 지도학습은 새로운 관측치에 대한 예측 오차를 최소화하는 것을 목표로 한다. 이때 관심의 대상은 개별 모형의 모수 값이 아니라, 반복 표본 추출 상황에서의 평균적인 예측 성능이다. 따라서 예측 문제에서는 다소의 편향이 존재하더라도 분산을 효과적으로 줄일 수 있다면, 전체 예측 오차는 오히려 감소할 수 있다. 이 관점에서는 모형이 참함수 f의 구조를 정확히 반영하는지보다는, 새로운 데이터에 대해 얼마나 안정적으로 작동하는지가 더 중요하다.</p>
<p>이러한 이유로 예측 중심 분석에서는 규제를 통한 모형 단순화, 앙상블 기법, 혹은 의도적인 편향 도입이 정당화된다. 예를 들어 릿지 회귀나 라쏘는 모수 추정에 편향을 도입하지만, 분산을 크게 감소시켜 예측 성능을 향상시킨다. 부스팅이나 랜덤 포레스트 역시 개별 모형의 해석 가능성을 희생하는 대신, 분산 감소를 통해 강력한 예측력을 확보한다. 즉, 예측 관점에서는 편향-분산 상충관계의 균형점이 분산 감소 쪽으로 이동한다.</p>
<p>반면 추론 관점에서의 지도학습은 설명변수와 반응변수 사이의 관계를 정확히 이해하는 것을 목표로 한다. 이 경우 분석의 핵심은 모형이 데이터 생성 과정을 얼마나 잘 반영하는지이며, 추정된 모수의 해석 가능성과 통계적 타당성이 중요하다. 따라서 추론 문제에서는 작은 편향조차도 심각한 문제가 될 수 있다. 편향된 모수 추정치는 설명변수의 효과에 대한 왜곡된 해석으로 이어지기 때문이다.</p>
<p>추론 중심 분석에서는 분산이 다소 크더라도, 모형이 올바르게 지정되어 있다면 편향이 없는 추정치를 선호한다. 이는 반복 표본 추출 하에서 추정량의 평균이 참값에 수렴한다는 점이 해석의 신뢰성을 보장하기 때문이다. 이러한 맥락에서 선형회귀와 같은 비교적 단순한 모형이 여전히 추론의 표준 도구로 사용되며, 신뢰구간과 가설검정이 중요한 역할을 한다. 즉, 추론 관점에서는 편향-분산 상충관계의 균형점이 편향 최소화 쪽에 놓인다.</p>
<p>이 차이는 과적합에 대한 태도에서도 분명히 드러난다. 예측 문제에서는 교차검증을 통해 과적합 여부를 판단하며, 새로운 데이터에서의 성능이 유지된다면 훈련 데이터에 대한 높은 적합도는 반드시 문제가 되지 않는다. 반면 추론 문제에서는 과적합된 모형이 불안정한 추정치와 왜곡된 효과 해석을 초래할 수 있으므로, 훨씬 더 엄격하게 경계된다.</p>
<p>결국 편향-분산 상충관계는 단순한 기술적 개념이 아니라, 분석 목적을 수학적으로 구체화한 틀이라 할 수 있다. 지도학습에서 예측과 추론을 구분한다는 것은, 어떤 종류의 오차를 더 용인할 것인지 편향인가, 분산인가에 대한 선택을 의미한다. 이 선택이 모형의 복잡도, 추정 방법, 결과 해석 전반을 결정하게 된다.</p>
</section>
<section id="데이터-생성-과정-관점에서-왜-추론이-더-까다로운가" class="level4">
<h4 class="anchored" data-anchor-id="데이터-생성-과정-관점에서-왜-추론이-더-까다로운가">6. 데이터 생성 과정 관점에서 왜 추론이 더 까다로운가</h4>
<p>지도학습에서 예측과 추론의 차이는 단순히 목적의 차이에 그치지 않으며, 보다 근본적으로는 데이터 생성 과정에 대해 무엇을 요구하는가의 차이로 이해할 수 있다. 이 관점에서 보면, 추론이 예측보다 본질적으로 훨씬 까다로운 문제임을 알 수 있다.</p>
<p>데이터 생성 과정란 관측된 데이터가 생성되는 확률적 메커니즘을 의미한다. 통계적 추론은 본질적으로 이 데이터 생성 과정에 대해 어떤 구조적 진술을 하고자 하는 작업이다. 즉, 추론의 목표는 단순히 관측된 데이터에 잘 맞는 함수를 찾는 것이 아니라, 데이터를 만들어낸 근본적인 관계가 무엇인지를 밝히는 데 있다. 따라서 추론에서는 모형이 데이터 생성 과정을 얼마나 정확히 반영하고 있는지가 핵심적인 문제가 된다.</p>
<p>이에 비해 예측 문제에서는 데이터 생성 과정을 정확히 복원할 필요가 없다. 새로운 입력 <span class="math inline">\(X_{\text{new}}\)</span>에 대해 반응변수 <span class="math inline">\(Y_{\text{new}}\)</span>를 잘 맞히기만 하면 되며, 그 과정에서 사용된 모형이 실제 DGP와 일치하는지는 부차적인 문제로 취급된다. 예측 정확도가 높다면, 모형이 데이터 생성 과정을 부분적으로 잘못 근사하고 있더라도 실용적인 목적은 달성된다. 이 점에서 예측은 데이터 생성 과정에 대한 약한 요구만을 가진 문제라 할 수 있다.</p>
<p>반면 추론은 데이터 생성 과정에 대해 훨씬 강한 요구를 부과한다. 예를 들어 선형회귀 모형에서 특정 설명변수의 계수 \beta_j를 해석하려면, 해당 모형이 데이터 생성 과정의 구조를 올바르게 반영하고 있다는 전제가 필요하다. 만약 중요한 설명변수가 누락되었거나, 함수 형태가 잘못 지정되었거나, 오차 구조에 대한 가정이 틀렸다면, 추정된 계수는 DGP의 실제 효과를 반영하지 못한다. 이 경우 추정치는 수치적으로 안정적일 수는 있어도, 해석적으로는 의미를 잃게 된다.</p>
<p>또한 추론에서는 조건부 관계와 인과적 해석이 암묵적으로 요구되는 경우가 많다. 설명변수 X_j의 효과를 논의한다는 것은, 다른 변수들이 고정된 상태에서 X_j가 변화할 때 Y가 어떻게 반응하는지를 해석하는 것을 의미한다. 이러한 해석은 DGP에 대한 구조적 가정 없이는 성립할 수 없다. 반면 예측은 이러한 조건부 해석을 필요로 하지 않으며, 단지 관측된 공변량 공간에서의 함수 근사 문제로 귀결된다.</p>
<p>데이터 생성 과정 관점에서 또 하나 중요한 차이는 모형 오지정(model misspecification) 에 대한 민감도이다. 예측 문제에서는 모형이 다소 잘못 지정되었더라도, 충분한 데이터와 유연한 학습 방법을 통해 예측 성능을 유지할 수 있다. 반면 추론 문제에서는 작은 오지정조차도 추정된 효과의 방향이나 크기를 왜곡할 수 있으며, 이는 잘못된 과학적 결론으로 이어질 수 있다. 즉, 추론은 데이터 생성 과정 오지정에 대해 훨씬 더 취약하다.</p>
<p>마지막으로, 추론은 관측되지 않은 반사실 상황에 대한 해석을 암묵적으로 포함하는 경우가 많다. <span dir="rtl">”</span>만약 이 변수가 달랐다면 결과는 어떻게 되었을까?“라는 질문은, 실제로 관측되지 않은 데이터 생성 과정을 상정해야만 답할 수 있다. 이러한 질문은 단순한 함수 근사로는 해결할 수 없으며, 데이터 생성 과정에 대한 구조적 이해를 전제로 한다. 이 점에서 추론은 예측보다 훨씬 더 강한 가정과 해석적 책임을 요구한다.</p>
<p>요약하면, 예측은 데이터 생성 과정을 잘 근사하는 것으로 충분한 문제인 반면, 추론은 데이터 생성 과정의 구조 자체를 이해하고 설명하려는 문제이다. 따라서 추론은 더 많은 가정에 의존하며, 모형 선택과 가정 위반에 훨씬 민감하다. 이러한 이유로 통계적 학습에서 추론은 예측보다 본질적으로 더 어렵고 까다로운 작업이라 할 수 있다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>