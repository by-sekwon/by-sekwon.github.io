<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>회귀분석 5. 로지스틱회귀 – 세상의 모든 통계 이야기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-d24c3880db9ce3ca4ea2d5bb002bea1f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">세상의 모든 통계 이야기</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">기초수학</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-">    
        <li>
    <a class="dropdown-item" href="../../notes/math/function.html">
 <span class="dropdown-text">함수</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math/derivate_integral.html">
 <span class="dropdown-text">미분적분</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math/vector.html">
 <span class="dropdown-text">벡터</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math/matrix.html">
 <span class="dropdown-text">행렬</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--1" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">수리통계</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--1">    
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/probability.html">
 <span class="dropdown-text">확률</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/random_variable.html">
 <span class="dropdown-text">확률변수</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/famous_distribution.html">
 <span class="dropdown-text">유명한분포</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/multi_variate.html">
 <span class="dropdown-text">다변량확률변수</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/random_sample.html">
 <span class="dropdown-text">확률표본_난수생성</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/estimation.html">
 <span class="dropdown-text">추정</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/hypothesis_testing.html">
 <span class="dropdown-text">가설검정_신뢰구간</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--2" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">조사방법론</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--2">    
        <li>
    <a class="dropdown-item" href="../../notes/survey/survey_intro.html">
 <span class="dropdown-text">조사방법 기초</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/sample_design.html">
 <span class="dropdown-text">표본설계</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/questionnaire.html">
 <span class="dropdown-text">설문지</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/nonresponse.html">
 <span class="dropdown-text">무응답 대체</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/data_process.html">
 <span class="dropdown-text">데이터 처리</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/survey_scale.html">
 <span class="dropdown-text">조사지 척도</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/delphi_ahp_conjoint.html">
 <span class="dropdown-text">델파이_AHP_컨조인트</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/psm.html">
 <span class="dropdown-text">PSM 성향점수매칭</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--3" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">일변량분석</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--3">    
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/concept_of_stat.html">
 <span class="dropdown-text">일변량분석 개념</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/data.html">
 <span class="dropdown-text">데이터와 통계</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/univariate.html">
 <span class="dropdown-text">일변량분석</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/crosstab.html">
 <span class="dropdown-text">교차표분석</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/goodness_of_fits.html">
 <span class="dropdown-text">적합성검정</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/normality.html">
 <span class="dropdown-text">정규변환</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/correlation.html">
 <span class="dropdown-text">상관분석</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/anova.html">
 <span class="dropdown-text">실험설계 분산분석</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/time_series.html">
 <span class="dropdown-text">시계열분석</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--4" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">회귀분석</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--4">    
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_concept.html">
 <span class="dropdown-text">개념&amp;추정</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_selection.html">
 <span class="dropdown-text">변수선택</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_multicolin.html">
 <span class="dropdown-text">다중공선성</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_diagnosis.html">
 <span class="dropdown-text">회귀진단</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_logistic.html">
 <span class="dropdown-text">로지스틱회귀</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../cardnews/index.html"> 
<span class="menu-text">카드뉴스</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../consult.html"> 
<span class="menu-text">통계상담</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--5" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">📡스트리밍</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--5">    
        <li>
    <a class="dropdown-item" href="https://by-sekwonappio-esqshnv7wueapp4da6jrizn.streamlit.app" target="_blank">
 <span class="dropdown-text">실시간주가[5대종목]</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://by-sekwonappio-k5e5n7wasvj3kveyqbwmgc.streamlit.app/" target="_blank">
 <span class="dropdown-text">대전유성구 일기예보</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#chapter-1.-일반화-선형모형" id="toc-chapter-1.-일반화-선형모형" class="nav-link active" data-scroll-target="#chapter-1.-일반화-선형모형"><span style="color:green">chapter 1. 일반화 선형모형</span></a>
  <ul>
  <li><a href="#일반화-선형모형-개념" id="toc-일반화-선형모형-개념" class="nav-link" data-scroll-target="#일반화-선형모형-개념"><span style="color:blue"> 1. 일반화 선형모형 개념</span></a></li>
  <li><a href="#왜-ols를-사용할-수-없나" id="toc-왜-ols를-사용할-수-없나" class="nav-link" data-scroll-target="#왜-ols를-사용할-수-없나"><span style="color:blue"> 2. 왜 OLS를 사용할 수 없나?</span></a></li>
  <li><a href="#연결-link-함수" id="toc-연결-link-함수" class="nav-link" data-scroll-target="#연결-link-함수"><span style="color:blue"> 3. 연결 LINK 함수</span></a></li>
  <li><a href="#일반화-선형모형-추정" id="toc-일반화-선형모형-추정" class="nav-link" data-scroll-target="#일반화-선형모형-추정"><span style="color:blue"> 4. 일반화 선형모형 추정</span></a></li>
  </ul></li>
  <li><a href="#chapter-2.-이진형-종속변수-로지스틱-회귀" id="toc-chapter-2.-이진형-종속변수-로지스틱-회귀" class="nav-link" data-scroll-target="#chapter-2.-이진형-종속변수-로지스틱-회귀"><span style="color:green">chapter 2. 이진형 종속변수 : 로지스틱 회귀</span></a>
  <ul>
  <li><a href="#개념" id="toc-개념" class="nav-link" data-scroll-target="#개념"><span style="color:blue"> 1. 개념</span></a></li>
  <li><a href="#링크함수-gpi_i-xb" id="toc-링크함수-gpi_i-xb" class="nav-link" data-scroll-target="#링크함수-gpi_i-xb"><span style="color:blue"> 2. 링크함수 <span class="math inline">\(g(\pi_{i}) = Xb\)</span> </span></a></li>
  <li><a href="#오즈비" id="toc-오즈비" class="nav-link" data-scroll-target="#오즈비"><span style="color:blue"> 3. 오즈비</span></a></li>
  <li><a href="#추정" id="toc-추정" class="nav-link" data-scroll-target="#추정"><span style="color:blue"> 4. 추정</span></a></li>
  </ul></li>
  <li><a href="#chapter-3.-로지스틱-회귀-사례분석" id="toc-chapter-3.-로지스틱-회귀-사례분석" class="nav-link" data-scroll-target="#chapter-3.-로지스틱-회귀-사례분석"><span style="color:green">chapter 3. 로지스틱 회귀 사례분석</span></a>
  <ul>
  <li><a href="#타니타닉-데이터" id="toc-타니타닉-데이터" class="nav-link" data-scroll-target="#타니타닉-데이터"><span style="color:blue"> 1. 타니타닉 데이터</span></a></li>
  <li><a href="#데이터-전처리" id="toc-데이터-전처리" class="nav-link" data-scroll-target="#데이터-전처리"><span style="color:blue"> 2. 데이터 전처리</span></a></li>
  <li><a href="#모형-추정" id="toc-모형-추정" class="nav-link" data-scroll-target="#모형-추정"><span style="color:blue"> 3. 모형 추정</span></a></li>
  <li><a href="#오즈비-1" id="toc-오즈비-1" class="nav-link" data-scroll-target="#오즈비-1"><span style="color:blue"> 4. 오즈비</span></a></li>
  <li><a href="#모형-정확도-confusion-행렬" id="toc-모형-정확도-confusion-행렬" class="nav-link" data-scroll-target="#모형-정확도-confusion-행렬"><span style="color:blue"> 5. 모형 정확도 Confusion 행렬 </span></a></li>
  <li><a href="#roc-커브" id="toc-roc-커브" class="nav-link" data-scroll-target="#roc-커브"><span style="color:blue"> 6. ROC 커브 </span></a></li>
  </ul></li>
  <li><a href="#chapter-4.-다중-로짓-회귀" id="toc-chapter-4.-다중-로짓-회귀" class="nav-link" data-scroll-target="#chapter-4.-다중-로짓-회귀"><span style="color:green">chapter 4. 다중 로짓 회귀</span></a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">회귀분석 5. 로지스틱회귀</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><br></p>
<section id="chapter-1.-일반화-선형모형" class="level3">
<h3 class="anchored" data-anchor-id="chapter-1.-일반화-선형모형"><span style="color:green">chapter 1. 일반화 선형모형</span></h3>
<section id="일반화-선형모형-개념" class="level4">
<h4 class="anchored" data-anchor-id="일반화-선형모형-개념"><span style="color:blue"> 1. 일반화 선형모형 개념</span></h4>
<p>전통적인 선형회귀모형은 목표변수가 연속형이고 정규분포를 따른다는 가정을 전제로 한다. 하지만 실제 자료에서는 목표변수가 이진형, 계수형, 범주형 등 다양한 형태로 나타난다. 예를 들어 구매 여부(예/아니오), 교통사고 건수, 고객의 만족도 척도 등은 정규분포 가정을 따르지 않는다. 이러한 경우에도 회귀분석의 틀을 적용할 수 있도록 확장한 것이 일반화선형모형(GLM)이다.</p>
<p>GLM은 세 가지 요소로 구성된다.</p>
<ul>
<li><p>확률분포 가정: 목표변수 Y는 지수족에 속하는 분포를 따른다고 가정한다. 여기에는 정규분포, 이항분포, 포아송분포, 감마분포 등이 포함된다.</p></li>
<li><p>선형예측자: 설명변수들의 선형 결합 <span class="math inline">\(\eta = \beta_{0} + \beta_{1}X_{1} + \cdots + \beta_{p}X_{p}\)</span>를 사용한다.</p></li>
<li><p>연결함수: 기대값 <span class="math inline">\(\mu = E(Y|X)\)</span>와 선형예측자 <span class="math inline">\(\eta\)</span>를 연결하는 함수 <span class="math inline">\(g(\mu) = \eta\)</span>를 정의한다. 이 함수는 분포의 제약(예: 확률은 0과 1 사이, 기대값은 양수 등)을 해소해준다.</p></li>
</ul>
<p>따라서 이산형 목표변수의 분포 특성에 맞는 회귀모형이 필요하다.</p>
<p><strong>이진형(binary)</strong>: 두 가지 결과(예: 성공/실패, 합격/불합격, 구매/비구매)만 가질 수 있는 경우이므로 베르누이 분포에 따르므로 로지스틱 회귀, 프로빗 회귀 등을 사용한다.</p>
<p><strong>이산형 정수형(count data)</strong>: 사건 발생 횟수를 나타내는 변수 (예: 교통사고 건수, 병원 방문 횟수, 감염 환자 수)로 포아송 분포 또는 음이항 분포를 따르므로 포아송 회귀를 사용한다.</p>
<p><strong>순서형(ordinal)</strong>: 순서 정보는 있으나 간격이 일정하지 않은 변수 (예: 학점 A–B–C–D–F, 만족도 리커트 척도)는 다항 분포 기반이므로 순서형 로지스틱 회귀분석을 이용한다.</p>
<p><strong>명목형(nominal)</strong>: 범주에 단순한 구분만 존재하고 순서가 없는 변수 (예: 직업, 거주지역, 혈액형) 다항 분포 기반인 다항 로지스틱 회귀분석을 이용한다.</p>
</section>
<section id="왜-ols를-사용할-수-없나" class="level4">
<h4 class="anchored" data-anchor-id="왜-ols를-사용할-수-없나"><span style="color:blue"> 2. 왜 OLS를 사용할 수 없나?</span></h4>
<p>이진형 종속변수(예: 합격=1, 불합격=0)를 설명변수 X로 회귀한다고 하자. 이때 단순히 선형회귀를 적용하면 여러 가지 문제가 발생한다.</p>
<p>첫째, 예측값의 범위 문제가 있다. 선형회귀식 <span class="math inline">\(Y = \beta_{0} + \beta_{1}X + \varepsilon\)</span>을 그대로 적용하면, 예측값 <span class="math inline">\(\widehat{Y}\)</span>는 이론적으로 모든 실수 값을 가질 수 있다. 그러나 이진형 변수는 성공 확률 p로 해석되어야 하므로, 예측값은 반드시 [0,1] 범위 안에 있어야 하나 실제로는 시험 점수 X=30일 때 <span class="math inline">\(\widehat{Y} = - 0.3\)</span>처럼 음수가 나오거나, X=90일 때 <span class="math inline">\(\widehat{Y} = 1.2\)</span>처럼 1을 초과할 수 있어 확률 해석이 불가능하다. 따라서 선형회귀식은 확률모형으로 적합하지 않다.</p>
<p>둘째, 분산 불일치 문제가 있다. 이진형 변수는 베르누이 확률변수이므로, 기대값은 <span class="math inline">\(E(Y|X) = p,\)</span>분산은 <span class="math inline">\(Var(Y|X) = p(1 - p)\)</span>의 형태를 가진다. 즉, 분산이 확률 p의 크기에 따라 달라진다. 그러나 선형회귀에서는 오차항의 분산이 일정하다는 가정, 즉 <span class="math inline">\(Var(\varepsilon) = \sigma^{2}\)</span>를 전제로 한다. 이 가정이 깨지므로 추정량의 효율성과 검정의 타당성에 문제가 생긴다.</p>
<p>셋째, 선형성 가정이 불합리하다는 점이다. 현실에서 사건 발생 확률은 설명변수가 증가한다고 직선적으로 증가하지 않는다. 보통은 S자 모양의 곡선을 따른다. 즉, 낮은 구간에서는 거의 0에 수렴하고, 일정 구간에서 급격히 증가하며, 높은 구간에서는 다시 1에 가까워지면서 평탄해진다. 하지만 선형회귀는 직선 관계만을 가정하기 때문에 확률의 비선형적 구조를 설명하지 못한다.</p>
<p>이러한 한계를 해결하기 위해 등장한 것이 로지스틱 회귀분석이다. 로지스틱 회귀에서는 확률 p를 직접 선형식으로 표현하지 않고, 로짓 변환을 사용한다. 로짓은 <span class="math inline">\(\text{logit}(p) = \log\frac{p}{1 - p}\)</span>로 정의되며, 이는 <span class="math inline">\(- \infty\)</span>부터 <span class="math inline">\(+ \infty\)</span>까지 모든 실수 값을 가질 수 있다. 따라서 이를 <span class="math inline">\(\beta_{0} + \beta_{1}X\)</span>와 같은 선형식으로 표현할 수 있다. 이후 역변환을 취하면, 확률 p는 항상 0과 1 사이에 위치하는 로지스틱 함수 형태가 된다. 이런 함수를 연결함수라 한다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">100</span>, <span class="dv">400</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>beta0, beta1 <span class="op">=</span> <span class="op">-</span><span class="dv">25</span>, <span class="fl">0.5</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>logit <span class="op">=</span> beta0 <span class="op">+</span> beta1 <span class="op">*</span> X</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> np.exp(<span class="op">-</span>logit))</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>fig, ax1 <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">5</span>))</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co"># 왼쪽 y축: 확률 (0~1)</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>ax1.plot(X, p, label<span class="op">=</span><span class="st">"Logistic (probability)"</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>ax1.set_ylim(<span class="op">-</span><span class="fl">0.05</span>, <span class="fl">1.05</span>)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>ax1.set_ylabel(<span class="st">"Probability p"</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>ax1.axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">"gray"</span>, linestyle<span class="op">=</span><span class="st">":"</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>ax1.axhline(<span class="dv">1</span>, color<span class="op">=</span><span class="st">"gray"</span>, linestyle<span class="op">=</span><span class="st">":"</span>)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>ax1.axvline(<span class="op">-</span>beta0<span class="op">/</span>beta1, color<span class="op">=</span><span class="st">"gray"</span>, linestyle<span class="op">=</span><span class="st">"--"</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co"># 오른쪽 y축: 선형 예측치</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>ax2 <span class="op">=</span> ax1.twinx()</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>ax2.plot(X, logit, color<span class="op">=</span><span class="st">"red"</span>, linestyle<span class="op">=</span><span class="st">"--"</span>, label<span class="op">=</span><span class="st">"Linear prediction"</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>ax2.set_ylabel(<span class="st">"Linear prediction"</span>)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="co"># 범례 합치기</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>h1, l1 <span class="op">=</span> ax1.get_legend_handles_labels()</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>h2, l2 <span class="op">=</span> ax2.get_legend_handles_labels()</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>ax1.legend(h1<span class="op">+</span>h2, l1<span class="op">+</span>l2, loc<span class="op">=</span><span class="st">"lower right"</span>)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">"Linear vs Logistic (dual y-axes)"</span>)</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>ax1.set_xlabel(<span class="st">"Score (0–100)"</span>)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>ax1.grid(<span class="va">True</span>)</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/로지스틱_선형모형비교.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
</section>
<section id="연결-link-함수" class="level4">
<h4 class="anchored" data-anchor-id="연결-link-함수"><span style="color:blue"> 3. 연결 LINK 함수</span></h4>
<p>일반화선형모형에서는 종속변수가 반드시 정규분포를 따를 필요가 없으며, 베르누이 분포, 포아송 분포, 다항 분포 등 다양한 분포를 따를 수 있다. 그러나 이들 분포에서 종속변수의 기대값 <span class="math inline">\(\mu = E(Y|X)\)</span>는 특정한 범위 제약을 갖는다. 예를 들어, 이진형 변수에서는 확률이므로 <span class="math inline">\(0 &lt; \mu &lt; 1\)</span>, 포아송 분포에서는 <span class="math inline">\(\mu &gt; 0\)</span>이어야 한다.</p>
<p>반면, 설명변수들의 선형 결합으로 만들어지는 선형예측자 <span class="math inline">\(\eta = \beta_{0} + \beta_{1}X_{1} + \cdots + \beta_{p}X_{p}\)</span>는 이론적으로 <span class="math inline">\(( - \infty, + \infty)\)</span>까지 모든 값을 가질 수 있다. 따라서 기대값 <span class="math inline">\(\mu\)</span>와 선형예측자 <span class="math inline">\(\eta\)</span>를 직접 연결할 경우, 서로의 값의 범위가 맞지 않는 문제가 발생한다.</p>
<p>이때 필요한 것이 바로 연결함수이다. 연결함수는 기대값 <span class="math inline">\(\mu\)</span>를 변환하여 <span class="math inline">\(\eta\)</span>와 같은 스케일로 만들어주는 함수이다. 즉, <span class="math inline">\(g(\mu) = \eta\)</span> 형태를 가지며, 이를 통해 <span class="math inline">\(\mu\)</span>와 <span class="math inline">\(\eta\)</span> 사이의 불일치를 해소한다. 예를 들어, 로지스틱 회귀에서는 <span class="math inline">\(\mu = p\)</span>가 확률이므로 [0,1] 범위를 갖는다. 이를 선형예측자와 연결하기 위해 로짓함수 <span class="math inline">\(g(p) = \log\frac{p}{1 - p}\)</span>를 사용한다. 로짓은 확률을 <span class="math inline">\(( - \infty, + \infty)\)</span> 범위로 변환하므로, 선형식과 자연스럽게 결합할 수 있다.</p>
<p>따라서 연결함수는 단순히 수학적 편의가 아니라, 확률모형으로서의 타당성을 확보하고 다양한 분포를 회귀분석에 활용할 수 있게 해주는 핵심 장치라고 할 수 있다.</p>
<p><strong>목표변수는 지수족이어야 한다.</strong></p>
<p>GLM의 기본 구조 <span class="math inline">\(g(\mu) = \eta = X\beta,\mu = E(Y|X)\)</span>이며 이에 필요한 전제는 다음과 같습니다. 분포의 평균과 분산이 간단한 형태로 표현되어야 한다. 그래야 기대값과 분산를 쉽게 다룰 수 있다. 지수족 분포는 평균과 분산이 모수(특히 자연모수)에 의해 단순하게 표현된다. 그리고 우도함수가 지수형태로 정리될 수 있어야 한다. 이렇게 해야 최대우도추정(MLE)이 수학적으로 해석 가능해지기 때문이다. 지수족은 정의에 의해 우도함수로 표현된다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 34%">
<col style="width: 47%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">목표변수 분포</td>
<td style="text-align: center;">연결함수</td>
<td style="text-align: center;">평균함수</td>
</tr>
<tr class="even">
<td style="text-align: center;">정규분포</td>
<td style="text-align: center;">항등함수 <span class="math inline">\(g(\mu) = \mu\)</span></td>
<td style="text-align: center;"><span class="math display">\[\mu = X\underset{¯}{b}\]</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">지수분포 감마분포</td>
<td style="text-align: center;">음의 역함수 <span class="math inline">\(g(\mu) = - \mu^{- 1}\)</span></td>
<td style="text-align: center;"><span class="math display">\[\mu = - X{\underset{¯}{b}}^{- 1}\]</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">포아송분포</td>
<td style="text-align: center;">로그함수 <span class="math inline">\(g(\mu) = ln(\mu)\)</span></td>
<td style="text-align: center;"><span class="math display">\[\mu = exp(X\underset{¯}{b})\]</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">베르누이분포</td>
<td style="text-align: center;">로짓함수 <span class="math inline">\(g(\mu) = ln(\frac{\mu}{1 - \mu})\)</span></td>
<td style="text-align: center;"><span class="math display">\[\mu = \frac{1}{1 + exp( - X\underset{¯}{b})}\]</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">이항분포</td>
<td style="text-align: center;">로짓함수 <span class="math inline">\(g(\mu) = ln(\frac{\mu}{n - \mu})\)</span></td>
<td style="text-align: center;"><span class="math display">\[\mu = \frac{1}{1 + exp( - X\underset{¯}{b})}\]</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">범주형분포<br>
다항분포</td>
<td style="text-align: center;">로짓함수 <span class="math inline">\(g(\mu) = ln(\frac{\mu}{1 - \mu})\)</span></td>
<td style="text-align: center;"><span class="math display">\[\mu = \frac{1}{1 + exp( - X\underset{¯}{b})}\]</span></td>
</tr>
</tbody>
</table>
</section>
<section id="일반화-선형모형-추정" class="level4">
<h4 class="anchored" data-anchor-id="일반화-선형모형-추정"><span style="color:blue"> 4. 일반화 선형모형 추정</span></h4>
<p>모형 <span class="math inline">\(g(E(y)) = Xb + e,e \sim N(0,\sigma^{2})\)</span></p>
<ul>
<li><p>이진형 분포 <span class="math inline">\(P(y_{i} = 1) = p,p = e^{( - \theta x)}\)</span> =&gt; <span class="math inline">\(g(p_{x}) = ln(p_{x}) = - \theta x\)</span></p></li>
<li><p>Poisson <span class="math inline">\(E(y) = \lambda,\lambda = ne^{\theta},g(\lambda_{i}) = ln(n_{i}) + \theta*i\)</span></p></li>
</ul>
<p><strong>지수족 exponential family</strong></p>
<p><span class="math inline">\(f(y;\theta) = h(x)exp(\eta(\theta)T(x) - A(\theta))\)</span>로 표현되는 확률변수 y는 지수족이다. <span class="math inline">\(\theta\)</span>는 모수, <span class="math inline">\(T(x)\)</span>는 충분통계량이다.</p>
<ul>
<li><p>(성질) 지수족의 T(x)는 완비통계량이며 T(x)의 함수 중 불편성을 만족하는 통계량이 MVUE이다.</p></li>
<li><p>(성질) 로그우도함수 <span class="math inline">\(ln(f(y;\theta))\)</span>는 다음 성질을 갖는다. (1) score 함수 <span class="math inline">\(U = \frac{dln(f(y;\theta))}{d\theta}\)</span>의 기대값은 <span class="math inline">\(E(U) = 0\)</span> 이다. (2) U의 분산을 Information이라 정의한다. <span class="math inline">\(V(U) = J\)</span> (3) 스코어 함수의 <span class="math inline">\(\theta\)</span> 1차 미분의 기대값은 <span class="math inline">\(E(\frac{dU}{d\theta}) = - V(U) = - J\)</span> 관계식을 갖는다.</p></li>
</ul>
<p>정규분포, 감마분포, 포아송분포, 이항분포, 베타분포 등 대부분의 유명한 분포는 지수족이다. 스코어 함수 <span class="math inline">\(U = 0\)</span>을 N-R 방식으로 풀면 <span class="math inline">\(\theta\)</span>의 MVUE 추정치를 얻는다. <span class="math inline">\({\widehat{\theta}}^{(m)} = {\widehat{\theta}}^{(m - 1)} + \frac{U^{(m - 1)}}{J^{(m - 1)}}\)</span></p>
<p><strong>추정량의 샘플링분포 <span class="math inline">\(\widehat{\theta} \sim ?\)</span></strong></p>
<p>대표본 이론에 의해 [이차형식] <span class="math inline">\(U'J^{- 1}U \sim \chi^{2}(p)\)</span>,<span class="math inline">\(p\)</span>=모수의 개수</p>
<p>MLE의 공분산 : <span class="math inline">\(E\lbrack(\widehat{\theta} - \theta)'(\widehat{\theta} - \theta)\rbrack = J(\widehat{\theta})\)</span></p>
<p>Wald 검정통계량 <span class="math inline">\((\widehat{\theta} - \theta)'J^{- 1}((\widehat{\theta})(\widehat{\theta} - \theta) \sim \chi^{2}(p)\)</span></p>
<p>LR 우도비 검정 <span class="math inline">\(H_{0}:\theta = 0\)</span></p>
<p><span class="math display">\[\lambda = \frac{L(y;\widehat{\theta}underH_{0})}{L(y;\widehat{\theta})} \sim 2ln\lambda \sim \chi^{2}(1)\]</span></p>
</section>
</section>
<section id="chapter-2.-이진형-종속변수-로지스틱-회귀" class="level3">
<h3 class="anchored" data-anchor-id="chapter-2.-이진형-종속변수-로지스틱-회귀"><span style="color:green">chapter 2. 이진형 종속변수 : 로지스틱 회귀</span></h3>
<section id="개념" class="level4">
<h4 class="anchored" data-anchor-id="개념"><span style="color:blue"> 1. 개념</span></h4>
<p>로짓변환은 목표변수가 이진형 변수이고 모수 <span class="math inline">\(p\)</span>(성공확률)를 추정하기 위한 연결함수이다. 이진형 변수를 따르는 확률실험의 성공의 회수는 개별 관측치 <span class="math inline">\(z_{i}B(\theta = \pi)\)</span>이므로 <span class="math inline">\(i -\)</span>구간의 성공 회수는 <span class="math inline">\(y_{i} \sim B(n,\pi)\)</span>이므로 <span class="math inline">\(E(Y) = np\)</span>이다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/로지스틱_이항분포.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:60.0%"></p>
</figure>
</div>
<p>이항분포를 따르는 경우에도 마찬가지로, 개별 관측치 수준에서는 이항 데이터를 0과 1의 이진형 데이터로 변환하여 로지스틱 회귀를 적용할 수 있다. 예를 들어 <span dir="rtl">”</span>10명 중 7명이 성공”이라는 집계 데이터를 7개의 성공(=1)과 3개의 실패(=0)로 풀어쓰면, 베르누이 시행들의 합이 이항분포가 된다는 점을 활용하는 것이다. 이렇게 변환하면 로지스틱 회귀는 이항분포와 베르누이분포를 모두 포괄할 수 있다.</p>
</section>
<section id="링크함수-gpi_i-xb" class="level4">
<h4 class="anchored" data-anchor-id="링크함수-gpi_i-xb"><span style="color:blue"> 2. 링크함수 <span class="math inline">\(g(\pi_{i}) = Xb\)</span> </span></h4>
<p>회귀모형 적용을 위해서는 링크함수의 범위는 반드시 <span class="math inline">\(( - \infty,\infty)\)</span>이어야 한다.</p>
<p><strong>로짓(link: logit)</strong></p>
<p>이진형 목표변수를 다룰 때 가장 널리 쓰이는 연결함수는 로짓이다. 로짓 함수는 확률 p를 오즈(odds)의 로그로 변환하여 선형예측자와 연결한다. 즉, <span class="math inline">\(g(p) = \log\frac{p}{1 - p}\)</span>의 형태를 가지며, 이를 통해 확률이 0과 1 사이에 있다는 제약을 풀어내고 선형식 <span class="math inline">\(\eta = X\beta\)</span>와 자연스럽게 결합시킨다. 로짓 모형의 큰 장점은 해석이 직관적이라는 점이다. 추정된 회귀계수 <span class="math inline">\(\beta_{j}\)</span>는 해당 설명변수가 1 단위 증가할 때 오즈비가 <span class="math inline">\(e^{\beta_{j}}\)</span>배 커진다는 의미를 갖는다. 이 때문에 로지스틱 회귀는 의학, 사회과학, 정책연구 등에서 사실상 표준처럼 사용되고 있으며, 특히 역학 연구에서 위험요인을 설명할 때 필수적으로 쓰인다.</p>
<p><strong>프로빗(link: probit)</strong></p>
<p>프로빗 함수는 확률을 표준정규분포의 누적분포함수(CDF)의 역함수를 통해 변환한다. 즉, <span class="math inline">\(g(p) = \Phi^{- 1}(p)\)</span>로 정의된다. 이는 곧 잠재변수 모형과 연결되는데, 보이지 않는 잠재변수 <span class="math inline">\(Y^{*} = X\beta + \varepsilon\)</span>를 가정하고, 오차항 <span class="math inline">\(\varepsilon\)</span>이 표준정규분포를 따른다고 할 때 Y=1일 확률이 <span class="math inline">\(\Phi(X\beta)\)</span>로 표현된다는 아이디어다. 프로빗 모형은 로짓과 형태가 거의 유사한 S자 곡선을 그리지만, 계수의 크기와 해석이 조금 다르다. 계수는 곧바로 오즈비로 해석하기는 어렵고, z-점수 단위의 변화량을 의미한다. 따라서 실제 보고에서는 한계효과를 계산해 해석하는 경우가 많다. 프로빗은 특히 경제학, 계량경제학 분야에서 널리 쓰이며, 효용모형이나 선택모형처럼 정규분포 오차가 자연스럽게 가정되는 상황에서 많이 활용된다.</p>
<p><strong>콤플리멘터리 로그–로그(link: cloglog)</strong></p>
<p>로짓이나 프로빗과 달리 비대칭적인 S자 곡선을 만든다. 정의는 <span class="math inline">\(g(p) = \log( - \log(1 - p))\)</span>이며, 역변환을 하면 <span class="math inline">\(p = 1 - \exp( - \exp(\eta))\)</span>의 형태를 갖는다. 이 함수는 특히 확률이 0에 가까운 영역에서 변화가 천천히 일어나다가 일정 시점 이후 급격히 1에 가까워지는 모양을 보인다. 따라서 희귀사건이나 불균형 데이터에서 사건 발생 확률을 모형화할 때 적합하다. 또한 이산 시간 생존모형서도 널리 쓰이는데, 이 경우 cloglog 링크를 사용하면 회귀계수의 지수형태가 위험률과 직접적으로 연결되기 때문이다. 다만 계수를 바로 오즈비로 해석하기는 어렵고, 누적위험이나 한계확률 효과를 중심으로 해석해야 한다.</p>
<p>즉, 세 가지 연결함수는 모두 이진형 목표변수에 적용할 수 있지만, 데이터 특성과 해석 목적에 따라 선택이 달라진다. 로짓은 오즈비 해석이 직관적이라 가장 보편적으로 쓰이고, 프로빗은 정규분포 오차를 가정하는 선택모형 이론과 잘 어울리며, cloglog는 비대칭 확률 구조와 위험률 해석이 필요한 상황에서 빛을 발한다.</p>
<p><strong>3가지 방법의 장점</strong></p>
<p>로짓 함수는 이진형 목표변수를 다룰 때 가장 널리 사용되는 방법이다. 그 이유는 해석이 매우 직관적이기 때문이다. 회귀계수 \beta_j는 설명변수 X_j가 한 단위 증가할 때 오즈비(odds ratio)가 e^{\beta_j}배 변한다는 의미를 갖는다. 오즈비는 상대위험이나 사건 발생 가능성을 직관적으로 보여주기 때문에 의학, 사회과학, 정책분야 등에서 널리 채택된다. 또한 로짓은 이항분포의 **정준 연결함수(canonical link)**로서 수학적으로도 우수한 성질을 지니며, 최대우도추정(MLE)에서 안정적인 결과를 준다.</p>
<p>프로빗 함수의 장점은 이론적 기반에 있다. 확률을 표준정규분포의 누적분포함수(CDF)의 역함수로 변환하기 때문에, 잠재변수 모형(latent variable model)과 자연스럽게 연결된다. 설명변수가 잠재효용이나 심리적 임계값을 통해 결과에 영향을 준다고 생각할 때 프로빗은 합리적인 선택이 된다. 경제학의 이산선택모형이나 심리측정 연구에서 주로 사용되는 이유가 여기에 있다. 또한 로짓과 결과가 크게 다르지 않으면서, 정규분포 기반의 해석틀을 선호하는 분야에서는 이론적 정합성이 강한 장점으로 작용한다.</p>
<p>cloglog 함수의 장점은 비대칭성을 표현할 수 있다는 점이다. 로짓이나 프로빗은 모두 대칭적인 S자 곡선을 가지지만, cloglog는 낮은 확률 영역에서는 매우 천천히 증가하다가 어느 시점 이후 급격히 1에 가까워진다. 이런 특성은 희귀사건(rare events)이나 불균형 데이터에서 유리하다. 또한 이산 시간 생존분석(discrete-time survival analysis)에서 hazard function과 직접 연결되기 때문에, 사건 발생의 위험률을 해석하는 데 특히 적합하다. 따라서 의료 통계, 생존분석, 공학적 신뢰도 분석 등에서 강점을 가진다.</p>
<p>로짓, 프로빗, cloglog 세 가지 방법은 모두 이진형 목표변수를 설명할 수 있으며, 실제 분석 결과에서 예측확률 자체는 크게 다르지 않은 경우가 많다. 따라서 어떤 연결함수를 선택하느냐는 <span dir="rtl">”</span>데이터의 특성”과 <span dir="rtl">”</span>연구 맥락”에 달려 있다.</p>
<p>실제로 로짓은 오즈비 해석이 직관적이기 때문에 기본값처럼 사용된다. 연구자나 독자가 <span dir="rtl">”</span>위험이 몇 배 늘어난다”와 같은 해석을 선호한다면 로짓이 가장 설득력이 있다. 반면, 잠재효용이나 임계값 같은 개념을 강조하는 경제학적 분석에서는 프로빗이 더 자연스럽다. 또 사건이 희귀하거나 생존시간 분석처럼 위험률을 직접 다루는 맥락에서는 cloglog가 적합하다.</p>
<p>즉, 세 가지 방법의 선택은 절대적인 우열이 아니라 데이터의 구조와 연구 목적을 기준으로 판단해야 한다. 중요한 점은 연결함수의 차이에 매몰되기보다는, 설명변수와 목표변수의 관계를 충실히 모형화했는지, 그리고 결과를 어떻게 해석할 것인지가 더 본질적이라는 것이다.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"># η 값 범위</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>eta <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">400</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 로짓</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>logit_p <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> np.exp(<span class="op">-</span>eta))</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co"># 프로빗</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>probit_p <span class="op">=</span> norm.cdf(eta)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co"># cloglog</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>cloglog_p <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> np.exp(<span class="op">-</span>np.exp(eta))</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co"># 그래프</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">5</span>))</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>plt.plot(eta, logit_p, label<span class="op">=</span><span class="st">"Logit"</span>, color<span class="op">=</span><span class="st">"blue"</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>plt.plot(eta, probit_p, label<span class="op">=</span><span class="st">"Probit"</span>, color<span class="op">=</span><span class="st">"green"</span>, linestyle<span class="op">=</span><span class="st">"--"</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>plt.plot(eta, cloglog_p, label<span class="op">=</span><span class="st">"Cloglog"</span>, color<span class="op">=</span><span class="st">"red"</span>, linestyle<span class="op">=</span><span class="st">"-."</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="co"># 기준선</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">"gray"</span>, linestyle<span class="op">=</span><span class="st">":"</span>)</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>plt.axhline(<span class="fl">0.5</span>, color<span class="op">=</span><span class="st">"gray"</span>, linestyle<span class="op">=</span><span class="st">":"</span>)</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Logit vs Probit vs Cloglog"</span>)</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Linear predictor η"</span>)</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Predicted probability"</span>)</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/로짓_프로빗.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
</section>
<section id="오즈비" class="level4">
<h4 class="anchored" data-anchor-id="오즈비"><span style="color:blue"> 3. 오즈비</span></h4>
<p>오즈비(odds ratio)는 두 가지 사건의 발생 확률을 비교하는 통계적 지표로, 주로 의학 연구나 사회과학 연구에서 두 집단 간의 관계를 평가할 때 사용됩니다. 오즈비는 특정 사건이 한 집단에서 발생할 오즈(odds)와 다른 집단에서 발생할 오즈의 비율을 의미한다.</p>
<p>예를 들어, 특정 약물이 질병을 예방하는지 평가하는 연구에서 다음과 같은 결과를 얻었다고 가정합시다:</p>
<ul>
<li><p>(a) 약물을 복용한 그룹 (노출 있음)에서 질병이 발생한 사람 수: 20명</p></li>
<li><p>(b) 약물을 복용한 그룹 (노출 있음)에서 질병이 발생하지 않은 사람 수: 80명</p></li>
<li><p>(c) 약물을 복용하지 않은 그룹 (노출 없음)에서 질병이 발생한 사람 수: 30명</p></li>
<li><p>(d) 약물을 복용하지 않은 그룹 (노출 없음)에서 질병이 발생하지 않은 사람 수: 70명</p></li>
<li><p>오즈비 : <span class="math inline">\(\frac{ad}{bc} = 0.5833\)</span></p></li>
<li><p>오즈비가 1보다 작으면 노출된 그룹이 노출되지 않은 그룹보다 사건 발생 확률이 낮다는 것을 의미하고, 오즈비가 1보다 크면 그 반대를 의미합니다. 위의 예시에서 오즈비가 0.5833이므로, 약물을 복용한 그룹이 질병에 걸릴 확률이 약물을 복용하지 않은 그룹보다 낮다고 해석할 수 있습니다.</p></li>
</ul>
</section>
<section id="추정" class="level4">
<h4 class="anchored" data-anchor-id="추정"><span style="color:blue"> 4. 추정</span></h4>
<p>앞에서 설명하였듯이 모수 <span class="math inline">\(b\)</span>의 추정량은 MLE 방법, N_R 방법으로 추정한다. 종속변수의 관측치는 (0, 1)의 이진형 값이나 추정 회귀계수에 의해 계산된 적합치는 (0, 1) 사이의 확률 값이다. 다음 예제는 약물 사용량에 따라 무당벌레 죽는 여부를 측정한 자료이다. 65마리 무당벌레에 1.69 용량을 살포했을 때 6마리는 죽고 나머지 59마리는 생존하였다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/로지스틱_이항분포_추정.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:60.0%"></p>
</figure>
</div>
<p><span class="math inline">\(logit(\pi_{i}) = log(\frac{\pi_{i}}{1 - \pi_{i}}) = a + b(Dose) + e\)</span>, <span class="math inline">\(\pi_{i} = P(Success|Dose = x_{i})\)</span></p>
<ul>
<li><p>오즈비 <span class="math inline">\(\frac{\pi}{1 - \pi}\)</span> : Dose=X 1단위 증가하면 오즈비는 <span class="math inline">\(e^{b}\)</span>만큼 증가한다.</p></li>
<li><p>모수 모형 : <span class="math inline">\(\pi = \frac{1}{1 - exp(a + b(Dose))}\)</span>, 회귀계수의 부호가 양수이고 값이 커지면 (성공: <span class="math inline">\(\pi_{i}\)</span> , event)가 커지므로 성공 확률이 높아지고 부호가 음수=&gt; 절대값이 커지면 <span class="math inline">\(\pi_{i}\)</span> 가 작아지므로 성공 확률이 낮아진다.</p></li>
</ul>
<p><strong>로지스틱 모형</strong></p>
<p><span class="math inline">\(logit(\pi) = ln\frac{\pi}{1 - \pi} = X\underset{¯}{b} + \underset{¯}{e},\underset{¯}{e} \sim N(\underset{¯}{0},\sigma^{2}I)\)</span>, <span class="math inline">\(\pi = P(Y = 1)\)</span></p>
<p><span class="math display">\[P(y_{i} = 1) = \pi_{i} = \frac{1}{1 + exp( - \alpha - \beta_{1}x_{1i} - ... - \beta_{p}x_{pi})} + e_{i}\]</span></p>
<ul>
<li><p>목표변수 : (목표변수=1(관심사건 발생)) 확률이므로 적합값은 사후확률이다.</p></li>
<li><p>오차 가정 : <span class="math inline">\(e_{i} \sim N(0,\sigma^{2})\)</span> (정규성, 독립성, 등분산성)</p></li>
<li><p>추정방법은 OLS 방법을 적용한다.</p></li>
</ul>
<p><strong>모형평가</strong></p>
<p>혼동 행렬(Confusion Matrix)은 분류 모델의 성능을 평가할 때 사용되는 도구입니다. 혼동 행렬은 실제 값과 모델의 예측 값 간의 비교를 통해 모델의 예측 성능을 시각적으로 표현한다.</p>
<p>질병 진단에서 질병이 없는 사람이 대부분인 경우, 정확도만으로 모델의 성능을 평가하는 것은 적절하지 않을 수 있습니다. 이 경우 정밀도, 재현율, F1 스코어 등의 지표를 함께 고려하는 것이 중요합니다.</p>
<ul>
<li><p>True Positive (TP, 진양성): 실제로 성공(양성)인 샘플을 성공으로 정확하게 예측한 경우의 수.</p></li>
<li><p>True Negative (TN, 진음성): 실제로 실패(음성)인 샘플을 성공으로 정확하게 예측한 경우의 수.</p></li>
<li><p>False Positive (FP, 위양성): 실제로 실패인 샘플을 성공으로 잘못 예측한 경우의 수. 흔히 Type I Error(1형 오류)라고 합니다.</p></li>
<li><p>False Negative (FN, 위음성): 실제로 성공인 샘플을 실패으로 잘못 예측한 경우의 수. 흔히 Type II Error(2형 오류)라고 합니다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">실제. 예측-&gt;</th>
<th style="text-align: center;">성공</th>
<th style="text-align: center;">실패</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">성공</td>
<td style="text-align: center;">TP</td>
<td style="text-align: center;">FP</td>
</tr>
<tr class="even">
<td style="text-align: center;">실패</td>
<td style="text-align: center;">FN</td>
<td style="text-align: center;">TN</td>
</tr>
</tbody>
</table></li>
<li><p>정확도 accuracy 전체 예측 중 맞은 비율 <span class="math inline">\(\frac{TP + TN}{TP + TN + FP + FN}\)</span>: 전체 예측 중에서 맞게 분류한 비율을 말한다. 즉, 모델이 전체 데이터에서 얼마나 많이 정답을 맞췄는지를 보여주는 가장 직관적인 지표이다. 하지만 정확도는 데이터가 불균형할 때(예: 사망자가 훨씬 많고 생존자가 적은 경우) 실제 성능을 과대평가할 수 있다는 한계가 있다.</p></li>
<li><p>정밀도 precison 양성 예측 중 실제 양성의 비율 <span class="math inline">\(\frac{TP}{TP + FP}\)</span>: 정밀도는 모델이 <span dir="rtl">”</span>양성(생존)“이라고 예측한 것 중에서 실제로 양성인 비율을 의미한다. 즉, 생존이라고 판정한 사람 중에서 실제로 생존한 사람의 비율이다. 정밀도가 높다는 것은 <span dir="rtl">”</span>거짓 양성”을 줄였다는 의미로, 잘못된 긍정을 피하는 데 강점이 있다.</p></li>
<li><p>재현율 recall 실제 양성 중 양성으로 예측한 비율 (TPRate) <span class="math inline">\(\frac{TP}{TP + FN}\)</span> 민감도 sensitivity 라 한다. 재현율은 실제 양성 중에서 모델이 양성으로 제대로 맞춘 비율을 말한다. 즉, 실제 생존자 중에서 모델이 생존으로 판정한 비율이다. 재현율이 높다는 것은 <span dir="rtl">”</span>거짓 음성(False Negative)“을 줄였다는 의미로, 놓치는 사례가 적다는 뜻이다. 특히 의료 진단처럼 놓치면 안 되는 문제에서 중요하다.</p></li>
<li><p>특이도 specificity 실제 음성 중 음성으로 예측한 비율 <span class="math inline">\(\frac{TN}{TN + FP}\)</span>: 특이도는 실제 음성(negative)인 대상 중에서 모델이 음성으로 올바르게 분류한 비율을 말한다. 즉, 사망자 중 사망이라고 맞춘 비율을 의미한다. 특이도가 높을수록, 모델이 실제 음성을 잘 걸러낸다는 의미다.</p></li>
<li><p>F1 스코어 : <span class="math inline">\(F1 = \frac{2 \times Precision \times Recall}{Precision + Recall}\)</span> 정밀도와 재현율의 조화 평균이다. F1은 Precision과 Recall 중 하나가 낮으면 값도 낮아지므로, 두 지표 사이의 균형을 평가하는 데 적합하다. 불균형 데이터 상황에서 Accuracy보다 훨씬 의미 있는 지표가 된다.</p></li>
</ul>
</section>
</section>
<section id="chapter-3.-로지스틱-회귀-사례분석" class="level3">
<h3 class="anchored" data-anchor-id="chapter-3.-로지스틱-회귀-사례분석"><span style="color:green">chapter 3. 로지스틱 회귀 사례분석</span></h3>
<section id="타니타닉-데이터" class="level4">
<h4 class="anchored" data-anchor-id="타니타닉-데이터"><span style="color:blue"> 1. 타니타닉 데이터</span></h4>
<ul>
<li><p>목표변수 : survived(생존=1, 사망=0)</p></li>
<li><p>측정형 예측변수 : 나이 age, 요금 fare, 동반 탑승한 형제자매, 배우자수 aibsp, 탑승한 부모자녀 수 parch</p></li>
<li><p>범주형 예측변수 : 성별 sex(이진형), 출항항구 embarked_town</p></li>
<li><p>(제외) 탑승권 등급 pclass, 객실등급 class는 요금과 상관계수가 높아 제외하였음</p></li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. 데이터 불러오기</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co"># seaborn 패키지에 내장된 타이타닉 데이터셋 불러오기</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>titanic <span class="op">=</span> sns.load_dataset(<span class="st">'titanic'</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 데이터 구조 확인</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co"># - 변수명, 자료형, 결측치 개수 등을 출력</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>titanic.info()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>pclass: 탑승권 등급, 1(upper), 2(middle), 3(lower)<br>
survived: 생존여부, 1=생존, 0=사망 •name: 탑승자 이름<br>
sex: 성별, male/female<br>
age: 탑승자 나이<br>
sibsp: 동반 탑승한 형제자매, 배우자 수 •parch: 탑승한 부모자녀 수<br>
fare: 탑승권 지불요금<br>
embarked_town: 출항항구, C = Cherbourg, Q=Queenstown, S=Southampton<br>
class : 객실등급 first, second, third<br>
adult_male : 성인남자 여부<br>
deck : 'C', 'E', 'G', 'D', 'A', 'B', 'F'<br>
alive: 생존여부<br>
alone : 혼자 탑승여부</p>
</section>
<section id="데이터-전처리" class="level4">
<h4 class="anchored" data-anchor-id="데이터-전처리"><span style="color:blue"> 2. 데이터 전처리</span></h4>
<p>범주형 변수를 이진형(0, 1) 변수로 만들어 측정형으로 만든다. 성별의 수준이 2개이므로 1개 이진형 변수(male 변수, 1=남자, 0=여자), 출발항구는 3곳이므로 2개 이진형 변수(Queenstown=0, Southampton=0이면 Cherbough 출항 승객)를 만들었다.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. 데이터 전처리</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co"># (1) 성별(sex) 변수 → 더미(dummy) 변수 변환</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co"># get_dummies(): 범주형 변수를 0/1 더미변수로 변환</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co"># drop_first=True → 기준 범주('female')를 제거하고 'male'만 생성</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co"># astype(int) → True/False를 1/0 정수형으로 변환</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>titanic[<span class="st">'male'</span>] <span class="op">=</span> pd.get_dummies(titanic[<span class="st">'sex'</span>], drop_first<span class="op">=</span><span class="va">True</span>).astype(<span class="bu">int</span>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co"># (2) 출항항구(embark_town) 변수 → 더미(dummy) 변수 변환</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="co"># embark_town 범주는 ['Cherbourg', 'Queenstown', 'Southampton']</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co"># drop_first=True → 기준 범주 'Cherbourg' 제거</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co"># 결과적으로 'Queenstown', 'Southampton' 두 개의 더미변수 생성</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>titanic[[<span class="st">'Queenstown'</span>, <span class="st">'Southampton'</span>]] <span class="op">=</span> pd.get_dummies(</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    titanic[<span class="st">'embark_town'</span>], drop_first<span class="op">=</span><span class="va">True</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>).astype(<span class="bu">int</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="모형-추정" class="level4">
<h4 class="anchored" data-anchor-id="모형-추정"><span style="color:blue"> 3. 모형 추정</span></h4>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. 로지스틱 회귀모형 추정</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 사용할 변수 지정</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="bu">vars</span> <span class="op">=</span> [<span class="st">'survived'</span>, <span class="st">'age'</span>, <span class="st">'sibsp'</span>, <span class="st">'parch'</span>, <span class="st">'fare'</span>, <span class="st">'male'</span>, <span class="st">'Queenstown'</span>, <span class="st">'Southampton'</span>]</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 결측치 제거</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>titanic_clean <span class="op">=</span> titanic[<span class="bu">vars</span>].dropna()</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co"># y와 X 재정의</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> titanic_clean[<span class="st">'survived'</span>]</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> titanic_clean[[<span class="st">'age'</span>, <span class="st">'sibsp'</span>, <span class="st">'parch'</span>, <span class="st">'fare'</span>, <span class="st">'male'</span>, <span class="st">'Queenstown'</span>, <span class="st">'Southampton'</span>]]</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> sm.add_constant(X)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="co"># 로지스틱 회귀 적합 및 출력</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>logit_model <span class="op">=</span> sm.Logit(y, X)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> logit_model.fit()</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result.summary2())</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/로지스틱_추정결과.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
<p>1. 모형 적합도 요약</p>
<ul>
<li><p>Pseudo R² = 0.288 → 설명력이 나쁘지 않은 수준 (의학·사회 데이터에서는 0.2~0.4도 꽤 괜찮음).</p></li>
<li><p>LLR p-value ≈ 3.9e-56 → 모형 전체가 유의함.</p></li>
</ul>
<p>2. 회귀계수 부호 해석</p>
<ul>
<li><p>age (-0.0214, p&lt;0.01): 나이가 많을수록 생존 확률이 감소한다. 즉, 나이 1살 증가 시 생존 오즈가 감소한다.</p></li>
<li><p>sibsp (-0.3911, p&lt;0.01): 동반한 형제자매·배우자 수가 많을수록 생존 확률이 낮다. 탑승 인원이 많으면 생존 가능성이 떨어지는 경향.</p></li>
<li><p>parch (-0.2167, p=0.067): 부모·자녀 동반 인원은 음(-)의 계수를 가지지만, 유의수준 5%에서는 통계적으로 유의하지 않다.</p></li>
<li><p>fare (0.0151, p&lt;0.001): 운임이 비쌀수록 생존 확률이 증가한다. 높은 요금은 객실 위치·구조 등과 연결될 가능성이 큼.</p></li>
<li><p>male (-2.5626, p&lt;0.001): 남성일수록 생존 확률이 크게 감소한다. 여성의 생존율이 높았다는 역사적 사실과 일치한다.</p></li>
<li><p>Queenstown (-1.3843, p&lt;0.05): 출항항구가 Queenstown일 경우, 기준(Cherbourg)보다 생존 확률이 낮다.</p></li>
<li><p>Southampton (-0.5943, p&lt;0.05): Southampton 출항자 역시 Cherbourg 대비 생존 확률이 낮음.</p></li>
</ul>
</section>
<section id="오즈비-1" class="level4">
<h4 class="anchored" data-anchor-id="오즈비-1"><span style="color:blue"> 4. 오즈비</span></h4>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 추정 오즈비 출력</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>odds_ratios <span class="op">=</span> np.exp(result.params)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(odds_ratios)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>const 8.432476 <br> age 0.978865 <br> sibsp 0.676346 <br> parch 0.805146 <br> fare 1.015252 <br> male 0.077106 <br> Queenstown 0.250506 <br> Southampton 0.551975</p>
<p>오즈비는 통제집단 대비 처리집단의 성공 가능성으로 1보다 높으면 처리집단이 높다는 것이다.</p>
<ul>
<li><p>age (0.98): 나이가 한 살 많을수록 생존 오즈가 약 2% 감소한다.</p></li>
<li><p>sibsp (0.68): 동반한 형제·자매·배우자가 1명 늘어나면 생존 오즈가 약 32% 감소한다.</p></li>
<li><p>parch (0.81): 부모·자녀 동반 인원이 많을수록 생존 오즈가 감소하지만, 통계적으로는 뚜렷하지 않음.</p></li>
<li><p>fare (1.02): 운임이 1 단위(파운드) 증가할 때 생존 오즈가 약 2% 증가한다.</p></li>
<li><p>male (0.08): 남성의 생존 오즈는 여성의 약 8%에 불과하다. (즉, 여성의 생존 확률이 훨씬 높음)</p></li>
<li><p>Queenstown (0.25): Queenstown에서 탑승한 승객은 Cherbourg 승객에 비해 생존 오즈가 75% 낮다.</p></li>
<li><p>Southampton (0.55): Southampton 탑승자는 Cherbourg 대비 생존 오즈가 약 45% 낮다.</p></li>
</ul>
</section>
<section id="모형-정확도-confusion-행렬" class="level4">
<h4 class="anchored" data-anchor-id="모형-정확도-confusion-행렬"><span style="color:blue"> 5. 모형 정확도 Confusion 행렬 </span></h4>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> confusion_matrix, classification_report</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. 예측확률 추출</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>y_pred_prob <span class="op">=</span> result.predict(X)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. 임계값 0.5 기준으로 분류 (생존=1, 사망=0)</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>y_pred <span class="op">=</span> (y_pred_prob <span class="op">&gt;=</span> <span class="fl">0.5</span>).astype(<span class="bu">int</span>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. 혼동행렬 생성</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>cm <span class="op">=</span> confusion_matrix(y, y_pred)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Confusion Matrix:"</span>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(cm)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="co"># 4. 추가로 정밀도/재현율/정확도 보고서 출력</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Classification Report:"</span>)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(classification_report(y, y_pred, digits<span class="op">=</span><span class="dv">3</span>))</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Confusion Matrix: <br> [[363 61] <br> [ 93 197]]</p>
<p>TN (363): 실제 사망(0), 예측도 사망(0) → 맞춘 경우 <br> FP (61): 실제 사망(0), 예측은 생존(1) → 잘못 예측 <br> FN (93): 실제 생존(1), 예측은 사망(0) → 잘못 예측 <br> TP (197): 실제 생존(1), 예측도 생존(1) → 맞춘 경우</p>
<p>즉, 모델은 사망자 424명 중 363명을 맞췄고, 생존자 290명 중 197명을 정분류하였다.</p>
<p>Classification Report: <br> precision recall f1-score support <br> 0 0.796 0.856 0.825 424 <br> 1 0.764 0.679 0.719 290 <br> accuracy 0.784 714 <br> macro avg 0.780 0.768 0.772 714 <br> weighted avg 0.783 0.784 0.782 714</p>
<p>Accuracy (정확도) = 0.784 (78.4%): 전체 예측의 약 78%가 맞았다. Titanic 데이터라는 복잡한 실제 사례에서는 꽤 준수한 성능이다.</p>
<p>Precision (정밀도): 사망(0): 0.796 → <span dir="rtl">”</span>사망이라고 예측한 사람 중 약 79.6%가 실제 사망”, 생존(1): 0.764 → <span dir="rtl">”</span>생존이라고 예측한 사람 중 약 76.4%가 실제 생존”</p>
<p>Recall (재현율): 사망(0): 0.856 → <span dir="rtl">”</span>실제 사망자 중 85.6%를 모델이 사망으로 잘 맞춤”, 생존(1): 0.679 → <span dir="rtl">”</span>실제 생존자 중 67.9%만 모델이 생존으로 맞춤” → 즉, 사망자 예측은 잘 하지만, 생존자를 놓치는 경우가 많다는 의미.</p>
<p>F1-score (정밀도와 재현율의 조화 평균): 사망(0): 0.825, 생존(1): 0.719, 생존자 쪽에서 다소 낮다.</p>
<p>모델은 사망자 분류에 더 강하다 (recall=0.856). 하지만 생존자 분류는 약하다 (recall=0.679). 즉, 실제 생존자를 <span dir="rtl">”</span>사망”으로 오판하는 경우(FN=93)가 적지 않다. Titanic 데이터의 역사적 사실(여성·아이 생존율 ↑, 남성·3등석 생존율 ↓)을 반영했지만, 단순 변수만으로는 생존자를 완전히 잘 구분하긴 어렵다. 전체 정확도는 78% 수준으로, 단순히 <span dir="rtl">”</span>다 사망했다고 예측하는 trivial model”보다 훨씬 낫다.</p>
</section>
<section id="roc-커브" class="level4">
<h4 class="anchored" data-anchor-id="roc-커브"><span style="color:blue"> 6. ROC 커브 </span></h4>
<p>ROC (Receiver Operating Characteristic) 커브는 이진 분류 문제에서 모델의 성능을 평가하는 그래프입니다. 이 커브는 y-축 민감도(TPR)와 x-축 (1-특이도=FPR)을 다양한 임계값(threshold)에서 계산하여 나타낸 그래프이다. ROC 커브 해석은 다음과 같다.</p>
<ul>
<li><p>커브의 좌상단에 가까울수록 좋은 모델: 민감도 높고 (1-특이도) 낮음.</p></li>
<li><p>대각선 (랜덤 분류기): (0, 0)에서 (1, 1)로 가는 대각선은 랜덤 추측을 의미합니다. 모델의 성능이 이 대각선에 가까울수록 무작위 추측과 다를 바 없습니다.</p></li>
</ul>
<p>AUC (Area Under the Curve): ROC 곡선 아래의 면적을 의미하며, 모델의 분류 능력을 종합적으로 평가하는 지표입니다. AUC 값은 0.5에서 1 사이의 값을 가집니다.</p>
<ul>
<li><p>AUC = 0.5: 랜덤 추측</p></li>
<li><p>AUC = 1: 완벽한 분류기</p></li>
<li><p>AUC &gt; 0.8: 좋은 분류기</p></li>
<li><p>AUC &lt; 0.5: 모델이 오히려 역으로 예측하고 있음</p></li>
</ul>
<p><strong>Youden’s J score</strong></p>
<p>ROC 커브에서 최적의 임계값(threshold)을 결정하는 데 사용하는 지표 중 하나입니다. 이 지표는 분류 모델의 성능을 평가할 때 민감도(sensitivity)와 특이도(specificity)를 동시에 고려합니다.</p>
<p>Youden's J score = 민감도 + 특이도 -1</p>
<p>Youden's J score는 -1에서 1 사이의 값을 가지며, 1에 가까울수록 모델의 성능이 좋다는 것을 의미합니다. 0일 경우에는 무작위 추측(random guessing)과 동일한 성능을 나타냅니다. Youden's J score의 해석은 다음과 같다.</p>
<ul>
<li><p>J = 1: 완벽한 분류기 (모든 양성 샘플을 정확히 양성으로, 모든 음성 샘플을 정확히 음성으로 분류함)</p></li>
<li><p>J = 0: 모델이 무작위로 추측하는 것과 동일한 성능</p></li>
<li><p>J &lt; 0: 모델이 오히려 반대로 예측하고 있음</p></li>
</ul>
<p>Youden's J score를 사용하여 최적의 임계값 찾기 : 모델의 예측 결과를 기반으로 다양한 임계값에 대해 TPR과 FPR을 계산하고, 각 임계값에서의 Youden's J score를 구하여 최적의 임계값을 찾을 수 있습니다. 이는 Youden's J score가 최대가 되는 지점입니다.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co"># ROC Curve &amp; AUC (for statsmodels Logit result)</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> roc_curve, roc_auc_score, confusion_matrix, classification_report</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 1) 예측확률</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>y_prob <span class="op">=</span> result.predict(X)      <span class="co"># P(Y=1|X)</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>y_true <span class="op">=</span> y.values <span class="cf">if</span> <span class="bu">hasattr</span>(y, <span class="st">"values"</span>) <span class="cf">else</span> y  <span class="co"># 정답 벡터</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 2) ROC 좌표와 AUC</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>fpr, tpr, thresholds <span class="op">=</span> roc_curve(y_true, y_prob)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>auc <span class="op">=</span> roc_auc_score(y_true, y_prob)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"AUC = </span><span class="sc">{</span>auc<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="co"># 3) ROC 그리기</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>,<span class="dv">5</span>))</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>plt.plot(fpr, tpr, lw<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="ss">f"ROC (AUC = </span><span class="sc">{</span>auc<span class="sc">:.3f}</span><span class="ss">)"</span>)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>plt.plot([<span class="dv">0</span>,<span class="dv">1</span>], [<span class="dv">0</span>,<span class="dv">1</span>], linestyle<span class="op">=</span><span class="st">"--"</span>, color<span class="op">=</span><span class="st">"gray"</span>, label<span class="op">=</span><span class="st">"Random guess"</span>)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>,<span class="dv">1</span>)<span class="op">;</span> plt.ylim(<span class="dv">0</span>,<span class="dv">1</span>)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"False Positive Rate (1 - Specificity)"</span>)</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"True Positive Rate (Sensitivity / Recall)"</span>)</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"ROC Curve"</span>)</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>plt.legend(loc<span class="op">=</span><span class="st">"lower right"</span>)</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a><span class="co"># 4) (선택) 최적 임계값 선택: Youden's J = TPR - FPR 최대화</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>youden_idx <span class="op">=</span> np.argmax(tpr <span class="op">-</span> fpr)</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>best_thresh <span class="op">=</span> thresholds[youden_idx]</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Best threshold by Youden's J = </span><span class="sc">{</span>best_thresh<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a><span class="co"># 5) (선택) 해당 임계값으로 성능 요약</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>y_pred_best <span class="op">=</span> (y_prob <span class="op">&gt;=</span> best_thresh).astype(<span class="bu">int</span>)</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>cm <span class="op">=</span> confusion_matrix(y_true, y_pred_best)</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Confusion matrix at best threshold:</span><span class="ch">\n</span><span class="st">"</span>, cm)</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Classification report at best threshold:"</span>)</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(classification_report(y_true, y_pred_best, digits<span class="op">=</span><span class="dv">3</span>))</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/로지스틱_ROC커브.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
<p>Best threshold by Youden's J = 0.287</p>
<p>Confusion matrix at best threshold:</p>
<p>[[333 91] <br> [ 65 225]]</p>
<p>Classification report at best threshold: <br> precision recall f1-score support <br> 0 0.837 0.785 0.810 424 <br> 1 0.712 0.776 0.743 290 <br> accuracy 0.782 714 <br> macro avg 0.774 0.781 0.776 714 <br> weighted avg 0.786 0.782 0.783 714</p>
<p>성공 예측 기준값을 0.5 사용 대신 0.287을 사용하면</p>
<p>Accuracy (정확도): 0.5 기준: 0.784, 0.287 기준: 0.782 → 전체 정확도는 거의 차이가 없음.</p>
<p>Precision (정밀도, class=1): 0.5 기준: 0.764, 0.287 기준: 0.712</p>
<p>→ 생존자라고 예측했을 때 실제 생존일 확률은 조금 낮아짐.</p>
<p>Recall (재현율, class=1): 0.5 기준: 0.679, 0.287 기준: 0.776 → 실제 생존자를 잡아내는 비율이 크게 향상됨.</p>
<p>F1-score (class=1): 0.5 기준: 0.719, 0.287 기준: 0.743 → 정밀도와 재현율의 균형 지표가 좋아짐.</p>
<p>임계값을 0.5로 두는 경우는 다소 보수적인 기준이다. 이때 모델은 <span dir="rtl">”</span>생존”이라고 판단하기보다는 <span dir="rtl">”</span>사망” 쪽으로 예측하는 경향이 강하다. 그 결과, 실제 생존자임에도 불구하고 사망으로 분류되는 사례가 많아져 재현율(Recall)이 낮아진다. 그러나 일단 <span dir="rtl">”</span>생존”이라고 예측한 경우에는 실제로 생존일 가능성이 높아 정밀도(Precision)는 상대적으로 좋아진다. 즉, 잘못된 긍정(False Positive)을 줄이는 데 강점이 있는 방식이다.</p>
<p>반대로 ROC 분석에서 제시된 Youden<span dir="rtl">’</span>s J 최적 임계값(약 0.287)을 적용한 경우, 모델은 더 많은 사람을 <span dir="rtl">”</span>생존”으로 분류한다. 이로 인해 생존자를 놓치는 경우(False Negative)가 줄어들어 재현율이 크게 향상된다. 다만, <span dir="rtl">”</span>생존”이라고 예측했지만 실제로는 사망인 경우가 늘어나므로 정밀도는 다소 떨어진다. 즉, 실제 생존자를 더 많이 잡아내는 대신, 예측의 순도는 조금 희생하는 결과가 된다.</p>
<p>정리하면, 임계값 0.5는 정밀도를 중시하는 보수적 접근이고, 임계값 0.287은 재현율을 중시하여 놓치는 생존자를 줄이는 접근이라고 할 수 있다.</p>
</section>
</section>
<section id="chapter-4.-다중-로짓-회귀" class="level3">
<h3 class="anchored" data-anchor-id="chapter-4.-다중-로짓-회귀"><span style="color:green">chapter 4. 다중 로짓 회귀</span></h3>
<section id="개념-1" class="level5">
<h5 class="anchored" data-anchor-id="개념-1">(1) 개념</h5>
<p>다중 로짓모형은 종속변수가 세 개 이상의 범주(명목형)를 가질 때 사용하는 확장된 로지스틱 회귀모형이다. 이항 로지스틱은 <span dir="rtl">”</span>예/아니오(0/1)” 두 가지 경우만 다루나 다중 로짓은 <span dir="rtl">”</span>A, B, C”처럼 세 가지 이상 범주를 동시에 다룬다. 각 범주에 속할 확률을 추정하며, 특정 범주를 기준(baseline)으로 두고 나머지 범주와의 상대적 오즈를 추정한다.</p>
</section>
<section id="모형-구조-및-해석" class="level5">
<h5 class="anchored" data-anchor-id="모형-구조-및-해석">(2) 모형 구조 및 해석</h5>
<p>예를 들어, 종속변수 Y가 K개의 범주를 가진다고 하자. 범주 k에 속할 확률은 <span class="math inline">\(P(Y = k|X) = \frac{\exp(X\beta_{k})}{\sum_{j = 1}^{K}\exp(X\beta_{j})},k = 1,\ldots,K\)</span> 으로 정의된다.</p>
<p>보통 하나의 범주(예: K)를 기준범주로 두고, 해당 범주에 대한 계수는 <span class="math inline">\(\beta_{K} = 0\)</span>으로 고정한다. 따라서 나머지 범주의 계수들은 기준범주 대비 상대적 로그 오즈를 의미한다.</p>
<p>이항 로짓에서는 계수 <span class="math inline">\(\beta_{j}\)</span>가 <span dir="rtl">”</span>X_j가 1 증가할 때 오즈비가 <span class="math inline">\(e^{\beta_{j}}\)</span>배 변한다”라고 해석된다.</p>
<p>다중 로짓에서도 동일하게, 각 계수는 기준범주에 비해 특정 범주에 속할 상대적 오즈비로 해석된다. 따라서 해석은 <span dir="rtl">”</span>기준범주와의 비교”라는 점을 잊지 말아야 한다.</p>
<p><strong>다중 로짓모형과 이항 로지스틱 회귀의 반복</strong></p>
<p>명목형 목표변수가 세 개 이상의 범주를 가질 때 가장 정석적인 방법은 다중 로짓모형을 적용하는 것이다. 이 모형은 한 번에 모든 범주를 고려하여 각 선택지에 속할 확률을 추정할 수 있고, 기준범주 대비 상대적 오즈비 해석도 가능하다.</p>
<p>그러나 실제 연구에서는 다중 로짓모형 대신 이항 로지스틱 회귀를 여러 번 수행하는 방법이 종종 권장되기도 한다. 예를 들어, 목표변수가 세 가지 범주(A, B, C)라면, (A vs 나머지), (B vs 나머지), (C vs 나머지)처럼 이진화(binary coding) 해서 각각 로지스틱 회귀를 적합할 수 있다. 또는 연구의 목적에 따라 (A vs B), (A vs C), (B vs C)처럼 특정 두 범주만 비교하는 쌍대 비교(pairwise comparison) 로 나눌 수도 있다.</p>
<p>이 방식의 장점은 해석이 단순하고, <span dir="rtl">”</span>A 범주일 확률이 다른 모든 범주보다 얼마나 높은가?” 또는 <span dir="rtl">”</span>B와 C 중 어떤 요인이 차이를 만드는가?“와 같이 명확한 질문에 답할 수 있다는 점이다. 특히 표본수가 적거나 변수 구조가 단순한 경우에는 다중 로짓보다 반복된 이항 로지스틱 회귀가 오히려 안정적이고 직관적일 수 있다.</p>
<p>즉, 다중 로짓모형은 이론적으로 가장 일반화된 접근이지만, 연구 목적에 따라 이항 로지스틱을 여러 번 수행하는 방법이 더 권장될 수도 있다. 실제 분석에서는 <span dir="rtl">”</span>모든 범주를 한꺼번에 설명하는 것이 필요한가?” 아니면 <span dir="rtl">”</span>특정 범주 쌍의 비교가 더 의미 있는가?“라는 질문을 먼저 던지고, 그에 따라 적절한 모형을 선택하는 것이 바람직하다.</p>
</section>
<section id="사례-분석" class="level5">
<h5 class="anchored" data-anchor-id="사례-분석">(3) 사례 분석</h5>
<p>데이터명: Travel Mode Choice (modechoice) <br> 1987년 호주 동부 지역(시드니–캔버라–멜번 구간) <br> 비업무(non-business) 목적의 장거리(intercity) 여행 자료 <br> 표본 수: 210명 응답자 × 4가지 교통수단, 1 = Air (항공기), 2 = Train (기차), 3 = Bus (버스), 4 = Car (자가용)</p>
<p>대안 특성(alternative-specific variables) <br> ttme : terminal waiting time (분) — car = 0 <br> invc : monetary cost ($, 1987 AUD 기준) <br> invt : in-vehicle travel time (분) <br> gc : generalized cost = invc + (invt × 시간가치)</p>
<p>개인 특성(individual-specific variables) <br> hinc : household income (in $1,000s 단위) <br> psize: party size (동행 인원 수)</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. 라이브러리 불러오기</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. 데이터 로드</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Travel Mode Choice (modechoice) 데이터 불러오기</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> sm.datasets.modechoice.load_pandas().data</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="co"># choice == 1 인 행만 골라 개인별 선택 모드 확인</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>chosen <span class="op">=</span> data.loc[data[<span class="st">'choice'</span>] <span class="op">==</span> <span class="dv">1</span>, [<span class="st">'individual'</span>, <span class="st">'mode'</span>]].copy()</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="co"># 모드 숫자코드 → 라벨로 변환</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>mode_map <span class="op">=</span> {<span class="dv">1</span>: <span class="st">'air'</span>, <span class="dv">2</span>: <span class="st">'train'</span>, <span class="dv">3</span>: <span class="st">'bus'</span>, <span class="dv">4</span>: <span class="st">'car'</span>}</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>chosen[<span class="st">'mode'</span>] <span class="op">=</span> chosen[<span class="st">'mode'</span>].<span class="bu">map</span>(mode_map)</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="co"># 종속변수 y: 개인별 선택 모드</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> chosen.set_index(<span class="st">'individual'</span>)[<span class="st">'mode'</span>]</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. long → wide 변환 (대안특성)</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>tmp <span class="op">=</span> data.copy()</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>tmp[<span class="st">'mode'</span>] <span class="op">=</span> tmp[<span class="st">'mode'</span>].<span class="bu">map</span>(mode_map)</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a><span class="co"># 비용, 시간, 대기, 일반화 비용</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>wide_invc <span class="op">=</span> tmp.pivot(index<span class="op">=</span><span class="st">'individual'</span>, columns<span class="op">=</span><span class="st">'mode'</span>, values<span class="op">=</span><span class="st">'invc'</span>).add_prefix(<span class="st">'invc_'</span>)</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>wide_invt <span class="op">=</span> tmp.pivot(index<span class="op">=</span><span class="st">'individual'</span>, columns<span class="op">=</span><span class="st">'mode'</span>, values<span class="op">=</span><span class="st">'invt'</span>).add_prefix(<span class="st">'invt_'</span>)</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>wide_ttme <span class="op">=</span> tmp.pivot(index<span class="op">=</span><span class="st">'individual'</span>, columns<span class="op">=</span><span class="st">'mode'</span>, values<span class="op">=</span><span class="st">'ttme'</span>).add_prefix(<span class="st">'ttme_'</span>)</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>wide_gc   <span class="op">=</span> tmp.pivot(index<span class="op">=</span><span class="st">'individual'</span>, columns<span class="op">=</span><span class="st">'mode'</span>, values<span class="op">=</span><span class="st">'gc'</span>).add_prefix(<span class="st">'gc_'</span>)</span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a><span class="co"># 개인 특성 (소득, 동승자 수)</span></span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>indiv <span class="op">=</span> (tmp.drop_duplicates([<span class="st">'individual'</span>])</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>           .set_index(<span class="st">'individual'</span>)[[<span class="st">'hinc'</span>,<span class="st">'psize'</span>]])</span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a><span class="co"># 4. 기준대안(car) 대비 차이변수 생성 함수</span></span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> diff_vs_car(df, var):</span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""wide 포맷 df에서 기준(car) 대비 대안별 차이 변수 생성"""</span></span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>    cols <span class="op">=</span> [<span class="ss">f'</span><span class="sc">{</span>var<span class="sc">}</span><span class="ss">_air'</span>, <span class="ss">f'</span><span class="sc">{</span>var<span class="sc">}</span><span class="ss">_train'</span>, <span class="ss">f'</span><span class="sc">{</span>var<span class="sc">}</span><span class="ss">_bus'</span>, <span class="ss">f'</span><span class="sc">{</span>var<span class="sc">}</span><span class="ss">_car'</span>]</span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> df[cols]</span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span> pd.DataFrame(index<span class="op">=</span>w.index)</span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> a <span class="kw">in</span> [<span class="st">'air'</span>, <span class="st">'train'</span>, <span class="st">'bus'</span>]:   <span class="co"># car는 기준</span></span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a>        out[<span class="ss">f'</span><span class="sc">{</span>var<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>a<span class="sc">}</span><span class="ss">_minus_car'</span>] <span class="op">=</span> w[<span class="ss">f'</span><span class="sc">{</span>var<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>a<span class="sc">}</span><span class="ss">'</span>] <span class="op">-</span> w[<span class="ss">f'</span><span class="sc">{</span>var<span class="sc">}</span><span class="ss">_car'</span>]</span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out</span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a><span class="co"># 차이변수 생성 (여기서는 일반화비용 gc만 사용)</span></span>
<span id="cb9-53"><a href="#cb9-53" aria-hidden="true" tabindex="-1"></a>X_gc <span class="op">=</span> diff_vs_car(wide_gc, <span class="st">'gc'</span>)</span>
<span id="cb9-54"><a href="#cb9-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-55"><a href="#cb9-55" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb9-56"><a href="#cb9-56" aria-hidden="true" tabindex="-1"></a><span class="co"># 5. 설명변수 설계행렬 구성</span></span>
<span id="cb9-57"><a href="#cb9-57" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb9-58"><a href="#cb9-58" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> pd.concat([X_gc, indiv], axis<span class="op">=</span><span class="dv">1</span>).loc[y.index]</span>
<span id="cb9-59"><a href="#cb9-59" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> sm.add_constant(X, has_constant<span class="op">=</span><span class="st">'add'</span>)  <span class="co"># 상수항 추가</span></span>
<span id="cb9-60"><a href="#cb9-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-61"><a href="#cb9-61" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb9-62"><a href="#cb9-62" aria-hidden="true" tabindex="-1"></a><span class="co"># 6. 다중 로짓(MNLogit) 적합</span></span>
<span id="cb9-63"><a href="#cb9-63" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb9-64"><a href="#cb9-64" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> sm.MNLogit(y, X)</span>
<span id="cb9-65"><a href="#cb9-65" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> model.fit()</span>
<span id="cb9-66"><a href="#cb9-66" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(res.summary())</span>
<span id="cb9-67"><a href="#cb9-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-68"><a href="#cb9-68" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb9-69"><a href="#cb9-69" aria-hidden="true" tabindex="-1"></a><span class="co"># 7. 오즈비(odds ratio) 계산</span></span>
<span id="cb9-70"><a href="#cb9-70" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb9-71"><a href="#cb9-71" aria-hidden="true" tabindex="-1"></a>odds_ratio <span class="op">=</span> np.exp(res.params)</span>
<span id="cb9-72"><a href="#cb9-72" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">[Odds Ratios]</span><span class="ch">\n</span><span class="st">"</span>, odds_ratio)</span>
<span id="cb9-73"><a href="#cb9-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-74"><a href="#cb9-74" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb9-75"><a href="#cb9-75" aria-hidden="true" tabindex="-1"></a><span class="co"># 8. 예측확률 출력</span></span>
<span id="cb9-76"><a href="#cb9-76" aria-hidden="true" tabindex="-1"></a><span class="co"># ===============================</span></span>
<span id="cb9-77"><a href="#cb9-77" aria-hidden="true" tabindex="-1"></a>pred_prob <span class="op">=</span> res.predict(X)</span>
<span id="cb9-78"><a href="#cb9-78" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">[First 5 predicted probabilities]</span><span class="ch">\n</span><span class="st">"</span>, pred_prob.head())</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/다중로짓_추정결과.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
<p>[Odds Ratios] <br> 0 1 2</p>
<p>const 2.191713 0.895179 13.068463 <br> gc_air_minus_car 0.992664 0.961226 0.947739 <br> gc_train_minus_car 1.025245 0.980246 0.907682 <br> gc_bus_minus_car 0.946977 1.091743 1.133681 <br> hinc 0.952935 0.989719 0.960261 <br> psize 0.909128 0.842491 0.773353</p>
<p>[First 5 predicted probabilities] <br> 0 1 2 3</p>
<p>individual <br> 1.0 0.286019 0.024696 0.456432 0.232852 <br> 2.0 0.159306 0.020636 0.399126 0.420931 <br> 3.0 0.343931 0.061799 0.587268 0.007002 <br> 4.0 0.250099 0.002585 0.644929 0.102388 <br> 5.0 0.207010 0.054901 0.117606 0.620483</p>
<p>(1) 모형 적합도:</p>
<p>Pseudo R² = 0.3437 → 선택행동 데이터를 설명하는 데 상당히 괜찮은 수준. LLR p-value &lt; 0.001 → 모형 전체가 통계적으로 유의.</p>
<p>(2) 비용 차이 변수</p>
<p>gc_air_minus_car: car, train 모두 음수 &amp; 유의 → 항공의 일반화 비용이 커질수록 다른 수단(car, train)을 선택할 확률이 증가. 즉, 항공이 비싸질수록 항공보다 다른 수단 선호.</p>
<p>gc_train_minus_car: train 방정식에서 음수 &amp; 매우 유의 → 기차의 일반화 비용이 커지면 car 대비 기차 선택 확률이 줄어듦. bus/car 식에서는 방향성이 약하거나 유의성 낮음.</p>
<p>gc_bus_minus_car: bus와 train 방정식에서 양수 &amp; 유의 → 버스의 일반화 비용이 커질수록 car 대비 bus 선택 가능성이 줄고, car 선택 가능성이 커짐.</p>
<p>정리: 일반화 비용(gc)이 커질수록 해당 교통수단의 선택 확률이 줄어든다는 경제적 직관과 일치.</p>
<p>(3) 개인 특성</p>
<p>hinc (소득): car, train, bus 모두 음수 &amp; 유의 → 소득이 높을수록 car 대비 다른 교통수단 선택 확률이 줄어듦. 즉, 소득이 높을수록 항공을 선호한다는 해석 가능. (air가 baseline이므로 나머지 수단 대비 항공 선택 확률 증가로 읽을 수 있음)</p>
<p>psize (동행인원): 모든 방정식에서 음수지만, 통계적으로 유의하지 않음. 즉, 동승자 수는 교통수단 선택에 뚜렷한 영향을 주지 않음.</p>
<p>(4) 오즈비(odds ratios) 해석</p>
<ul>
<li><p>gc_air_minus_car: 오즈비 &lt; 1 → 항공비용이 커질수록 상대수단 선택 오즈 증가.</p></li>
<li><p>gc_train_minus_car (train eq.) ≈ 0.91: 기차의 일반화 비용이 1단위 증가할 때, car 대비 기차 선택 오즈가 약 9% 감소.</p></li>
<li><p>gc_bus_minus_car (bus eq.) ≈ 0.95: 버스의 일반화 비용이 1단위 증가하면, car 대비 버스 선택 오즈가 약 5% 감소.</p></li>
<li><p>hinc ≈ 0.95: 소득이 1000$ 증가할 때, car 대비 bus/train 선택 오즈가 약 5% 감소 → 소득이 높을수록 항공 선호.</p></li>
<li><p>psize &lt; 1 (0.77~0.91): 동승 인원 많을수록 car 대비 다른 교통수단 선택 오즈가 줄지만 통계적 유의성은 낮음.</p></li>
</ul>
<p>(5) 요약</p>
<p>대안특성 효과: 각 교통수단의 일반화 비용(gc)이 커질수록 해당 교통수단의 선택 확률은 감소. 경제학적으로 일관된 결과dlek.</p>
<p>개인특성 효과: 소득(hinc)이 높을수록 car·bus·train보다 항공 선택 가능성이 커짐. 동승자 수(psize)는 뚜렷한 영향 없ek</p>
<p>전체적 시사점: 교통수단 선택은 비용/시간 같은 대안특성이 주요 결정요인이고, 개인 특성 중에서는 소득이 강한 영향. 이는 <span dir="rtl">”</span>소득이 높을수록 빠른 교통수단(항공)을 선호한다”는 행동경제학적 직관과 부합한다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "복사완료!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "복사완료!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© 2025 Kwon</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>Built with Quarto</p>
</div>
  </div>
</footer>




</body></html>