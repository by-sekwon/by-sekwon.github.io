<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>lm_diagnosis – 세상의 모든 통계 이야기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">세상의 모든 통계 이야기</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">기초수학</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-">    
        <li>
    <a class="dropdown-item" href="../../notes/math/function.html">
 <span class="dropdown-text">함수</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math/derivate_integral.html">
 <span class="dropdown-text">미분적분</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math/vector.html">
 <span class="dropdown-text">벡터</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math/matrix.html">
 <span class="dropdown-text">행렬</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--1" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">수리통계</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--1">    
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/probability.html">
 <span class="dropdown-text">확률</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/random_variable.html">
 <span class="dropdown-text">확률변수</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/famous_distribution.html">
 <span class="dropdown-text">유명한분포</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/multi_variate.html">
 <span class="dropdown-text">다변량확률변수</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/random_sample.html">
 <span class="dropdown-text">확률표본_난수생성</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/estimation.html">
 <span class="dropdown-text">추정</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/hypothesis_testing.html">
 <span class="dropdown-text">가설검정_신뢰구간</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--2" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">조사방법론</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--2">    
        <li>
    <a class="dropdown-item" href="../../notes/survey/survey_intro.html">
 <span class="dropdown-text">조사방법 기초</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/sample_design.html">
 <span class="dropdown-text">표본설계</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/questionnaire.html">
 <span class="dropdown-text">설문지</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/nonresponse.html">
 <span class="dropdown-text">무응답 대체</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/data_process.html">
 <span class="dropdown-text">데이터 처리</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/survey_scale.html">
 <span class="dropdown-text">조사지 척도</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/delphi_ahp_conjoint.html">
 <span class="dropdown-text">델파이_AHP_컨조인트</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/psm.html">
 <span class="dropdown-text">PSM 성향점수매칭</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--3" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">일변량분석</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--3">    
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/concept_of_stat.html">
 <span class="dropdown-text">일변량분석 개념</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/data.html">
 <span class="dropdown-text">데이터와 통계</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/univariate.html">
 <span class="dropdown-text">일변량분석</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/crosstab.html">
 <span class="dropdown-text">교차표분석</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/goodness_of_fits.html">
 <span class="dropdown-text">적합성검정</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/normality.html">
 <span class="dropdown-text">정규변환</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/correlation.html">
 <span class="dropdown-text">상관분석</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/anova.html">
 <span class="dropdown-text">실험설계 분산분석</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/time_series.html">
 <span class="dropdown-text">시계열분석</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--4" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">회귀분석</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--4">    
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_concept.html">
 <span class="dropdown-text">개념&amp;추정</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_selection.html">
 <span class="dropdown-text">변수선택</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_multicolin.html">
 <span class="dropdown-text">다중공선성</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_diagnosis.html">
 <span class="dropdown-text">회귀진단</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_logistic.html">
 <span class="dropdown-text">로지스틱회귀</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../cardnews/index.html"> 
<span class="menu-text">|카드뉴스|</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../consult.html"> 
<span class="menu-text">|통계상담|</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--5" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">📡스트리밍</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--5">    
        <li>
    <a class="dropdown-item" href="https://by-sekwonappio-esqshnv7wueapp4da6jrizn.streamlit.app">
 <span class="dropdown-text">실시간주가[5대종목]</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://by-sekwonappio-k5e5n7wasvj3kveyqbwmgc.streamlit.app/">
 <span class="dropdown-text">대전유성구 일기예보</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<p>Chapter 1. 회귀진단</p>
<p>권세혁교수 통계 사전 【다중공선성】</p>
<p>s<a href="https://sites.google.com/view/wolfpack61"><u>https://sites.google.com/view/wolfpack61</u></a></p>
<p>1. 회귀진단이란?</p>
<p>회귀분석에서 모델을 한 번 적합했다고 해서 그 결과를 그대로 신뢰할 수는 없다. 추정된 회귀계수는 최소제곱법에 의해 잘 정의되지만, 실제 데이터에서는 여러 가지 문제가 숨어 있을 수 있다. 이러한 문제를 찾아내고 모델이 가정에 잘 부합하는지 점검하는 과정이 회귀진단(regression diagnostics)이다.</p>
<p>회귀진단의 출발점은 <span dir="rtl">”</span>이 모델이 데이터를 제대로 설명하고 있는가?“라는 질문이다. 그 답을 찾기 위해 크게 두 가지 축에서 생각한다. 첫째, 회귀모형의 가정 점검이다. 선형성, 오차항의 등분산성, 독립성, 정규성과 같은 기본 가정들이 지켜지지 않으면 추정량의 성질이나 검정의 신뢰성이 흔들리게 된다. 예를 들어 잔차(residuals)를 살펴보면 선형관계가 어긋나거나 특정 구간에서만 분산이 커지는 등분산 위배 패턴을 발견할 수 있다.</p>
<p>둘째, 이상점(outlier)과 영향점(influential point)의 탐색이다. 데이터 중 일부는 다른 점들과 지나치게 동떨어져 있거나, 회귀직선의 모양 자체를 크게 좌우하는 경우가 있다. 이러한 점들을 무시하면 추정치가 왜곡되므로, 잔차분석, 레버리지(leverage), 쿡의 거리(Cook<span dir="rtl">’</span>s distance)와 같은 진단통계량을 활용하여 확인한다.</p>
<p>요컨대 회귀진단은 단순히 결정계수(R²)나 유의확률만 보는 것이 아니라, 모델이 데이터의 구조를 얼마나 충실히 반영하고 있는지, 가정 위배나 특정 관측치의 왜곡이 없는지를 살펴보는 과정이다. 이러한 진단 과정을 거쳐야 회귀분석 결과를 자신 있게 해석하고 실무적 의사결정에 활용할 수 있다.</p>
<p>오차 가정 진단</p>
<p>회귀분석의 기본 전제는 오차항이 일정한 가정을 충족한다는 것이다. 이러한 가정이 성립하지 않으면 추정된 회귀계수나 검정 결과를 신뢰할 수 없게 된다. 따라서 회귀모형이 가정을 만족하는지 여부를 점검하는 과정이 필요하며, 이를 회귀진단(잔차분석)이라 한다.</p>
<p>선형성 가정은 회귀모형의 유의성 검정 결과와 직접적으로 연결되므로, 잔차분석에서는 주로 오차항에 대한 세 가지 가정을 점검한다. 즉, 정규성, 등분산성, 독립성이다. 이 가운데 독립성은 자료가 시계열 형태일 때 비로소 문제가 되므로, 일반 횡단면 자료에서는 정규성과 등분산성을 중점적으로 진단한다.</p>
<p>요컨대 잔차분석은 회귀모형이 통계적 가정을 위배하지 않고 안정적으로 추정되었는지를 검증하는 핵심 절차이다.</p>
<p>이상치, 영향치 진단</p>
<p>회귀모형은 데이터 전체의 경향성을 바탕으로 추정되기 때문에 일부 관측값이 지나치게 벗어나 있거나 모형을 과도하게 지배할 경우 추정 결과가 왜곡될 수 있다. 이러한 점을 이상치 또는 영향치라 하며, 회귀분석에서는 이들을 진단하는 과정이 반드시 필요하다.</p>
<p>이상치와 영향치 진단이 필요한 이유는 다음과 같다.</p>
<p>첫째, 모형의 정확성 보장이다. 이상치나 영향치를 방치하면 회귀계수 추정치가 왜곡되고, 그 결과 예측력과 설명력이 저하된다.</p>
<p>둘째, 모형의 신뢰성 확보이다. 극단적인 관측값은 추정계수를 편향시켜 통계적 검정 결과를 불안정하게 만들 수 있다.</p>
<p>셋째, 적합성 확인이다. 이상치와 영향치는 잔차의 분포를 왜곡하여 정규성이나 등분산성 가정을 위배하게 하고, 이는 곧 회귀모형의 부적합성을 시사한다.</p>
<p>넷째, 해석의 정확성 제고이다. 영향치는 회귀계수의 크기와 방향을 바꿀 수 있어, 이를 무시하면 계수 해석이 잘못될 수 있다.</p>
<p>다섯째, 데이터 품질 향상이다. 이상치와 영향치 탐지는 자료 수집이나 측정 과정에서 발생한 오류를 찾아내어 수정할 기회를 제공한다.</p>
<p>따라서 이상치와 영향치를 체계적으로 진단하고 적절히 처리하는 것은 회귀분석 결과의 타당성과 해석의 정확성을 높이는 핵심 과정이다.</p>
<p>2. 잔차분석</p>
<p>회귀모형 및 OLS 추정</p>
<p>회귀모형 <span class="math inline">\(y_{i} = \alpha + \overset{p}{\sum_{k = 1}}\beta_{k}x_{ki} + e_{i}\)</span> , <span class="math inline">\(e_{i} \sim N(0,\sigma^{2})\)</span> [행렬 표현] <span class="math inline">\(\underset{¯}{y} = X\underset{¯}{\beta} + \underset{¯}{e}\)</span>, <span class="math inline">\(\underset{¯}{e} \sim MN(\underset{¯}{0},\sigma^{2}I)\)</span></p>
<p>추정 (OLS) : <span class="math inline">\(\widehat{\underset{¯}{\beta}} = (X'X)^{- 1}X'\underset{¯}{y}\)</span></p>
<p>적합치 : <span class="math inline">\(\widehat{\underset{¯}{y}} = H\underset{¯}{y}\)</span>, <span class="math inline">\(H = X(X'X)^{- 1}X'\)</span>는 멱등행렬</p>
<p>잔차 정의</p>
<p><span class="math inline">\(\underset{¯}{r} = (I - H)\underset{¯}{y}\)</span>, <span class="math inline">\(r_{i} = y_{i} - {\widehat{y}}_{i}\)</span> : 잔차는 종속변수 관측치와 모형 적합치의 차이</p>
<p>회귀모형 오차항(<span class="math inline">\(e_{i}\)</span>)의 MVUE : <span class="math inline">\({\widehat{e}}_{i} = r_{i}\)</span></p>
<p>잔차성질</p>
<p>잔차의 평균은 <span class="math inline">\(E(r_{i}) = 0\)</span>이고 분산은 <span class="math inline">\(V(r_{i}) = \sigma^{2}\)</span>이다.</p>
<p>잔차는 서로 독립인가? 사실 오차는 독립을 가정하나 잔차는 독립이 아니다. 회귀계수 OLS추정에는 <span class="math inline">\((x_{i},y_{i})\)</span>모든 관측치가 포함되어 있기 때문이다.</p>
<p><span class="math inline">\(\sum x_{i}r_{i} = 0\)</span>: 예측변수와 잔차의 곱의 합은 0이다 - 설명변수와 잔차는 독립이다. 예측변수에 의해 설명되고 남은 부분(잔차)은 서로 독립이다.</p>
<p><span class="math inline">\(\sum{\widehat{y}}_{i}r_{i} = 0\)</span> : 적합치와 잔차의 곱의 합은 0이다. 적합치는 예측변수에 의해 설명된 부분과 설명되지 않은 잔차 부분은 서로 독립이다.</p>
<p>잔차분석이란</p>
<p>잔차분석은 회귀분석에서 오차항을 직접 관측할 수 없기 때문에, 그 추정치인 잔차(residual)를 활용하여 모형의 가정을 점검하는 과정이다. 잔차가 회귀모형의 기본 가정을 잘 따르고 있는지를 확인함으로써 추정 결과의 신뢰성과 해석의 타당성을 확보할 수 있다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image3.png" style="width:2.37613in;height:1.70811in" class="figure-img"></p>
<figcaption>pasted-image.pdf</figcaption>
</figure>
</div>
<p>잔차분석에서 확인하는 주요 사항은 다음과 같다.</p>
<p>첫째, 선형성이다. 설명변수와 종속변수의 관계가 선형이라면 잔차는 특정 패턴 없이 무작위로 분포해야 한다. 이는 회귀계수의 유의성 검정 결과와도 밀접하게 연결된다.</p>
<p>둘째, 등분산성이다. 설명변수의 값이 달라짐에 따라 잔차의 분산이 달라지지 않아야 한다. 즉, 잔차가 일정한 폭을 유지하며 퍼져 있어야 한다.</p>
<p>셋째, 독립성이다. 오차항이 서로 독립이라는 가정은 일반적인 횡단면 자료에서는 크게 문제되지 않지만, 시계열 자료에서는 반드시 확인해야 한다.</p>
<p>넷째, 정규성이다. 오차항이 정규분포를 따른다는 가정은 회귀계수에 대한 통계적 추론(검정과 신뢰구간)의 타당성을 보장한다. 잔차의 분포를 히스토그램이나 Q-Q 플롯으로 확인하여 검토한다.</p>
<p>다섯째, 이상치와 영향치의 존재 여부다. 표준화 잔차가 지나치게 크거나, 회귀선의 모양을 크게 바꾸는 영향점은 모형의 추정 결과를 왜곡시킬 수 있으므로 반드시 확인해야 한다.</p>
<p>여섯째, 누락 변수 가능성이다. 잔차가 특정한 패턴을 보인다면 이는 모형에 포함되지 않은 중요한 설명변수가 존재함을 시사한다. 이 경우 현실성이 떨어지는 모형이 될 수 있다.</p>
<p>결국 잔차분석은 단순히 모형의 적합도를 평가하는 단계를 넘어, 회귀모형이 기본 가정을 충족하는지 점검하고, 잠재적인 문제를 찾아내어 보완하는 핵심 절차이다.</p>
<p>3. 잔차 종류</p>
<p>표준화 standardized 잔차</p>
<p><span class="math inline">\(z_{i} = \frac{r_{i} - \overline{r}}{s(r_{i}) = \sqrt{MSE}}\)</span>, <span class="math inline">\(MSE = \widehat{\sigma^{2}}\)</span></p>
<p>표준화 잔차는 추정 회귀식으로부터 관측치가 얼마나 떨어져 있나를 나타내는 것으로 <span class="math inline">\(\pm 2\)</span> (표준정규분포의 경우 <span class="math inline">\(\pm 1.96\)</span> 구간 안에는 95% 관측치가 있음) 보다 크면 이상치일 가능성이 높다.</p>
<p>스튜던트 studentized 잔차</p>
<p><span class="math inline">\(st_{i} = \frac{r_{i}}{\sqrt{MSE/(1 - h_{ii})}}\)</span>, <span class="math inline">\(h_{ii} = {\underset{¯}{x}}_{i}'(X'X)^{- 1}{\underset{¯}{x}}_{i}\)</span></p>
<p>잔차를 t-분포를 따르는 통계량으로 만든 것으로 <span class="math inline">\(\pm 2\)</span>이면 이상치로 판단한다.</p>
<p><span class="math inline">\(h_{ii}\)</span> : <span class="math inline">\(H = X(X'X)^{- 1}X'\)</span> 행렬의 대각 원소로 leverage 레버리지(지렛대)로 정의되며 영향치 판단에 사용한다.</p>
<p>표준화/스튜던트 제외 standardized &amp; deleted 잔차</p>
<p><span class="math inline">\(z_{(i)} = \frac{r_{(i)} - \overline{r}}{\sqrt{MSE_{(i)}}}\)</span>, <span class="math inline">\(st_{(i)} = \frac{r_{(}i)}{\sqrt{MSE_{(i)}/(1 - h_{ii})}}\)</span></p>
<p><span class="math inline">\(i -\)</span>번째 관측치를 제외하고 회귀모형을 추정한 후 얻은 적합치를 사용하여 얻은 잔차로 표준화/스튜던트 잔차에 비해 더 정확한 개념의 잔차이지만 현실에서는 자주 사용하지 않는다.</p>
<p>4. 진단도구</p>
<p>잔차와 종속변수 추정치 산점도</p>
<p>잔차와 종속변수 추정치 산점도는 회귀모형의 타당성을 점검하는 가장 기본적인 도구이다. 이때 잔차를 Y축에 두고, 종속변수의 예측값(추정치)을 X축에 두어 산점도를 작성한다.</p>
<p>잔차는 추정된 회귀모형이 설명하지 못한 부분에 해당하므로, 이 산점도에는 어떠한 체계적인 패턴도 나타나지 않아야 한다. 즉, 잔차가 평균 0을 중심으로 무작위로 흩어져 있는 형태가 바람직하다. 만약 특정 곡선 형태나 일정한 방향성을 띠는 패턴이 나타난다면, 이는 선형성 가정의 위배나 누락된 설명변수의 존재를 시사한다.</p>
<p>또한 예측값이 커지거나 작아짐에 따라 잔차의 분산이 달라지는 모습이 관찰된다면, 이는 등분산성 가정의 위배를 의미한다. 따라서 잔차 산점도를 통해 선형성과 등분산성을 동시에 진단할 수 있다.</p>
<p>아울러 잔차가 지나치게 크게 나타나는 점은 다른 점들과 동떨어진 이상치(outlier)일 가능성이 있으며, 이러한 점들은 회귀계수 추정치와 모형의 안정성을 심각하게 왜곡할 수 있다.</p>
<p>결국 잔차–추정치 산점도는 회귀모형의 기본 가정(선형성, 등분산성) 진단뿐 아니라, 이상치 탐지에도 중요한 역할을 하는 핵심 도구이다.</p>
<p>잔차(Y-축)와 시간(time, X-축)의 시간도표(time plot)</p>
<p>시계열 데이터에만 국한된다.</p>
<p>잔차 활용</p>
<p>회귀분석에서 오차항 자체는 관측할 수 없으므로, 그 추정치인 잔차를 활용하여 모형의 타당성을 점검하게 된다. 잔차는 종속변수의 실제값과 회귀모형이 추정한 예측값의 차이로 정의되며, 이 값 속에는 모형이 설명하지 못한 변동이 담겨 있다. 따라서 잔차를 체계적으로 살펴보면 회귀모형이 기본적으로 전제한 오차항의 가정이 충족되는지, 그리고 개별 관측치가 모형에 과도한 영향을 주고 있지는 않은지를 확인할 수 있다.</p>
<p>구체적으로는 잔차의 분포와 패턴을 분석하여 정규성, 등분산성, 독립성과 같은 오차항의 가정을 진단한다. 예를 들어 잔차가 무작위로 흩어져 있으면 선형성과 등분산성이 충족되었다고 볼 수 있고, 잔차의 분포가 종 모양을 띠면 정규성이 유지된 것으로 해석할 수 있다.</p>
<p>아울러 잔차의 크기와 분포를 살펴보면 이상치나 영향치를 식별할 수 있다. 잔차가 지나치게 크거나 특정 관측치가 회귀직선의 기울기와 절편을 크게 좌우한다면, 이는 모형의 안정성과 해석의 신뢰성을 저해하는 요인으로 작용한다.</p>
<p>결국 잔차분석은 단순히 회귀모형의 적합도를 평가하는 수준을 넘어, 오차항의 가정 점검과 이상치 진단을 동시에 수행하는 핵심 절차이며, 회귀분석 결과를 신뢰할 수 있도록 보장하는 중요한 단계이다.</p>
<p>*) 잔차의 정규성 검정에 대해서는 상반된 견해가 존재한다. 한쪽에서는 잔차가 종속변수의 평균에 기반하여 계산되므로, 표본의 크기가 충분히 크면 중심극한정리에 따라 정규분포에 근사한다고 본다. 따라서 일반적으로 표본이 30개 이상인 경우에는 정규성 위배가 분석 결과에 큰 영향을 주지 않으며, 이때는 굳이 정규성 검정을 수행하지 않아도 된다는 입장이다.</p>
<p>5. 회귀진단 절차 및 최종 추정모형</p>
<p>회귀모형 추정 및 잔차 산점도</p>
<p>데이터에 설정된 회귀모형이 완전하다면 (목표변수 관측값- 추정 모형에 의해 적합된 값) 차이인 잔차에는 어떤 패턴도 있어서는 안된다. 즉 백색잡음, 정규분포를 따라야 한다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td><p># ==============================================</p>
<p># 최종 회귀모형 추정 : adjust 결정계수 최대</p>
<p># ==============================================</p>
<p>import itertools</p>
<p>import pandas as pd</p>
<p>import numpy as np</p>
<p>import statsmodels.api as sm</p>
<p>from sklearn.datasets import fetch_openml</p>
<p># 1. 데이터 불러오기</p>
<p>boston = fetch_openml(name="boston", version=1, as_frame=True)</p>
<p>df = boston.frame.copy()</p></td>
</tr>
</tbody>
</table>
<p>Best Model (Adjusted R² 기준):</p>
<p>변수: ('CHAS', 'NOX', 'RM', 'DIS', 'PTRATIO', 'B', 'LSTAT')</p>
<p>Adj R²: 0.7182560407158507</p>
<p>예측변수 DIS 상관계수 부호와 회귀계수 부호</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td><p># --- 4) 최종 모형 적합 ---</p>
<p>selected = ['CHAS', 'NOX', 'RM', 'PTRATIO', 'B', 'LSTAT'] # 선택된 변수 리스트</p>
<p>X_final = sm.add_constant(X[selected], has_constant='add') # 정제된 X 사용</p>
<p>final_model = sm.OLS(y, X_final).fit()</p>
<p>print(final_model.summary())</p></td>
</tr>
</tbody>
</table>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image4.png" style="width:4.5in;height:3.77974in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<p>[2] VIF (모든 변수)</p>
<p>variable VIF</p>
<p>5 LSTAT 2.453</p>
<p>2 RM 1.698</p>
<p>1 NOX 1.664</p>
<p>4 B 1.242</p>
<p>3 PTRATIO 1.216</p>
<p>0 CHAS 1.045</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td><p>import seaborn as sns</p>
<p>import matplotlib.pyplot as plt</p>
<p># 1. 잔차 계산</p>
<p>residuals = final_model.resid_pearson</p>
<p>fitted = final_model.fittedvalues</p>
<p># 2. 잔차, 예측 산점도</p>
<p>sns.residplot(x=fitted, y=residuals, lowess=True, line_kws={'color': 'red', 'lw': 1})</p>
<p>plt.title('scatter plot of (yhat vs standard_res)')</p>
<p>plt.axhline(2)</p>
<p>plt.axhline(-2)</p>
<p>plt.show()</p></td>
</tr>
</tbody>
</table>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image5.png" style="width:4.5in;height:3.58517in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<p>곡선 패턴 존재</p>
<p>잔차가 단순히 무작위로 흩어진 것이 아니라, 예측값이 작을 때와 클 때 잔차가 양수 방향으로 커지고, 중간값에서는 음수 쪽으로 몰려 있으므로 빨간 곡선(스무딩 선)이 U자형을 그리는 모습이 선형성 가정이 무너졌음을 보여준다. → 선형성 가정 위배</p>
<p>잔차 분산의 불균일</p>
<p>예측값이 커질수록 잔차의 분산이 조금 더 커지는 경향이 보이므로 이는 등분산성 위배(이분산성)의 가능성을 시사한다.</p>
<p>극단적인 점들</p>
<p>y축 <span dir="rtl">±</span>2를 넘는 점들이 상당히 보이고, 특히 위쪽으로 튀는 점들이 다수 있으므로 이는 이상치 또는 영향치일 가능성이 크다.</p>
<p>선형성 검정</p>
<p>회귀분석에서 가장 먼저 확인해야 할 사항은 선형성 가정이다. 즉, 종속변수와 설명변수 간의 함수관계가 선형(직선)으로 표현될 수 있어야 한다는 것이다. 이는 선형 회귀모형의 기본 전제 조건이다.</p>
<p>실제 분석에서는 회귀모형을 추정하기 전에 종속변수와 각 설명변수 간의 산점도를 통해 선형성 여부를 사전 점검하고, 필요하다면 적절한 변환을 통해 문제를 해결한다. 이후 회귀모형의 유의성 검정을 거치면, 일반적으로 선형성 가정은 만족하는 것으로 판단할 수 있다. 따라서 기본적인 회귀분석에서는 별도의 선형성 검정 절차가 필수적이지 않다.</p>
<p>그러나 설명변수 간의 관계가 복잡하게 얽혀 있거나, 함수형태의 잘못된 특정화 가능성이 우려될 경우에는 보다 엄밀한 통합적 선형성 검정 방법을 적용할 필요가 있다. 대표적으로 Harvey와 Collier(1977)가 제안한 Functional Form Misspecification Test가 있으며, Johnston(1984)에서도 이 방법이 소개되어 있다.</p>
<p>Harvey A. and Collier P. (1977);&nbsp;Testing for Functional Misspecification in Regression Analysis, Journal of Econometrics 6, 103--119. Johnston, J. (1984);&nbsp;Econometric Methods, Third Edition, McGraw Hill Inc.</p>
<ul>
<li><p>귀무가설 : 목표변수와 예측변수들 간에는 선형성이 존재한다.</p></li>
<li><p>대립가설 : 목표변수와 예측변수들 간에는 선형성이 존재하지 않는다.</p></li>
</ul>
<p>본 연구에서는 목표변수와 설명변수 간의 상관계수가 매우 유의하게 나타났으며, 이는 곧 선형 함수관계가 존재함을 의미한다. 따라서 선형성 가정은 충족되었고, 앞서 언급한 것처럼 굳이 별도의 검정을 수행할 필요는 없다는 결론에 도달한다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td><p># 선형성 검정</p>
<p>from statsmodels.stats.diagnostic import linear_harvey_collier</p>
<p>t_stat, p_val = linear_harvey_collier(final_model)</p>
<p>print(f"[Harvey–Collier] t = {t_stat:.3f}, p-value = {p_val:.4g}")</p>
<p># 해석: p-value &lt; 0.05 이면 선형성 가정이 유의하게 깨졌다고 본다.</p></td>
</tr>
</tbody>
</table>
<p>linear_harvey_collier 오류는 초기 부분표본이 특이(singular) 해서 생긴다. 해결은 두 가지다:</p>
<p>1. 초기 표본 크기 skip를 충분히 크게 잡고,</p>
<p>2. 초기에 변동이 충분히 들어오도록 표본 순서를 order_by로 재배열한다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td><p>from statsmodels.stats.diagnostic import linear_reset</p>
<p># Ramsey RESET (비선형성/함수형 잘못특정)</p>
<p>reset_res = linear_reset(final_model, power=2, use_f=True)</p>
<p>print("[RESET test]")</p>
<p>print(f"F-statistic = {reset_res.fvalue:.3f}")</p>
<p>print(f"p-value = {reset_res.pvalue:.4g}")</p></td>
</tr>
</tbody>
</table>
<p>[RESET test]</p>
<p>F-statistic = 183.651</p>
<p>p-value = 7.741e-36</p>
<p>p-value 사실상 0에 가까우므로 귀무가설(회귀모형은 선형으로 잘 특정되었다)**는 기각된다. 즉, 현재 추정한 선형회귀모형은 종속변수와 예측변수 간의 관계를 제대로 설명하지 못하고 있으며, 비선형성이나 누락된 변수가 존재할 가능성이 매우 높다는 의미한다.</p>
<ul>
<li><p>비선형항(예: RM², LSTAT²)이나 변수 변환(로그, 제곱근 등)을 도입해 모델을 개선해야 한다.</p></li>
<li><p>또는 상호작용항 추가, 더 나아가 비선형 모형(GAM, 트리기반 모형)을 고려할 필요가 있다.</p>
<p>정규성</p></li>
</ul>
<p>회귀분석에서 오차항이 정규분포를 따른다는 가정은 매우 중요한 전제이다. 이 가정이 충족되어야만 모형 전체의 유의성을 검정하는 분산분석 F-검정과 개별 예측변수의 유의성을 검정하는 t-검정이 타당하게 적용될 수 있다.</p>
<p>오차항은 직접 관측할 수 없으므로, 그 추정치인 잔차를 이용하여 정규성을 검정한다. 따라서 잔차의 정규성 검정은 곧 오차항의 정규성 가정을 점검하는 절차이다.</p>
<ul>
<li><p>귀무가설 : 데이터는 정규분포를 따른다.</p></li>
<li><p>대립가설 : 정규분포를 따르지 않는다.</p></li>
</ul>
<p>잔차가 정규성을 만족한다면 회귀분석에서의 추론이 통계적으로 타당하다고 볼 수 있으며, 정규성이 위배될 경우에는 비모수적 방법, 변수변환, 또는 강건추정 방법을 고려해야 한다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>#오차의 정규성 검정</p>
<p>from scipy.stats import shapiro, jarque_bera</p>
<p># Shapiro–Wilk</p>
<p>stat, p = shapiro(residuals)</p>
<p>print(f"Shapiro–Wilk W={stat:.3f}, p={p:.4g}")</p>
<p># Jarque–Bera</p>
<p>jb_stat, jb_p = jarque_bera(residuals)</p>
<p>print(f"Jarque–Bera JB={jb_stat:.3f}, p={jb_p:.4g}")</p></td>
</tr>
</tbody>
</table>
<p>Shapiro–Wilk W=0.873, p=6.84e-20</p>
<p>Jarque–Bera JB=1187.536, p=1.348e-258</p>
<p>등분산 가정</p>
<p>잔차와 예측치 산점도가 다음과 같이 나팔 fan 모양일 때 등분산 가정이 무너진다. 종속변수의 값에 의존하여 분산이 커지거나 작아짐 - 등분산 가정이 무너지면 분산이 큰 부분에서 종속변수의 값이 적합선을 많이 벗어난 것이 적합 정도가 떨어진다고 결론 내릴 수 없음, 이는 분산이 다르므로 이상치가 발생할 수 있기 때문이다.<img src="media/image6.png" style="width:4.30301in;height:1.22509in" alt="pastedGraphic.pdf"></p>
<ul>
<li><p>귀무가설 : 잔차는 등분산성을 갖는다.</p></li>
<li><p>대립가설 : 잔차는 등분산성을 갖지 않는다.</p></li>
</ul>
<p>Breush-Pagan test</p>
<p>Gujarati, Damodar N.; Porter, Dawn C. (2009).&nbsp;Basic Econometrics&nbsp;(Fifth ed.). New York: McGraw-Hill Irwin. pp.&nbsp;385–86.</p>
<p>Goldfeld-Quandt test</p>
<p>Goldfeld, Stephen M.; Quandt, R. E. (June 1965). "Some Tests for Homoscedasticity".&nbsp;Journal of the American Statistical Association.&nbsp;60&nbsp;(310): 539–547.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 101%">
</colgroup>
<tbody>
<tr class="odd">
<td><p># 등분산 가정 검정 패키지</p>
<p>from statsmodels.stats.diagnostic import het_breuschpagan, het_white, het_goldfeldquandt</p>
<p>from statsmodels.nonparametric.smoothers_lowess import lowess</p>
<p>import numpy as np</p>
<p>import pandas as pd</p>
<p>import matplotlib.pyplot as plt</p>
<p>import seaborn as sns</p>
<p># ---------------------------------------</p>
<p># 0) 준비: 잔차(피어슨), 적합값</p>
<p># ---------------------------------------</p>
<p>resid = final_model.resid_pearson # 표준화 잔차(피어슨)</p>
<p>fitted = final_model.fittedvalues</p>
<p>exog = final_model.model.exog # 상수 포함 X 행렬</p>
<p>endog = final_model.model.endog # y</p></td>
</tr>
</tbody>
</table>
<p>[Breusch–Pagan]</p>
<p>LM stat = 27.371, LM p = 0.0001234</p>
<p>F stat = 4.756, F p = 9.984e-05</p>
<p>[White]</p>
<p>LM stat = 182.805, LM p = 1.644e-25</p>
<p>F stat = 10.420, F p = 1.309e-32</p>
<p>[Goldfeld–Quandt]</p>
<p>F stat = 1.229, df = two-sided, p = 0.1068</p>
<p>BP, White는 <span dir="rtl">”</span>이분산 있음” 쪽으로 강한 신호.</p>
<p>GQ는 <span dir="rtl">”</span>등분산 vs 이분산”에서 결정적 증거를 못 줌.</p>
<p>보통 White가 가장 포괄적이라, 결과적으로는 이 모형의 잔차는 등분산 가정을 만족하지 않는다라고 보는 게 타당합니다.</p>
<p>1. 강건표준오차(robust standard errors, HC3)로 계수 검정 보정 → 추론 왜곡 방지.</p>
<p>2. WLS(가중최소제곱): 분산구조를 모형화(예: fitted에 비례, 특정 변수의 역수).</p>
<p>3. 변수변환: y나 문제되는 X에 로그/제곱근 변환 고려.</p>
<p>4. 모형 재특정: 누락된 변수·비선형 항이 없는지 점검.</p>
<p>OLS대신 WLS 가중최소자승법 사용</p>
<p><span class="math inline">\(min_{\alpha,\beta_{1},...,\beta_{p}}\sum w_{i}(y_{i} - \alpha - \overset{p}{\sum_{k = 1}}\beta_{k}x_{ki})^{2}\)</span>을 최소화 하는 추정치를 가중최소추정량이라 한다. 가중치 <span class="math inline">\(w_{i} = \frac{1}{{\widehat{y}}_{i}^{2}}\)</span>을 사용한다.</p>
<p>잔차는 등분산 가정이 무너져 WLS 추정 결과 결정계수 55%로 떨어졌고 예측변수 RM는 유의하지 않고 회귀계수 부호와 상관계수 부호가 일치하지 않는다. 등분산 검정 결과 등분산성이 여전히 만족되지 않는다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td><p>import statsmodels.api as sm</p>
<p>import numpy as np</p>
<p># --- 1) 적합값 기반 가중치 ---</p>
<p># 잔차 크기와 fitted 관계를 보고, 분산이 fitted^2에 비례한다고 가정</p>
<p>weights = 1 / (final_model.fittedvalues**2)</p>
<p>X_final = sm.add_constant(X[selected], has_constant='add')</p>
<p>wls_model = sm.WLS(y, X_final, weights=weights).fit()</p>
<p>print("\n[WLS: fitted값 기반 가중치]")</p>
<p>print(wls_model.summary())</p></td>
</tr>
</tbody>
</table>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image7.png" style="width:4.5in;height:2.73739in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td><p>from statsmodels.stats.diagnostic import het_breuschpagan, het_white</p>
<p># --- WLS 잔차 (weighted residuals) ---</p>
<p>resid_wls = wls_model.resid</p>
<p>exog_wls = wls_model.model.exog # 설명변수 행렬</p>
<p># --- Breusch–Pagan test ---</p>
<p>bp_lm, bp_lm_p, bp_f, bp_f_p = het_breuschpagan(resid_wls, exog_wls)</p>
<p>print("\n[WLS Breusch–Pagan]")</p>
<p>print(f"LM stat = {bp_lm:.3f}, p = {bp_lm_p:.4g}")</p>
<p>print(f"F stat = {bp_f:.3f}, p = {bp_f_p:.4g}")</p>
<p># --- White test ---</p>
<p>w_lm, w_lm_p, w_f, w_f_p = het_white(resid_wls, exog_wls)</p>
<p>print("\n[WLS White]")</p>
<p>print(f"LM stat = {w_lm:.3f}, p = {w_lm_p:.4g}")</p>
<p>print(f"F stat = {w_f:.3f}, p = {w_f_p:.4g}")</p></td>
</tr>
</tbody>
</table>
<p>[WLS Breusch–Pagan]</p>
<p>LM stat = 102.675, p = 6.938e-20</p>
<p>F stat = 21.172, p = 3.565e-22</p>
<p>[WLS White]</p>
<p>LM stat = 252.399, p = 5.857e-39</p>
<p>F stat = 18.336, p = 3.614e-56</p>
<p>독립성</p>
<p>개념</p>
<p>시계열 데이터의 경우 오차항이 전 차항의 오차들에 의해 영향을 받게 되면 오차의 독립성이 파괴된다. 오차항 독립이 아니면 종속변수에 설정된 설명변수가 설명하지 못하는 일정의 패턴이 존재하므로 회귀추정이 불완전하게 된다.</p>
<p>진단도구</p>
<p>Durbin Watson 퉁계량 <img src="media/image8.png" style="width:1.88889in;height:0.53223in" alt="pastedGraphic.pdf"></p>
<p>DW 검정통계량의 값은 <span class="math inline">\(2(1 - r)\)</span>에 근사한다. 상관계수 <span class="math inline">\(r\)</span>은 <span class="math inline">\((e_{t},e_{t - 1})\)</span>의 상관계수 (&lt;=&gt; 오차의 1차 자기상관계수)이다.</p>
<p>오차가 독립(자기상관이 존재하지 않음)이면 <span class="math inline">\(r = 0\)</span>이고 <span class="math inline">\(DW = 2\)</span>에 근사한다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image9.png" style="width:4.49986in;height:1.12277in" class="figure-img"></p>
<figcaption>1__#$!@%!#__pastedGraphic.pdf</figcaption>
</figure>
</div>
<p>positive autocorrelation (양의 상관관계)</p>
<ul>
<li><p>If <span class="math inline">\(DW &lt; D_{L}\)</span> , 양의 상관관계가 존재한다.</p></li>
<li><p>If <span class="math inline">\(DW &gt; D_{U}\)</span>, 자기상관이 존재하지 않는다. 독립이다.</p></li>
<li><p>If <span class="math inline">\(D_{L} &lt; DW &lt; D_{U}\)</span>, 결론 내릴 수 없음</p></li>
</ul>
<p>negative autocorrelation (음의 상관관계) the test statistic (4&nbsp;−&nbsp;d)</p>
<ul>
<li><p>If <span class="math inline">\(DW &gt; 4 - D_{L}\)</span>, 음의 상관관계가 존재한다.</p></li>
<li><p>If <span class="math inline">\(DW &lt; 4 - D_{U}\)</span>, 자기상관이 존재하지 않는다. 독립이다.</p></li>
<li><p>If <span class="math inline">\(4 - d_{u} &lt; DW &lt; 4 - d_{L}\)</span>, 결론 내릴 수 없음</p></li>
</ul>
<p>해결책</p>
<p>목표변수의 1차 전기 항<span class="math inline">\((y_{t - 1})\)</span>을 예측변수로 사용하거나 종속변수의 차분항(<span class="math inline">\(\bigtriangledown Y_{t} = (Y_{t} - Y_{t - 1})\)</span>)을 목표변수로 사용한다.</p>
<p>sm.OLS, sm.WLS 실행하면 DW(Durbin Watson) 자동 출력된다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image10.png" style="width:4.5in;height:1.47309in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<p>오차 가정 만족하지 않은 회귀모형 이유 파악</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>#잔차분석 관련 모든 그래프</p>
<p>import matplotlib.pyplot as plt</p>
<p># 잔차</p>
<p>residuals = final_model.resid</p>
<p># 선택된 변수들</p>
<p>selected = ['CHAS', 'NOX', 'RM', 'PTRATIO', 'B', 'LSTAT']</p>
<p># 그리기</p>
<p>fig, axes = plt.subplots(2, 3, figsize=(15, 8))</p>
<p>axes = axes.flatten()</p>
<p>for i, var in enumerate(selected):</p>
<p>axes[i].scatter(X[var], residuals, alpha=0.7)</p>
<p>axes[i].axhline(y=0, color="red", linestyle="--", linewidth=1)</p>
<p>axes[i].set_xlabel(var)</p>
<p>axes[i].set_ylabel("Residuals")</p>
<p>axes[i].set_title(f"{var} vs Residuals")</p>
<p>plt.suptitle("scatter plot of (yhat vs standard_res)", fontsize=14)</p>
<p>plt.tight_layout()</p>
<p>plt.show()</p></td>
</tr>
</tbody>
</table>
<p>RM, LSTA 예측변수가 이분산 형태를 가지므로 잔차의 등분산 가정이 무너졌다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image11.png" style="width:4.5in;height:2.38449in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<p>이상치 &amp; 영향치<img src="media/image12.png" style="width:3.40278in;height:1.68328in" alt="pasted-image.pdf"></p>
<p>이상치와 영향치는 회귀분석에서 반드시 구분해야 하는 개념이다.</p>
<p>이상치(outlier)는 설명변수의 관측값은 정상 범위 내에 있으나 반응변수 값이 회귀선에서 크게 벗어난 점이다. 이상치는 잔차가 크므로 회귀모형의 적합 정도를 떨어뜨리고, 결정계수를 낮추는 원인이 된다. 데이터 입력 오류로 발생한 이상치는 제거하는 것이 옳고, 실제 값인 경우에는 robust 회귀와 같은 방법으로 영향을 줄일 수 있다.</p>
<p>영향치(influential point)는 설명변수 값 자체가 다른 관측치와 동떨어져 분포 범위를 벗어난 점이다. 이러한 점은 레버리지가 높아 회귀선을 강하게 끌어당긴다. 표면적으로는 회귀선에 잘 붙어 있어 잔차가 크지 않을 수 있으나, 실제로는 회귀계수와 결정계수를 왜곡시킨다. 그 결과 모형이 잘 맞는 것처럼 보이게 만들며, 회귀계수의 유의성이 과대평가되는 문제가 발생한다. 영향치는 주변에 표본을 추가로 수집하거나 해당 관측치를 제외한 후 모형을 다시 적합하는 방식으로 대처할 수 있다.</p>
<p>따라서 이상치는 반응변수의 문제이고, 영향치는 설명변수의 문제이다. 이 둘을 구분하여 진단하고 적절히 처리하는 것이 회귀모형 분석의 핵심이다.</p>
<p>이상치 진단도구</p>
<ul>
<li><p>원 변수 산점도, 잔차-적합치 산점도에서 시각적 판단</p></li>
<li><p>표준화 잔차: <span class="math inline">\(r_{i} = \frac{e_{i}}{\widehat{\sigma}\sqrt{1 - h_{ii}}}\)</span>, 여기서 <span class="math inline">\(e_{i} = y_{i} - {\widehat{y}}_{i}\)</span>는 잔차, <span class="math inline">\({\widehat{\sigma}}^{2} = MSE\)</span>, <span class="math inline">\(h_{ii}\)</span>는 hat matrix <span class="math inline">\(H = X(X'X)^{- 1}X'\)</span>의 대각원소, 레버리지이다. 단순 잔차를 표준오차로 나눈 값으로, 서로 다른 관측치 간 비교가 가능하다. <span class="math inline">\(\pm 2\)</span>이상이면 이상치이다.</p></li>
<li><p>스튜던트 잔차: <span class="math inline">\(t_{i} = \frac{e_{i}}{\widehat{\sigma}(i)\sqrt{1 - hii}}\)</span>, <span class="math inline">\(\widehat{\sigma}{(i)}^{2} = \frac{\sum j \neq ie_{j}^{2}}{n - p - 1}\)</span>는 <span class="math inline">\(i\)</span>번째 관측치를 제외하고 추정한 오차분산이다.표준화 잔차와 비슷하지만, 특정 관측치를 제거하고 분산을 다시 계산하기 때문에 해당 점의 영향력을 더 정확히 반영한다. <span class="math inline">\(t_{i}\)</span>는 근사적으로 자유도 <span class="math inline">\(n - p - 1\)</span>인 <span class="math inline">\(t\)</span>-분포를 따른다.</p></li>
</ul>
<p>영향치 판단도구</p>
<ul>
<li><p>레버러지 <span class="math inline">\(h_{ii} = x_{i}'(X'X)^{- 1}x_{i}\)</span>: <span class="math inline">\(i\)</span>번째 예측변수 벡터(관측값)가 전체 회귀모형 적합에 얼마나 영향을 주는지 나타내는 값이다. <span class="math inline">\(0 \leq h_{ii} \leq 1\)</span>, 평균값은 <span class="math inline">\(\overline{h} = \frac{p + 1}{n}\)</span>( p: 예측변수 개수, n: 표본 수 )이고 <span class="math inline">\(h_{ii} &gt; 2\overline{h}\)</span>이면 높은 레버리지 점으로 본다.</p></li>
<li><p>DFFITS(Difference in Fits) <span class="math inline">\(DFBETAS_{ij} = \frac{{\widehat{\beta}}_{j} - {\widehat{\beta}}_{j(i)}}{SE({\widehat{\beta}}_{j})}\)</span>: 관측치 i를 제거했을 때 회귀계수 <span class="math inline">\(\beta_{j}\)</span>가 얼마나 변하는지 표준오차 단위로 측정한다. <span class="math inline">\(|DFBETAS_{ij}| &gt; \frac{2}{\sqrt{n}}\)</span>이면 변수 j의 추정치에 큰 영향을 미친다고 판단한다.</p></li>
<li><p>Cook’s 거리 <span class="math inline">\(D_{i} = \frac{e_{i}^{2}}{p{\widehat{\sigma}}^{2}} \cdot \frac{h_{ii}}{(1 - h_{ii})^{2}}\)</span>, 관측치 i를 제거했을 때 회귀계수 전체가 얼마나 변하는지를 나타내는 척도이다. 값이 클수록 그 점이 회귀선 전체에 큰 영향을 미친다는 의미하며 <span class="math inline">\(D_{i} &gt; 1\)</span>이면 영향치로 의심할 수 있다.</p></li>
<li><p>DFFITS <span class="math inline">\(DFFITS_{i} = \frac{\widehat{y}i - \widehat{y}i(i)}{\widehat{\sigma}(i)\sqrt{hii}}\)</span>: 관측치 i를 제거했을 때 예측값 <span class="math inline">\({\widehat{y}}_{i}\)</span>가 얼마나 변하는지 나타낸다. <span class="math inline">\(|DFFITS_{i}| &gt; 2\sqrt{\frac{p}{n}}\)</span>이면 영향력이 크다고 본다.</p></li>
</ul>
<p>해결책</p>
<ul>
<li><p>이상치 - 삭제 : 회귀모형의 적합성 높아짐 &lt;=&gt; 결정계수 높아짐</p></li>
<li><p>영향치 : 결정계수를 커지게 하는 경향이 있음 &lt;=&gt; 제외하고 추정 모형을 예측하는 것이 적절하다.</p></li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 101%">
</colgroup>
<tbody>
<tr class="odd">
<td><p># -----------------------------------------</p>
<p># 1) 진단 그래프 2종: Studentized Residuals vs Fitted, Influence plot</p>
<p># -----------------------------------------</p>
<p>import numpy as np</p>
<p>import matplotlib.pyplot as plt</p>
<p>import seaborn as sns</p>
<p>from statsmodels.nonparametric.smoothers_lowess import lowess</p>
<p>from statsmodels.graphics.regressionplots import influence_plot</p>
<p># --- 최종 모형 적합 ---</p>
<p>selected = ['CHAS', 'NOX', 'RM', 'PTRATIO', 'B', 'LSTAT'] # 선택된 변수 리스트</p>
<p>X_final = sm.add_constant(X[selected], has_constant='add') # 정제된 X 사용</p>
<p>final_model = sm.OLS(y, X_final).fit()</p>
<p>print(final_model.summary())</p>
<p>sns.set_style("whitegrid")</p>
<p># ✅ studentized residuals는 get_influence()에서 가져온다.</p>
<p>infl = final_model.get_influence()</p>
<p>resid = infl.resid_studentized_internal # 또는 infl.resid_studentized_external</p>
<p>fitted = final_model.fittedvalues</p></td>
</tr>
</tbody>
</table>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image13.png" style="width:4.5in;height:3.19565in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image14.png" style="width:4.5in;height:3.37321in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td><p>import numpy as np</p>
<p>import pandas as pd</p>
<p>import statsmodels.api as sm</p>
<p>from statsmodels.stats.outliers_influence import OLSInfluence</p>
<p># --- 1. 기존 최종 모형 적합 ---</p>
<p>selected = ['CHAS', 'NOX', 'RM', 'PTRATIO', 'B', 'LSTAT']</p>
<p>X_final = sm.add_constant(X[selected], has_constant='add')</p>
<p>final_model = sm.OLS(y, X_final).fit()</p>
<p>print("[원래 최종 모형]")</p>
<p>print(final_model.summary())</p>
<p># --- 2. 영향치/이상치 진단 ---</p>
<p>infl = OLSInfluence(final_model)</p>
<p>std_resid = infl.resid_studentized_internal # studentized residuals</p>
<p>cooks_d = infl.cooks_distance[0] # Cook's D</p>
<p>lev = infl.hat_matrix_diag # leverage</p>
<p>n = int(final_model.nobs)</p>
<p>p = int(final_model.df_model) + 1</p>
<p># 기준값</p>
<p>thr_resid = 2.0</p>
<p>thr_cook = 4/n</p>
<p>thr_lev = 2*p/n</p>
<p># 이상치 또는 영향치 플래그</p>
<p>mask_bad = (np.abs(std_resid) &gt; thr_resid) | (cooks_d &gt; thr_cook) | (lev &gt; thr_lev)</p>
<p>print(f"제거 대상 관측치 수: {mask_bad.sum()} / {n}")</p>
<p># --- 3. 이상치/영향치 제거 후 모형 재적합 ---</p>
<p>X_clean = X_final.loc[~mask_bad].copy()</p>
<p>y_clean = y.loc[~mask_bad].copy()</p>
<p>refit_model = sm.OLS(y_clean, X_clean).fit()</p>
<p>print("\n[이상치/영향치 제거 후 모형]")</p>
<p>print(refit_model.summary())</p></td>
</tr>
</tbody>
</table>
<p>CHAS의 회귀계수 부호가 상관계수 부호와 상이하여 제거 후 최종 회귀모형을 추정하였다.<img src="media/image15.png" style="width:4.5in;height:2.79425in" alt="붙여넣은 동영상.png"></p>
<p>예측값, 신뢰구간, 예측구간</p>
<p>회귀모형 <span class="math inline">\(\underset{¯}{y} = X\underset{¯}{\beta} + \underset{¯}{e}\)</span></p>
<p>OLS 추정치 : <span class="math inline">\(\widehat{\underset{¯}{\beta}} = (X'X)^{- 1}X'\underset{¯}{y}\)</span></p>
<p>주어진 예측변수 값 벡터 : <span class="math inline">\({\underset{¯}{x}}_{0}\)</span> 예측구간</p>
<p>주어진 예측변수 <span class="math inline">\({\underset{¯}{x}}_{0}\)</span> 목표변수 적합치 : <span class="math inline">\(\widehat{{\underset{¯}{y}}_{0}}|{\underset{¯}{x}}_{0} = {\underset{¯}{x}}_{0}\widehat{\underset{¯}{\beta}} + {\underset{¯}{e}}_{0}\)</span></p>
<p><span class="math inline">\({\underset{¯}{e}}_{0}\)</span>는 오차이고 평균이 0이므로 추정량은 <span class="math inline">\(\widehat{{\underset{¯}{y}}_{0}}|{\underset{¯}{x}}_{0} = {\underset{¯}{x}}_{0}\widehat{\underset{¯}{\beta}}\)</span>으로 기대값 추정량과 동일하다.</p>
<p>추정량 평균 : <span class="math inline">\(E(\widehat{{\underset{¯}{y}}_{0}}|{\underset{¯}{x}}_{0}) = {\underset{¯}{x}}_{0}\widehat{\underset{¯}{\beta}}\)</span></p>
<p>추정량 분산 : <span class="math inline">\(V(\widehat{{\underset{¯}{y}}_{0}}|{\underset{¯}{x}}_{0}) = \sigma^{2}(I + {\underset{¯}{x}}_{0}'(X'X)^{- 1}{\underset{¯}{x}}_{0})\)</span></p>
<p>추정량은 목표변수의 선형결합이므로 추정량의 샘플링분포는 정규분포를 따른다.</p>
<p>주어진 예측변수 값 벡터 : <span class="math inline">\({\underset{¯}{x}}_{0}\)</span> 신뢰구간</p>
<p>주어진 예측변수의 목표변수 기대값 추정량 : <span class="math inline">\(E(\widehat{{\underset{¯}{y}}_{0}}|{\underset{¯}{x}}_{0}) = {\underset{¯}{x}}_{0}\widehat{\underset{¯}{\beta}}\)</span></p>
<p>추정량 평균 : <span class="math inline">\(E(\widehat{{\underset{¯}{y}}_{0}}|{\underset{¯}{x}}_{0}) = {\underset{¯}{x}}_{0}\widehat{\underset{¯}{\beta}}\)</span></p>
<p>추정량 분산 : <span class="math inline">\(V(\widehat{{\underset{¯}{y}}_{0}}|{\underset{¯}{x}}_{0}) = \sigma^{2}I\)</span></p>
<p>추정량은 목표변수의 선형결합이므로 추정량의 샘플링분포는 정규분포를 따른다.</p>
<p>예측구간, 신뢰구간 어느 것을 사용하나? 신뢰구간이 예측구간보다 작으나 예측변수의 개별 관측값이 주어진 경우 목표변수 관측값을 예측하는 것이므로 예측구간을 사용하는 것이 적절하다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td><p># refit_model에 적합했던 행렬을 그대로 사용</p>
<p>pred_int = refit_model.get_prediction(X_clean)</p>
<p>pred_int.summary_frame(alpha=0.05)</p></td>
</tr>
</tbody>
</table>
<p>mean mean_se mean_ci_lower mean_ci_upper obs_ci_lower obs_ci_upper</p>
<p>0 29.474740 0.399196 28.690070 30.259410 22.918274 36.031206</p>
<p>1 25.281274 0.195985 24.896039 25.666508 18.760542 31.802006</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td><p>import pandas as pd</p>
<p># 예: 새 관측치 (변수는 최종 모형과 동일하게 입력)</p>
<p>new_X = pd.DataFrame({</p>
<p>"NOX": [0.5],</p>
<p>"RM": [6.5],</p>
<p>"PTRATIO": [18],</p>
<p>"B": [390],</p>
<p>"LSTAT": [10]</p>
<p>})</p>
<p># 상수항 추가</p>
<p>X_new = sm.add_constant(new_X, has_constant="add")</p>
<p># 최종 모형 기준 예측</p>
<p>pred = refit_model.get_prediction(X_new)</p>
<p># 신뢰구간(평균 응답), 예측구간(새 관측치) 모두 포함</p>
<p>print(pred.summary_frame(alpha=0.05))</p></td>
</tr>
</tbody>
</table>
<p>mean mean_se mean_ci_lower mean_ci_upper obs_ci_lower obs_ci_upper</p>
<p>25.022419 0.178576 24.671405 25.373433 18.503619 31.541219</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>