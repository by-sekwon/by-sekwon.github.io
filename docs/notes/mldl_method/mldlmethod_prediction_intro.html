<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>MLDL 예측방법. 1.서론 – 세상의 모든 통계 이야기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-2757cfadcc89ddbfb9e61569f8c3689f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">세상의 모든 통계 이야기</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../notes/math/index.html"> 
<span class="menu-text">기초수학</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/math_stat/index.html"> 
<span class="menu-text">수리통계</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/intro_stat/index.html"> 
<span class="menu-text">기초통계</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/survey/index.html"> 
<span class="menu-text">조사방법론</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/linear_model/index.html"> 
<span class="menu-text">회귀분석</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mda/index.html"> 
<span class="menu-text">다변량분석</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl/index.html"> 
<span class="menu-text">머신·딥러닝 개념 w/GPT</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../notes/mldl_method/index.html" aria-current="page"> 
<span class="menu-text">머신·딥러닝 방법론 w/GPT</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cardnews/index.html"> 
<span class="menu-text">카드뉴스</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../consult.html"> 
<span class="menu-text">통계상담</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../notes/mldl_method/mldlmethod_prediction_intro.html">📄 1.예측방법: 서론</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">【HOME】</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 0.MLDL 방법론 소개</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_prediction_intro.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">📄 1.예측방법: 서론</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_prediction_reg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 1.예측방법: 회귀분석</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_prediction_regulation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 1.예측방법: 규제회귀</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">contents</h2>
   
  <ul>
  <li><a href="#chapter-1.-예측모형-통계적-정의" id="toc-chapter-1.-예측모형-통계적-정의" class="nav-link active" data-scroll-target="#chapter-1.-예측모형-통계적-정의">Chapter 1. 예측모형 통계적 정의</a>
  <ul>
  <li><a href="#예측-문제의-통계적-정의" id="toc-예측-문제의-통계적-정의" class="nav-link" data-scroll-target="#예측-문제의-통계적-정의">1. 예측 문제의 통계적 정의</a></li>
  <li><a href="#불가약오차irreducible-error와-잡음-모델" id="toc-불가약오차irreducible-error와-잡음-모델" class="nav-link" data-scroll-target="#불가약오차irreducible-error와-잡음-모델">2. 불가약오차(Irreducible error)와 잡음 모델</a></li>
  <li><a href="#y가-이진형-혹은-범주형인-경우-예측은-분류이다." id="toc-y가-이진형-혹은-범주형인-경우-예측은-분류이다." class="nav-link" data-scroll-target="#y가-이진형-혹은-범주형인-경우-예측은-분류이다.">3. Y가 이진형 혹은 범주형인 경우 예측은 분류이다.</a></li>
  <li><a href="#예측문제는-본질적으로-함수-근사-문제이다." id="toc-예측문제는-본질적으로-함수-근사-문제이다." class="nav-link" data-scroll-target="#예측문제는-본질적으로-함수-근사-문제이다.">4. 예측문제는 본질적으로 함수 근사 문제이다.</a></li>
  <li><a href="#y-in-mathbbr에-대한-규제는-함수-공간을-줄이는-장치이다." id="toc-y-in-mathbbr에-대한-규제는-함수-공간을-줄이는-장치이다." class="nav-link" data-scroll-target="#y-in-mathbbr에-대한-규제는-함수-공간을-줄이는-장치이다.">5. <span class="math inline">\(Y \in \mathbb{R}\)</span>에 대한 규제는 함수 공간을 줄이는 장치이다.</a></li>
  <li><a href="#검증오차-관점의-함수-선택" id="toc-검증오차-관점의-함수-선택" class="nav-link" data-scroll-target="#검증오차-관점의-함수-선택">6. 검증오차 관점의 함수 선택</a></li>
  <li><a href="#예측모형-통계적-사고와-ml-사고" id="toc-예측모형-통계적-사고와-ml-사고" class="nav-link" data-scroll-target="#예측모형-통계적-사고와-ml-사고">7. 예측모형: 통계적 사고와 ML 사고</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">MLDL 예측방법. 1.서론</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="chapter-1.-예측모형-통계적-정의" class="level3">
<h3 class="anchored" data-anchor-id="chapter-1.-예측모형-통계적-정의">Chapter 1. 예측모형 통계적 정의</h3>
<section id="예측-문제의-통계적-정의" class="level4">
<h4 class="anchored" data-anchor-id="예측-문제의-통계적-정의">1. 예측 문제의 통계적 정의</h4>
<p>예측이란 설명변수 X가 주어졌을 때 반응변수 Y의 값을 가능한 한 정확하게 추정하는 문제이다. 여기서는 반응변수가 연속형인 경우, 즉 <span class="math inline">\(Y \in \mathbb{R}\)</span>인 상황을 다룬다.</p>
<p>통계적 관점에서 예측 문제는 함수 추정 문제로 정의된다. 확률변수 (X, Y)에 대해, 다음의 기대제곱오차를 최소화하는 함수 f를 찾는 것이 목표이다.</p>
<p><span class="math inline">\(f^{*} = \arg\min_{f}\mathbb{E}\lbrack(Y - f(X))^{2}\rbrack\)</span>, 이때 제곱오차 손실 하에서의 최적 해는 잘 알려진 바와 같이 <span class="math inline">\(f^{*}(x) = \mathbb{E}\lbrack Y \mid X = x\rbrack\)</span>이다. 그러나 실제 데이터 분석에서는 <span class="math inline">\(\mathbb{E}\lbrack Y \mid X = x\rbrack\)</span>를 정확히 알 수 없으므로, 제한된 표본 데이터를 이용해 이를 근사(approximation)한다.</p>
<p>즉, 예측 문제는 본질적으로 <span dir="rtl">”</span>미지의 함수 <span class="math inline">\(f^{*}\)</span>를 데이터로부터 얼마나 잘 근사할 수 있는가”라는 질문으로 귀결된다.</p>
</section>
<section id="불가약오차irreducible-error와-잡음-모델" class="level4">
<h4 class="anchored" data-anchor-id="불가약오차irreducible-error와-잡음-모델">2. 불가약오차(Irreducible error)와 잡음 모델</h4>
<p>현실의 데이터에서 Y는 X만으로 완전히 결정되지 않는다. 동일한 X가 주어져도 관측되는 Y는 여러 요인의 영향으로 변동할 수 있으며, 이 변동은 예측모형이 아무리 정교해도 완전히 제거할 수 없다. 이러한 관점은 예측 문제를 다음과 같은 잡음(noise) 포함 모델로 표현하게 한다.</p>
<p><strong>1. 잡음 모델 <span class="math inline">\(Y = f^{*}(X) + \varepsilon\)</span></strong></p>
<p>예측의 이론적 최적함수 <span class="math inline">\(f^{*}(x) = \mathbb{E}\lbrack Y \mid X = x\rbrack\)</span>를 기준으로, <span class="math inline">\(Y = f^{*}(X) + \varepsilon\)</span>라고 쓸 수 있다. 여기서 <span class="math inline">\(\varepsilon\)</span>는 X로 설명되지 않는 변동(잡음)을 나타내며, 정의상 <span class="math inline">\(\mathbb{E}\lbrack\varepsilon \mid X\rbrack = 0\)</span>을 만족한다. 즉, <span class="math inline">\(\varepsilon\)</span>는 <span dir="rtl">”</span>평균적으로는 0이지만, 개별 관측치에서는 예측을 흔드는 요인”이다. 이 표현은 예측문제가 결국 신호(signal) <span class="math inline">\(f^{*}(X)\)</span>와 잡음(noise) <span class="math inline">\(\varepsilon\)</span>를 구분하는 작업임을 보여준다.</p>
<p><strong>2. 불가약오차의 의미</strong></p>
<p>어떤 예측함수 f를 사용하더라도 기대제곱오차는 0이 될 수 없다. 그 이유는 X가 동일하더라도 Y가 확률적으로 변동하기 때문이다. 특히 제곱오차 기준에서 최적함수 <span class="math inline">\(f^{*}\)</span>를 사용하더라도 남는 오차는 <span class="math inline">\(\mathbb{E}\lbrack(Y - f^{*}(X))^{2}\rbrack\)</span>이며, 이것이 바로 불가약오차이다.</p>
<p>조건부 분산을 이용하면 이 값은 더 명확히 해석된다:</p>
<p><span class="math display">\[\mathbb{E}\lbrack(Y - f^{*}(X))^{2}\rbrack = \mathbb{E}\lbrack Var(Y \mid X)\rbrack\]</span></p>
<p>즉 불가약오차는 <span dir="rtl">”</span>X가 주어졌을 때 Y가 본질적으로 가지는 변동성(조건부 분산)“의 평균이며, 데이터 생성과정 자체가 갖는 한계이다. 따라서 예측모형의 목표는 불가약오차를 없애는 것이 아니라, 그 위에 추가로 발생하는 오차를 최소화하는 것이다.</p>
<p><strong>3. (중요) 오차 분해: 줄일 수 있는 것 vs 줄일 수 없는 것</strong></p>
<p>임의의 예측함수 f에 대해 제곱오차는 다음과 같이 분해된다:</p>
<p><span class="math display">\[\mathbb{E}\lbrack(Y - f(X))^{2}\rbrack = \underset{\text{불가약오차}}{\underbrace{\mathbb{E}\lbrack(Y - f^{*}(X))^{2}\rbrack}} + \underset{\text{근사/추정 오차}}{\underbrace{\mathbb{E}\lbrack(f^{*}(X) - f(X))^{2}\rbrack}}\]</span></p>
<p>두 번째 항은 f가 <span class="math inline">\(f^{*}\)</span>를 얼마나 잘 근사하는지에 따라 달라지는 부분으로, 모형 선택·규제·데이터 크기 등에 의해 줄일 수 있다. 반면 첫 번째 항은 데이터 생성 과정의 잡음 크기에 의해 결정되며, 모형을 바꿔도 사라지지 않는다.</p>
<p>이 관점은 <span dir="rtl">”</span>왜 아무리 복잡한 모델도 테스트오차가 0이 되지 않는가”, <span dir="rtl">”</span>왜 과적합을 피해야 하는가”를 설명하는 이론적 근거가 된다.</p>
<p><strong>4. 실무적 해석과 함의</strong></p>
<p>불가약오차가 크다는 것은, X만으로는 Y를 정밀하게 예측하기 어렵다는 뜻이다. 이때의 대응은 대체로 두 가지 방향이다.</p>
<p>정보를 추가한다(특징 확장): 더 유의미한 설명변수(센서, 설문, 로그 등)를 확보하면 <span class="math inline">\(Var(Y \mid X)\)</span>를 줄일 수 있다.</p>
<p>목표를 조정한다: 점예측의 한계를 인정하고, 예측구간/확률예측처럼 불확실성을 함께 보고한다.</p>
<p>요약하면, 예측모형의 성능에는 근본적 하한이 존재하며(불가약오차), 우리가 할 수 있는 일은 그 하한 위에서 f^*에 최대한 가까운 \hat f를 학습하도록 복잡도 조절과 검증 기반 선택을 수행하는 것이다.</p>
</section>
<section id="y가-이진형-혹은-범주형인-경우-예측은-분류이다." class="level4">
<h4 class="anchored" data-anchor-id="y가-이진형-혹은-범주형인-경우-예측은-분류이다.">3. Y가 이진형 혹은 범주형인 경우 예측은 분류이다.</h4>
<p>반응변수가 이진형인 경우, 예측 문제는 분류(classification) 문제로 구분된다. 즉, <span class="math inline">\(Y \in \{ 0,1\}\)</span> 또는 보다 일반적으로 <span class="math inline">\(Y \in \{ 1,2,\ldots,K\}\)</span>와 같이 유한한 범주 값을 갖는 경우, 목표는 연속값을 추정하는 것이 아니라 어느 범주에 속하는지를 결정하는 것이다.</p>
<p>다만 여기서 중요한 점은, 분류 문제 역시 본질적으로는 함수 추정 문제라는 사실이다. 분류에서는 일반적으로 다음과 같은 조건부 확률 함수를 추정한다. <span class="math inline">\(\eta(x) = P(Y = 1 \mid X = x)\)</span></p>
<p>그리고 실제 분류 규칙은 이 확률 함수에 대한 임계값(threshold)을 통해 정의된다.</p>
<p><span class="math inline">\(\widehat{Y} = \{\begin{matrix}
1, &amp; \eta(x) \geq c \\
0, &amp; \eta(x) &lt; c
\end{matrix}\)</span>. 이때 임계값 c는 흔히 0.5로 설정되지만, 비용 구조나 문제 맥락에 따라 달라질 수 있다.</p>
<p>이 관점에서 보면, 회귀=예측은 <span class="math inline">\(f(x) \approx \mathbb{E}\lbrack Y \mid X = x\rbrack\)</span>를 직접 근사하는 문제이고, 분류는 <span class="math inline">\(f(x) \approx P(Y = 1 \mid X = x)\)</span>와 같은 확률 함수를 근사한 뒤, 이를 의사결정 규칙으로 변환하는 문제이다.</p>
<p>따라서 회귀와 분류의 차이는 출력 공간과 손실함수의 차이이지, <span dir="rtl">”</span>예측 문제라는 본질”이 다른 것은 아니다. 연속형 반응변수에서는 제곱오차(MSE)가 자연스럽고, 이진형 반응변수에서는 로그손실(log-loss)이나 크로스엔트로피가 자연스럽게 등장한다.</p>
</section>
<section id="예측문제는-본질적으로-함수-근사-문제이다." class="level4">
<h4 class="anchored" data-anchor-id="예측문제는-본질적으로-함수-근사-문제이다.">4. 예측문제는 본질적으로 함수 근사 문제이다.</h4>
<p>통계적 예측 문제는 겉으로 보면 <span dir="rtl">”</span>주어진 설명변수로 반응변수를 맞히는 문제”처럼 보이지만, 그 본질은 훨씬 일반적인 함수 근사 문제로 이해할 수 있다.</p>
<p>예측문제는 반응변수가 연속형일 경우, <span class="math inline">\(Y \in \mathbb{R}\)</span>, 위험 함수, <span class="math inline">\(\min_{f}\mathbb{E}\lbrack(Y - f(X))^{2}\rbrack\)</span>를 최소화하는 함수 <span class="math inline">\(f\)</span>를 찾는 문제로 정식화된다. 이때 제곱오차 손실 하에서 이론적으로 최적인 함수는 조건부 기댓값 <span class="math inline">\(f^{*}(X) = \mathbb{E}\lbrack Y \mid X\rbrack\)</span>임이 알려져 있다. 즉, 모든 예측 문제의 이상적인 해는 조건부 평균 함수이다. 그러나 실제 데이터 분석에서는 모집단의 분포를 알 수 없고, 오직 유한한 표본 <span class="math inline">\(\{(x_{1},y_{1}),\ldots,(x_{n},y_{n})\}\)</span>만이 주어진다. 따라서 실제 목표는 <span class="math inline">\(f^{*}\)</span> 자체를 구하는 것이 아니라, 데이터로부터 이를 근사하는 함수 <span class="math inline">\(\widehat{f}\)</span>를 구성하는 데 있다.</p>
<p>이 관점에서 보면, 예측 문제는 다음과 같이 재해석된다.</p>
<p>미지의 함수 <span class="math inline">\(f^{*}:\mathcal{X} \rightarrow \mathbb{R}\)</span>를 제한된 데이터와 제한된 함수 공간 내에서 얼마나 잘 근사할 수 있는가? 이때 핵심은 어떤 함수 공간을 선택하느냐이다. 함수 공간의 선택은 곧 예측모형의 성격을 결정한다.</p>
<ul>
<li>선형회귀는 <span class="math inline">\(\mathcal{F} = \{ f(x) = \beta_{0} + \beta^{\top}x\}\)</span>와 같은 유한차원 선형 함수 공간을 가정한다.</li>
<li>다항회귀는 입력변수를 비선형 변환하여 보다 큰 함수 공간을 구성한다.</li>
<li>트리 기반 모형은 입력 공간을 분할한 뒤 각 영역에서 상수 또는 단순 함수를 사용함으로써 비연속적 함수 근사를 수행한다.</li>
<li>신경망은 다층 비선형 변환을 통해 매우 큰 함수 공간을 형성하며, 이론적으로 임의의 연속함수를 근사할 수 있다.</li>
</ul>
<p>함수 공간이 커질수록 근사 오차)는 감소하지만, 동시에 추정 오차는 증가한다. 이는 예측 문제의 핵심 딜레마인 편향–분산 트레이드오프(Bias–Variance Trade-off) 로 이어진다. 이를 분해하여 표현하면, 임의의 점 x에서의 평균 제곱오차는 다음과 같이 나눌 수 있다.</p>
<p><span class="math display">\[\mathbb{E}\lbrack(Y - \widehat{f}(x))^{2}\rbrack = \underset{\text{모형 한계}}{\underbrace{\text{Bias}^{2}}} + \underset{\text{추정 불안정성}}{\underbrace{\text{Variance}}} + \underset{\text{불가피한 잡음}}{\underbrace{\sigma^{2}}}\]</span></p>
<p>따라서 예측모형의 설계란 단순히 <span dir="rtl">”</span>복잡한 모형을 쓰는 것”이 아니라, 함수 공간의 크기, 데이터 양, 노이즈 수준, 그리고 일반화 성능을 함께 고려하여 적절한 함수 근사 수준을 선택하는 과정이다.</p>
</section>
<section id="y-in-mathbbr에-대한-규제는-함수-공간을-줄이는-장치이다." class="level4">
<h4 class="anchored" data-anchor-id="y-in-mathbbr에-대한-규제는-함수-공간을-줄이는-장치이다.">5. <span class="math inline">\(Y \in \mathbb{R}\)</span>에 대한 규제는 함수 공간을 줄이는 장치이다.</h4>
<p><strong>왜 규제가 필요한가: 고차원과 불안정성</strong></p>
<p>예측변수의 개수 <span class="math inline">\(p\)</span>가 크거나 <span class="math inline">\(X^{\top}X\)</span>가 거의 특이(singular)하면(이를 다중공선성(multicollinearity) 문제) <span class="math inline">\(\widehat{\beta}\)</span> 분산이 커지고 예측이 흔들린다.</p>
<ul>
<li>훈련오차는 줄어도 테스트오차가 증가하는 과적합이 발생한다.</li>
<li>규제는 <span dir="rtl">”</span>계수의 크기를 제한”하여 함수 공간을 사실상 축소한다.</li>
</ul>
<p><strong>제한형 문제와 패널티형 문제의 동치</strong></p>
<p>규제는 다음 두 형태로 동치가 성립한다(라그랑주 관점).</p>
<ul>
<li>제한형(함수 공간 축소의 직접 표현) <span class="math inline">\(\min_{\beta} \parallel y - X\beta \parallel^{2}\text{s.t.} \parallel \beta \parallel_{q} \leq t\)</span></li>
<li>패널티형(목적함수에 벌점 추가) <span class="math inline">\(\min_{\beta} \parallel y - X\beta \parallel^{2} + \lambda \parallel \beta \parallel_{q}^{q}\)</span></li>
</ul>
<p>즉, 규제는 <span dir="rtl">”</span>좋은 함수”의 정의에 복잡도 비용을 포함시키는 방식이다.</p>
<p><strong>Ridge: L_2 규제와 수축(shrinkage)</strong></p>
<ul>
<li>목적함수: <span class="math inline">\(\min_{\beta} \parallel y - X\beta \parallel^{2} + \lambda \parallel \beta \parallel_{2}^{2}\)</span></li>
<li>해: <span class="math inline">\({\widehat{\beta}}_{\text{ridge}} = (X^{\top}X + \lambda I)^{- 1}X^{\top}y\)</span></li>
<li>해석: <span class="math inline">\(\lambda I\)</span>를 더해 역행렬 안정화(수치적·통계적 안정성) 하고 계수는 0에 가깝게 연속적으로 수축한다(변수 선택은 직접적이지 않음).</li>
<li>기하학: 제곱오차 등고선(타원)과 L_2 제약(원/구)의 접점.</li>
</ul>
<p><strong>Lasso: L_1 규제와 희소성(sparsity)</strong></p>
<ul>
<li>목적함수: <span class="math inline">\(\min_{\beta} \parallel y - X\beta \parallel^{2} + \lambda \parallel \beta \parallel_{1}\)</span></li>
<li>특징: 일부 계수가 정확히 0이 되며 변수 선택 효과가 나타난다.</li>
<li>기하학: L_1 제약은 마름모(고차원에서는 뾰족한 다면체)라 접점이 축에 걸리기 쉬워 0이 자주 발생.</li>
</ul>
<p><strong>Elastic Net: 혼합 규제의 실용적 타협</strong></p>
<p><span class="math display">\[\min_{\beta} \parallel y - X\beta \parallel^{2} + \lambda\left( \alpha \parallel \beta \parallel_{1} + (1 - \alpha) \parallel \beta \parallel_{2}^{2} \right)\]</span></p>
<ul>
<li>Lasso의 변수 선택 + Ridge의 안정성(상관 높은 변수군에서 그룹화 경향).</li>
</ul>
<p><strong>규제의 핵심 메시지</strong></p>
<p>규제는 단순히 <span dir="rtl">”</span>벌점 추가”가 아니라, 허용하는 함수 공간을 <span dir="rtl">’</span>계수의 크기 제약<span dir="rtl">’</span>으로 축소하여 일반화 성능을 높이는 장치 로 이해해야 한다. 그러나 규제 강도 <span class="math inline">\(\lambda\)</span>와 같은 하이퍼파라미터는 데이터가 알려주지 않으면 정할 수 없다. 이 선택의 기준이 바로 검증오차이며, 결국 함수 선택은 검증오차 최소화로 구현된다.</p>
</section>
<section id="검증오차-관점의-함수-선택" class="level4">
<h4 class="anchored" data-anchor-id="검증오차-관점의-함수-선택">6. 검증오차 관점의 함수 선택</h4>
<p><strong>훈련오차 vs 일반화오차</strong></p>
<p>예측모형의 성능을 논할 때 가장 먼저 구분해야 할 개념은 훈련오차(training error) 와 일반화오차(generalization error) 이다.</p>
<p>훈련오차란, 학습에 사용된 데이터에 대해 모형이 얼마나 잘 맞는지를 측정한 값으로, 주어진 함수 f에 대해 다음과 같이 정의된다.</p>
<p><span class="math inline">\(\text{TrainErr}(f) = \frac{1}{n}\overset{n}{\sum_{i = 1}}(y_{i} - f(x_{i}))^{2}\)</span>. 이는 관측된 표본에서 계산되는 경험적 오차로서, 데이터가 주어지면 언제든지 계산할 수 있다.</p>
<p>그러나 예측의 궁극적인 목적은 훈련 데이터에 잘 맞추는 것이 아니라, 아직 관측되지 않은 새로운 데이터에서도 잘 작동하는 것이다. 이를 수학적으로 표현한 것이 일반화오차 또는 테스트오차이다. 일반화오차는 테스트 분포, 즉 모집단 분포에서의 평균 제곱오차로 정의된다.</p>
<p><span class="math inline">\(\text{TestErr}(f) = \mathbb{E}\lbrack(Y - f(X))^{2}\rbrack\)</span> 이 값은 확률변수 X, Y의 분포에 대한 기댓값이므로, 실제로는 직접 계산할 수 없고 추정의 대상이 된다.</p>
<p>중요한 점은 훈련오차가 작다고 해서 일반화오차도 반드시 작은 것은 아니라는 사실이다. 함수 공간 <span class="math inline">\(\mathcal{F}\)</span>가 커질수록, 즉 모형이 복잡해질수록 훈련오차는 단조롭게 감소한다. 충분히 유연한 함수라면 훈련 데이터의 모든 점을 거의 완벽하게 통과하도록 만들 수 있기 때문이다. 그러나 이러한 복잡한 모형은 데이터에 포함된 우연한 잡음까지 함께 학습하게 되어, 새로운 데이터에 대해서는 오히려 예측 성능이 나빠질 수 있다.</p>
<p>이 현상을 시각적으로 표현하면, 함수 공간의 복잡도에 따라 훈련오차는 지속적으로 감소하는 반면, 테스트오차는 U자 형태를 띠는 경우가 많다. 복잡도가 너무 작은 경우에는 모형이 데이터의 구조를 충분히 표현하지 못해 편향이 크고, 반대로 복잡도가 지나치게 큰 경우에는 분산이 커져 과적합이 발생한다. 이 두 효과의 균형점에서 테스트오차가 최소가 된다.</p>
<p>따라서 예측모형 학습의 핵심은 훈련오차를 최소화하는 것이 아니라, 일반화오차를 최소화하는 함수의 복잡도를 선택하는 것이다. 이 관점에서 검증셋과 교차검증은 보이지 않는 테스트오차를 데이터로부터 간접적으로 추정하기 위한 핵심 도구가 된다.</p>
<p><strong>왜 훈련오차 최소화만으로는 충분하지 않은가</strong></p>
<p>예측모형의 학습 과정은 흔히 훈련오차를 최소화하는 문제로 표현된다. 실제로 많은 모형은 다음과 같은 경험적 위험을 최소화하도록 설계되어 있다.</p>
<p><span class="math inline">\(\text{TrainErr}(f) = \frac{1}{n}\overset{n}{\sum_{i = 1}}(y_{i} - f(x_{i}))^{2}\)</span>. 이 식은 주어진 데이터에 대해 모형이 얼마나 잘 맞는지를 정량적으로 측정해 주며, 계산도 간단하다. 그러나 훈련오차를 최소화하는 것만으로는 좋은 예측모형을 보장할 수 없다.</p>
<p>그 이유는 훈련오차가 본질적으로 과거 데이터에 대한 적합도만을 반영하기 때문이다. 훈련 데이터는 모집단 분포에서 우연히 추출된 하나의 표본에 불과하며, 그 안에는 구조적인 신호뿐 아니라 우연적 잡음도 함께 포함되어 있다. 훈련오차를 지나치게 줄이려는 과정은 이 잡음까지 함께 학습하도록 모형을 유도할 수 있다.</p>
<p>이를 극단적으로 생각해 보면, 충분히 유연한 함수 공간 <span class="math inline">\(\mathcal{F}\)</span>를 허용할 경우, 훈련 데이터의 모든 관측값을 정확히 통과하는 함수 <span class="math inline">\(f\)</span>를 항상 구성할 수 있다. 이 경우 훈련오차는 거의 0이 된다. 그러나 이러한 함수는 데이터의 일반적인 구조를 학습했다기보다, 특정 표본의 우연한 패턴을 외운 것에 가깝다. 이처럼 훈련오차는 작지만 새로운 데이터에 대한 예측 성능이 나쁜 현상을 과적합이라 한다.</p>
<p>이 문제를 수학적으로 이해하기 위해, 테스트오차를 다음과 같이 분해할 수 있다.</p>
<p><span class="math display">\[\mathbb{E}\lbrack(Y - \widehat{f}(X))^{2}\rbrack = \underset{\text{모형의 구조적 한계}}{\underbrace{\text{Bias}^{2}}} + \underset{\text{표본에 대한 민감도}}{\underbrace{\text{Variance}}} + \underset{\text{불가피한 오차}}{\underbrace{\sigma^{2}}}\]</span></p>
<p>훈련오차 최소화는 주로 편향을 줄이는 방향으로 작동한다. 모형을 복잡하게 만들수록 데이터에 더 잘 맞게 되어 편향은 감소한다. 그러나 동시에 추정된 함수 \hat f는 표본의 작은 변화에도 크게 달라지게 되어 분산이 급격히 증가할 수 있다. 결국 테스트오차는 감소하지 않고 오히려 증가할 수 있다.</p>
<p>또한 훈련오차는 함수 공간의 크기에 대해 단조 감소하는 성질을 가진다. 즉, 허용되는 함수의 수가 많아질수록 훈련오차는 항상 같거나 더 작아진다. 반면 테스트오차는 이러한 단조성을 가지지 않으며, 적절한 복잡도 수준에서 최소값을 가진다. 따라서 훈련오차만을 기준으로 모형을 선택하면, 필연적으로 지나치게 복잡한 모형을 선택하게 된다.</p>
<p>이러한 이유로 예측 문제에서의 학습 목표는 훈련오차 최소화가 아니라, <span class="math inline">\(\text{TestErr}(f) = \mathbb{E}\lbrack(Y - f(X))^{2}\rbrack\)</span>를 최소화하는 것이다. 그러나 이 값은 관측할 수 없으므로, 실제로는 검증오차나 교차검증 오차를 통해 간접적으로 추정한다.</p>
<p>결론적으로, 훈련오차 최소화는 예측모형 학습의 필요조건일 수는 있으나 충분조건은 아니다. 좋은 예측모형이란, 훈련 데이터에 잘 맞는 모형이 아니라, 보이지 않는 데이터에서도 안정적으로 작동하는 모형이다. 이 차이를 인식하는 것이 통계적 예측과 머신러닝 방법론을 이해하는 출발점이다.</p>
<p><strong>검증오차는 왜 테스트오차의 대리 변수인가</strong></p>
<p>예측모형의 궁극적인 목표는 훈련 데이터에 대한 적합도가 아니라, 모집단 분포에서의 예측 성능, 즉 일반화오차 또는 테스트오차를 최소화하는 것이다. <span class="math inline">\(\text{TestErr}(f) = \mathbb{E}\lbrack(Y - f(X))^{2}\rbrack\)</span> 값은 확률변수 (X, Y)의 분포에 대한 기댓값이므로, 모집단 분포를 알지 못하는 현실에서는 직접 계산할 수 없다. 예측 문제에서 발생하는 근본적인 어려움은 바로 이 지점에 있다. 우리가 최소화하고 싶은 대상은 관측 불가능하다.</p>
<p>이러한 상황에서 등장하는 개념이 검증오차이다. 검증오차란, 학습에 사용되지 않은 데이터에 대해 계산한 예측오차로, 일반적으로 다음과 같이 정의된다.</p>
<p><span class="math inline">\(\text{ValErr}(f) = \frac{1}{m}\overset{m}{\sum_{j = 1}}(y_{j}^{(v)} - f(x_{j}^{(v)}))^{2}\)</span>, 여기서 <span class="math inline">\(\{(x_{j}^{(v)},y_{j}^{(v)})\}\)</span>는 훈련 과정에서 사용하지 않은 검증 데이터이다. 검증오차가 테스트오차의 대리 변수로 사용될 수 있는 이유는, 검증 데이터가 훈련 데이터와 동일한 모집단 분포로부터 독립적으로 추출되었다는 가정에 있다. 이 가정이 성립한다면, 검증오차는 테스트오차에 대한 하나의 표본 평균으로 해석할 수 있다.</p>
<p>즉, <span class="math inline">\(\mathbb{E}\lbrack\text{ValErr}(f)\rbrack = \text{TestErr}(f)\)</span>가 성립한다. 이 의미는 매우 중요하다. 검증오차는 불편추정량으로서 테스트오차를 추정하고 있는 것이다. 물론 검증오차는 표본 평균이므로 변동성을 가진다. 검증 데이터의 크기 m이 작을수록 검증오차의 분산은 커지며, 이로 인해 우연한 표본 변동에 의해 잘못된 모형을 선택할 위험이 존재한다. 이러한 이유로 단순한 단일 분할은 데이터가 충분히 클 때에만 안정적으로 작동한다.</p>
<p>그럼에도 불구하고 검증오차는 훈련오차와 본질적으로 다른 정보를 제공한다. 훈련오차는 항상 훈련 데이터에 대해 낙관적으로 편향되어 있으며, 함수 공간이 커질수록 단조 감소한다. 반면 검증오차는 새로운 데이터에 대한 성능을 반영하므로, 함수의 복잡도 증가에 따라 증가하거나 감소할 수 있다. 이로 인해 검증오차는 과적합이 시작되는 지점을 감지할 수 있는 지표가 된다.</p>
<p>요약하면, 검증오차는 다음 두 조건이 만족될 때 테스트오차의 합리적인 대리 변수로 작동한다.</p>
<p>첫째, 검증 데이터가 훈련 데이터와 독립적이며 동일한 분포에서 추출되어야 한다.</p>
<p>둘째, 검증 데이터가 학습 과정에 사용되지 않아야 한다.</p>
<p>이 두 조건이 깨질 경우, 검증오차는 더 이상 테스트오차를 정확히 반영하지 못하며, 이는 데이터 누수로 이어진다.</p>
<p>결국 검증오차를 사용하는 이유는 단순히 <span dir="rtl">”</span>계산 가능하기 때문”이 아니다. 검증오차는 관측 불가능한 일반화오차를 데이터로부터 추정할 수 있게 해주는 유일한 통로이기 때문이다. 예측모형 선택이란, 검증오차를 통해 테스트오차를 간접적으로 최소화하는 과정이라고 이해할 수 있다.</p>
<p><strong>교차검증은 왜 검증오차의 분산을 줄이는가?</strong></p>
<p>검증오차는 테스트오차를 추정하기 위한 중요한 도구이지만, 단일한 검증셋을 사용하는 경우 그 값은 우연한 표본 분할에 크게 의존할 수 있다. 특히 데이터의 크기가 크지 않은 상황에서는, 어떤 관측치가 검증셋에 포함되었는지에 따라 검증오차가 상당히 달라질 수 있다. 이는 검증오차가 표본 평균으로서 상당한 분산을 가질 수 있음을 의미한다.</p>
<p>이를 보다 명확히 이해하기 위해, 단일 검증셋을 사용하는 경우의 검증오차를 다시 적어보자.</p>
<p><span class="math inline">\(\text{ValErr}(f) = \frac{1}{m}\overset{m}{\sum_{j = 1}}(y_{j}^{(v)} - f(x_{j}^{(v)}))^{2}\)</span>. 이 값은 모집단 오차 <span class="math inline">\(\text{TestErr}(f)\)</span>의 불편추정량이지만, 표본 크기 m이 작을수록 분산이 커진다. 즉, 기대값은 맞지만 추정의 안정성은 떨어질 수 있다. 이로 인해, 우연히 낮은 검증오차를 보인 모형이 실제로는 더 나쁜 일반화 성능을 가질 가능성도 존재한다.</p>
<p>교차검증(cross-validation)은 이러한 문제를 해결하기 위한 방법으로, 검증오차를 여러 번 계산하여 평균을 내는 절차로 이해할 수 있다. 가장 널리 사용되는 K-겹 교차검증에서는 데이터를 K개의 서로 겹치지 않는 부분집합으로 나눈 뒤, 각 부분집합을 한 번씩 검증셋으로 사용한다. 이때의 교차검증 오차는 다음과 같이 정의된다.</p>
<p><span class="math inline">\(\text{CV}_{K}(f) = \frac{1}{K}\overset{K}{\sum_{k = 1}}\text{Err}^{(k)}(f)\)</span>, 여기서 <span class="math inline">\(\text{Err}^{(k)}(f)\)</span>는 k번째 분할에서 계산된 검증오차이다.</p>
<p>교차검증이 검증오차의 분산을 줄이는 이유는 크게 두 가지로 설명할 수 있다.</p>
<p>첫째, 여러 검증셋을 평균내는 효과이다. 각 <span class="math inline">\(\text{Err}^{(k)}(f)\)</span>는 동일한 테스트오차를 추정하지만, 서로 다른 표본 변동을 가진다. 이들을 평균내면, 분산은 대략 <span class="math inline">\(\text{Var}(\text{CV}_{K}(f)) \approx \frac{1}{K^{2}}\overset{K}{\sum_{k = 1}}\text{Var}(\text{Err}^{(k)}(f))\)</span>의 형태로 감소한다. 완전히 독립은 아니지만, 평균화 효과 자체만으로도 단일 검증오차보다 훨씬 안정적인 추정이 가능해진다.</p>
<p>둘째, 데이터 활용의 균형이다. 단일 검증셋 방식에서는 학습에 사용되지 않는 데이터가 고정되어 있지만, 교차검증에서는 모든 관측치가 학습과 검증에 번갈아 사용된다. 이로 인해 특정 관측치의 영향력이 과도하게 커지는 현상이 완화되며, 특정 분할에 대한 의존성이 줄어든다.</p>
<p>이러한 이유로 교차검증 오차는 단일 검증오차보다 표본 분할에 덜 민감하며, 테스트오차의 형태를 보다 안정적으로 반영한다. 다만 교차검증 역시 완전한 해법은 아니다. K가 너무 작으면 분산 감소 효과가 제한적이고, K가 너무 크면 계산 비용이 증가하며 분할 간 상관이 커질 수 있다. LOOCV(K=n)의 경우, 편향은 작지만 분산이 오히려 커질 수 있다는 점도 함께 주의해야 한다.</p>
<p>결론적으로 교차검증은 테스트오차를 직접 관측할 수 없는 상황에서, 검증오차의 변동성을 줄여 보다 신뢰할 수 있는 모형 선택 기준을 제공하는 방법이다. 예측모형 선택에서 교차검증이 표준 도구로 사용되는 이유는, 그것이 가장 이론적으로 타당하고 실용적인 일반화오차 추정 방식이기 때문이다.</p>
<p><strong>검증오차 최소화가 곧 최적 예측을 보장하지 않는 이유</strong></p>
<p>검증오차는 관측할 수 없는 테스트오차를 추정하기 위한 핵심 도구이며, 실제 예측모형 선택 과정에서는 검증오차를 최소화하는 모형이 선택된다. 그러나 검증오차를 최소화했다고 해서, 그 모형이 반드시 최적의 예측 성능을 가진다고 보장할 수는 없다. 이는 검증오차가 테스트오차의 추정값이지, 그 자체가 참값은 아니기 때문이다.</p>
<p>이를 수식으로 표현하면, 우리가 실제로 최소화하고자 하는 대상은 <span class="math inline">\(\text{TestErr}(f) = \mathbb{E}\lbrack(Y - f(X))^{2}\rbrack\)</span>이지만, 현실에서는 이를 직접 계산할 수 없으므로 다음과 같은 검증오차를 사용한다.</p>
<p><span class="math inline">\(\text{ValErr}(f) = \frac{1}{m}\overset{m}{\sum_{j = 1}}(y_{j}^{(v)} - f(x_{j}^{(v)}))^{2}\)</span> 문제는 <span class="math inline">\(\text{ValErr}(f)\)</span>가 확률변수라는 점이다. 즉, 동일한 함수 f에 대해서도 어떤 검증 데이터가 선택되었는지에 따라 값이 달라질 수 있다.</p>
<p>특히 여러 후보 모형 <span class="math inline">\(\mathcal{F} = \{ f_{1},\ldots,f_{M}\}\)</span> 중에서 검증오차가 가장 작은 모형 <span class="math inline">\(\widehat{f} = \arg\min_{f \in \mathcal{F}}\text{ValErr}(f)\)</span>을 선택하는 과정 자체가 확률적 선택 과정이라는 점이 중요하다. 이때 선택된 모형은 실제 테스트오차가 가장 작은 모형이 아니라, 우연히 검증오차가 작게 관측된 모형일 수 있다.</p>
<p>이 현상은 다중 비교의 관점에서 이해할 수 있다. 후보 모형의 수 M이 많아질수록, 일부 모형은 단지 표본 변동에 의해 검증오차가 과도하게 작게 나타날 가능성이 커진다. 즉, <span class="math inline">\(\min_{f \in \mathcal{F}}\text{ValErr}(f)\)</span>은 평균적으로 <span class="math inline">\(\min_{f \in \mathcal{F}}\text{TestErr}(f)\)</span>보다 낙관적으로 편향된다. 이로 인해 검증오차를 기준으로 선택한 모형의 실제 일반화 성능은 기대보다 낮아질 수 있다.</p>
<p>또한 검증오차 최소화는 본질적으로 모형 선택 편향을 수반한다. 검증 데이터를 사용해 모형을 선택한 후, 동일한 검증 데이터로 해당 모형의 성능을 평가하면, 그 평가는 선택 과정의 영향을 받은 값이 된다. 이는 검증오차가 <span dir="rtl">”</span>평가 지표”가 아니라 <span dir="rtl">”</span>선택 기준”으로 사용되었기 때문이다.</p>
<p>이러한 이유로, 검증오차 최소화는 최적 예측을 위한 합리적인 전략이기는 하지만, 확률적 불확실성을 내포한 전략이기도 하다. 검증오차는 테스트오차의 기대값을 맞추지만, 최소값을 선택하는 순간 그 분포는 왜곡될 수 있다.</p>
<p>결론적으로, 검증오차 최소화가 보장하는 것은 <span dir="rtl">”</span>주어진 후보들 중에서 평균적으로 성능이 좋을 가능성이 높은 모형”이지, 항상 최적의 예측모형은 아니다. 이 한계를 인식하는 것이 중요하며, 이를 보완하기 위해 테스트셋 분리, 중첩 교차검증(nested cross-validation), 또는 독립적인 외부 검증이 사용된다.</p>
<p><strong>모형 선택 편향과 중첩 교차검증</strong></p>
<p>검증오차를 이용한 모형 선택은 예측 문제에서 필수적인 절차이지만, 이 과정에는 구조적인 편향이 내재되어 있다. 이를 모형 선택 편향이라 한다. 모형 선택 편향이란, 검증 데이터를 사용해 모형을 선택한 뒤, 동일한 데이터를 이용해 그 모형의 예측 성능을 평가할 때 발생하는 낙관적 편향을 의미한다.</p>
<p>이 현상을 이해하기 위해, 후보 모형의 집합을 <span class="math inline">\(\mathcal{F} = \{ f_{1},f_{2},\ldots,f_{M}\}\)</span>이라 하자. 각 모형에 대해 계산된 검증오차 <span class="math inline">\(\text{ValErr}(f_{m})\)</span>는 테스트오차 <span class="math inline">\(\text{TestErr}(f_{m})\)</span>의 불편추정량이지만, 이는 각 모형을 고정했을 때의 이야기이다. 실제로는 다음과 같은 선택 연산이 추가된다.</p>
<p><span class="math inline">\(\widehat{f} = \arg\min_{f \in \mathcal{F}}\text{ValErr}(f)\)</span>. 이때 문제가 되는 점은, 최소 연산이 확률변수의 분포를 왜곡한다는 사실이다. 여러 개의 확률변수 중 최소값을 취하면, 그 기대값은 각 확률변수의 기대값보다 체계적으로 작아진다. 즉, <span class="math inline">\(\mathbb{E}\lbrack\min_{f \in \mathcal{F}}\text{ValErr}(f)\rbrack &lt; \min_{f \in \mathcal{F}}\text{TestErr}(f)\)</span>가 일반적으로 성립한다. 이로 인해, 검증오차를 기준으로 선택된 모형의 성능은 실제보다 과도하게 좋아 보이게 된다.</p>
<p>이 편향은 후보 모형의 수가 많을수록, 하이퍼파라미터 탐색 범위가 넓을수록, 그리고 교차검증을 반복적으로 사용할수록 더 심각해진다. 특히 머신러닝과 딥러닝에서는 수많은 하이퍼파라미터 조합을 탐색하므로, 모형 선택 편향의 위험이 더욱 커진다.</p>
<p>이 문제를 해결하기 위한 표준적인 방법이 중첩 교차검증(nested cross-validation) 이다. 중첩 교차검증의 핵심 아이디어는 모형 선택과 성능 평가를 서로 다른 데이터 분할에서 수행하는 것이다.</p>
<p><strong>중첩 교차검증은 두 개의 반복 구조를 가진다.</strong></p>
<p>먼저 바깥쪽 교차검증(outer loop)에서는 데이터를 K개로 나누고, 각 분할을 한 번씩 테스트셋으로 사용한다. 이 바깥쪽 테스트셋은 오직 최종 성능 평가에만 사용되며, 모형 선택에는 전혀 관여하지 않는다.</p>
<p>그 다음 안쪽 교차검증(inner loop)에서는, 바깥쪽에서 남겨진 학습 데이터를 다시 여러 분할로 나누어 교차검증을 수행한다. 이 안쪽 교차검증을 통해 하이퍼파라미터를 선택하고, 최적의 모형을 결정한다.</p>
<p>절차를 요약하면 다음과 같다.</p>
<p>1. 바깥쪽 분할에서 하나의 폴드를 테스트셋으로 분리한다.</p>
<p>2. 나머지 데이터에 대해 안쪽 교차검증을 수행하여 최적의 모형을 선택한다.</p>
<p>3. 선택된 모형을 바깥쪽 테스트셋에 적용하여 예측오차를 계산한다.</p>
<p>4. 이 과정을 모든 바깥쪽 폴드에 대해 반복하고, 테스트오차를 평균낸다.</p>
<p>이때 바깥쪽에서 계산된 오차는 모형 선택 과정을 포함한 전체 학습 절차의 일반화 성능을 추정하게 된다. 즉, 중첩 교차검증은 <span class="math inline">\(\mathbb{E}\lbrack\text{TestErr}(\widehat{f})\rbrack\)</span>를 직접적으로 추정하는 방법이라고 볼 수 있다.</p>
<p>중첩 교차검증의 중요한 장점은, 모형 선택 편향을 구조적으로 차단한다는 점이다. 테스트셋이 모형 선택에 전혀 사용되지 않기 때문에, 평가 결과가 선택 과정의 영향을 받지 않는다. 이는 예측 성능을 보고하거나, 서로 다른 알고리즘을 공정하게 비교해야 하는 상황에서 특히 중요하다.</p>
<p>다만 중첩 교차검증은 계산 비용이 크다는 단점이 있다. 데이터 크기가 크거나 모형 학습 비용이 높은 경우에는 실무적으로 부담이 될 수 있다. 이러한 경우에는 충분히 큰 독립 테스트셋을 별도로 확보하는 방식이 대안이 될 수 있다.</p>
<p>결론적으로, 모형 선택 편향은 검증오차 기반 학습에서 피할 수 없는 구조적 문제이며, 중첩 교차검증은 이를 이론적으로 가장 깔끔하게 해결하는 방법이다. 예측 성능을 엄밀하게 평가하고자 할 때, <span dir="rtl">”</span>교차검증을 했다”는 사실보다 교차검증이 어떤 역할로 사용되었는지가 훨씬 더 중요하다.</p>
</section>
<section id="예측모형-통계적-사고와-ml-사고" class="level4">
<h4 class="anchored" data-anchor-id="예측모형-통계적-사고와-ml-사고">7. 예측모형: 통계적 사고와 ML 사고</h4>
<p><strong>예측과 추론의 목적 차이: 왜 p-value는 여기서 중요하지 않은가</strong></p>
<p>통계 분석에서 예측과 추론은 종종 같은 방법을 사용함에도 불구하고, 그 목적과 평가 기준은 근본적으로 다르다. 이 차이를 명확히 구분하지 않으면, 예측 문제에서 부적절한 기준을 적용하거나, 추론 문제에서 잘못된 결론에 도달할 위험이 있다.</p>
<p>추론의 목적은 설명변수와 반응변수 사이의 관계에 대한 불확실성을 정량화하는 데 있다. 예를 들어 선형회귀 모형 <span class="math inline">\(Y = \beta_{0} + \beta_{1}X_{1} + \cdots + \beta_{p}X_{p} + \varepsilon\)</span>에서 추론의 핵심 질문은 다음과 같다. <span dir="rtl">”</span>계수 <span class="math inline">\(\beta_{j}\)</span>는 0과 유의미하게 다른가?“, <span dir="rtl">”</span>이 변수의 효과는 통계적으로 존재한다고 말할 수 있는가?”</p>
<p>이러한 질문에 답하기 위해 추론에서는 표본분포, 표준오차, 신뢰구간, 그리고 p-value가 사용된다. p-value는 특정 귀무가설 하에서 관측된 통계량이 얼마나 극단적인지를 나타내는 지표로, 모수에 대한 가설 검정을 위해 설계된 개념이다.</p>
<p>반면 예측의 목적은 전혀 다르다. 예측 문제에서의 핵심 질문은 <span dir="rtl">”</span>이 모형이 새로운 데이터에 대해 얼마나 정확한 값을 산출하는가?“이다. 즉 관심의 대상은 개별 계수의 해석이나 통계적 유의성이 아니라, <span class="math inline">\(\widehat{f}(X) \approx \mathbb{E}\lbrack Y \mid X\rbrack\)</span>라는 함수 근사가 얼마나 잘 이루어졌는가에 있다.</p>
<p>이 관점에서 보면, p-value는 예측 성능을 직접적으로 평가하는 정보가 아니다. 어떤 변수의 회귀계수가 통계적으로 유의하지 않더라도, 그 변수가 포함된 모형이 전체적으로 더 나은 예측 성능을 보일 수 있다. 반대로 매우 작은 p-value를 가진 변수만으로 구성된 모형이 반드시 좋은 예측모형이 되는 것도 아니다.</p>
<p>이 차이는 손실함수의 관점에서 더욱 명확해진다. 예측 문제에서의 학습과 평가는 다음과 같은 손실함수를 중심으로 이루어진다.</p>
<p><span class="math inline">\(\mathbb{E}\lbrack(Y - f(X))^{2}\rbrack,\mathbb{E}\lbrack|Y - f(X)|\rbrack\)</span>. 즉, 예측 오차의 크기가 유일한 평가 기준이다. 이때 모형 내부의 계수가 어떤 분포를 가지는지, 또는 특정 계수가 0인지 아닌지는 부차적인 문제이다.</p>
<p>또한 p-value는 모형이 올바르게 지정되었다는 가정 하에서만 해석 가능하다. 선형성, 등분산성, 독립성, 정규성 등의 가정이 위배될 경우, p-value의 의미는 급격히 약화된다. 그러나 예측 문제에서는 이러한 가정이 반드시 성립할 필요가 없다. 비선형 모형, 트리, 신경망과 같이 p-value 자체가 정의되지 않는 모형들도 뛰어난 예측 성능을 가질 수 있다.</p>
<p>더 나아가, 예측 문제에서 변수 선택을 p-value에 의존할 경우 심각한 문제가 발생할 수 있다. p-value 기반 변수 선택은 훈련 데이터에 대한 통계적 유의성을 기준으로 하기 때문에, 일반화 성능과는 직접적인 연관이 없다. 이는 앞서 논의한 모형 선택 편향을 더욱 악화시킬 수 있다.</p>
<p>이러한 이유로 예측 문제에서의 모형 선택 기준은 p-value가 아니라 검증오차, 교차검증 오차, 그리고 테스트오차와 같은 일반화 성능 지표가 되어야 한다.</p>
<p>결론적으로, p-value는 <span dir="rtl">”</span>이 변수가 통계적으로 의미 있는가?“라는 질문에는 적절한 도구이지만, <span dir="rtl">”</span>이 모형이 미래를 잘 예측하는가?”라는 질문에는 답을 주지 않는다. 예측과 추론은 서로 경쟁하는 개념이 아니라, 서로 다른 질문에 답하는 서로 다른 목적의 분석이다. 예측 문제에서 중요한 것은 설명의 그럴듯함이 아니라, 보이지 않는 데이터에 대한 성능이다.</p>
<p><strong>통계적 사고에서 ML 사고로의 전환</strong></p>
<p>전통적인 통계 분석과 머신러닝은 동일한 데이터와 유사한 모형을 사용하는 경우가 많지만, 문제를 바라보는 사고방식에는 본질적인 차이가 있다. 이 차이를 이해하는 것은 예측모형을 올바르게 설계하고 해석하는 데 있어 매우 중요하다.</p>
<p>통계적 사고의 출발점은 모형 가정이다. 선형회귀를 예로 들면, 분석자는 먼저 반응변수와 설명변수 사이의 관계가 선형이라는 가정을 세우고, 오차항에 대해 독립성, 등분산성, 정규성 등의 조건을 부여한다. 이러한 가정 하에서 관심의 대상은 모수 <span class="math inline">\(\beta\)</span>이며, 데이터는 이 모수를 추론하기 위한 수단으로 사용된다. 즉, 통계적 사고에서의 핵심 질문은 <span dir="rtl">”</span>이 모수는 무엇이며, 얼마나 정확하게 추론할 수 있는가?“이다.</p>
<p>이와 달리 머신러닝적 사고의 출발점은 예측 성능이다. ML에서는 모형이 현실을 얼마나 정확히 설명하는가보다, 새로운 데이터에 대해 얼마나 잘 작동하는가가 우선적인 관심사이다. 따라서 특정한 함수 형태나 분포 가정을 강하게 두기보다는, 다양한 함수 공간을 열어두고 데이터가 그중에서 적절한 함수를 선택하도록 한다. 이때 관심의 대상은 개별 모수가 아니라, 전체 함수 <span class="math inline">\(\widehat{f}(X)\)</span>의 일반화 성능이다.</p>
<p>이 차이는 손실함수의 역할에서도 분명히 드러난다. 통계적 추론에서는 우도 함수와 그로부터 유도되는 검정통계량이 중심이 되는 반면, 머신러닝에서는 명시적인 손실함수 <span class="math inline">\(L(Y,f(X))\)</span>를 정의하고, 그 기댓값을 최소화하는 방향으로 학습이 이루어진다. 이 관점에서 보면, 예측 문제는 본질적으로 최적화 문제이며, 확률모형은 그중 하나의 선택지일 뿐이다.</p>
<p>또 하나의 중요한 전환점은 모형 복잡도에 대한 태도이다. 통계적 사고에서는 과도한 복잡성이 해석을 어렵게 하고 가정 위반의 위험을 높이기 때문에, 가능한 한 단순한 모형이 선호된다. 반면 머신러닝에서는 복잡한 모형 자체를 문제로 보지 않는다. 대신, 복잡도가 일반화 성능을 해치지 않도록 규제와 검증을 통해 통제한다. 즉, ML 사고에서는 <span dir="rtl">”</span>모형은 복잡해도 좋지만, 검증오차로 검증되어야 한다”는 원칙이 작동한다.</p>
<p>데이터의 역할 역시 다르게 인식된다. 통계적 추론에서 데이터는 불확실성을 줄이기 위한 표본이며, 표본의 크기가 작더라도 이론적 분포에 근거한 추론이 가능하다. 반면 머신러닝에서는 데이터의 양이 모형 성능을 결정하는 핵심 자원이며, 데이터가 많아질수록 더 유연한 함수 공간을 사용할 수 있다. 이 때문에 ML에서는 <span dir="rtl">”</span>좋은 가정”보다 <span dir="rtl">”</span>충분한 데이터와 검증 절차”가 더 중요해진다.</p>
<p>이러한 차이를 종합하면, 통계적 사고에서 머신러닝 사고로의 전환은 다음과 같이 요약할 수 있다.</p>
<p>통계적 사고는 모형 가정 → 모수 추론 → 해석과 검정의 흐름을 따른다면, 머신러닝 사고는 손실함수 정의 → 함수 공간 선택 → 검증 기반 성능 평가의 흐름을 따른다.</p>
<p>이 전환은 통계를 부정하는 것이 아니라, 통계적 사고를 더 넓은 예측 프레임 안으로 확장하는 것이다. 실제로 많은 머신러닝 방법은 통계적 원리에서 출발하며, 규제, 교차검증, 편향–분산 트레이드오프와 같은 핵심 개념은 양쪽을 연결하는 공통 언어이다.</p>
<p>결론적으로, 예측 문제에서 요구되는 사고방식은 <span dir="rtl">”</span>이 모형이 의미 있는가?“가 아니라 <span dir="rtl">”</span>이 모형이 미래에도 잘 작동하는가?”이다. 이 질문에 답하기 위해서는 통계적 추론의 도구를 넘어, 머신러닝적 검증과 선택의 논리를 함께 받아들여야 한다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>