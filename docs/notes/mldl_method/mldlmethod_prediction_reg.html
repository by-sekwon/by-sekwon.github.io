<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>MLDL 예측방법. 2.회귀분석 – 세상의 모든 통계 이야기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-2757cfadcc89ddbfb9e61569f8c3689f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">세상의 모든 통계 이야기</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../notes/math_stat/index.html"> 
<span class="menu-text">기초·수리통계</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/intro_stat/index.html"> 
<span class="menu-text">기초통계·조사방법</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/linear_model/index.html"> 
<span class="menu-text">회귀·다변량분석</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl/index.html"> 
<span class="menu-text">MLDL 개념 w/GPT</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../notes/mldl_method/index.html" aria-current="page"> 
<span class="menu-text">MLDL 예측방법 w/GPT</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cardnews/index.html"> 
<span class="menu-text">카드뉴스</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../consult.html"> 
<span class="menu-text">통계상담</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../notes/mldl_method/mldlmethod_prediction_reg.html">📄 예측방법: 회귀분석</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">【머신·딥러닝 예측방법】</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 MLDL 방법론 소개</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_prediction_intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 예측방법: 서론</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_prediction_reg.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">📄 예측방법: 회귀분석</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_prediction_regulation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 예측방법: 규제회귀</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_prediction_dimension.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 예측방법: 차원축소</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_prediction_nonreg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 예측방법: 비선형회귀</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_prediction_treebase.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 예측방법: 트리기반</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_prediction_deeplearning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 예측방법: 딥러닝회귀</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#chapter-2.-고전적-선형회귀모형" id="toc-chapter-2.-고전적-선형회귀모형" class="nav-link active" data-scroll-target="#chapter-2.-고전적-선형회귀모형">Chapter 2. 고전적 선형회귀모형</a>
  <ul>
  <li><a href="#선형회귀모형-개념" id="toc-선형회귀모형-개념" class="nav-link" data-scroll-target="#선형회귀모형-개념">1. 선형회귀모형 개념</a></li>
  <li><a href="#선형회귀모형-가정" id="toc-선형회귀모형-가정" class="nav-link" data-scroll-target="#선형회귀모형-가정">2. 선형회귀모형 가정</a></li>
  <li><a href="#회귀계수-추론" id="toc-회귀계수-추론" class="nav-link" data-scroll-target="#회귀계수-추론">3. 회귀계수 추론</a></li>
  <li><a href="#모형-선택-기준" id="toc-모형-선택-기준" class="nav-link" data-scroll-target="#모형-선택-기준">4. 모형 선택 기준</a></li>
  <li><a href="#변수-선택" id="toc-변수-선택" class="nav-link" data-scroll-target="#변수-선택">5. 변수 선택</a></li>
  <li><a href="#범주형-설명변수" id="toc-범주형-설명변수" class="nav-link" data-scroll-target="#범주형-설명변수">6. 범주형 설명변수</a></li>
  <li><a href="#사례분석" id="toc-사례분석" class="nav-link" data-scroll-target="#사례분석">7. 사례분석</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">MLDL 예측방법. 2.회귀분석</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="chapter-2.-고전적-선형회귀모형" class="level3">
<h3 class="anchored" data-anchor-id="chapter-2.-고전적-선형회귀모형">Chapter 2. 고전적 선형회귀모형</h3>
<section id="선형회귀모형-개념" class="level4">
<h4 class="anchored" data-anchor-id="선형회귀모형-개념">1. 선형회귀모형 개념</h4>
<p>가장 기본적인 예측모형은 선형회귀모형이다. 선형회귀는 설명변수와 반응변수 사이의 관계를 비교적 단순한 수학적 구조로 표현하면서도, 예측과 추론이라는 두 목적을 동시에 수행할 수 있는 대표적인 통계 모형이다.</p>
<p>다중선형회귀모형은 일반적으로 다음과 같이 표현된다. <span class="math inline">\(Y = \beta_{0} + \beta_{1}X_{1} + \cdots + \beta_{p}X_{p} + \varepsilon\)</span>, 여기서 Y는 반응변수, <span class="math inline">\(X_{1},\ldots,X_{p}\)</span>는 설명변수, <span class="math inline">\(\beta_{0},\beta_{1},\ldots,\beta_{p}\)</span>는 미지의 회귀계수이며, <span class="math inline">\(\varepsilon\)</span>는 평균이 0인 오차항이다. 이 모형에서 오차항은 설명변수로 설명되지 않는 변동을 나타내며, 확률적 불확실성을 수학적으로 표현하는 역할을 한다.</p>
<p>선형회귀의 핵심적인 특징은 예측 문제를 모수적 함수 추정 문제로 단순화한다는 점이다. 즉, 무한히 많은 가능한 함수 중에서 <span class="math inline">\(f(x) = \beta_{0} + \beta^{\top}x\)</span>와 같은 유한차원 함수 공간만을 고려함으로써, 예측 문제를 소수의 모수 <span class="math inline">\(\beta\)</span>를 추정하는 문제로 환원한다. 이로 인해 선형회귀는 계산적으로 효율적이며, 해석 가능한 구조를 갖는다.</p>
<p>이러한 단순성은 선형회귀의 가장 큰 장점이기도 하다. 각 회귀계수 <span class="math inline">\(\beta_{j}\)</span>는 다른 변수들이 고정된 상태에서 <span class="math inline">\(X_{j}\)</span>가 한 단위 증가할 때 반응변수의 평균이 얼마나 변화하는지를 나타내는 명확한 의미를 가진다. 또한 최소제곱추정량은 수학적으로 명시적인 형태를 가지며, 그 통계적 성질(불편성, 불편성을 갖는 추정량 중 최소분산, 신뢰구간, 가설검정 추론)을 이론적으로 정확히 분석할 수 있다.</p>
<p>선형회귀모형은 이러한 이유로 통계학과 데이터 분석 전반에서 가장 널리 사용되는 예측 및 추론 도구로 자리 잡아 왔다. 그러나 이러한 활용 가능성은 임의적인 것이 아니라, 모형이 전제하는 몇 가지 핵심 가정이 충족될 때 비로소 보장된다. 선형성, 독립성, 등분산성, 그리고 추론 목적에서의 정규성 가정은 단순한 기술적 조건이 아니라, 회귀계수의 해석 가능성과 예측 결과의 신뢰성을 뒷받침하는 논리적 기반을 이룬다.</p>
<p>즉, 선형회귀는 <span dir="rtl">”</span>항상 잘 작동하는 만능 모형”이 아니라, 명확한 가정 하에서 안정성과 해석력을 제공하는 모형이다. 이러한 가정을 이해하고 그 의미를 정확히 인식하는 것은, 선형회귀를 예측 도구로 올바르게 활용하고, 나아가 더 유연한 머신러닝 모형으로 확장해 나가기 위한 출발점이 된다.</p>
</section>
<section id="선형회귀모형-가정" class="level4">
<h4 class="anchored" data-anchor-id="선형회귀모형-가정">2. 선형회귀모형 가정</h4>
<section id="기본-가정" class="level5">
<h5 class="anchored" data-anchor-id="기본-가정">(1) 기본 가정</h5>
<p><strong>1. 선형성(linearity)</strong></p>
<p>선형성 가정이란, 설명변수 X가 주어졌을 때 반응변수의 조건부 기댓값이 설명변수의 선형결합으로 표현될 수 있다는 것을 의미한다.</p>
<p><span class="math display">\[\mathbb{E}(Y \mid X) = \beta_{0} + \beta_{1}X_{1} + \cdots + \beta_{p}X_{p}\]</span></p>
<p>이 가정이 필요한 이유는, 선형회귀가 본질적으로 제한된 함수 공간 안에서 조건부 평균을 근사하는 방법이기 때문이다. 만약 실제 조건부 평균 함수가 강한 비선형 구조를 가진다면, 선형모형은 구조적으로 이를 표현할 수 없으며, 이는 체계적인 편향(bias)으로 이어진다.</p>
<p>중요한 점은, 선형성 가정이 반드시 변수 자체에 대한 선형성을 의미하지는 않는다는 것이다. 설명변수를 로그 변환하거나 다항식 항을 추가하는 경우에도, 모형은 여전히 계수에 대해 선형이며 선형회귀의 틀 안에 있다. 따라서 선형성 가정은 <span dir="rtl">”</span>현상을 단순하게 본다”기보다는, 모형을 통해 표현 가능한 함수 형태를 명시적으로 제한하는 선택으로 이해하는 것이 바람직하다.</p>
<p><strong>2. 독립성(independence)</strong></p>
<p>독립성 가정은 오차항들이 서로 독립이라는 조건이다.</p>
<p><span class="math display">\[\varepsilon_{1},\varepsilon_{2},\ldots,\varepsilon_{n}\text{are independent}\]</span></p>
<p>이 가정이 중요한 이유는, 회귀계수의 분산 추정과 통계적 추론이 관측치 간 독립성을 전제로 이루어지기 때문이다. 오차가 서로 상관되어 있을 경우, 표준오차는 실제보다 과소 또는 과대 추정될 수 있으며, 이는 신뢰구간과 가설검정 결과를 왜곡한다.</p>
<p>특히 시계열 자료나 공간 자료에서는 독립성 가정이 쉽게 깨진다. 이 경우에도 회귀계수 자체는 계산될 수 있지만, 그 불확실성에 대한 해석은 더 이상 신뢰할 수 없게 된다. 즉, 독립성 가정은 계수의 크기보다 그 불확실성을 정확히 평가하기 위해 필요하다고 볼 수 있다.</p>
<p><strong>3. 등분산성(homoscedasticity)</strong></p>
<p>등분산성 가정은 오차항의 분산이 설명변수의 값과 무관하다는 조건이다.</p>
<p><span class="math display">\[\text{Var}(\varepsilon \mid X) = \sigma^{2}\]</span></p>
<p>이 가정이 필요한 이유는, 선형회귀에서 최소제곱추정량이 효율적인 추정량이 되기 위해서이다. 등분산성이 만족될 경우, 최소제곱법은 모든 선형 불편추정량 중 분산이 가장 작은 추정량이 된다(Gauss–Markov 정리).</p>
<p>등분산성이 깨지는 경우, 회귀계수 추정치 자체는 여전히 불편하지만, 분산이 불필요하게 커지거나 표준오차가 왜곡된다. 이는 추론의 신뢰성을 약화시키며, 예측구간의 폭 또한 부정확해진다. 따라서 등분산성 가정은 추정의 효율성과 예측 불확실성의 정확한 정량화를 위해 중요하다.</p>
<p><strong>4. 정규성(normality) (추론 목적일 경우)</strong></p>
<p>정규성 가정은 오차항이 정규분포를 따른다는 가정이다.</p>
<p><span class="math display">\[\varepsilon \sim \mathcal{N}(0,\sigma^{2})\]</span></p>
<p>이 가정은 예측 자체보다는 통계적 추론을 위해 필요하다. 오차가 정규분포를 따른다는 가정 하에서, 회귀계수의 표본분포 역시 정규분포를 따르게 되며, 이는 t-검정, F-검정, 신뢰구간과 같은 고전적 추론 도구의 이론적 근거가 된다.</p>
<p>중요한 점은, 데이터의 크기가 충분히 클 경우 중심극한정리에 의해 정규성 가정의 중요성이 감소한다는 것이다. 또한 예측 문제에서는 정규성이 충족되지 않더라도, 검증오차나 테스트오차 기반 평가가 가능하다. 따라서 정규성 가정은 추론 중심 분석에서 핵심적이며, 예측 중심 분석에서는 필수 조건은 아니다.</p>
<p><strong>5. 가정 위반의 현실적 의미</strong></p>
<p>이러한 가정이 모두 만족될 경우, 선형회귀는 해석 가능하고 안정적인 예측 도구가 된다. 각 계수는 명확한 의미를 가지며, 불확실성 또한 이론적으로 정량화할 수 있다. 그러나 현실 데이터에서는 비선형성, 다중공선성, 이분산성, 고차원 문제 등이 빈번하게 발생한다.</p>
<p>이때 중요한 점은, 가정 위반이 곧 <span dir="rtl">”</span>분석 불가능”을 의미하지는 않는다는 것이다. 대신 이는 선형회귀가 가정한 함수 공간과 데이터 구조가 잘 맞지 않음을 시사하는 신호로 해석해야 한다. 이러한 상황에서 규제 회귀, 트리 기반 모형, 딥러닝과 같은 방법은 가정을 완화하거나 다른 방식으로 일반화 성능을 확보하는 대안이 된다.</p>
<p>결론적으로, 선형회귀의 가정은 단순한 제약 조건이 아니라, 해석 가능성과 안정성을 얻기 위해 지불하는 대가이다. 예측 문제에서는 이 대가가 적절한지, 또는 더 유연한 함수 공간이 필요한지를 검증오차를 통해 판단하는 것이 핵심이다.</p>
</section>
<section id="선형회귀-실패" class="level5">
<h5 class="anchored" data-anchor-id="선형회귀-실패">(2) 선형회귀 실패</h5>
<p>선형회귀모형은 단순하고 해석 가능한 구조를 가지지만, 그 성능과 신뢰성은 모형이 전제하는 가정이 얼마나 현실 데이터와 잘 맞는가에 크게 의존한다. 가정이 심각하게 위반될 경우, 선형회귀는 더 이상 안정적인 예측 도구나 신뢰할 수 있는 추론 도구로 기능하지 못한다. 따라서 선형회귀가 <span dir="rtl">”</span>실패한다”는 것은 모형이 틀렸다는 의미라기보다는, 데이터가 선형회귀가 가정한 함수 공간과 맞지 않음을 드러내는 신호로 이해하는 것이 바람직하다.</p>
<p><strong>1. 비선형성: 구조적 편향의 발생</strong></p>
<p>선형회귀의 가장 근본적인 가정은 조건부 평균이 설명변수의 선형결합으로 표현될 수 있다는 것이다. 그러나 실제 데이터에서 반응변수와 설명변수의 관계가 강한 비선형 구조를 가진 경우, 선형회귀는 이를 표현할 수 없다. 이때 발생하는 문제는 단순한 오차 증가가 아니라, 체계적인 편향(structural bias) 이다.</p>
<p>비선형성이 존재하면, 아무리 데이터의 양이 많아도 선형회귀의 예측은 특정 방향으로 지속적으로 틀리게 된다. 이는 잔차가 설명변수의 값에 따라 패턴을 보이는 형태로 나타나며, 잔차–설명변수 산점도에서 곡선 구조가 관측되는 것이 대표적인 신호이다. 이러한 경우 선형회귀는 데이터의 본질적인 구조를 포착하지 못하고 있으며, 함수 공간 자체의 확장이 필요함을 시사한다.</p>
<p><strong>2. 독립성 위반: 불확실성의 왜곡</strong></p>
<p>관측치 간 오차가 서로 독립이라는 가정이 위반되는 경우, 회귀계수의 추정값 자체보다도 그 불확실성의 평가가 문제를 일으킨다. 시계열 자료나 공간 자료에서는 인접한 관측치들이 서로 상관되어 있는 경우가 많으며, 이때 표준오차는 실제보다 과소 추정되는 경향이 있다.</p>
<p>이러한 상황에서는 회귀계수가 통계적으로 매우 유의해 보이더라도, 이는 독립성 위반으로 인한 착시일 가능성이 크다. 즉, 모형이 예측값을 제공할 수는 있지만, 그 신뢰구간이나 가설검정 결과는 신뢰하기 어렵다. 독립성 위반은 선형회귀가 추론 도구로서 실패하는 대표적인 경우라 할 수 있다.</p>
<p><strong>3. 이분산성: 효율성 상실과 예측 불확실성 문제</strong></p>
<p>오차의 분산이 설명변수의 값에 따라 달라지는 이분산성은, 선형회귀가 제공하는 추정의 효율성을 약화시킨다. 이분산성이 존재할 경우 최소제곱추정량은 여전히 불편하지만, 더 이상 최소 분산을 가지는 추정량은 아니다.</p>
<p>이분산성의 신호는 잔차의 산포가 특정 구간에서 넓어지거나 좁아지는 패턴으로 나타난다. 이러한 경우 예측구간은 실제보다 과도하게 좁거나 넓게 설정될 수 있으며, 이는 예측의 불확실성을 잘못 전달하게 된다. 즉, 평균 예측값 자체보다 예측의 신뢰도가 훼손된다.</p>
<p><strong>4. 다중공선성: 해석 가능성의 붕괴</strong></p>
<p>설명변수들 사이에 강한 상관관계가 존재하는 다중공선성은, 선형회귀의 해석 가능성을 크게 떨어뜨린다. 이 경우 회귀계수는 데이터의 작은 변화에도 크게 흔들리며, 계수의 부호나 크기가 직관과 다르게 나타날 수 있다.</p>
<p>다중공선성이 존재하면 예측값 자체는 비교적 안정적인 경우도 많지만, 개별 계수의 의미는 모호해진다. 즉, 선형회귀는 예측 도구로서는 작동하지만 추론 도구로서는 실패할 수 있다. 이는 예측과 추론의 목적 차이를 다시 한 번 강조하는 사례이다.</p>
<p><strong>5. 고차원 문제: 과적합과 불안정성</strong></p>
<p>설명변수의 수가 관측치 수에 비해 많아지는 고차원 상황에서는, 선형회귀의 기본 가정 이전에 추정 자체가 불안정해진다. p가 n에 가까워지거나 이를 초과하면, 최소제곱해는 존재하지 않거나 극단적으로 불안정해진다.</p>
<p>이러한 상황에서 선형회귀는 훈련 데이터에는 잘 맞지만 새로운 데이터에 대해서는 예측 성능이 급격히 저하되는 과적합을 보인다. 이는 함수 공간이 데이터 양에 비해 지나치게 크다는 신호이며, 규제 회귀나 차원 축소가 필요함을 명확히 보여준다.</p>
</section>
<section id="선형회귀-실패의-의미" class="level5">
<h5 class="anchored" data-anchor-id="선형회귀-실패의-의미">(3) 선형회귀 실패의 의미</h5>
<p>중요한 점은, 선형회귀의 실패가 곧 분석의 실패를 의미하지는 않는다는 것이다. 오히려 이는 데이터가 더 풍부한 구조를 가지고 있음을 알려주는 진단 신호이다. 가정 위반은 모델을 버려야 한다는 메시지가 아니라, 함수 공간을 확장하거나, 규제를 도입하거나, 다른 예측 프레임으로 이동해야 한다는 संकेत이다.</p>
<p>결론적으로 선형회귀는 언제나 출발점으로서의 가치를 지닌다. 그러나 잔차 패턴, 불안정한 계수, 과도한 민감성 등은 모두 <span dir="rtl">”</span>이제 더 유연한 예측모형이 필요하다”는 신호로 해석되어야 한다. 이러한 인식 위에서 규제 회귀, 트리 기반 모형, 딥러닝으로의 확장이 자연스럽게 이어진다.</p>
</section>
<section id="선형회귀에서-머신러닝으로의-확장-경로" class="level5">
<h5 class="anchored" data-anchor-id="선형회귀에서-머신러닝으로의-확장-경로">(5) 선형회귀에서 머신러닝으로의 확장 경로</h5>
<p>선형회귀는 예측모형 설계의 출발점이다. 단순한 수학적 구조와 명확한 해석 가능성 덕분에, 선형회귀는 예측과 추론을 동시에 이해할 수 있는 가장 기본적인 틀을 제공한다. 그러나 현실 데이터가 점점 복잡해지고 고차원화됨에 따라, 선형회귀가 전제하는 가정과 함수 공간은 많은 경우 충분하지 않게 된다. 머신러닝으로의 확장은 이러한 한계를 인식하는 데서 자연스럽게 시작된다.</p>
<p><strong>1. 출발점: 선형회귀라는 제한된 함수 공간</strong></p>
<p>선형회귀는 예측 문제를 <span class="math inline">\(f(x) = \beta_{0} + \beta^{\top}x\)</span>와 같은 유한차원 선형 함수 공간에서 해결한다. 이는 예측 문제를 소수의 모수 추정 문제로 환원시켜 주며, 안정성과 해석력을 제공한다. 그러나 이 선택은 동시에 강한 제약이기도 하다. 실제 조건부 평균 함수가 비선형 구조를 가지거나, 변수 간 복잡한 상호작용이 존재할 경우, 선형회귀는 구조적으로 편향된 예측을 낳는다. 즉, 선형회귀는 <span dir="rtl">”</span>데이터가 단순할 것”을 전제로 한 예측모형이다.</p>
<p><strong>2. 첫 번째 확장: 규제를 통한 안정화</strong></p>
<p>선형회귀의 가장 흔한 실패는 비선형성보다는 불안정성에서 먼저 나타난다. 다중공선성이나 고차원 문제로 인해 계수가 폭주하고 예측이 흔들리는 경우, 함수 형태를 바꾸기보다는 먼저 함수 공간의 크기를 제어할 필요가 있다.</p>
<p>규제 회귀는 이 문제를 해결하는 첫 번째 확장이다. Ridge, Lasso, Elastic Net은 모두 선형 구조를 유지하면서 계수의 크기를 제한함으로써, 예측함수의 복잡도를 조절한다. 이는 선형회귀를 예측 중심으로 재해석한 결과이며, 통계적 회귀에서 머신러닝적 사고로 이동하는 중요한 전환점이다.</p>
<p>이 단계에서 이미 관심의 중심은 회귀계수의 유의성에서 벗어나, 검증오차와 일반화 성능으로 이동한다.</p>
<p><strong>3. 두 번째 확장: 특징공간의 비선형화</strong></p>
<p>규제로도 해결되지 않는 문제가 있다. 반응변수와 설명변수의 관계 자체가 비선형일 경우, 계수의 안정성보다 표현력의 한계가 더 큰 문제가 된다. 이때 등장하는 접근이 특징공간의 확장이다.</p>
<p>다항회귀, 스플라인, 커널 방법 등은 입력변수 X를 비선형 변환한 뒤, 그 변환된 공간에서 선형모형을 적용한다. 이는 <span dir="rtl">”</span>모형은 선형이되, 데이터 표현은 비선형”이라는 전략이다. 이 단계에서 예측모형은 점차 추론 중심의 틀을 벗어나, 함수 근사 관점으로 이동한다.</p>
<p><strong>4. 세 번째 확장: 구조적 비선형 모형</strong></p>
<p>특징공간 확장조차 명시적 설계에 의존한다는 한계를 가진다. 이에 대한 대안으로 등장한 것이 트리 기반 모형이다. 결정트리는 입력 공간을 분할하여 각 영역에서 단순한 예측을 수행하며, 변수 간 상호작용과 비선형성을 자동으로 포착한다.</p>
<p>랜덤 포레스트와 그래디언트 부스팅은 단일 트리의 불안정성을 앙상블로 해결하며, 예측 성능을 크게 향상시킨다. 이 단계에서 예측모형은 더 이상 명시적인 수식 형태를 갖지 않으며, 해석 가능성보다 성능과 안정성이 우선시된다.</p>
<p><strong>5. 네 번째 확장: 표현 학습으로서의 딥러닝</strong></p>
<p>머신러닝 확장의 최종 단계는 신경망 기반 모형이다. 딥러닝은 입력변수의 표현 자체를 데이터로부터 학습하며, 다층 비선형 변환을 통해 매우 넓은 함수 공간을 구성한다. 이론적으로 신경망은 임의의 연속함수를 근사할 수 있으며, 이는 선형회귀에서 출발한 함수 근사 문제의 극단적인 확장이라 할 수 있다.</p>
<p>이 단계에서는 모형 가정보다 데이터 양, 최적화 알고리즘, 규제 전략이 성능을 좌우한다. 예측은 완전히 데이터 주도적(data-driven) 과정이 된다.</p>
<p><strong>6. 확장의 핵심 논리</strong></p>
<p>선형회귀에서 머신러닝으로의 확장은 단절이 아니라 연속이다. 이 경로를 관통하는 공통 논리는 다음과 같다.</p>
<ul>
<li>예측은 조건부 평균 함수의 근사 문제이다.</li>
<li>실패의 원인은 대부분 함수 공간과 데이터 구조의 불일치이다.</li>
<li>확장은 함수 공간을 점진적으로 넓히는 과정이다.</li>
<li>넓어진 함수 공간은 규제와 검증으로 통제된다.</li>
</ul>
<p>즉, 머신러닝은 선형회귀를 부정하는 것이 아니라, 선형회귀의 한계를 체계적으로 확장한 결과이다.</p>
<p>선형회귀는 예측모형 설계의 시작점이며, 규제 회귀는 그 첫 번째 보완이다. 비선형 특징 확장과 트리 기반 모형은 표현력을 확장하고, 딥러닝은 표현 학습 자체를 자동화한다. 이 모든 과정은 <span dir="rtl">”</span>더 복잡한 모형으로 가는 길”이 아니라, 데이터가 요구하는 만큼 함수 공간을 확장하는 합리적 선택의 연속이다.</p>
<p>이러한 관점에서 머신러닝은 새로운 통계가 아니라, 예측 문제를 끝까지 밀어붙인 통계적 사고의 확장판이라고 이해할 수 있다.</p>
</section>
</section>
<section id="회귀계수-추론" class="level4">
<h4 class="anchored" data-anchor-id="회귀계수-추론">3. 회귀계수 추론</h4>
<section id="최소제곱-추정" class="level5">
<h5 class="anchored" data-anchor-id="최소제곱-추정">(1) 최소제곱 추정</h5>
<p>다중선형회귀모형에서는 하나의 반응변수가 여러 설명변수의 선형결합으로 표현된다. 관측값 <span class="math inline">\(i = 1,\ldots,n\)</span>에 대해 모형은 다음과 같이 주어진다.</p>
<p><span class="math inline">\(y_{i} = \beta_{0} + \beta_{1}x_{i1} + \beta_{2}x_{i2} + \cdots + \beta_{p}x_{ip} + \varepsilon_{i}\)</span>, <span class="math inline">\(\mathbf{y} = \mathbf{X}\mathbf{\beta} + \mathbf{\varepsilon}\)</span></p>
<p>여기서 <span class="math inline">\(\beta_{0},\beta_{1},\ldots,\beta_{p}\)</span>는 미지의 회귀계수이며, 실제 자료 분석에서는 이 계수들을 표본으로부터 추정해야 한다.</p>
<p>회귀계수 추정방법은 최소제곱법이며 관측값과 모형이 예측한 값 사이의 차이, 즉 잔차의 제곱합을 최소화하는 계수 벡터를 찾는 방법이다. 이를 수식으로 나타내면, 다음의 잔차제곱합을 최소화하는 <span class="math inline">\(\beta_{0},\beta_{1},\ldots,\beta_{p}\)</span>를 구하는 문제로 정식화된다.</p>
<p><span class="math display">\[RSS = \overset{n}{\sum_{i = 1}}\left( y_{i} - \beta_{0} - \beta_{1}x_{i1} - \beta_{2}x_{i2} - \cdots - \beta_{p}x_{ip} \right)^{2}\]</span></p>
<p><span class="math inline">\(S(\mathbf{\beta}) = (\mathbf{y} - \mathbf{X}\mathbf{\beta})^{\top}(\mathbf{y} - \mathbf{X}\mathbf{\beta})\)</span> ↔︎ <span class="math inline">\(\widehat{\mathbf{\beta}} = (\mathbf{X}^{\top}\mathbf{X})^{- 1}\mathbf{X}^{\top}\mathbf{y}\)</span></p>
<p>다중회귀모형에서 각 회귀계수 <span class="math inline">\(\beta_{j}\)</span>는 다른 모든 설명변수가 고정된 상태에서 <span class="math inline">\(x_{j}\)</span>가 한 단위 증가할 때 반응변수의 평균이 얼마나 변하는지를 나타낸다. 즉, 단순회귀와 달리 각 계수는 조건부 효과를 의미한다.</p>
<p>이러한 해석은 설명변수들 간의 상관관계가 존재할 때 특히 중요하다. 설명변수들이 서로 강하게 연관되어 있는 경우, 단순한 상관계수와 회귀계수의 부호나 크기가 일치하지 않을 수도 있다. 이는 다중회귀모형이 각 변수의 독립적인 기여도를 분리하여 추정하기 때문이다.</p>
</section>
<section id="최소제곱-추정치-성질" class="level5">
<h5 class="anchored" data-anchor-id="최소제곱-추정치-성질">(2) 최소제곱 추정치 성질</h5>
<p>오차항이 평균 0, 분산 <span class="math inline">\(\sigma^{2}\)</span>, 서로 독립이라는 가정하에서 최소제곱추정량은 다음과 같은 성질을 가진다.</p>
<p>첫째, <span class="math inline">\(\widehat{\mathbf{\beta}}\)</span>는 불편추정량이다. <span class="math inline">\(E(\widehat{\mathbf{\beta}}) = \mathbf{\beta}\)</span></p>
<p>둘째, <span class="math inline">\(\widehat{\mathbf{\beta}}\)</span>의 분산-공분산 행렬은 <span class="math inline">\(Var(\widehat{\mathbf{\beta}}) = \sigma^{2}(\mathbf{X}^{\top}\mathbf{X})^{- 1}\)</span>로 주어진다. 이 결과는 회귀계수의 표준오차, 신뢰구간, 가설검정의 기초가 된다.</p>
<p>셋째, 오차항이 정규분포를 따른다면, <span class="math inline">\(\widehat{\mathbf{\beta}}\)</span> 역시 다변량 정규분포를 따른다. 이 경우 정확한 t-검정과 F-검정을 수행할 수 있다.</p>
</section>
<section id="회귀계수의-표준오차와-t-검정" class="level5">
<h5 class="anchored" data-anchor-id="회귀계수의-표준오차와-t-검정">(3) 회귀계수의 표준오차와 t-검정</h5>
<p><span class="math inline">\(\widehat{\mathbf{\beta}}\)</span>의 분산-공분산 행렬은 <span class="math inline">\(Var(\widehat{\mathbf{\beta}}) = \sigma^{2}(\mathbf{X}^{\top}\mathbf{X})^{- 1}\)</span>은 추정량의 분산을 의미하며, 그 제곱근이 해당 회귀계수의 표준오차가 된다. 실제 분석에서는 <span class="math inline">\(\sigma^{2}\)</span>를 알 수 없으므로, 잔차를 이용해 다음과 같이 추정한다.</p>
<p><span class="math inline">\({\widehat{\sigma}}^{2} = \frac{1}{n - p - 1}\overset{n}{\sum_{i = 1}}{\widehat{\varepsilon}}_{i}^{2}\)</span>, 여기서 p는 설명변수의 개수이다.</p>
<p>회귀계수의 표준오차는 해당 계수 추정값이 표본에 따라 얼마나 크게 흔들릴 수 있는지를 나타낸다. 동일한 추정값이라 하더라도 표준오차가 작으면 비교적 안정적인 추정으로 해석할 수 있고, 표준오차가 크면 추정의 불확실성이 크다고 판단한다.</p>
<p>회귀계수가 통계적으로 유의한지를 판단하기 위해 t-검정을 사용한다. 다중회귀모형에서 가장 기본적인 가설은 다음과 같다.</p>
<p><span class="math display">\[H_{0}:\beta_{j} = 0\text{vs.}H_{1}:\beta_{j} \neq 0.\]</span></p>
<p>이는 다른 모든 설명변수를 고정한 상태에서, j번째 설명변수가 반응변수에 선형적인 영향을 미치지 않는다는 가설이다. 이에 대한 t-통계량은 다음과 같이 정의되고 오차항이 정규분포를 따른다는 가정하에서 다음이 성립한다.</p>
<p><span class="math display">\[t_{j} = \frac{{\widehat{\beta}}_{j}}{SE({\widehat{\beta}}_{j})} \sim t(n - p - 1)\]</span></p>
<p>다중회귀모형에서의 t-검정은 단순회귀와 해석이 다르다는 점에 주의해야 한다. 단순회귀에서의 t-검정은 설명변수 하나와 반응변수 간의 관계를 검정하는 반면, 다중회귀에서의 t-검정은 다른 모든 설명변수를 통제한 상태에서 해당 변수의 추가적인 설명력이 존재하는지를 검정한다. 따라서 단순회귀에서는 유의하던 설명변수가 다중회귀에서는 유의하지 않게 나타날 수 있다.</p>
</section>
<section id="모형-전체에-대한-분산분석" class="level5">
<h5 class="anchored" data-anchor-id="모형-전체에-대한-분산분석">(4) 모형 전체에 대한 분산분석</h5>
<p>앞에서는 개별 회귀계수의 유의성을 t-검정을 통해 살펴보았다. 그러나 다중회귀모형에서는 개별 설명변수의 효과뿐만 아니라, 모형 전체가 반응변수의 변동을 얼마나 잘 설명하는지도 함께 평가해야 한다. 이를 위해 사용하는 방법이 분산분석(analysis of variance, ANOVA)이다.</p>
<p>분산분석의 기본 아이디어는 반응변수의 총 변동을 모형에 의해 설명되는 부분과 설명되지 않는 부분으로 나누어 보는 것이다. 이를 위해 반응변수 <span class="math inline">\(y_{1},\ldots,y_{n}\)</span>에 대해 다음과 같은 제곱합 분해를 고려한다.</p>
<p><span class="math display">\[\overset{n}{\sum_{i = 1}}(y_{i} - \overline{y})^{2} = \overset{n}{\sum_{i = 1}}({\widehat{y}}_{i} - \overline{y})^{2} + \overset{n}{\sum_{i = 1}}(y_{i} - {\widehat{y}}_{i})^{2}.\]</span></p>
<p>왼쪽 항은 반응변수의 총제곱합(Total Sum of Squares, TSS)으로, 반응변수 전체의 변동성을 나타낸다. 오른쪽의 첫 번째 항은 회귀제곱합(Regression Sum of Squares, SSR)으로, 회귀모형에 의해 설명되는 변동을 의미한다. 두 번째 항은 잔차제곱합(Residual Sum of Squares, SSE)으로, 모형이 설명하지 못한 변동을 나타낸다. 이 분해는 다음과 같이 정리된다.</p>
<p><span class="math display">\[TSS = SSR + SSE\]</span></p>
<p>이러한 제곱합 분해를 바탕으로, 모형 전체의 유의성을 검정하기 위한 F-검정을 수행한다. 다중회귀모형에서 가장 기본적인 귀무가설은 다음과 같다.</p>
<p><span class="math inline">\(H_{0}:\beta_{1} = \beta_{2} = \cdots = \beta_{p} = 0\)</span>.</p>
<p>이는 모든 설명변수가 반응변수의 평균에 아무런 선형적 영향을 미치지 않는다는 가설로, 이 경우 모형은 단순히 반응변수의 평균만을 예측하는 모형과 동일해진다.</p>
<p>이에 대응하는 대립가설은 적어도 하나의 회귀계수가 0이 아니라는 것이다. 즉, 설명변수들 중 일부가 반응변수의 변동을 설명하는 데 기여하고 있는지를 검정하는 문제이다. 이 가설을 검정하기 위해 다음과 같은 F-통계량을 사용한다.</p>
<p><span class="math inline">\(F = \frac{\frac{SSR}{p}}{SSE/(n - p - 1)} \sim F(p,n - p - 1)\)</span>.</p>
<p>모형 전체에 대한 F-검정은 개별 회귀계수의 t-검정과 서로 다른 정보를 제공한다. F-검정은 설명변수들이 집합적으로 반응변수의 변동을 설명하는지를 평가하는 반면, t-검정은 각 설명변수의 조건부 효과를 평가한다. 따라서 개별 회귀계수가 모두 유의하지 않더라도, 모형 전체는 유의하게 나타날 수 있으며, 그 반대의 경우도 가능하다.</p>
<p>분산분석의 결과는 보통 분산분석표(ANOVA table)의 형태로 제시된다. 이 표에는 제곱합, 자유도, 평균제곱, F-통계량, 그리고 이에 대응하는 p-value가 정리되어 있으며, 이를 통해 모형 전체의 설명력을 체계적으로 평가할 수 있다.</p>
</section>
</section>
<section id="모형-선택-기준" class="level4">
<h4 class="anchored" data-anchor-id="모형-선택-기준">4. 모형 선택 기준</h4>
<section id="결정계수-r2와-수정된-r2" class="level5">
<h5 class="anchored" data-anchor-id="결정계수-r2와-수정된-r2">(1) 결정계수 <span class="math inline">\(R^{2}\)</span>와 수정된 <span class="math inline">\(R^{2}\)</span></h5>
<p>분산분석을 통해 다중회귀모형이 반응변수의 변동을 통계적으로 유의하게 설명하는지를 판단할 수 있다면, 결정계수 <span class="math inline">\(R^{2}\)</span>는 그 설명력이 어느 정도인지를 수치적으로 요약해 주는 지표이다. 즉, <span class="math inline">\(R^{2}\)</span>는 모형이 반응변수의 전체 변동 중 얼마만큼을 설명하고 있는지를 나타낸다.</p>
<p><span class="math display">\[R^{2} = \frac{SSR}{TSS} = 1 - \frac{SSE}{TSS}.\]</span></p>
<p>이 값은 0과 1 사이의 값을 가지며, <span class="math inline">\(R^{2}\)</span>가 클수록 회귀모형이 반응변수의 변동을 잘 설명한다고 해석한다. 예를 들어 <span class="math inline">\(R^{2} = 0.8\)</span>이라면, 반응변수 변동의 약 80%가 설명변수들에 의해 설명된다는 의미이다.</p>
<p>그러나 <span class="math inline">\(R^{2}\)</span>를 해석할 때는 중요한 주의점이 있다. 다중회귀모형에서 설명변수를 하나 추가하면, 해당 변수가 실제로 의미 있는 정보를 제공하지 않더라도 <span class="math inline">\(SSE\)</span>는 감소하거나 그대로 유지되기 때문에 R^2는 절대로 감소하지 않는다. 즉, 결정계수는 모형의 복잡도가 증가할수록 자동으로 커지는 성질을 가진다. 이로 인해 단순히 결정계수의 크기만으로 서로 다른 모형의 우열을 판단하는 것은 적절하지 않을 수 있다.</p>
<p>이러한 한계를 보완하기 위해 사용되는 지표가 수정된 결정계수이다. 수정된 결정계수는 설명변수의 개수와 표본크기를 함께 고려하여, 불필요한 변수를 추가했을 때 발생하는 과도한 설명력 증가를 보정한다. 수정된 결정계수는 다음과 같이 정의된다.</p>
<p><span class="math inline">\({\overline{R}}^{2} = 1 - \frac{SSE/(n - p - 1)}{TSS/(n - 1)},\)</span>여기서 n은 관측값의 수, p는 설명변수의 개수이다.</p>
<p>수정된 결정계수는 의미 없는 설명변수가 추가될 경우 감소할 수 있으며, 따라서 서로 다른 차수나 변수 개수를 가진 모형을 비교할 때 결정계수보다 더 합리적인 기준을 제공한다. 특히 다중회귀모형에서 설명변수의 수가 많아질수록 수정된 결정계수의 해석적 중요성은 커진다.</p>
<p>다만 수정된 결정계수 역시 한계가 존재한다. 이 지표는 모형의 적합도를 요약해 줄 뿐, 새로운 데이터에 대한 예측 성능을 직접적으로 반영하지는 않는다. 즉, 수정된 결정계수가 큰 모형이 항상 더 나은 일반화 성능을 갖는다고 보장할 수는 없다. 이러한 이유로 예측을 목적으로 하는 분석에서는 교차검증과 같은 재표본 기반 방법이 함께 사용된다.</p>
</section>
<section id="aic와-bic" class="level5">
<h5 class="anchored" data-anchor-id="aic와-bic">(2) AIC와 BIC</h5>
<p>앞에서 살펴본 t-검정과 F-검정은 회귀계수 또는 모형 전체의 통계적 유의성을 평가하는 데 유용한 도구이다. 그러나 이러한 검정은 특정 가설이 참인지 여부를 판단하는 데 초점이 맞추어져 있으며, 여러 후보 모형 중에서 어떤 모형이 더 적절한지를 직접적으로 비교하는 데에는 한계가 있다. 특히 설명변수의 수가 많아지거나, 서로 다른 구조를 가진 여러 모형을 비교해야 하는 상황에서는 모형 선택을 위한 보다 체계적인 기준이 필요하다.</p>
<p>이러한 맥락에서 등장한 것이 정보 기준(information criteria)이다. 정보 기준은 모형의 적합도와 복잡도를 동시에 고려하여, 서로 다른 모형들을 하나의 수치로 비교할 수 있도록 해 준다. 그중 가장 널리 사용되는 기준이 AIC와 BIC이다.</p>
<p>AIC(Akaike Information Criterion)는 모형이 데이터를 얼마나 잘 설명하는지와 동시에, 모형의 복잡도가 지나치게 커지는 것을 얼마나 억제하는지를 균형 있게 평가하기 위한 지표이다. 회귀모형에서 AIC는 다음과 같이 정의된다.</p>
<p><span class="math inline">\(AIC = - 2\log L + 2k\)</span>, 여기서 L은 모형의 최대우도값, k는 추정되는 모수의 개수이다. 첫 번째 항은 모형의 적합도를 나타내며, 두 번째 항은 모형의 복잡도에 대한 벌점(penalty)을 의미한다. AIC는 값이 작을수록 더 좋은 모형으로 간주된다.</p>
<p>BIC(Bayesian Information Criterion)는 AIC와 유사한 구조를 가지지만, 모형의 복잡도에 대해 더 강한 벌점을 부과한다. BIC는 다음과 같이 정의된다.</p>
<p><span class="math inline">\(BIC = - 2\log L + k\log n\)</span>, 여기서 n은 표본의 크기이다. BIC에서는 표본 크기가 커질수록 복잡한 모형에 대한 벌점이 커지므로, 상대적으로 단순한 모형을 더 선호하는 경향을 가진다.</p>
<p>AIC와 BIC의 차이는 모형 선택의 관점 차이로 이해할 수 있다. AIC는 주어진 데이터 생성 과정을 가장 잘 근사하는 모형을 찾는 데 초점을 두며, 예측 성능을 중시하는 기준으로 해석할 수 있다. 반면 BIC는 실제 데이터 생성 모형이 후보 모형 집합 안에 존재한다는 가정하에서, 그 모형을 식별하는 데 초점을 둔다. 이로 인해 BIC는 표본 크기가 충분히 큰 경우, 불필요한 설명변수를 포함하지 않는 보다 간결한 모형을 선택하는 경향을 보인다.</p>
<p>중요한 점은 AIC와 BIC 모두 가설검정과는 다른 철학을 따른다는 것이다. 이 기준들은 특정 가설의 참·거짓을 판단하지 않으며, p-value를 제공하지도 않는다. 대신 여러 후보 모형을 상대적으로 비교하여, 정보 손실이 가장 적을 것으로 기대되는 모형을 선택하는 데 목적이 있다. 따라서 AIC나 BIC가 작은 모형이 반드시 <span dir="rtl">”</span>참인 모형”이라고 해석해서는 안 되며, 단지 비교 대상 중에서 상대적으로 더 적합하다고 판단되는 모형일 뿐이다.</p>
<p>정리하면, t-검정과 F-검정은 추론 중심의 질문에 답하는 도구인 반면, AIC와 BIC는 모형 선택이라는 실용적인 문제에 초점을 둔 기준이다. 이들은 회귀모형의 해석 단계에서 예측과 선택의 단계로 넘어가는 중요한 연결 고리를 형성하며, 이후 다룰 머신러닝 기반 모형 선택과도 자연스럽게 이어진다.</p>
</section>
<section id="aicbic와-교차검증의-비교" class="level5">
<h5 class="anchored" data-anchor-id="aicbic와-교차검증의-비교">(3) AIC/BIC와 교차검증의 비교</h5>
<p>AIC와 BIC는 모형의 적합도와 복잡도를 동시에 고려하는 정보 기준으로, 서로 다른 회귀모형을 비교하고 선택하는 데 유용한 도구이다. 한편, 교차검증은 재표본을 통해 모형의 일반화 성능을 직접적으로 추정하는 방법이다. 두 접근법은 모두 모형 선택에 사용되지만, 그 목적과 철학은 본질적으로 다르다.</p>
<p>AIC와 BIC는 최대우도 추정에 기반한 기준으로, 하나의 데이터셋을 이용해 계산된다. 이 기준들은 모형이 주어진 데이터를 얼마나 잘 설명하는지를 나타내는 우도 항과, 모형의 복잡도에 대한 벌점 항을 결합한 형태를 가진다. 따라서 AIC와 BIC는 동일한 데이터에 대해 여러 모형을 비교할 수 있는 간결한 수치를 제공하며, 계산 비용이 매우 적다는 장점이 있다.</p>
<p>반면 교차검증은 데이터를 반복적으로 분할하여, 학습에 사용되지 않은 데이터에서의 성능을 평가함으로써 테스트 오차를 추정한다. 교차검증은 모형의 일반화 능력을 직접적으로 평가한다는 점에서 예측 문제에 매우 적합한 방법이다. 특히 모형의 구조가 복잡하거나, 닫힌형 해석이 어려운 머신러닝 모형에서는 교차검증이 사실상 표준적인 모형 선택 도구로 사용된다.</p>
<p>이러한 차이로 인해 AIC/BIC와 교차검증은 서로 다른 질문에 답한다. AIC와 BIC는 <span dir="rtl">”</span>주어진 데이터 생성 과정을 가장 잘 근사하는 모형은 무엇인가”라는 질문에 초점을 두는 반면, 교차검증은 <span dir="rtl">”</span>새로운 데이터에서 가장 작은 예측 오차를 보일 모형은 무엇인가”라는 질문에 답한다. 따라서 두 기준은 선택하는 모형이 서로 다를 수 있으며, 이는 방법론의 우열 문제가 아니라 목적의 차이에서 비롯된다.</p>
<p>또한 두 접근법은 표본 크기와 모형 복잡도에 대한 민감도에서도 차이를 보인다. BIC는 표본 크기가 커질수록 복잡한 모형에 대해 강한 벌점을 부과하므로, 일관적으로 단순한 모형을 선택하는 경향을 가진다. 반면 교차검증은 표본 크기가 충분히 크고 데이터가 대표성을 가질수록, 보다 복잡한 모형을 선택하는 경향을 보일 수 있다. AIC는 이러한 두 극단 사이에 위치한 기준으로 이해할 수 있다.</p>
<p>실제 분석에서는 AIC/BIC와 교차검증을 대립적인 방법으로 보기보다는, 서로 보완적인 도구로 사용하는 것이 바람직하다. 예를 들어 해석과 추론이 중요한 분석에서는 AIC나 BIC를 통해 간결한 모형을 선택한 뒤, 교차검증을 통해 예측 성능이 지나치게 나쁘지 않은지를 확인할 수 있다. 반대로 예측이 주된 목적이라면 교차검증을 중심으로 모형을 선택하되, 선택된 모형이 과도하게 복잡하지 않은지 AIC나 BIC로 점검할 수 있다.</p>
<p>정리하면, AIC와 BIC는 정보 이론과 우도 기반의 모형 선택 기준이며, 교차검증은 재표본을 통한 일반화 성능 평가 방법이다. 어느 방법이 더 우수한지를 묻기보다는, 분석의 목적이 설명과 추론인지, 아니면 예측과 일반화인지에 따라 적절한 기준을 선택하는 것이 중요하다.</p>
</section>
</section>
<section id="변수-선택" class="level4">
<h4 class="anchored" data-anchor-id="변수-선택">5. 변수 선택</h4>
<section id="부분-설명변수들-f-검정" class="level5">
<h5 class="anchored" data-anchor-id="부분-설명변수들-f-검정">(1) 부분 설명변수들 F-검정</h5>
<p>다중회귀분석에서 때로는 모든 설명변수가 아니라, 특정한 q개의 회귀계수가 동시에 0인지 여부를 검정하고자 할 수도 있다. 이 경우 귀무가설은 <span class="math inline">\(H_{0}:\beta_{p - q + 1} = \beta_{p - q + 2} = \cdots = \beta_{p} = 0\)</span>의 형태를 갖는다.</p>
<p>이때 해당 q개의 변수를 제외한 축소 모형을 적합하고, 그 잔차제곱합을 <span class="math inline">\(SSE_{0}\)</span>라 하면, 적절한 F-통계량은 <span class="math inline">\(F = \frac{(SSE_{0} - SSE)/q}{SSE/(n - p - 1)} \sim F(q,n - p - 1)\)</span>으로 정의된다. 이는 전체 모형과 축소 모형을 비교하는 중첩 모형 검정의 형태이다.</p>
<p>F-검정을 통해 적어도 하나의 설명변수가 반응변수와 관련되어 있다는 결론을 얻었다면, 다음으로 자연스럽게 떠오르는 질문은 어떤 설명변수들이 중요한가 하는 것이다.</p>
<p>개별 회귀계수의 t-검정과 p-value를 통해 이를 판단할 수 있지만, 설명변수의 수 p가 큰 경우에는 우연에 의한 잘못된 발견이 발생할 가능성이 높아진다. 실제로는 모든 설명변수가 중요한 경우도 있지만, 대부분의 경우 반응변수는 설명변수의 일부와만 관련되어 있다.</p>
</section>
<section id="f-검정과-t-검정의-관계" class="level5">
<h5 class="anchored" data-anchor-id="f-검정과-t-검정의-관계">(2) F-검정과 t-검정의 관계</h5>
<p>다중회귀모형에서 t-검정은 다음과 같은 귀무가설을 검정한다.</p>
<p><span class="math inline">\(H_{0}:\beta_{j} = 0\)</span>. 이는 다른 모든 설명변수를 고정한 상태에서 j번째 설명변수가 반응변수에 선형적인 영향을 미치지 않는다는 가설이다. 이에 대한 t-통계량은 회귀계수 추정값을 그 표준오차로 나눈 값이며, 오차항이 정규분포를 따른다는 가정하에서 자유도 n-p-1인 t-분포를 따른다.</p>
<p>반면, F-검정은 다음과 같은 모형 전체에 대한 귀무가설을 검정한다.</p>
<p><span class="math inline">\(H_{0}:\beta_{1} = \beta_{2} = \cdots = \beta_{p} = 0\)</span>.</p>
<p>이는 모든 설명변수가 동시에 반응변수의 평균에 영향을 미치지 않는다는 가설로, 이 경우 회귀모형은 단순히 반응변수의 평균만을 예측하는 모형과 동일해진다. F-통계량은 회귀제곱합과 잔차제곱합의 비율을 이용해 구성되며, 자유도 p와 n-p-1을 갖는 F-분포를 따른다.</p>
<p>이 두 검정의 관계는 설명변수의 개수가 하나일 때 가장 명확하게 드러난다. 설명변수가 하나인 단순선형회귀모형에서는 모형 전체에 대한 F-검정과 해당 회귀계수에 대한 t-검정이 본질적으로 동일한 정보를 제공한다. 실제로 이 경우 F-통계량과 t-통계량 사이에는 다음과 같은 관계가 성립한다.</p>
<p><span class="math inline">\(F = t^{2}\)</span>. 즉, 단순회귀에서는 F-검정과 t-검정이 동일한 가설을 서로 다른 방식으로 검정하고 있는 것이다.</p>
<p>다중회귀모형에서는 이러한 일대일 대응이 성립하지 않는다. t-검정은 각 설명변수가 다른 변수들을 통제한 상태에서 추가적인 설명력을 가지는지를 개별적으로 평가하는 반면, F-검정은 설명변수들이 집합적으로 반응변수의 변동을 설명하는지를 평가한다. 따라서 어떤 경우에는 모형 전체에 대한 F-검정은 유의하지만, 개별 회귀계수에 대한 t-검정은 모두 유의하지 않을 수도 있다. 이는 설명변수들이 함께 있을 때는 의미 있는 설명력을 가지지만, 개별적으로는 강한 효과를 보이지 않는 상황을 반영한다.</p>
<p>반대로, 특정 회귀계수에 대한 t-검정이 유의하다고 해서 반드시 모형 전체의 F-검정이 유의하다고 보장되는 것은 아니다. 특히 설명변수의 수가 많고 표본 크기가 제한적인 경우, 이러한 차이가 더 뚜렷하게 나타날 수 있다.</p>
<p>정리하면, t-검정은 개별 회귀계수의 조건부 효과를 평가하는 도구이며, F-검정은 모형 전체의 집합적 설명력을 평가하는 도구이다. 두 검정은 서로 보완적인 역할을 하며, 다중회귀모형의 해석에서는 어느 하나만이 아니라 두 결과를 함께 고려하는 것이 중요하다.</p>
</section>
<section id="유의한-변수-선택-개념" class="level5">
<h5 class="anchored" data-anchor-id="유의한-변수-선택-개념">(3) 유의한 변수 선택 개념</h5>
<p>설명변수 p개 중 일부를 골라 모형을 구성하는 문제를 변수 선택이라 한다. 가능한 부분집합 모형의 수는 공집합(절편만)까지 포함하면 <span class="math inline">\(2^{p}\)</span></p>
<p>개이며, 예를 들어 p=30이면 <span class="math inline">\(2^{30} = 1,073,741,824\)</span>로 약 10억 개가 되어 전수 비교는 현실적으로 불가능하다. 따라서 실제 분석에서는 (1) 순차적 탐색(전진/후진/혼합), (2) 정보기준·검정 기반 중단 규칙, (3) 교차검증 기반 예측오차 최소화를 이용해 <span dir="rtl">”</span>좋은” 부분집합을 찾는다.</p>
<p>변수 선택에서 <span dir="rtl">”</span>좋다”는 의미는 목적에 따라 달라진다.</p>
<ul>
<li>설명/해석 중심: 유의성(p-value), 단순성(변수 수), 해석 가능성</li>
<li>예측 중심: 검증(또는 교차검증) 오차 최소화</li>
<li>모형 균형: 적합도와 복잡도 절충(AIC, BIC, C_p, Adjusted <span class="math inline">\(R^{2}\)</span>)</li>
</ul>
</section>
<section id="고전적인-방법" class="level5">
<h5 class="anchored" data-anchor-id="고전적인-방법">(4) 고전적인 방법</h5>
<p><strong>1. 전진 선택법(Forward Selection)</strong></p>
<p>절편만 포함된 모형에서 시작하여, 추가했을 때 가장 큰 적합도 개선(예: SSE 감소, 또는 AIC/BIC 개선)을 주는 변수를 하나씩 넣는다.</p>
<p>【절차】</p>
<p>1. 초기 모형: <span class="math inline">\(M_{0}:y = \beta_{0} + \varepsilon\)</span></p>
<p>2. 현재 모형 <span class="math inline">\(M_{k}\)</span>에 포함되지 않은 변수들 중 하나 <span class="math inline">\(x_{j}\)</span>를 각각 추가한 후보모형 <span class="math inline">\(M_{k} + x_{j}\)</span>들을 만든다.</p>
<p>3. 각 후보모형에 대해 성능을 평가한다. 대표적으로 SSE 감소량 <span class="math inline">\(\Delta SSE = SSE(M_{k}) - SSE(M_{k} + x_{j})\)</span> 최대 또는 부분 F-검정(추가변수의 유의성), 또는 AIC/BIC/CV error가 가장 좋아지는 변수 선택 <span class="math inline">\(M_{k + 1}\)</span>로 업데이트한다.</p>
<p>4. 중단 규칙을 만족할 때까지 반복한다. 중단 규칙은 다음과 같다.</p>
<ul>
<li>새로 추가되는 변수의 <span class="math inline">\(p - value &gt; \alpha_{\text{in}}\)</span>이면 중단 (예: 0.05 또는 0.10)</li>
<li>AIC/BIC가 더 이상 개선되지 않으면 중단</li>
<li>교차검증 오차가 더 이상 감소하지 않으면 중단</li>
<li>최대 변수 수 <span class="math inline">\(k_{\max}\)</span>도달 시 중단</li>
</ul>
<p>계산이 빠르고 직관적이나 초기에 잘못 들어간 변수가 이후 선택을 왜곡할 수 있어 탐욕적 탐색, 상호작용/비선형 구조에는 취약하다.</p>
<p>탐욕적 탐색이란 여러 선택지 중에서 매 단계마다 현재 기준에서 가장 좋아 보이는 선택을 우선적으로 택해 해를 구성해 나가는 탐색 방법이다. 예를 들어 변수 선택에서 전진 선택법은 <span dir="rtl">”</span>지금 추가했을 때 SSE를 가장 크게 감소시키는 변수”를 하나씩 더하는 방식으로 진행되는데, 이는 각 단계의 결정이 그 순간에는 최선처럼 보이더라도 전체적으로 가장 좋은 변수 조합(전역 최적 모형)에 도달한다는 보장이 없다는 점에서 탐욕적 탐색의 전형적 사례이다. 따라서 탐욕적 탐색은 계산 효율이 높아 실무에서 널리 사용되지만, 변수들 간 상관이나 상호작용 구조가 강한 경우에는 선택 결과가 국소 최적에 머물 수 있으므로 교차검증이나 안정성 평가 등으로 결과의 타당성을 함께 점검하는 것이 바람직하다.</p>
<p><strong>2. 후진 제거법(Backward Elimination)</strong></p>
<p>모든 설명변수를 포함한 모형에서 시작하여, 가장 덜 중요한 변수부터 제거한다. 보통 <span dir="rtl">”</span>덜 중요함”은 p-value가 크다는 뜻으로 잡는다.</p>
<p>【절차】</p>
<p>1. 초기 모형: <span class="math inline">\(M_{p}\)</span>, 모든 p개 변수 포함한다.</p>
<p>2. 각 변수의 회귀계수에 대한 t-검정 p-value를 계산한다.</p>
<p>3. p-value가 가장 큰 변수(가장 유의하지 않은 변수)를 제거하여 모형을 갱신한다.</p>
<p>4. 모든 남은 변수의 p-value가 충분히 작아질 때까지(또는 AIC/BIC/CV 기준이 개선될 때까지) 반복한다.</p>
<ul>
<li>모든 변수의 <span class="math inline">\(p - value \leq \alpha_{\text{out}}\)</span>이면 중단 (예: 0.05)</li>
<li>BIC 최소가 되는 지점에서 중단(해석 중심에서 자주 사용)</li>
<li>교차검증 오차 최소 지점에서 중단(예측 중심)</li>
</ul>
<p>큰 모형에서 시작하므로 <span dir="rtl">”</span>누락 위험”이 상대적으로 적으나 p가 크거나 <span class="math inline">\(p &gt; n\)</span>이면 시작 자체가 불가능(최소제곱 추정 불가), 다중공선성이 크면 p-value가 불안정하여 제거되지 않는 한계를 지닌다.</p>
<p><strong>3. 혼합 선택법(Mixed / Stepwise Selection)</strong></p>
<p>전진 선택을 하되, 변수를 추가하는 과정에서 이미 포함된 변수 중 중요도가 떨어진 변수를 다시 제거한다. 즉, <span dir="rtl">”</span>넣고(Forward)–빼고(Backward)“를 함께 수행한다.</p>
<p>【절차】</p>
<p>1. 절편 모형에서 시작한다.</p>
<p>2. 전진 단계: 추가 후보 중 가장 좋은 변수 1개를 추가(예: <span class="math inline">\(p - value \leq \alpha_{\text{in}}\)</span>또는 AIC 개선)한다.</p>
<p>3. 후진 점검: 현재 모형의 변수들 중 p-value가 <span class="math inline">\(\alpha_{\text{out}}\)</span>보다 큰 것이 있으면 제거(보통 <span class="math inline">\(\alpha_{\text{out}} \geq \alpha_{\text{in}}\)</span>)한다.</p>
<p>4. 더 이상 추가/제거가 일어나지 않을 때까지 반복한다.</p>
<p>전진/후진 단독보다 유연하며 실무에서 계산 부담이 적으나 같은 데이터로 반복 검정을 수행하므로 선택 후 p-value 해석이 과도하게 낙관적이 될 수 있고(선택 편의), 표본이 조금만 바뀌어도 선택 결과가 흔들릴 수 있다.</p>
</section>
<section id="빅데이터p가-매우-큼-p-gg-n에서의-변수-선택-방법" class="level5">
<h5 class="anchored" data-anchor-id="빅데이터p가-매우-큼-p-gg-n에서의-변수-선택-방법">(5) 빅데이터(p가 매우 큼, <span class="math inline">\(p \gg n\)</span>)에서의 변수 선택 방법</h5>
<p>순차선택(전진/후진/stepwise)은 p가 커지면 계산·안정성·과적합 문제로 한계가 뚜렷하다. 빅데이터에서는 다음 계열의 방법이 표준처럼 쓰인다.</p>
<p>트리·부스팅 기반(Embedded) 선택: Random Forest / XGBoost 등</p>
<p>결정트리 계열은 학습 과정에서 분할에 기여하는 변수를 반복적으로 사용하므로 내재적으로 변수 중요도를 제공한다. 중요도 산출은 분할 개선량 기반 중요도(모델 내장), Permutation importance(변수를 섞어 성능 저하 측정), SHAP(변수 기여도 설명) 등이 있다. 비선형·상호작용이 많은 빅데이터에서 특히 강점이 크다.</p>
<p><strong>필터(Filter) 방식의 1차 스크리닝(초고차원에서 필수)</strong></p>
<p>모형을 돌리기 전에 변수 후보를 빠르게 줄이는 방법이다.</p>
<ul>
<li>연속형: 상관계수 기반 스크리닝, 분산 필터, ANOVA/F-통계량</li>
<li>범주형: <span class="math inline">\(\chi^{2}\)</span>-통계량, 정보이득, <span class="math inline">\(Cramer'sV\)</span></li>
<li>일반: 상호정보량(Mutual Information), ReliefF 등</li>
</ul>
<p>이 단계는 <span dir="rtl">”</span>최종 선택”이라기보다, 후속(라쏘/부스팅) 적용 가능하게 차원을 줄이는 전처리로 이해하는 게 정확하다.</p>
<p><strong>래퍼(Wrapper) 방식: RFE(Recursive Feature Elimination)</strong></p>
<p>모델(예: SVM, 로지스틱, 랜덤포레스트)을 반복 학습하며 중요도가 낮은 변수를 단계적으로 제거한다. 계산 비용이 크지만, <span dir="rtl">”</span>특정 예측모델에 최적화된 변수 집합”을 만들 수 있다.</p>
<p>(고급) 오류율 통제 기반 선택: Knockoff / FDR 통제</p>
<p><span dir="rtl">”</span>선택된 변수들 중 거짓 선택 비율(FDR)을 통제”하는 접근이다. 해석·발견이 중요한 빅데이터 과학 연구에서 점점 중요해지는 축이다.</p>
</section>
</section>
<section id="범주형-설명변수" class="level4">
<h4 class="anchored" data-anchor-id="범주형-설명변수">6. 범주형 설명변수</h4>
<p>회귀분석에서 범주형 변수를 처리하는 기본적인 방법은 더미 변수(dummy variable) 또는 지시 변수(indicator variable)를 사용하는 것이다. 더미 변수는 범주형 변수의 각 범주를 0과 1로 표현함으로써, 범주 간 평균 차이를 회귀계수의 형태로 모형에 반영한다.</p>
<section id="두-개의-범주를-갖는-범주형-변수" class="level5">
<h5 class="anchored" data-anchor-id="두-개의-범주를-갖는-범주형-변수">(1) 두 개의 범주를 갖는 범주형 변수</h5>
<p>먼저 범주가 두 개인 경우를 고려한다. 예를 들어 주택 소유 여부(own)가 <span dir="rtl">”</span>소유함”과 <span dir="rtl">”</span>소유하지 않음”의 두 범주를 갖는 경우, 다음과 같은 더미 변수를 정의할 수 있다.</p>
<p><span class="math display">\[x_{i} = \{\begin{matrix}
1 &amp; \text{if}i\text{번째 개인이 주택을 소유함} \\
0 &amp; \text{if}i\text{번째 개인이 주택을 소유하지 않음}
\end{matrix}\]</span></p>
<p>이 더미 변수를 회귀모형에 포함하면, <span class="math inline">\(y_{i} = \beta_{0} + \beta_{1}x_{i} + \varepsilon_{i}\)</span>와 같은 모형을 얻게 된다. 이때 회귀계수의 해석은 매우 직관적이다.</p>
<ul>
<li><span class="math inline">\(\beta_{0}\)</span>는 기준 범주(주택을 소유하지 않은 집단)의 평균 반응값을 의미한다.</li>
<li><span class="math inline">\(\beta_{0} + \beta_{1}\)</span>는 비교 범주(주택을 소유한 집단)의 평균 반응값을 의미한다.</li>
<li><span class="math inline">\(\beta_{1}\)</span>은 두 집단 간 평균 반응값의 차이를 나타낸다.</li>
</ul>
<p>즉, 두 범주형 변수의 경우 더미 변수 하나만으로 범주 간 평균 차이를 회귀모형 안에서 명확하게 표현할 수 있다.</p>
</section>
<section id="세-개-이상의-범주를-갖는-범주형-변수" class="level5">
<h5 class="anchored" data-anchor-id="세-개-이상의-범주를-갖는-범주형-변수">(2) 세 개 이상의 범주를 갖는 범주형 변수</h5>
<p>범주형 변수가 세 개 이상의 범주를 가질 경우에는 하나의 더미 변수만으로는 모든 범주를 표현할 수 없다. 이 경우 범주의 수가 K라면, 일반적으로 K-1개의 더미 변수를 생성한다.</p>
<p>예를 들어 지역(region)이 East, West, South의 세 범주를 갖는 경우를 생각해 보자. 이때 다음과 같은 두 개의 더미 변수를 정의할 수 있다.</p>
<p><span class="math display">\[x_{i1} = \{\begin{matrix}
1 &amp; \text{if}i\text{번째 개인이 South 지역} \\
0 &amp; \text{otherwise}
\end{matrix}x_{i2} = \{\begin{matrix}
1 &amp; \text{if}i\text{번째 개인이 West 지역} \\
0 &amp; \text{otherwise}
\end{matrix}\]</span></p>
<p>이 두 더미 변수를 사용한 회귀모형은 <span class="math inline">\(y_{i} = \beta_{0} + \beta_{1}x_{i1} + \beta_{2}x_{i2} + \varepsilon_{i}\)</span>로 표현된다. 이때 East 지역은 두 더미 변수 모두 0이 되는 기준 범주가 된다. 각 범주에서의 평균 반응값은 다음과 같이 해석된다.</p>
<p>East 지역: <span class="math inline">\(\beta_{0}\)</span> <br> South 지역: <span class="math inline">\(\beta_{0} + \beta_{1}\)</span> <br> West 지역: <span class="math inline">\(\beta_{0} + \beta_{2}\)</span></p>
</section>
<section id="더미-변수와-다중공선성" class="level5">
<h5 class="anchored" data-anchor-id="더미-변수와-다중공선성">(3) 더미 변수와 다중공선성</h5>
<p>범주가 K개일 때 K개의 더미 변수를 모두 포함하면 완전한 선형 종속 관계가 발생한다. 이는 설계행렬의 열들이 선형 종속이 되는 문제로, 회귀계수를 추정할 수 없게 만든다. 이를 더미 변수 함정이라고 한다.</p>
<p>이 문제를 피하기 위해 항상 하나의 범주는 기준 범주로 두고, 해당 범주에 대한 더미 변수는 포함하지 않는다. 대부분의 통계 소프트웨어는 범주형 변수를 지정하면 이 처리를 자동으로 수행한다.</p>
</section>
<section id="범주형-변수-회귀계수의-해석" class="level5">
<h5 class="anchored" data-anchor-id="범주형-변수-회귀계수의-해석">(4) 범주형 변수 회귀계수의 해석</h5>
<p>범주형 변수가 포함된 회귀모형에서 회귀계수는 <span dir="rtl">”</span>조건부 평균의 차이”로 해석된다. 즉, 다른 모든 설명변수를 고정한 상태에서, 특정 범주에 속할 때 반응변수가 얼마나 달라지는지를 나타낸다. 이는 단순한 집단 평균 비교와는 다르며, 다중회귀모형의 중요한 해석 포인트이다.</p>
<p>특히 범주형 변수의 회귀계수에 대한 t-검정은, 해당 범주가 기준 범주와 통계적으로 유의미한 차이를 갖는지를 검정하는 것으로 이해할 수 있다.</p>
</section>
<section id="범주형-변수와-연속형-변수의-상호작용" class="level5">
<h5 class="anchored" data-anchor-id="범주형-변수와-연속형-변수의-상호작용">(5) 범주형 변수와 연속형 변수의 상호작용</h5>
<p>지금까지는 범주형 변수와 연속형 변수가 반응변수에 독립적으로(additively) 영향을 미친다고 가정하였다. 즉, 범주형 변수는 집단 간 평균 차이를 나타내고, 연속형 변수는 모든 집단에서 동일한 기울기를 갖는다고 가정하였다. 그러나 실제 데이터에서는 연속형 변수의 효과가 범주에 따라 달라지는 경우가 매우 흔하다. 이러한 상황을 모형화하기 위해 상호작용항을 도입한다.</p>
<p>상호작용이란 한 변수의 효과가 다른 변수의 값에 의존하는 구조를 의미한다. 회귀모형에서 상호작용은 두 변수의 곱을 새로운 설명변수로 포함함으로써 표현된다.</p>
<p><strong>기본 모형: 상호작용이 없는 경우</strong></p>
<p>연속형 변수 X와 두 범주를 갖는 범주형 변수 D (더미 변수)가 있다고 하자.</p>
<p><span class="math display">\[D = \{\begin{matrix}
1 &amp; \text{if 범주 A} \\
0 &amp; \text{if 범주 B}
\end{matrix}\]</span></p>
<p>상호작용이 없는 모형은 다음과 같다.</p>
<p><span class="math display">\[y_{i} = \beta_{0} + \beta_{1}X_{i} + \beta_{2}D_{i} + \varepsilon_{i}\]</span></p>
<p>이 모형에서 두 집단은 서로 평행한 회귀선을 갖는다.</p>
<p><strong>상호작용 모형의 도입</strong></p>
<p>연속형 변수의 효과가 범주에 따라 달라진다고 가정하면, 다음과 같은 상호작용항을 포함한 모형을 사용한다.</p>
<p><span class="math inline">\(y_{i} = \beta_{0} + \beta_{1}X_{i} + \beta_{2}D_{i} + \beta_{3}(X_{i} \times D_{i}) + \varepsilon_{}\)</span>i, 여기서 <span class="math inline">\(X_{i} \times D_{i}\)</span>는 연속형 변수와 더미 변수의 곱이다. 범주별 회귀식을 나누어 보면 해석이 명확해진다.</p>
<p>기준 범주(B, D=0): <span class="math inline">\(y_{i} = \beta_{0} + \beta_{1}X_{i} + \varepsilon_{i}\)</span></p>
<p>비교 범주(A, D=1): <span class="math inline">\(y_{i} = (\beta_{0} + \beta_{2}) + (\beta_{1} + \beta_{3})X_{i} + \varepsilon_{i}\)</span></p>
<p><strong>회귀계수의 해석</strong></p>
<p>상호작용 모형에서 각 회귀계수는 다음과 같이 해석된다.</p>
<ul>
<li><span class="math inline">\(\beta_{0}\)</span>: 기준 범주에서 X=0일 때 평균 반응값</li>
<li><span class="math inline">\(\beta_{1}\)</span>: 기준 범주에서 X의 효과(기울기)</li>
<li><span class="math inline">\(\beta_{2}\)</span>: X=0일 때 두 범주 간 평균 차이</li>
<li><span class="math inline">\(\beta_{3}\)</span>: 두 범주 간 X의 효과 차이(기울기의 차이)</li>
</ul>
<p>특히 <span class="math inline">\(\beta_{3}\)</span>가 통계적으로 유의하다면, 이는 연속형 변수의 효과가 범주에 따라 다르다는 것을 의미한다. 다시 말해, 단순한 평균 차이만으로는 설명할 수 없는 구조가 존재함을 뜻한다.</p>
<p><strong>그래프적 이해</strong></p>
<p>상호작용이 없는 경우 두 집단의 회귀선은 서로 평행하다. 반면 상호작용이 존재하는 경우, 두 집단의 회귀선은 서로 다른 기울기를 가지며 교차하거나 발산한다. 따라서 상호작용의 존재 여부는 산점도 위에 범주별 회귀선을 그려보는 것만으로도 직관적으로 확인할 수 있다.</p>
<p><strong>세 개 이상의 범주를 갖는 경우</strong></p>
<p>범주형 변수가 K개의 범주를 갖는 경우에는 K-1개의 더미 변수와 각각의 연속형 변수와의 곱을 포함한다. 예를 들어 범주형 변수 <span class="math inline">\(D_{1},D_{2}\)</span>가 있다면, <span class="math inline">\(X \times D_{1},X \times D_{2}\)</span>와 같은 상호작용항을 추가한다. 이때 각 상호작용항은 기준 범주 대비 해당 범주에서의 기울기 차이를 나타낸다.</p>
</section>
<section id="상호작용과-모형-해석의-주의점" class="level5">
<h5 class="anchored" data-anchor-id="상호작용과-모형-해석의-주의점">(6) 상호작용과 모형 해석의 주의점</h5>
<p>상호작용항이 포함된 모형에서는 개별 회귀계수의 해석이 단독으로 이루어질 수 없다. 예를 들어 \beta_1은 전체 자료에서의 평균 효과가 아니라, 기준 범주에서의 효과임을 반드시 인식해야 한다. 또한 상호작용항이 포함된 경우, 단순한 주효과(main effect)의 유의성만으로 결론을 내리는 것은 부적절하다.</p>
<p>범주형 변수와 연속형 변수의 상호작용은 <span dir="rtl">”</span>한 변수의 효과가 다른 변수에 따라 달라진다”는 현실적인 구조를 회귀모형에 반영하는 핵심 장치이다. 상호작용항을 포함함으로써 회귀모형은 단순한 평균 비교를 넘어, 집단별 관계 구조의 차이를 정량적으로 분석할 수 있다. 이는 이후 비선형 모형, 트리 기반 모형, 그리고 머신러닝 모델에서 자동으로 학습되는 구조를 이해하는 중요한 출발점이 된다.</p>
</section>
<section id="상호작용과-다중공선성-문제" class="level5">
<h5 class="anchored" data-anchor-id="상호작용과-다중공선성-문제">(7) 상호작용과 다중공선성 문제</h5>
<p>상호작용항은 회귀모형의 표현력을 크게 확장하지만, 동시에 다중공선성 문제를 악화시킬 수 있다. 이는 상호작용항이 기존 설명변수들의 곱으로 정의되기 때문에, 설계행렬의 열들 사이에 강한 선형 의존성이 자연스럽게 발생하기 때문이다. 따라서 상호작용항을 포함한 회귀모형에서는 추정의 안정성과 해석 가능성에 각별한 주의가 필요하다.</p>
<p><strong>상호작용항이 다중공선성을 유발하는 구조적 이유</strong></p>
<p>연속형 변수 X와 더미 변수 D의 상호작용항은 X \times D의 형태로 정의된다. 이때 설명변수 집합은 <span class="math inline">\(\{ 1,X,D,X \times D\}\)</span>로 구성된다.</p>
<p>문제는 <span class="math inline">\(X \times D\)</span>가 이미 X와 D의 정보를 동시에 포함하고 있다는 점이다. 특히 범주형 변수 D가 0 또는 1의 값을 가질 때,</p>
<p>D=0인 관측치에서는 <span class="math inline">\(X \times D = 0\)</span>,</p>
<p>D=1인 관측치에서는 <span class="math inline">\(X \times D = X\)</span>가 된다. 이로 인해 X와 X \times D는 표본 내에서 강한 상관관계를 가지게 되며, 이는 다중공선성의 전형적인 원인이 된다.</p>
<p>범주형 변수가 세 개 이상일 경우, 여러 개의 더미 변수와 각 더미에 대한 상호작용항이 동시에 포함되면서 이러한 문제는 더욱 심화된다.</p>
<p><strong>다중공선성이 초래하는 추정 및 해석 문제</strong></p>
<p>상호작용항으로 인해 다중공선성이 커지면 다음과 같은 문제가 발생한다.</p>
<p>첫째, 회귀계수의 분산이 증가한다. 이는 표준오차가 커지고, 그 결과 개별 회귀계수의 t-검정이 유의하지 않게 나타날 가능성을 높인다. 실제로 상호작용이 중요한 구조임에도 불구하고, 통계적으로 유의하지 않다는 잘못된 결론에 도달할 수 있다.</p>
<p>둘째, 회귀계수의 추정값이 불안정해진다. 표본이 약간만 변해도 회귀계수의 크기와 부호가 크게 달라질 수 있으며, 이는 해석의 신뢰성을 저해한다.</p>
<p>셋째, 주효과(main effect)의 해석이 왜곡될 수 있다. 상호작용항이 포함된 모형에서 주효과 계수는 더 이상 <span dir="rtl">”</span>전체 평균 효과”를 의미하지 않고, 특정 기준 조건에서의 효과를 나타낸다. 다중공선성이 심한 경우 이러한 해석상의 미묘함은 더욱 혼란을 초래한다.</p>
<p><strong>중심화(centering)를 통한 완화</strong></p>
<p>연속형 변수와 상호작용항 간의 다중공선성을 완화하는 가장 기본적인 방법은 중심화(centering)이다. 연속형 변수 X를 <span class="math inline">\(X_{c} = X - \overline{X}\)</span>와 같이 평균 중심화한 후, 상호작용항을 X_c \times D로 정의한다.</p>
<p>이 방법은 상호작용의 의미를 바꾸지 않으면서도, X와 <span class="math inline">\(X \times D\)</span>사이의 상관을 크게 줄여준다. 특히 절편과 주효과 계수의 해석이 명확해진다는 장점이 있다. 중심화 이후 <span class="math inline">\(\beta_{0}\)</span>는 <span dir="rtl">”</span>평균적인 X”에서의 기준 범주 평균으로 해석할 수 있다.</p>
<p>다만 중심화는 다중공선성을 완전히 제거하는 방법은 아니며, 해석과 수치적 안정성을 개선하는 보조적 수단으로 이해해야 한다.</p>
</section>
<section id="규제-회귀와-상호작용" class="level5">
<h5 class="anchored" data-anchor-id="규제-회귀와-상호작용">(8) 규제 회귀와 상호작용</h5>
<p>상호작용항이 다수 포함된 고차원 회귀모형에서는 Ridge, Lasso, Elastic Net과 같은 규제 회귀가 효과적인 대안이 된다. 규제 회귀는 다중공선성으로 인해 불안정해진 회귀계수를 축소함으로써 예측 성능과 추정의 안정성을 동시에 개선한다.</p>
<p>특히 Lasso나 Elastic Net은 상호작용항 중 불필요한 항을 자동으로 제거할 수 있어, 고차 상호작용이 많은 모형에서 실무적으로 자주 사용된다. 이는 고전적 변수 선택이 상호작용 구조에서는 급격히 복잡해진다는 점을 보완한다.</p>
</section>
</section>
<section id="사례분석" class="level4">
<h4 class="anchored" data-anchor-id="사례분석">7. 사례분석</h4>
<section id="데이터-불러오기" class="level5">
<h5 class="anchored" data-anchor-id="데이터-불러오기">(1) 데이터 불러오기</h5>
<p><strong>데이터 개요</strong></p>
<p>연비 mpg(연속형)를 예측하는 회귀 문제로 mpg는 값이 클수록 연비가 좋다는 것을 의미한다. <br> 크기와 구조: 392개 관측치 × 9개 변수, 이는 df = df.dropna()로 결측이 있는 행을 제거한 결과 <br> 변수 구성(타깃 1 + 설명변수 8) <br> 반응변수(Y): mpg <br> 설명변수(X): cylinders, displacement, horsepower, weight, acceleration, model_year, origin, (name)</p>
<p><strong>메타정보</strong></p>
<ul>
<li>mpg (float, 연속형): 차량의 연비를 의미하며 단위는 miles per gallon이다. 일반적으로 본 데이터에서는 예측 대상인 반응변수 (Y) 로 두며, 값이 클수록 연비가 우수함을 뜻한다.</li>
<li>cylinders (int, 이산형): 엔진의 실린더 개수(예: 4, 6, 8)를 나타낸다. 수치형 변수로 투입할 수도 있으나, 실린더 수에 따른 성능 차이가 단계적으로 나타날 수 있어 범주형(더미변수) 로 처리하는 경우도 많다.</li>
<li>displacement (float, 연속형): 엔진 배기량을 의미하며(통상 cubic inches), 값이 커질수록 엔진이 크고 출력이 높은 경향이 있다. 일반적으로 배기량이 증가하면 연료 소비가 늘어 mpg와는 음의 관계가 관찰된다.</li>
<li>horsepower (float, 연속형): 엔진의 마력(hp)을 나타낸다. 원자료에서는 결측이 포함되는 경우가 있어, 분석에서는 결측 제거(dropna) 또는 적절한 대체(imputation) 전략을 함께 다루기 좋다.</li>
<li>weight (int, 연속형에 가까움): 차량의 중량(통상 pounds)을 의미한다. 중량이 증가할수록 차량이 더 많은 에너지를 필요로 하므로 mpg와 강한 음의 상관이 흔하며, 동시에 displacement, horsepower 등과도 상관이 커 다중공선성 논의에 유용하다.</li>
<li>acceleration (float, 연속형): 가속 성능을 나타내는 지표로, 보통 0→60mph 도달 시간(초)과 같은 형태로 제공된다. 이 경우 값이 클수록 가속이 느린 것(시간이 더 오래 걸림) 이므로 해석 시 방향을 주의해야 한다.</li>
<li>model_year (int, 이산형): 차량의 모델 연식을 나타내며(예: 70~82), 시간에 따른 기술 변화(연비 개선 등)를 반영하는 변수로 사용된다. 선형 추세로 넣을 수도 있고, 필요하면 연도별 효과를 유연하게 보기 위해 범주형 처리 또는 비선형 항(다항/스플라인)으로 확장할 수 있다.</li>
<li>origin (object, 범주형): 차량의 생산 지역(국가/권역)을 나타낸다. Seaborn 버전에서는 보통 usa, europe, japan과 같은 문자열 범주로 제공되어, 회귀모형에서는 더미변수로 변환해 포함시키는 것이 일반적이다.</li>
<li>name (object, 문자열): 차종(모델) 이름으로, 식별자 성격이 강하고 고유값이 많아 일반적인 선형회귀의 설명변수로는 바로 쓰기 어렵다. 보통은 제외하며, 필요할 경우 제조사(브랜드) 추출 등 특성공학(feature engineering) 단계에서 활용할 수 있다.</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># =========================</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 1) 데이터 불러오기 (가장 간단)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># =========================</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> sns.load_dataset(<span class="st">"mpg"</span>)   <span class="co"># Auto MPG (Seaborn 내장 데이터)</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 필요시 결측 제거(특히 horsepower에 결측이 있는 경우가 흔함)</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.dropna()</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co"># =========================</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 2) 기본 메타정보</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># =========================</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"=== Basic Info ==="</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"shape:"</span>, df.shape)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"columns:"</span>, df.columns.tolist())</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">head:"</span>)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>df.info()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>=== Basic Info === <br> shape: (392, 9) <br> columns: ['mpg', 'cylinders', 'displacement', 'horsepower', 'weight', 'acceleration', 'model_year', 'origin', 'name'] <br> Data columns (total 9 columns):</p>
<p>0 mpg 392 non-null float64 <br> 1 cylinders 392 non-null int64 <br> 2 displacement 392 non-null float64 <br> 3 horsepower 392 non-null float64 <br> 4 weight 392 non-null int64 <br> 5 acceleration 392 non-null float64 <br> 6 model_year 392 non-null int64 <br> 7 origin 392 non-null object <br> 8 name 392 non-null object</p>
</section>
<section id="데이터-전처리" class="level5">
<h5 class="anchored" data-anchor-id="데이터-전처리">(2) 데이터 전처리</h5>
<p><strong>범주형 변수 더미변수 만들기</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># =========================</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 1) cylinders -&gt; 3개 그룹</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co"># =========================</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>df[<span class="st">"cyl_group"</span>] <span class="op">=</span> np.select(</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    [</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">"cylinders"</span>].isin([<span class="dv">3</span>, <span class="dv">4</span>]),</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">"cylinders"</span>].isin([<span class="dv">5</span>, <span class="dv">6</span>]),</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">"cylinders"</span>].eq(<span class="dv">8</span>),</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    [<span class="st">"cyl_34"</span>, <span class="st">"cyl_56"</span>, <span class="st">"cyl_8"</span>],</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    default<span class="op">=</span><span class="st">"other"</span>   <span class="co"># 문자열로 통일(에러 방지)</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co"># 혹시 other가 있으면 확인(필요 시 제거)</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (df[<span class="st">"cyl_group"</span>] <span class="op">==</span> <span class="st">"other"</span>).<span class="bu">any</span>():</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"⚠️ 그룹에 안 들어간 cylinders 값:"</span>, <span class="bu">sorted</span>(df.loc[df[<span class="st">"cyl_group"</span>]<span class="op">==</span><span class="st">"other"</span>,<span class="st">"cylinders"</span>].unique()))</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 필요하면 다음 줄로 제거</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># df = df.loc[df["cyl_group"] != "other"].copy()</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="co"># =========================</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a><span class="co"># 2) origin 값 정리(혹시 1/2/3 코드인 경우 대비)</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="co"># =========================</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>origin_map <span class="op">=</span> {<span class="dv">1</span>: <span class="st">"usa"</span>, <span class="dv">2</span>: <span class="st">"europe"</span>, <span class="dv">3</span>: <span class="st">"japan"</span>}</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>tmp <span class="op">=</span> pd.to_numeric(df[<span class="st">"origin"</span>], errors<span class="op">=</span><span class="st">"coerce"</span>)</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> tmp.notna().<span class="bu">all</span>():  <span class="co"># 전부 숫자로 변환되면(=1/2/3 코딩)</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">"origin"</span>] <span class="op">=</span> tmp.astype(<span class="bu">int</span>).<span class="bu">map</span>(origin_map).astype(<span class="st">"object"</span>)</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a><span class="co"># =========================</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a><span class="co"># 3) 더미변수(0/1) 생성 후 df에 붙이기</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="co"># =========================</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>cyl_dum <span class="op">=</span> pd.get_dummies(df[<span class="st">"cyl_group"</span>], dtype<span class="op">=</span><span class="bu">int</span>).drop(columns<span class="op">=</span>[<span class="st">"other"</span>], errors<span class="op">=</span><span class="st">"ignore"</span>)</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>origin_dum <span class="op">=</span> pd.get_dummies(df[<span class="st">"origin"</span>], prefix<span class="op">=</span><span class="st">"origin"</span>, dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.concat([df, cyl_dum, origin_dum], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a><span class="co"># 확인</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"cyl_group counts:</span><span class="ch">\n</span><span class="st">"</span>, df[<span class="st">"cyl_group"</span>].value_counts(dropna<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">origin counts:</span><span class="ch">\n</span><span class="st">"</span>, df[<span class="st">"origin"</span>].value_counts(dropna<span class="op">=</span><span class="va">False</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>cyl_group counts: <br> cyl_group <br> cyl_34 203 (base dummy) <br> cyl_8 103 <br> cyl_56 86</p>
<p>origin counts: <br> origin <br> usa 245 (base dummy) <br> japan 79 <br> europe 68</p>
</section>
<section id="회귀모형-추론" class="level5">
<h5 class="anchored" data-anchor-id="회귀모형-추론">(3) 회귀모형 추론</h5>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.formula.api <span class="im">as</span> smf</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> statsmodels.stats.anova <span class="im">import</span> anova_lm</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 회귀식: cylinders, origin → 더미 변수 사용</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>formula <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="st">mpg ~ displacement + horsepower + weight + acceleration + model_year + cyl_56 + cyl_8 + origin_europe + origin_japan</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> smf.ols(formula, data<span class="op">=</span>df).fit()</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co"># 1) 회귀결과 요약</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(model.summary())</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="co"># 2) 분산분석표(ANOVA)</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="co"># typ=2: Type II SS (주효과 기준으로 많이 사용)</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>anova_table <span class="op">=</span> anova_lm(model, typ<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">=== ANOVA (Type II) ==="</span>)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(anova_table)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>모형 전체 성능</strong></p>
<ul>
<li>R² = 0.839, Adj R² = 0.835 → 이 모형이 mpg 변동의 약 83~84%를 설명한다.</li>
<li>전체 F-test p = 2.10e-145 → <span dir="rtl">”</span>설명변수들이 전혀 도움 안 된다”는 가설은 강하게 기각 → 모형 전체는 유의하다.</li>
</ul>
<p>계수(회귀식) 해석 (<span dir="rtl">”</span>다른 변수들을 고정한 상태에서”의 평균 변화량)</p>
<ul>
<li>weight: -0.0061 (p&lt;0.001) → 무게가 1 lb 증가하면 mpg가 0.0061 감소 → 1000 lb 증가 시 약 6.1 mpg 감소 (영향 매우 큼)</li>
<li>model_year: +0.7601 (p&lt;0.001) → 연식이 1년 증가하면 mpg가 0.76 증가 → 기술 발전/연비 개선 효과를 반영</li>
<li>horsepower: -0.0371 (p=0.006) → 마력 1 증가 시 mpg 0.037 감소 → 10 hp 증가 시 약 0.37 mpg 감소</li>
<li>acceleration: +0.0825 (p=0.382) → 유의하지 않음 → 이 모형에서는 acceleration을 굳이 넣을 근거가 약하다.</li>
<li>displacement: +0.0236 (p=0.001) → <span dir="rtl">”</span>배기량이 커지면 mpg가 증가”처럼 보이지만, 해석 주의가 필요하다. 보통 배기량은 mpg와 음의 관계가 자연스러운데, 여기선 weight, horsepower와 강한 상관(다중공선성) 때문에 부호가 뒤집히는 <span dir="rtl">’</span>억제(suppression)<span dir="rtl">’</span> 현상이 생길 수 있다. ⇒ 개별 계수 해석은 조심, 예측용으로는 쓸 수 있으나 <span dir="rtl">”</span>배기량이 늘면 연비가 좋아진다”로 해석하면 위험하다.</li>
</ul>
<p><strong>더미변수(기준범주 대비 차이)</strong></p>
<ul>
<li>cyl_56: -3.1814 (p&lt;0.001) → 기준(= cyl_34) 대비 5~6기통 그룹은 mpg가 평균 3.18 낮음</li>
<li>cyl_8: -1.4790 (p=0.233) → 기준 대비 낮아 보이지만 유의하지 않음 → (표준오차가 크고 신뢰구간이 0을 포함)</li>
</ul>
<p>origin_europe: +2.1776 (p&lt;0.001), origin_japan: +2.4823 (p&lt;0.001) → 기준(= origin_usa) 대비 유럽/일본 차량이 연비가 유의하게 더 높음</p>
<p><strong>Type II ANOVA 해석(<span dir="rtl">”</span>부분 기여도” 관점)</strong></p>
<p>Type II ANOVA의 F값이 클수록, 다른 변수 통제 후에도 그 변수가 설명력을 크게 갖습니다. 가장 큰 영향: model_year (F≈233) &gt; 다음: weight (F≈92.5) &gt; 그 다음: cyl_56, origin_japan, displacement, origin_europe, horsepower</p>
<p>acceleration, cyl_8은 유의하지 않음(p가 큼) → 이 결과만 보면, mpg의 핵심 설명축은 연식 + 중량 + (기통/원산지) + 출력/배기량입니다.</p>
<p><strong>아래 진단 메시지(중요 경고)</strong></p>
<p>Jarque–Bera p ≈ 3e-14 → 잔차 정규성 가정이 깨질 가능성 큼(표본이 커서 더 민감하게 유의해질 수도 있음)</p>
<p>Cond. No.&nbsp;= 8.64e+04 (매우 큼) → 강한 다중공선성 또는 스케일 문제 경고 특히 displacement–horsepower–weight 조합에서 흔합니다. ⇒ 그래서 displacement 부호가 이상하게 나올 수 있고, 계수의 안정성이 떨어질 수 있다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/prediction_lm_result.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
</section>
<section id="변수-선택-1" class="level5">
<h5 class="anchored" data-anchor-id="변수-선택-1">(4) 변수 선택</h5>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.formula.api <span class="im">as</span> smf</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> statsmodels.stats.anova <span class="im">import</span> anova_lm</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"># -------------------------</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co"># AIC 계산용</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co"># -------------------------</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fit_aic(data, response, included):</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    formula <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>response<span class="sc">}</span><span class="ss"> ~ "</span> <span class="op">+</span> <span class="st">" + "</span>.join(included) <span class="cf">if</span> included <span class="cf">else</span> <span class="ss">f"</span><span class="sc">{</span>response<span class="sc">}</span><span class="ss"> ~ 1"</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> smf.ols(formula, data<span class="op">=</span>data).fit()</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> model.aic, model, formula</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="co"># -------------------------</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Stepwise (AIC, 양방향)</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co"># -------------------------</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> stepwise_aic(data, response, candidates, initial<span class="op">=</span><span class="va">None</span>, verbose<span class="op">=</span><span class="va">True</span>, tol<span class="op">=</span><span class="fl">1e-8</span>):</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    included <span class="op">=</span> [] <span class="cf">if</span> initial <span class="kw">is</span> <span class="va">None</span> <span class="cf">else</span> <span class="bu">list</span>(initial)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        changed <span class="op">=</span> <span class="va">False</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 현재 모델</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        current_aic, _, _ <span class="op">=</span> fit_aic(data, response, included)</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ---- Forward: 추가 ----</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        excluded <span class="op">=</span> [t <span class="cf">for</span> t <span class="kw">in</span> candidates <span class="cf">if</span> t <span class="kw">not</span> <span class="kw">in</span> included]</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> excluded:</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>            aic_add <span class="op">=</span> {term: fit_aic(data, response, included <span class="op">+</span> [term])[<span class="dv">0</span>] <span class="cf">for</span> term <span class="kw">in</span> excluded}</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>            best_add_term <span class="op">=</span> <span class="bu">min</span>(aic_add, key<span class="op">=</span>aic_add.get)</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>            best_add_aic <span class="op">=</span> aic_add[best_add_term]</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> best_add_aic <span class="op">&lt;</span> current_aic <span class="op">-</span> tol:</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>                included.append(best_add_term)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>                changed <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> verbose:</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="ss">f"Add : </span><span class="sc">{</span>best_add_term<span class="sc">:15s}</span><span class="ss">  AIC </span><span class="sc">{</span>current_aic<span class="sc">:.3f}</span><span class="ss"> -&gt; </span><span class="sc">{</span>best_add_aic<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 업데이트</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>        current_aic, _, _ <span class="op">=</span> fit_aic(data, response, included)</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ---- Backward: 제거 ----</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> included:</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>            aic_drop <span class="op">=</span> {term: fit_aic(data, response, [t <span class="cf">for</span> t <span class="kw">in</span> included <span class="cf">if</span> t <span class="op">!=</span> term])[<span class="dv">0</span>] <span class="cf">for</span> term <span class="kw">in</span> included}</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>            best_drop_term <span class="op">=</span> <span class="bu">min</span>(aic_drop, key<span class="op">=</span>aic_drop.get)</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>            best_drop_aic <span class="op">=</span> aic_drop[best_drop_term]</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> best_drop_aic <span class="op">&lt;</span> current_aic <span class="op">-</span> tol:</span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>                included.remove(best_drop_term)</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>                changed <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> verbose:</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="ss">f"Drop: </span><span class="sc">{</span>best_drop_term<span class="sc">:15s}</span><span class="ss">  AIC </span><span class="sc">{</span>current_aic<span class="sc">:.3f}</span><span class="ss"> -&gt; </span><span class="sc">{</span>best_drop_aic<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> changed:</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>    final_aic, final_model, final_formula <span class="op">=</span> fit_aic(data, response, included)</span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> verbose:</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Final formula:"</span>, final_formula)</span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Final AIC:"</span>, final_aic)</span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> final_model</span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a><span class="co"># -------------------------</span></span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a><span class="co"># 후보항(더미 포함, 컬럼 단위)</span></span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a><span class="co"># - 기준범주(cyl_34, origin_usa)는 이미 제외된 상태라 더미트랩 문제 없음</span></span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a><span class="co"># -------------------------</span></span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>candidates <span class="op">=</span> [</span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>    <span class="st">"displacement"</span>, <span class="st">"horsepower"</span>, <span class="st">"weight"</span>, <span class="st">"acceleration"</span>, <span class="st">"model_year"</span>,</span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a>    <span class="st">"cyl_56"</span>, <span class="st">"cyl_8"</span>,</span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>    <span class="st">"origin_europe"</span>, <span class="st">"origin_japan"</span></span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a><span class="co"># 실행</span></span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a>model_aic_dummy <span class="op">=</span> stepwise_aic(df, <span class="st">"mpg"</span>, candidates, verbose<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a><span class="co"># 결과 출력</span></span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(model_aic_dummy.summary())</span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a><span class="co"># -------------------------</span></span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a><span class="co"># 선택된 변수 리스트(terms) 출력</span></span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a><span class="co"># -------------------------</span></span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a>terms <span class="op">=</span> [t <span class="cf">for</span> t <span class="kw">in</span> model_aic_dummy.model.data.design_info.term_names <span class="cf">if</span> t <span class="op">!=</span> <span class="st">"Intercept"</span>]</span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Selected terms:"</span>, terms)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Stepwise가 선택한 최종 모형</strong></p>
<ul>
<li><span class="math display">\[mpg \sim weight + model_{y}ear + cyl_{5}6 + horsepower + origin_{j}apan + origin_{e}urope + displacement\]</span></li>
<li>R² = 0.838 (Adj R² = 0.835): 설명력은 매우 높음(약 84%).</li>
<li>Final AIC = 2025.57: 후보들 중 <span dir="rtl">”</span>적합도-복잡도 균형”이 가장 좋게 나온 조합.</li>
</ul>
<p><strong>변수 채택 순서(AIC 감소량) 해석</strong></p>
<ul>
<li>가장 먼저 들어온 변수: weight AIC가 2724 → 2264로 크게 감소<br>
→ 연비(mpg)를 설명하는 1순위 핵심 변수이다.</li>
<li>다음 핵심: model_year → 연식 효과(기술 발전/규제 등)가 독립적으로 연비를 강하게 설명.</li>
<li>구조적 그룹 효과: cyl_56 → 같은 무게/연식/마력 등을 통제해도 <span dir="rtl">”</span>기통 그룹(5~6기통)“이 평균 연비 차이를 설명.</li>
<li>성능 지표: horsepower → 마력이 클수록 연비가 떨어지는 패턴이 추가 설명력을 가짐.</li>
<li>지역(생산국) 효과: origin_japan, origin_europe → 미국(기준) 대비 일본/유럽 차량의 추가적인 평균 연비 우위가 존재.</li>
<li>마지막으로 displacement가 추가됨 → weight, horsepower를 이미 넣었는데도 배기량이 남는 설명력을 조금 더 제공.</li>
</ul>
<p><strong>“The condition number is large, 7.76e+04.”</strong></p>
<p>weight(중량), horsepower(마력), displacement(배기량) 이 세 변수가 <span dir="rtl">”</span>차가 크고 무거울수록 마력도 크고 배기량도 크다”는 물리적 구조 때문에 강하게 묶여 움직이므로 변수선택 이후에도 다중공선성 문제는 여전히 존재한다.그래서 stepwise가 이들 중 2~3개를 동시에 남기면, 공선성은 자연스럽게 유지된다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/prediction_lm_result02.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
</section>
<section id="다중공선성-진단" class="level5">
<h5 class="anchored" data-anchor-id="다중공선성-진단">(5) 다중공선성 진단</h5>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> patsy</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> statsmodels.stats.outliers_influence <span class="im">import</span> variance_inflation_factor</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co"># terms 예: ['weight','model_year','cyl_56','horsepower','origin_japan','origin_europe','displacement']</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 1) 선택된 설명변수로 formula 생성</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>formula_sel <span class="op">=</span> <span class="st">"mpg ~ "</span> <span class="op">+</span> <span class="st">" + "</span>.join(terms)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Selected formula:</span><span class="ch">\n</span><span class="st">"</span>, formula_sel)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 2) patsy로 설계행렬(X) 생성 (이미 더미가 컬럼으로 들어가 있으므로 그대로 사용)</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>y, X <span class="op">=</span> patsy.dmatrices(formula_sel, data<span class="op">=</span>df, return_type<span class="op">=</span><span class="st">"dataframe"</span>)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Design matrix columns:"</span>)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">list</span>(X.columns))</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="co"># 3) VIF 계산 (Intercept 제외)</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>vif_df <span class="op">=</span> pd.DataFrame({</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    <span class="st">"variable"</span>: X.columns,</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span class="st">"VIF"</span>: [variance_inflation_factor(X.values, i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(X.shape[<span class="dv">1</span>])]</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>vif_df <span class="op">=</span> vif_df[vif_df[<span class="st">"variable"</span>] <span class="op">!=</span> <span class="st">"Intercept"</span>].sort_values(<span class="st">"VIF"</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">=== VIF (selected predictors) ==="</span>)</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>display(vif_df)</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="co"># 4) Condition Number(조건수): (a) 원래 X, (b) 표준화 X 비교</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>X_noi <span class="op">=</span> X.drop(columns<span class="op">=</span>[<span class="st">"Intercept"</span>], errors<span class="op">=</span><span class="st">"ignore"</span>).values</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>cond_raw <span class="op">=</span> np.linalg.cond(X_noi)</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>X_std <span class="op">=</span> (X_noi <span class="op">-</span> X_noi.mean(axis<span class="op">=</span><span class="dv">0</span>)) <span class="op">/</span> X_noi.std(axis<span class="op">=</span><span class="dv">0</span>, ddof<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>cond_std <span class="op">=</span> np.linalg.cond(X_std)</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">=== Condition Number ==="</span>)</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"cond(raw X, no intercept)        :"</span>, cond_raw)</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"cond(standardized X, no intercept):"</span>, cond_std)</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a><span class="co"># 5) 연속형 변수만 상관행렬(직관적 확인)</span></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>cont_vars <span class="op">=</span> [t <span class="cf">for</span> t <span class="kw">in</span> terms <span class="cf">if</span> t <span class="kw">in</span> [<span class="st">"weight"</span>, <span class="st">"model_year"</span>, <span class="st">"horsepower"</span>, <span class="st">"displacement"</span>]]</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> cont_vars:</span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">=== Correlation (continuous only) ==="</span>)</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>    display(df[cont_vars].corr())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>VIF 해석</strong></p>
<p>VIF는 <span dir="rtl">”</span>한 설명변수가 다른 설명변수들로 얼마나 잘 설명되는가”를 수치로 나타내는 지표이다. 일반적으로 VIF 5 이상은 주의, VIF 10 이상은 강한 다중공선성으로 해석하는 것이 관행이다.</p>
<ul>
<li>displacement: VIF = 12.994 이다 → 강한 다중공선성이 존재하는 수준이다.</li>
<li>weight: VIF = 8.750 이다 → 상당한 다중공선성이 존재하는 수준이다.</li>
<li>horsepower: VIF = 6.765 이다 → 다중공선성이 뚜렷한 수준이다.</li>
</ul>
<p>따라서 이 모형의 다중공선성 문제는 displacement–weight–horsepower 3개 연속형 변수에서 집중적으로 발생하는 구조이다.</p>
<p><strong>상태지수 (Condition Number) 해석</strong></p>
<p>cond(raw X) = 12658.43 이다 → 원자료 스케일에서 수치적으로 불안정할 수 있음을 강하게 경고하는 값이다.</p>
<p>cond(standardized X) = 7.92 이다 → 표준화 후에는 수치적 불안정성이 크게 완화되는 값이다.</p>
<p>이 결과는 <span dir="rtl">”</span>조건수의 큰 값”이 (i) 변수 단위/스케일 차이 영향을 크게 받았고, 표준화하면 그 영향이 제거된다는 점을 보여주는 것이다. 다만 표준화로 조건수가 작아졌다고 해서 다중공선성이 사라진 것은 아니다. 공선성 자체는 VIF와 상관계수에서 이미 확인되는 구조이다.</p>
<p><strong>상관계수 해석</strong></p>
<ul>
<li>corr(weight, displacement) = 0.933 이다 → 거의 같은 <span dir="rtl">”</span>차량 크기” 정보를 공유하는 수준이다.</li>
<li>corr(horsepower, displacement) = 0.897 이다 → 강한 동행 구조이다.</li>
<li>corr(weight, horsepower) = 0.865 이다 → 강한 동행 구조이다.</li>
</ul>
<p>즉, <span dir="rtl">”</span>차가 크고 무거울수록 배기량과 마력도 함께 커지는” 물리적 구조가 데이터에 강하게 존재하는 상황이다.</p>
<p><strong>결론</strong></p>
<p>displacement–weight–horsepower 예측변수가 다중공선성 문제를 일으키므로 mpg와 상관관계가 가장 낮은 displacement를 제외한다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/prediction_lm_vif.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:60.0%"></p>
</figure>
</div>
</section>
<section id="회귀진단-및-영향치이상치-진단" class="level5">
<h5 class="anchored" data-anchor-id="회귀진단-및-영향치이상치-진단">(6) 회귀진단 및 영향치/이상치 진단</h5>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.stats <span class="im">as</span> stats</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.formula.api <span class="im">as</span> smf</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> statsmodels.stats.anova <span class="im">import</span> anova_lm</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> statsmodels.stats.stattools <span class="im">import</span> jarque_bera, durbin_watson</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> statsmodels.stats.diagnostic <span class="im">import</span> (</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    het_breuschpagan, het_white, acorr_breusch_godfrey,</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    linear_reset, normal_ad</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> statsmodels.stats.diagnostic <span class="im">import</span> linear_reset, linear_rainbow, linear_harvey_collier</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="co"># =========================================================</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="co"># 0) 최종 모형: displacement 제외</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="co"># =========================================================</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>formula_final <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="st">mpg ~ weight + model_year + cyl_56 + horsepower + origin_japan + origin_europe</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>model_final <span class="op">=</span> smf.ols(formula_final, data<span class="op">=</span>df).fit()</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(model_final.summary())</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a><span class="co"># =========================================================</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a><span class="co"># 1) 선형성 검정</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a><span class="co"># =========================================================</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a><span class="co"># 1) Ramsey RESET (F-stat, p-value)</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>reset_res <span class="op">=</span> linear_reset(model_final, power<span class="op">=</span><span class="dv">2</span>, use_f<span class="op">=</span><span class="va">True</span>)  <span class="co"># power=3로 바꿔도 됨</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a><span class="co"># 2) Rainbow test (stat, p-value)</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>rainbow_stat, rainbow_p <span class="op">=</span> linear_rainbow(model_final)</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a><span class="co"># 3) Harvey–Collier test (오류 수정 버전)</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> model_final.model.exog</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> X.shape[<span class="dv">1</span>]  <span class="co"># 파라미터 수(절편 포함)</span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a><span class="co"># 관측치 순서를 랜덤으로 섞기(재현성 위해 seed 고정)</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.default_rng(<span class="dv">0</span>)</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>order_by <span class="op">=</span> rng.permutation(X.shape[<span class="dv">0</span>])</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a><span class="co"># full-rank가 되는 최소 skip 찾기</span></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>X_ord <span class="op">=</span> X[order_by, :]</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>skip <span class="op">=</span> <span class="va">None</span></span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(p <span class="op">+</span> <span class="dv">1</span>, X.shape[<span class="dv">0</span>] <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> np.linalg.matrix_rank(X_ord[:k, :]) <span class="op">==</span> p:</span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>        skip <span class="op">=</span> k</span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> skip <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"어떤 skip에서도 초기 설계행렬이 full-rank가 되지 않습니다. (더미/상수항 점검 필요)"</span>)</span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a>hc_stat, hc_p <span class="op">=</span> linear_harvey_collier(model_final, order_by<span class="op">=</span>order_by, skip<span class="op">=</span>skip)</span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a>out <span class="op">=</span> pd.DataFrame({</span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Test"</span>: [<span class="st">"Ramsey RESET (F)"</span>, <span class="st">"Rainbow (F)"</span>, <span class="st">"Harvey–Collier (t)"</span>],</span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Statistic"</span>: [<span class="bu">float</span>(reset_res.fvalue), <span class="bu">float</span>(rainbow_stat), <span class="bu">float</span>(hc_stat)],</span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a>    <span class="st">"p-value"</span>: [<span class="bu">float</span>(reset_res.pvalue), <span class="bu">float</span>(rainbow_p), <span class="bu">float</span>(hc_p)],</span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a>    <span class="st">"skip_used"</span>: [np.nan, np.nan, skip]</span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> **선형성 검증** </span><span class="ch">\n</span><span class="st">"</span>,out)</span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a><span class="co"># =========================================================</span></span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true" tabindex="-1"></a><span class="co"># 2) 오차 가정 검정</span></span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true" tabindex="-1"></a><span class="co"># =========================================================</span></span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true" tabindex="-1"></a>resid  <span class="op">=</span> model_final.resid</span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true" tabindex="-1"></a>fitted <span class="op">=</span> model_final.fittedvalues</span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true" tabindex="-1"></a>exog   <span class="op">=</span> model_final.model.exog  <span class="co"># 설계행렬(X)</span></span>
<span id="cb6-73"><a href="#cb6-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-74"><a href="#cb6-74" aria-hidden="true" tabindex="-1"></a><span class="co"># (1) 정규성</span></span>
<span id="cb6-75"><a href="#cb6-75" aria-hidden="true" tabindex="-1"></a>jb_stat, jb_p, skew, kurt <span class="op">=</span> jarque_bera(resid)</span>
<span id="cb6-76"><a href="#cb6-76" aria-hidden="true" tabindex="-1"></a>ad_stat, ad_p <span class="op">=</span> normal_ad(resid)          <span class="co"># Anderson-Darling</span></span>
<span id="cb6-77"><a href="#cb6-77" aria-hidden="true" tabindex="-1"></a>sh_stat, sh_p <span class="op">=</span> stats.shapiro(resid)      <span class="co"># Shapiro-Wilk</span></span>
<span id="cb6-78"><a href="#cb6-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-79"><a href="#cb6-79" aria-hidden="true" tabindex="-1"></a><span class="co"># (2) 등분산성</span></span>
<span id="cb6-80"><a href="#cb6-80" aria-hidden="true" tabindex="-1"></a>bp_lm, bp_lm_p, bp_f, bp_f_p <span class="op">=</span> het_breuschpagan(resid, exog)</span>
<span id="cb6-81"><a href="#cb6-81" aria-hidden="true" tabindex="-1"></a>w_lm, w_lm_p, w_f, w_f_p     <span class="op">=</span> het_white(resid, exog)</span>
<span id="cb6-82"><a href="#cb6-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-83"><a href="#cb6-83" aria-hidden="true" tabindex="-1"></a><span class="co"># (3) 독립성(자기상관)</span></span>
<span id="cb6-84"><a href="#cb6-84" aria-hidden="true" tabindex="-1"></a>dw <span class="op">=</span> durbin_watson(resid)</span>
<span id="cb6-85"><a href="#cb6-85" aria-hidden="true" tabindex="-1"></a>bg_lm1, bg_lm1_p, bg_f1, bg_f1_p <span class="op">=</span> acorr_breusch_godfrey(model_final, nlags<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb6-86"><a href="#cb6-86" aria-hidden="true" tabindex="-1"></a>bg_lm2, bg_lm2_p, bg_f2, bg_f2_p <span class="op">=</span> acorr_breusch_godfrey(model_final, nlags<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb6-87"><a href="#cb6-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-88"><a href="#cb6-88" aria-hidden="true" tabindex="-1"></a><span class="co"># (4) 모형 정합성(누락된 비선형/변수) : Ramsey RESET</span></span>
<span id="cb6-89"><a href="#cb6-89" aria-hidden="true" tabindex="-1"></a>reset_res <span class="op">=</span> linear_reset(model_final, power<span class="op">=</span><span class="dv">2</span>, use_f<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb6-90"><a href="#cb6-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-91"><a href="#cb6-91" aria-hidden="true" tabindex="-1"></a>tests <span class="op">=</span> pd.DataFrame({</span>
<span id="cb6-92"><a href="#cb6-92" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Test"</span>: [</span>
<span id="cb6-93"><a href="#cb6-93" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Jarque–Bera (Normality)"</span>, <span class="st">"Anderson–Darling (Normality)"</span>, <span class="st">"Shapiro–Wilk (Normality)"</span>,</span>
<span id="cb6-94"><a href="#cb6-94" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Breusch–Pagan (Homoskedasticity)"</span>, <span class="st">"White (Homoskedasticity)"</span>,</span>
<span id="cb6-95"><a href="#cb6-95" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Durbin–Watson (Autocorr diag)"</span>,</span>
<span id="cb6-96"><a href="#cb6-96" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Breusch–Godfrey lag1 (Autocorr)"</span>, <span class="st">"Breusch–Godfrey lag2 (Autocorr)"</span>,</span>
<span id="cb6-97"><a href="#cb6-97" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Ramsey RESET (Specification)"</span></span>
<span id="cb6-98"><a href="#cb6-98" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb6-99"><a href="#cb6-99" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Statistic"</span>: [</span>
<span id="cb6-100"><a href="#cb6-100" aria-hidden="true" tabindex="-1"></a>        jb_stat, ad_stat, sh_stat,</span>
<span id="cb6-101"><a href="#cb6-101" aria-hidden="true" tabindex="-1"></a>        bp_lm, w_lm,</span>
<span id="cb6-102"><a href="#cb6-102" aria-hidden="true" tabindex="-1"></a>        dw,</span>
<span id="cb6-103"><a href="#cb6-103" aria-hidden="true" tabindex="-1"></a>        bg_lm1, bg_lm2,</span>
<span id="cb6-104"><a href="#cb6-104" aria-hidden="true" tabindex="-1"></a>        <span class="bu">float</span>(reset_res.fvalue)</span>
<span id="cb6-105"><a href="#cb6-105" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb6-106"><a href="#cb6-106" aria-hidden="true" tabindex="-1"></a>    <span class="st">"p-value"</span>: [</span>
<span id="cb6-107"><a href="#cb6-107" aria-hidden="true" tabindex="-1"></a>        jb_p, ad_p, sh_p,</span>
<span id="cb6-108"><a href="#cb6-108" aria-hidden="true" tabindex="-1"></a>        bp_lm_p, w_lm_p,</span>
<span id="cb6-109"><a href="#cb6-109" aria-hidden="true" tabindex="-1"></a>        np.nan,</span>
<span id="cb6-110"><a href="#cb6-110" aria-hidden="true" tabindex="-1"></a>        bg_lm1_p, bg_lm2_p,</span>
<span id="cb6-111"><a href="#cb6-111" aria-hidden="true" tabindex="-1"></a>        <span class="bu">float</span>(reset_res.pvalue)</span>
<span id="cb6-112"><a href="#cb6-112" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb6-113"><a href="#cb6-113" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb6-114"><a href="#cb6-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-115"><a href="#cb6-115" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">=== Assumption Tests (Final model) ==="</span>)</span>
<span id="cb6-116"><a href="#cb6-116" aria-hidden="true" tabindex="-1"></a>display(tests)</span>
<span id="cb6-117"><a href="#cb6-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-118"><a href="#cb6-118" aria-hidden="true" tabindex="-1"></a><span class="co"># =========================================================</span></span>
<span id="cb6-119"><a href="#cb6-119" aria-hidden="true" tabindex="-1"></a><span class="co"># 3) 진단 플롯(권장 3종)</span></span>
<span id="cb6-120"><a href="#cb6-120" aria-hidden="true" tabindex="-1"></a><span class="co"># =========================================================</span></span>
<span id="cb6-121"><a href="#cb6-121" aria-hidden="true" tabindex="-1"></a>infl <span class="op">=</span> model_final.get_influence()</span>
<span id="cb6-122"><a href="#cb6-122" aria-hidden="true" tabindex="-1"></a>std_resid <span class="op">=</span> infl.resid_studentized_internal</span>
<span id="cb6-123"><a href="#cb6-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-124"><a href="#cb6-124" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb6-125"><a href="#cb6-125" aria-hidden="true" tabindex="-1"></a>plt.scatter(fitted, resid)</span>
<span id="cb6-126"><a href="#cb6-126" aria-hidden="true" tabindex="-1"></a>plt.axhline(<span class="dv">0</span>)</span>
<span id="cb6-127"><a href="#cb6-127" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Fitted values"</span>)</span>
<span id="cb6-128"><a href="#cb6-128" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Residuals"</span>)</span>
<span id="cb6-129"><a href="#cb6-129" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Residuals vs Fitted (Final model)"</span>)</span>
<span id="cb6-130"><a href="#cb6-130" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb6-131"><a href="#cb6-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-132"><a href="#cb6-132" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-133"><a href="#cb6-133" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb6-134"><a href="#cb6-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-135"><a href="#cb6-135" aria-hidden="true" tabindex="-1"></a><span class="co"># model_final이 이미 fit되어 있다고 가정</span></span>
<span id="cb6-136"><a href="#cb6-136" aria-hidden="true" tabindex="-1"></a>infl <span class="op">=</span> model_final.get_influence()</span>
<span id="cb6-137"><a href="#cb6-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-138"><a href="#cb6-138" aria-hidden="true" tabindex="-1"></a><span class="co"># 영향치 핵심 지표</span></span>
<span id="cb6-139"><a href="#cb6-139" aria-hidden="true" tabindex="-1"></a>summary <span class="op">=</span> infl.summary_frame()  <span class="co"># df: leverage, cooks_d, dffits, student_resid 등 포함</span></span>
<span id="cb6-140"><a href="#cb6-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-141"><a href="#cb6-141" aria-hidden="true" tabindex="-1"></a><span class="co"># 관측치 식별용: 원본 df의 index와 name(차종) 같이 보기</span></span>
<span id="cb6-142"><a href="#cb6-142" aria-hidden="true" tabindex="-1"></a>out <span class="op">=</span> summary.copy()</span>
<span id="cb6-143"><a href="#cb6-143" aria-hidden="true" tabindex="-1"></a>out[<span class="st">"index"</span>] <span class="op">=</span> df.index</span>
<span id="cb6-144"><a href="#cb6-144" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">"name"</span> <span class="kw">in</span> df.columns:</span>
<span id="cb6-145"><a href="#cb6-145" aria-hidden="true" tabindex="-1"></a>    out[<span class="st">"name"</span>] <span class="op">=</span> df[<span class="st">"name"</span>].values</span>
<span id="cb6-146"><a href="#cb6-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-147"><a href="#cb6-147" aria-hidden="true" tabindex="-1"></a><span class="co"># ---- 1) Cook's distance 기준 Top 10 ----</span></span>
<span id="cb6-148"><a href="#cb6-148" aria-hidden="true" tabindex="-1"></a>top10_cook <span class="op">=</span> out.sort_values(<span class="st">"cooks_d"</span>, ascending<span class="op">=</span><span class="va">False</span>).head(<span class="dv">10</span>)</span>
<span id="cb6-149"><a href="#cb6-149" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"=== Top 10 영향치 (Cook's distance) ==="</span>)</span>
<span id="cb6-150"><a href="#cb6-150" aria-hidden="true" tabindex="-1"></a>display(top10_cook[[<span class="st">"index"</span>,<span class="st">"name"</span>,<span class="st">"cooks_d"</span>,<span class="st">"hat_diag"</span>,<span class="st">"dffits_internal"</span>,<span class="st">"student_resid"</span>]]</span>
<span id="cb6-151"><a href="#cb6-151" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="st">"name"</span> <span class="kw">in</span> top10_cook.columns <span class="cf">else</span></span>
<span id="cb6-152"><a href="#cb6-152" aria-hidden="true" tabindex="-1"></a>        top10_cook[[<span class="st">"index"</span>,<span class="st">"cooks_d"</span>,<span class="st">"hat_diag"</span>,<span class="st">"dffits_internal"</span>,<span class="st">"student_resid"</span>]])</span>
<span id="cb6-153"><a href="#cb6-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-154"><a href="#cb6-154" aria-hidden="true" tabindex="-1"></a><span class="co"># ---- (선택) 2) Leverage(hat_diag) 기준 Top 10 ----</span></span>
<span id="cb6-155"><a href="#cb6-155" aria-hidden="true" tabindex="-1"></a>top10_lev <span class="op">=</span> out.sort_values(<span class="st">"hat_diag"</span>, ascending<span class="op">=</span><span class="va">False</span>).head(<span class="dv">10</span>)</span>
<span id="cb6-156"><a href="#cb6-156" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">=== Top 10 Leverage (hat values) ==="</span>)</span>
<span id="cb6-157"><a href="#cb6-157" aria-hidden="true" tabindex="-1"></a>display(top10_lev[[<span class="st">"index"</span>,<span class="st">"name"</span>,<span class="st">"hat_diag"</span>,<span class="st">"cooks_d"</span>,<span class="st">"dffits_internal"</span>,<span class="st">"student_resid"</span>]]</span>
<span id="cb6-158"><a href="#cb6-158" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="st">"name"</span> <span class="kw">in</span> top10_lev.columns <span class="cf">else</span></span>
<span id="cb6-159"><a href="#cb6-159" aria-hidden="true" tabindex="-1"></a>        top10_lev[[<span class="st">"index"</span>,<span class="st">"hat_diag"</span>,<span class="st">"cooks_d"</span>,<span class="st">"dffits_internal"</span>,<span class="st">"student_resid"</span>]])</span>
<span id="cb6-160"><a href="#cb6-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-161"><a href="#cb6-161" aria-hidden="true" tabindex="-1"></a><span class="co"># ---- (선택) 3) |Studentized residual| 기준 Top 10 ----</span></span>
<span id="cb6-162"><a href="#cb6-162" aria-hidden="true" tabindex="-1"></a>out[<span class="st">"abs_student_resid"</span>] <span class="op">=</span> np.<span class="bu">abs</span>(out[<span class="st">"student_resid"</span>])</span>
<span id="cb6-163"><a href="#cb6-163" aria-hidden="true" tabindex="-1"></a>top10_resid <span class="op">=</span> out.sort_values(<span class="st">"abs_student_resid"</span>, ascending<span class="op">=</span><span class="va">False</span>).head(<span class="dv">10</span>)</span>
<span id="cb6-164"><a href="#cb6-164" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">=== Top 10 |Studentized residual| ==="</span>)</span>
<span id="cb6-165"><a href="#cb6-165" aria-hidden="true" tabindex="-1"></a>display(top10_resid[[<span class="st">"index"</span>,<span class="st">"name"</span>,<span class="st">"student_resid"</span>,<span class="st">"hat_diag"</span>,<span class="st">"cooks_d"</span>,<span class="st">"dffits_internal"</span>]]</span>
<span id="cb6-166"><a href="#cb6-166" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="st">"name"</span> <span class="kw">in</span> top10_resid.columns <span class="cf">else</span></span>
<span id="cb6-167"><a href="#cb6-167" aria-hidden="true" tabindex="-1"></a>        top10_resid[[<span class="st">"index"</span>,<span class="st">"student_resid"</span>,<span class="st">"hat_diag"</span>,<span class="st">"cooks_d"</span>,<span class="st">"dffits_internal"</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>모형 전체의 유의성과 설명력 해석</strong></p>
<ul>
<li>R² = 0.834, 수정 R² = 0.831 이다. 종속변수 mpg 변동의 약 83%를 설명하는 모형이다.</li>
<li>F-statistic = 321.4, p = 1.62e-146 이다. 모형 전체가 유의하다고 판단되는 수준이다.</li>
</ul>
<p>즉, 이 모형은 예측·설명력 측면에서 강한 성능을 갖는 모형이다.</p>
<p><strong>회귀계수 해석</strong></p>
<ul>
<li>weight의 계수는 -0.0049 이다(p&lt;0.001). 차량 중량이 증가할수록 연비가 감소하는 방향이다. 1000 lb 증가 시 mpg가 약 4.9 감소하는 크기이다.</li>
<li>model_year의 계수는 0.7347 이다(p&lt;0.001). 연식이 1년 증가할수록 평균 mpg가 약 0.735 증가하는 방향이다.</li>
<li>cyl_56의 계수는 -2.4569 이다(p&lt;0.001). 기준집단 대비(더미 기준범주) 5~6기통 그룹의 연비가 평균적으로 약 2.46 낮다는 의미이다.</li>
<li>horsepower의 계수는 -0.0268 이다(p=0.005). 마력이 증가할수록 연비가 감소하는 방향이다.<br>
10 hp 증가 시 mpg가 약 0.268 감소하는 크기이다.</li>
<li>origin_japan의 계수는 1.8590 이다(p&lt;0.001). 기준 원산지(미국) 대비 일본 차량의 평균 연비가 약 1.86 높다는 의미이다.</li>
<li>origin_europe의 계수는 1.4274 이다(p=0.005). 기준 원산지(미국) 대비 유럽 차량의 평균 연비가 약 1.43 높다는 의미이다.</li>
</ul>
<p>즉, 연비를 가장 크게 좌우하는 축은 중량(음의 효과)과 연식(양의 효과)이며, 그 다음으로 기통 그룹, 마력, 원산지 효과가 유의하게 작동하는 모형이다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/prediction_lm_result03.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
<p><strong>선형성(모형 지정) 검정 해석</strong></p>
<ul>
<li>Ramsey RESET: p = 4.81e-24 이다. 선형모형 지정이 충분하다는 귀무가설이 강하게 기각되는 결과이다.</li>
<li>Rainbow test: p = 2.55e-06 이다. 선형성이 전 구간에서 잘 유지된다는 귀무가설이 기각되는 결과이다.</li>
<li>Harvey–Collier는 NaN 이다. 계산이 불안정하여 통계량이 산출되지 않았으므로 해석 대상이 아니다.</li>
</ul>
<p>따라서 이 모형은 <span dir="rtl">”</span>설명력은 높지만, 평균구조에 비선형성 또는 누락된 구조가 남아 있을 가능성이 높다”는 결론이다.</p>
<p><strong>오차 가정 검정 해석</strong></p>
<p>정규성 가정: Jarque–Bera p = 7.86e-21, Anderson–Darling p = 4.60e-06, Shapiro–Wilk p = 7.14e-08 이다. → 잔차가 정규분포라는 가정이 기각되는 결과이다. 즉, 잔차의 꼬리(첨도) 또는 비대칭(왜도)이 존재하는 상황이다.</p>
<p><strong>등분산성 가정</strong></p>
<p>Breusch–Pagan p = 4.65e-05, White p = 1.11e-07 이다. →<br>
등분산성이 기각되므로 **이분산(heteroskedasticity)**이 존재하는 상황이다. 즉, 표준오차와 p-value의 신뢰성이 떨어질 수 있으므로, 강건표준오차(HC3 등) 사용이 권장되는 상황이다.</p>
<p><strong>독립성(자기상관) 진단</strong></p>
<p>시계열 데이터가 아니므로 검증 대상이 아니다.</p>
<p><strong>선형성 검증</strong></p>
<p>Test Statistic p-value skip_used <br> 0 Ramsey RESET (F) 117.371033 4.810671e-24 NaN <br> 1 Rainbow (F) 1.945926 2.554181e-06 NaN <br> 2 Harvey–Collier (t) NaN NaN 8.0</p>
<p>=== Assumption Tests (Final model) ===</p>
<table class="caption-top table">
<colgroup>
<col style="width: 52%">
<col style="width: 21%">
<col style="width: 22%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;">Test</td>
<td style="text-align: left;">Statistic</td>
<td style="text-align: left;">p-value</td>
</tr>
<tr class="even">
<td style="text-align: left;">Jarque–Bera (Normality)</td>
<td style="text-align: left;">92.584552</td>
<td style="text-align: left;">7.861762E-21</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Anderson–Darling (Normality)</td>
<td style="text-align: left;">2.393462</td>
<td style="text-align: left;">4.597709E-06</td>
</tr>
<tr class="even">
<td style="text-align: left;">Shapiro–Wilk (Normality)</td>
<td style="text-align: left;">0.966171</td>
<td style="text-align: left;">7.141925E-08</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Breusch–Pagan (Homoskedasticity)</td>
<td style="text-align: left;">29.616074</td>
<td style="text-align: left;">4.649558E-05</td>
</tr>
<tr class="even">
<td style="text-align: left;">White (Homoskedasticity)</td>
<td style="text-align: left;">76.628977</td>
<td style="text-align: left;">1.105979E-07</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Durbin–Watson (Autocorr diag)</td>
<td style="text-align: left;">1.337720</td>
<td style="text-align: left;">NaN</td>
</tr>
<tr class="even">
<td style="text-align: left;">Breusch–Godfrey lag1 (Autocorr)</td>
<td style="text-align: left;">43.455561</td>
<td style="text-align: left;">4.336974E-11</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Breusch–Godfrey lag2 (Autocorr)</td>
<td style="text-align: left;">58.529957</td>
<td style="text-align: left;">1.951558E-13</td>
</tr>
<tr class="even">
<td style="text-align: left;">Ramsey RESET (Specification)</td>
<td style="text-align: left;">117.371033</td>
<td style="text-align: left;">4.810671E-24</td>
</tr>
</tbody>
</table>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/prediction_lm_resplot.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
<p><strong>Cook<span dir="rtl">’</span>s distance 해석</strong></p>
<p>Cook<span dir="rtl">’</span>s distance는 해당 관측치를 제거했을 때 회귀계수(추정치)가 얼마나 크게 변하는지를 나타내는 영향치 지표이다. 값이 클수록 모형 전체 추정에 미치는 영향이 크다고 해석하는 것이 일반적이다.</p>
<p>표본수가 n=392이므로 경험적 기준 <span class="math inline">\(4/n \approx 0.0102\)</span> 이다. 상위 10개는 모두 Cook<span dir="rtl">’</span>s D가 0.02~0.05 수준이며 4/n을 충분히 초과하는 값이다.</p>
<p>즉, 상위 10개 관측치는 모형 추정에 실질적 영향을 주는 영향관측치(influential points)라고 판단되는 결과이다.</p>
<p>특히 상위권에 diesel 차량들(audi 5000s (diesel), vw dasher (diesel), oldsmobile … (diesel) 등)이 다수 포함되어 있는 점이 특징이다. 이는 <span dir="rtl">”</span>디젤 차량이 평균 구조에서 특이한 패턴을 갖는다” 또는 <span dir="rtl">”</span>현재 모형에 디젤 특성을 설명하는 구조가 누락되어 있다”는 신호로 해석되는 경우가 많다.</p>
<p><strong>Leverage(hat_diag) 해석</strong></p>
<p>레버리지는 설명변수 공간에서 관측치가 얼마나 <span dir="rtl">’</span>특이한 위치<span dir="rtl">’</span>에 있는지를 의미하는 지표이다. 값이 클수록 X공간에서 멀리 떨어진 관측치이며, 잔차가 조금만 커도 추정에 큰 영향을 줄 수 있는 구조이다.</p>
<p>현재 모형은 설명변수 6개 + 절편이므로 모수 개수를 <span class="math inline">\(p \approx 7\)</span>로 보면, 경험적 기준 <span class="math inline">\(2p/n \approx 0.0357\)</span>, <span class="math inline">\(3p/n \approx 0.0536\)</span> 정도가 자주 쓰이는 경계이다.</p>
<p>buick estate wagon (sw)의 hat_diag가 0.106으로 매우 크며, 3p/n을 크게 초과하는 매우 높은 레버리지 관측치이다. 반면 이 관측치는 Cook<span dir="rtl">’</span>s D가 매우 작고(studentized residual도 작음) 잔차가 크지 않으므로, X공간에서는 특이하지만 Y방향 이상치는 아닌 관측치로 해석되는 결과이다. 즉, 레버리지가 높다는 사실만으로 제거 대상이라고 결론내리기보다는, 잔차와 Cook<span dir="rtl">’</span>s D를 함께 보는 것이 타당하다.</p>
<p><strong>Studentized residual| 해석</strong></p>
<p>스튜던트 잔차는 표준화된 잔차(이상치 여부)를 보는 지표이다. 통상 <span class="math inline">\(\mid ri \mid &gt; 3\)</span>이면 이상치(outlier) 가능성이 높다고 해석하는 것이 관행이다.</p>
<p>상위 10개 중 다수가 <span class="math inline">\(|student\_ resid| \geq 3\)</span>을 만족한다. mazda glc의 studentized residual이 4.215로 가장 크며, 잔차 관점에서 매우 강한 이상치 후보이다. oldsmobile cutlass ciera (diesel), vw dasher (diesel), vw rabbit c (diesel) 등도 3 이상으로 강한 이상치 후보이다. maxda rx3는 -3.04로 음의 방향 이상치이다(실제 mpg가 모형 예측보다 유의하게 낮게 관측되는 유형이다).</p>
<p>즉, 이 모형은 일부 관측치에서 큰 잔차가 체계적으로 발생하고 있으며, 이는 앞서 RESET/Rainbow에서 나타난 <span dir="rtl">”</span>선형식 부족/누락 구조” 신호와도 정합적인 결과이다.</p>
<p><strong>종합 결론 해석</strong></p>
<p>Cook<span dir="rtl">’</span>s D 상위 관측치가 다수 존재하므로, 이 모형은 일부 관측치에 의해 계수 추정이 민감할 가능성이 있는 모형이다.</p>
<p>레버리지가 매우 큰 관측치(예: buick estate wagon (sw))가 존재하므로, 설명변수 조합이 특이한 차량이 포함되어 있음을 의미하는 결과이다.</p>
<p><span class="math inline">\(|studentizedresidual| &gt; 3\)</span> 관측치가 다수이며 디젤 차량이 집중되어 있으므로, 연료/차종 특성(디젤 여부 등)이 모형에 반영되지 않아 잔차가 커지는 구조가 존재할 가능성이 큰 결과이다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/prediction_lm_cooks.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/prediction_lm_studrersidual.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>