<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>MLDL 방법론 게요 – 세상의 모든 통계 이야기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-2757cfadcc89ddbfb9e61569f8c3689f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">세상의 모든 통계 이야기</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../notes/math_stat/index.html"> 
<span class="menu-text">기초·수리통계</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/intro_stat/index.html"> 
<span class="menu-text">기초통계·조사방법</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/linear_model/index.html"> 
<span class="menu-text">회귀분석·다변량분석</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl/index.html"> 
<span class="menu-text">머신·딥러닝 개념 w/GPT</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../notes/mldl_method/index.html" aria-current="page"> 
<span class="menu-text">머신·딥러닝 예측방법 w/GPT</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cardnews/index.html"> 
<span class="menu-text">카드뉴스</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../consult.html"> 
<span class="menu-text">통계상담</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../notes/mldl_method/mldlmethod_introduction.html">📄 MLDL 방법론 소개</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">【머신·딥러닝 예측방법】</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_introduction.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">📄 MLDL 방법론 소개</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_prediction_intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 예측방법: 서론</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_prediction_reg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 예측방법: 회귀분석</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_prediction_regulation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 예측방법: 규제회귀</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_prediction_dimension.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 예측방법: 차원축소</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_prediction_nonreg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 예측방법: 비선형회귀</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_prediction_treebase.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 예측방법: 트리기반</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_prediction_deeplearning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 예측방법: 딥러닝회귀</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#chapter-1.-표본-모집단-그리고-일반화" id="toc-chapter-1.-표본-모집단-그리고-일반화" class="nav-link active" data-scroll-target="#chapter-1.-표본-모집단-그리고-일반화">Chapter 1. 표본, 모집단 그리고 일반화</a>
  <ul>
  <li><a href="#모집단" id="toc-모집단" class="nav-link" data-scroll-target="#모집단">1. 모집단</a></li>
  <li><a href="#표본" id="toc-표본" class="nav-link" data-scroll-target="#표본">2. 표본</a></li>
  <li><a href="#일반화" id="toc-일반화" class="nav-link" data-scroll-target="#일반화">3. 일반화</a></li>
  <li><a href="#모집단에-대한-관심의-차이-통계-머신러닝-딥러닝" id="toc-모집단에-대한-관심의-차이-통계-머신러닝-딥러닝" class="nav-link" data-scroll-target="#모집단에-대한-관심의-차이-통계-머신러닝-딥러닝">4. 모집단에 대한 관심의 차이: 통계, 머신러닝, 딥러닝</a></li>
  </ul></li>
  <li><a href="#chapter-2.-손실함수와-위험" id="toc-chapter-2.-손실함수와-위험" class="nav-link" data-scroll-target="#chapter-2.-손실함수와-위험">Chapter 2. 손실함수와 위험</a>
  <ul>
  <li><a href="#손실함수" id="toc-손실함수" class="nav-link" data-scroll-target="#손실함수">1. 손실함수</a></li>
  <li><a href="#경험적-위험" id="toc-경험적-위험" class="nav-link" data-scroll-target="#경험적-위험">2. 경험적 위험</a></li>
  <li><a href="#모집단-위험" id="toc-모집단-위험" class="nav-link" data-scroll-target="#모집단-위험">3. 모집단 위험</a></li>
  </ul></li>
  <li><a href="#chapter-3.-resampling과-일반화-성능-추정" id="toc-chapter-3.-resampling과-일반화-성능-추정" class="nav-link" data-scroll-target="#chapter-3.-resampling과-일반화-성능-추정">Chapter 3. Resampling과 일반화 성능 추정</a>
  <ul>
  <li><a href="#재표본-개념" id="toc-재표본-개념" class="nav-link" data-scroll-target="#재표본-개념">1. 재표본 개념</a></li>
  <li><a href="#일반화-성능-추정의-필요성" id="toc-일반화-성능-추정의-필요성" class="nav-link" data-scroll-target="#일반화-성능-추정의-필요성">2. 일반화 성능 추정의 필요성</a></li>
  <li><a href="#재표본의-기본-아이디어" id="toc-재표본의-기본-아이디어" class="nav-link" data-scroll-target="#재표본의-기본-아이디어">3. 재표본의 기본 아이디어</a></li>
  </ul></li>
  <li><a href="#chapter-4.-재표본-방법" id="toc-chapter-4.-재표본-방법" class="nav-link" data-scroll-target="#chapter-4.-재표본-방법">Chapter 4. 재표본 방법</a>
  <ul>
  <li><a href="#훈련-오차-테스트-오차-그리고-재표본" id="toc-훈련-오차-테스트-오차-그리고-재표본" class="nav-link" data-scroll-target="#훈련-오차-테스트-오차-그리고-재표본">1. 훈련 오차, 테스트 오차 그리고 재표본</a></li>
  <li><a href="#교차검증" id="toc-교차검증" class="nav-link" data-scroll-target="#교차검증">2. 교차검증</a></li>
  <li><a href="#부트스트랩" id="toc-부트스트랩" class="nav-link" data-scroll-target="#부트스트랩">3. 부트스트랩</a></li>
  </ul></li>
  <li><a href="#chapter-5.-재표본-사례" id="toc-chapter-5.-재표본-사례" class="nav-link" data-scroll-target="#chapter-5.-재표본-사례">Chapter 5. 재표본 사례</a>
  <ul>
  <li><a href="#부스트랩" id="toc-부스트랩" class="nav-link" data-scroll-target="#부스트랩">1. 부스트랩</a></li>
  <li><a href="#검증세트-방법-loocv-k-겹-교차검증" id="toc-검증세트-방법-loocv-k-겹-교차검증" class="nav-link" data-scroll-target="#검증세트-방법-loocv-k-겹-교차검증">2. 검증세트 방법, LOOCV, k-겹 교차검증</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">MLDL 방법론 게요</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="chapter-1.-표본-모집단-그리고-일반화" class="level3">
<h3 class="anchored" data-anchor-id="chapter-1.-표본-모집단-그리고-일반화">Chapter 1. 표본, 모집단 그리고 일반화</h3>
<section id="모집단" class="level4">
<h4 class="anchored" data-anchor-id="모집단">1. 모집단</h4>
<p>통계적 학습은 모집단에 대한 가정을 출발점으로 한다. 모집단은 분석의 대상이 되는 전체를 의미하지만, 통계적 학습에서는 이를 단순한 개체들의 집합이 아니라 확률적 생성 구조로 이해한다. 즉, 설명변수와 반응변수는 일정한 확률 규칙에 따라 생성되며, 이 확률 규칙이 모집단을 규정한다.</p>
<p>통계적 학습에서는 설명변수 X와 반응변수 Y가 어떤 결합확률분포를 따른다고 가정한다.</p>
<p><span class="math display">\[(X,Y) \sim P_{XY}\]</span></p>
<p>이 분포는 직접 관측할 수 없으며, 오직 표본을 통해 간접적으로 추론할 수 있다. 회귀, 분류, 머신러닝, 딥러닝을 포함한 모든 학습 방법은 이 보이지 않는 확률 구조를 요약하거나 근사하는 것을 목표로 한다.</p>
<p>모집단을 확률분포로 이해한다는 관점은 이후에 등장하는 모든 학습 문제를 하나의 공통된 틀 안에서 다루게 해준다.</p>
</section>
<section id="표본" class="level4">
<h4 class="anchored" data-anchor-id="표본">2. 표본</h4>
<p>현실에서는 모집단 전체를 관측할 수 없기 때문에, 우리는 모집단으로부터 추출된 유한한 개수의 관측값을 사용한다. 이 관측값들의 집합을 표본이라고 한다. 표본은 모집단 분포로부터 우연히 생성된 결과로 간주되며, 다음과 같은 가정을 바탕으로 한다.</p>
<p><span class="math display">\[(x_{1},y_{1}),(x_{2},y_{2}),\ldots,(x_{n},y_{n})\overset{iid}{\sim}P_{XY}\]</span></p>
<p>이 가정은 통계적 학습 이론의 기본 전제이며, 이후에 등장하는 추론, 예측, 검증 절차의 이론적 기반이 된다. 표본의 크기와 구성은 학습 결과의 안정성과 신뢰성에 직접적인 영향을 미친다. 표본이 작을수록 우연 변동의 영향은 커지며, 동일한 방법을 적용하더라도 결과가 크게 달라질 수 있다.</p>
<p>중요한 점은, 표본이 아무리 많아지더라도 모집단 그 자체가 되지는 않는다는 사실이다. 데이터 분석에서 발생하는 불확실성은 대부분 이 표본과 모집단 사이의 간극에서 비롯된다.</p>
</section>
<section id="일반화" class="level4">
<h4 class="anchored" data-anchor-id="일반화">3. 일반화</h4>
<p>통계적 학습의 목적은 표본을 가능한 한 잘 설명하는 데 있지 않다. 학습의 궁극적인 목표는 표본을 통해 학습한 규칙이나 모형이 아직 관측하지 않은 새로운 데이터에 대해서도 잘 작동하도록 만드는 데 있다. 이를 일반화라고 한다.</p>
<p>학습 알고리즘은 입력 변수 X로부터 출력 변수 Y를 예측하는 함수 f(X)를 학습한다. 훈련 데이터에서 계산되는 평균 손실은 다음과 같다.</p>
<p><span class="math display">\[\frac{1}{n}\overset{n}{\sum_{i = 1}}L(y_{i},f(x_{i}))\]</span></p>
<p>이 값은 모델이 이미 관측한 데이터에 얼마나 잘 맞는지를 보여주는 지표이다. 그러나 우리가 실제로 관심을 가지는 것은 모집단 전체에서의 평균적인 성능이다. 이는 다음과 같은 기댓값으로 표현된다.</p>
<p><span class="math display">\[\mathbb{E}_{(X,Y) \sim P_{XY}}\lbrack L(Y,f(X))\rbrack\]</span></p>
<p>훈련 데이터에서의 성능과 모집단에서의 성능은 일반적으로 일치하지 않는다. 표본에 지나치게 맞춰진 모델은 새로운 데이터에 대해 성능이 급격히 저하될 수 있으며, 이를 과적합이라고 한다. 일반화는 이러한 위험을 인식하고 통제하는 개념이다.</p>
</section>
<section id="모집단에-대한-관심의-차이-통계-머신러닝-딥러닝" class="level4">
<h4 class="anchored" data-anchor-id="모집단에-대한-관심의-차이-통계-머신러닝-딥러닝">4. 모집단에 대한 관심의 차이: 통계, 머신러닝, 딥러닝</h4>
<p>모집단을 확률적 생성 구조로 이해한다는 점에서는 통계학, 머신러닝, 딥러닝이 동일한 출발점을 공유한다. 그러나 이들 방법론은 모집단의 무엇에 관심을 두는지에 따라 서로 다른 방향으로 발전해 왔다.</p>
<p>전통적인 통계학은 모집단 분포의 특정한 요약량에 주된 관심을 둔다. 평균, 분산, 회귀계수와 같은 모수는 모집단 구조를 간결하게 설명하는 핵심 요소로 간주된다. 통계적 추론의 목적은 이러한 모수를 추정하고, 그 불확실성을 정량화하는 데 있다. 이 관점에서 모델은 모집단을 설명하기 위한 수단이며, 해석 가능성이 중요한 위치를 차지한다.</p>
<p>머신러닝은 모집단 분포 자체의 해석보다는, 모집단으로부터 생성될 새로운 관측값에 대해 얼마나 정확한 예측을 할 수 있는지에 더 큰 관심을 둔다. 즉, 조건부 분포의 구조를 직접 해석하기보다는 예측 오차를 최소화하는 함수 f(X)를 찾는 데 초점을 맞춘다. 이 과정에서 일반화 성능은 핵심 평가 기준이 된다.</p>
<p>딥러닝은 머신러닝의 이러한 관점을 더욱 확장한 접근법이다. 딥러닝 모델은 모집단 분포에 대한 명시적 가정보다는, 고차원 입력 공간에서의 복잡한 함수 관계를 직접 근사하는 데 집중한다. 이때 주요 관심사는 해석 가능한 모수보다는 표현 학습과 대규모 데이터 환경에서의 예측 성능이다.</p>
<p>요약하면, 통계학은 모집단의 구조와 모수에, 머신러닝은 모집단에서의 예측 성능에, 딥러닝은 고차원 데이터에서의 표현과 함수 근사 능력에 더 큰 비중을 둔다. 이러한 관점의 차이는 이후 장들에서 각 방법론의 장점과 한계를 이해하는 데 중요한 기준이 된다.</p>
</section>
</section>
<section id="chapter-2.-손실함수와-위험" class="level3">
<h3 class="anchored" data-anchor-id="chapter-2.-손실함수와-위험">Chapter 2. 손실함수와 위험</h3>
<p>통계적 학습에서 <span dir="rtl">”</span>모형이 얼마나 잘 작동하는가”라는 질문은 반드시 수식으로 정의되어야 한다. 그렇지 않으면 서로 다른 방법을 비교하거나, 학습의 목표를 명확히 설정할 수 없다. 손실함수와 위험은 이러한 질문에 체계적으로 답하기 위해 도입되는 개념이다. 이 절에서는 모든 학습 문제를 하나의 공통된 최소화 문제로 이해하는 관점을 소개한다.</p>
<section id="손실함수" class="level4">
<h4 class="anchored" data-anchor-id="손실함수">1. 손실함수</h4>
<p>손실함수는 예측값과 실제값 사이의 차이를 수치로 표현하는 함수이다. 학습 알고리즘은 이 손실을 기준으로 자신의 성능을 판단하며, 손실이 작을수록 더 좋은 예측을 수행한다고 간주한다.</p>
<p>입력 변수 X에 대해 예측 함수 f(X)를 사용한다고 하자. 관측된 실제 값이 Y일 때, 손실함수는 다음과 같은 형태를 가진다.</p>
<p><span class="math display">\[L(Y,f(X))\]</span></p>
<p>손실함수의 선택은 학습 문제의 성격에 따라 달라진다. 회귀 문제에서는 제곱오차 손실이나 절대오차 손실이 자주 사용되며, 분류 문제에서는 0–1 손실이나 로그 손실이 사용된다. 중요한 점은 손실함수가 단순한 계산 도구가 아니라, 무엇을 <span dir="rtl">”</span>잘 맞춘다”고 볼 것인가에 대한 기준을 명확히 규정한다는 것이다.</p>
<p>예를 들어 제곱오차 손실은 큰 오차에 더 큰 벌점을 부여하며, 이는 평균적인 성능을 중시하는 관점을 반영한다. 반면 절대오차 손실은 이상치의 영향을 상대적으로 덜 받는다. 이처럼 손실함수는 학습의 철학을 수식으로 표현한 것이라고 볼 수 있다.</p>
</section>
<section id="경험적-위험" class="level4">
<h4 class="anchored" data-anchor-id="경험적-위험">2. 경험적 위험</h4>
<p>모집단 전체에 대해 손실을 계산하는 것은 현실적으로 불가능하다. 우리가 실제로 사용할 수 있는 정보는 유한한 표본 뿐이다. 따라서 통계적 학습에서는 표본을 이용해 손실의 평균을 계산하고, 이를 최소화하는 방향으로 학습을 수행한다.</p>
<p>표본 <span class="math inline">\((x_{1},y_{1}),\ldots,(x_{n},y_{n})\)</span>이 주어졌을 때, 평균 손실은 다음과 같이 정의된다.</p>
<p><span class="math display">\[\widehat{R}(f) = \frac{1}{n}\overset{n}{\sum_{i = 1}}L(y_{i},f(x_{i}))\]</span></p>
<p>이 값을 경험적 위험이라고 한다. 경험적 위험은 관측된 데이터에 기반해 계산된 손실의 평균이며, 학습 알고리즘이 직접적으로 최소화하는 대상이다. 선형회귀의 최소제곱법, 로지스틱 회귀의 최대우도추정, 신경망 학습에서의 경사하강법은 모두 경험적 위험 최소화의 구체적인 구현이다.</p>
<p>그러나 경험적 위험이 작다고 해서 반드시 좋은 모델이라고 말할 수는 없다. 경험적 위험은 표본에 대한 성능만을 반영하며, 표본에 지나치게 맞춰진 모델은 새로운 데이터에 대해 나쁜 성능을 보일 수 있다. 이 지점에서 일반화 문제가 다시 등장한다.</p>
</section>
<section id="모집단-위험" class="level4">
<h4 class="anchored" data-anchor-id="모집단-위험">3. 모집단 위험</h4>
<p>우리가 궁극적으로 관심을 가지는 것은 표본이 아니라 모집단 전체에서의 평균적인 성능이다. 이를 모집단 위험이라고 하며, 다음과 같이 정의된다.</p>
<p><span class="math display">\[R(f) = \mathbb{E}_{(X,Y) \sim P_{XY}}\lbrack L(Y,f(X))\rbrack\]</span></p>
<p>모집단 위험은 예측 함수 f가 모집단 분포로부터 생성될 임의의 관측값에 대해 얼마나 잘 작동하는지를 나타내는 척도이다. 이상적으로는 이 값을 직접 최소화하는 것이 목표이지만, 모집단 분포는 알 수 없기 때문에 모집단 위험을 직접 계산할 수는 없다.</p>
<p>통계적 학습의 핵심 문제는 경험적 위험과 모집단 위험 사이의 관계에 있다. 표본의 크기가 충분히 크고, 모델의 복잡도가 적절히 통제된다면 경험적 위험은 모집단 위험의 좋은 근사값이 될 수 있다. 반대로 표본이 작거나 모델이 지나치게 복잡하면 두 값 사이의 차이는 커질 수 있다.</p>
<p>이러한 관점에서 통계적 학습은 다음과 같은 문제로 요약된다. 경험적 위험을 최소화하면서도, 모집단 위험이 함께 작아지도록 학습 과정을 설계하는 것이다. 이후 절에서 다룰 규제, 재표본 방법, 검증 기법들은 모두 이 목표를 달성하기 위한 장치들이다.</p>
</section>
</section>
<section id="chapter-3.-resampling과-일반화-성능-추정" class="level3">
<h3 class="anchored" data-anchor-id="chapter-3.-resampling과-일반화-성능-추정">Chapter 3. Resampling과 일반화 성능 추정</h3>
<p>앞 절에서 살펴본 바와 같이, 통계적 학습에서 우리가 직접 계산할 수 있는 것은 경험적 위험이며, 실제로 관심을 가지는 대상은 모집단 위험이다. 문제는 모집단 분포를 알 수 없기 때문에 모집단 위험을 직접 계산할 수 없다는 점이다. 여기서는 이러한 한계를 극복하기 위해 사용되는 방법인 재표본과 일반화 성능 추정의 개념을 다룬다.</p>
<section id="재표본-개념" class="level4">
<h4 class="anchored" data-anchor-id="재표본-개념">1. 재표본 개념</h4>
<p>재표본 방법(resampling methods)은 현대 통계학과 통계적 학습에서 핵심적인 역할을 하는 도구이다. 재표본 방법이란, 하나의 학습 데이터로부터 반복적으로 표본을 추출하고, 각 표본마다 동일한 통계적 모형을 다시 적합함으로써 이미 적합된 모형에 대해 추가적인 정보를 얻는 방법을 의미한다. 이러한 절차를 통해 단일 표본에 기반한 분석만으로는 파악하기 어려운 모형의 성질을 보다 체계적으로 이해할 수 있다.</p>
<p>예를 들어, 선형회귀 모형의 적합 결과가 얼마나 안정적인지를 평가하고자 할 때, 학습 데이터로부터 서로 다른 표본을 반복적으로 추출한 뒤 각 표본에 대해 선형회귀 모형을 적합할 수 있다. 이후 각 표본에서 얻어진 회귀 계수나 예측 성능이 서로 어느 정도 차이를 보이는지를 분석함으로써, 추정치의 변동성과 불확실성을 평가할 수 있다. 이러한 접근은 원래의 학습 표본을 한 번만 사용하여 모형을 적합하는 경우에는 얻기 어려운 정보를 제공한다.</p>
<p>재표본 방법은 동일한 통계적 방법을 서로 다른 데이터 부분집합에 대해 여러 번 반복 적용해야 하므로 계산 비용이 큰 방법으로 인식되기도 한다. 그러나 최근 계산 자원의 발전으로 인해, 재표본 방법에 필요한 계산량은 대부분의 응용 문제에서 실질적인 제약이 되지 않는다. 이에 따라 재표본 방법은 이론적 논의에 머무르지 않고, 실제 데이터 분석과 통계적 학습 문제에서 널리 활용되고 있다.</p>
<p>가장 단순한 재표본 방법은 주어진 표본을 두 부분으로 나누는 방식이다. 일반적으로 하나는 학습용 데이터로, 다른 하나는 평가용 데이터로 사용되며, 이를 hold-out 방법이라고 한다. 이 방법은 구현이 간단하고 계산 비용이 적다는 장점이 있지만, 데이터 분할 방식에 따라 평가 결과가 크게 달라질 수 있다는 한계를 가진다. 특히 표본의 크기가 작은 경우에는 우연한 분할로 인해 일반화 성능이 과대 또는 과소 평가될 위험이 있다.</p>
<p>본 장에서는 재표본 방법 가운데 가장 널리 사용되는 두 가지 방법인 교차검증과 부트스트랩을 다룬다. 이 두 방법은 다양한 통계적 학습 절차를 실제로 적용하는 과정에서 중요한 도구로 활용된다. 교차검증은 특정 통계적 학습 방법의 일반화 성능, 즉 테스트 오차를 추정하는 데 사용되며, 동시에 모형의 적절한 복잡도나 유연성 수준을 선택하는 데에도 활용된다. 모형의 예측 성능을 평가하는 과정을 모형 평가라고 하며, 여러 후보 모형 가운데 적절한 모형을 선택하는 과정을 모형 선택이라고 한다.</p>
<p>한편, 부트스트랩은 여러 상황에서 활용되는 재표본 방법으로, 특히 모수 추정치의 정확도와 변동성을 평가하는 데 자주 사용된다. 또한 특정 통계적 학습 방법이 표본의 변동에 얼마나 민감한지를 파악하는 데에도 유용하다. 이처럼 재표본 방법은 일반화 성능의 평가와 추정의 불확실성 분석을 연결하는 중요한 역할을 수행한다.</p>
</section>
<section id="일반화-성능-추정의-필요성" class="level4">
<h4 class="anchored" data-anchor-id="일반화-성능-추정의-필요성">2. 일반화 성능 추정의 필요성</h4>
<p>학습된 모형의 성능을 평가하는 가장 단순한 방법은 훈련 데이터에서의 평균 손실을 계산하는 것이다. 이 값은 모형이 주어진 학습 데이터에 얼마나 잘 적합되었는지를 보여주는 지표로서 의미를 가진다. 그러나 훈련 데이터에서의 성능이 우수하다는 사실만으로, 해당 모형이 새로운 데이터에 대해서도 동일한 수준의 성능을 보일 것이라고 기대할 수는 없다.</p>
<p>특히 모형의 복잡도가 증가할수록 이러한 문제는 더욱 두드러진다. 복잡한 모형은 훈련 데이터의 패턴을 정교하게 따라갈 수 있기 때문에 훈련 오차를 매우 작게 만들 수 있다. 그러나 이 과정에서 표본에 포함된 우연한 변동까지 함께 학습하게 되면, 새로운 데이터에 대해서는 오히려 예측 성능이 저하될 수 있다. 이와 같은 현상은 통계적 학습에서 과적합으로 알려져 있으며, 일반화 성능을 평가할 필요성을 분명하게 보여준다.</p>
<p>통계적 학습의 관점에서 중요한 것은 훈련 데이터에 대한 적합도가 아니라, 아직 관측되지 않은 데이터에 대한 평균적인 성능이다. 즉, 학습된 모형이 모집단으로부터 새롭게 생성될 관측값에 대해 얼마나 안정적으로 작동하는지를 평가해야 한다. 이를 일반화 성능 추정이라고 한다.</p>
<p>이상적으로는 훈련 데이터와는 독립적인 새로운 데이터를 이용하여 모형의 성능을 평가하는 것이 바람직하다. 그러나 현실적인 분석 상황에서는 이러한 별도의 데이터셋을 확보하기가 쉽지 않다. 따라서 통계적 학습에서는 하나의 표본을 여러 방식으로 나누거나 반복적으로 재구성하여, 새로운 데이터가 주어졌을 때의 상황을 간접적으로 모의하는 방법을 사용한다.</p>
<p>이러한 접근법이 바로 재표본 방법이며, 재표본은 일반화 성능을 추정하기 위한 실질적인 도구로 사용된다. 즉, 재표본 방법은 단순한 계산 기법이 아니라, 훈련 오차와 모집단 성능 사이의 간극을 줄이기 위한 핵심적인 방법론이다.</p>
</section>
<section id="재표본의-기본-아이디어" class="level4">
<h4 class="anchored" data-anchor-id="재표본의-기본-아이디어">3. 재표본의 기본 아이디어</h4>
<p>재표본 방법의 핵심 아이디어는 하나의 표본을 고정된 데이터셋으로 취급하지 않고, 모집단으로부터 추출될 수 있는 여러 가능한 표본 가운데 하나로 간주하는 데 있다. 즉, 현재 관측된 데이터는 모집단으로부터 우연히 생성된 결과이며, 동일한 모집단에서라면 다른 표본이 관측될 수도 있었음을 전제로 한다.</p>
<p>이러한 관점에서 재표본 방법은 주어진 데이터셋을 여러 방식으로 나누거나, 혹은 중복을 허용하여 다시 추출함으로써, 새로운 데이터가 관측되는 상황을 간접적으로 모의한다. 이를 통해 하나의 표본만을 사용했을 때는 관찰하기 어려운 학습 결과의 변동성과 불확실성을 평가할 수 있다.</p>
<p>재표본 과정에서는 일반적으로 데이터의 일부를 모형 학습에 사용하고, 나머지를 모형 평가에 사용한다. 학습에 사용되지 않은 데이터는 훈련 과정에 관여하지 않기 때문에, 새로운 데이터에 대한 관측값과 유사한 역할을 한다. 이 평가 데이터에서 계산된 손실은, 모형이 실제로 새로운 데이터에 대해 보일 성능을 간접적으로 반영한다.</p>
<p>중요한 점은, 재표본 방법이 새로운 정보를 인위적으로 만들어내는 것이 아니라, 동일한 표본을 서로 다른 역할로 반복적으로 활용함으로써 일반화 성능을 추정한다는 점이다. 이러한 절차를 통해 통계적 학습은 훈련 오차와 모집단 성능 사이의 간극을 보다 현실적으로 이해할 수 있게 된다.</p>
<p>이 기본 아이디어를 구체화한 것이 이후에 다룰 hold-out 방법, 교차검증, 그리고 부트스트랩이다. 각 방법은 재표본을 구성하는 방식과 평가 전략에서 차이를 보이지만, 모두 일반화 성능을 추정하기 위한 공통된 목적을 공유한다.</p>
</section>
</section>
<section id="chapter-4.-재표본-방법" class="level3">
<h3 class="anchored" data-anchor-id="chapter-4.-재표본-방법">Chapter 4. 재표본 방법</h3>
<section id="훈련-오차-테스트-오차-그리고-재표본" class="level4">
<h4 class="anchored" data-anchor-id="훈련-오차-테스트-오차-그리고-재표본">1. 훈련 오차, 테스트 오차 그리고 재표본</h4>
<p>회귀 문제를 중심으로 다루어진 편향–분산 트레이드오프와 같은 핵심 개념은 분류 문제에도 거의 그대로 적용된다. 분류 문제에서 차이가 있다면 반응변수가 연속형이 아니라 범주형이라는 점이며, 이에 따라 성능을 측정하는 방식이 오차율(error rate)의 형태로 정의된다는 점이다.</p>
<p>훈련 관측값 <span class="math inline">\(\{(x_{1},y_{1}),\ldots,(x_{n},y_{n})\}\)</span>을 이용하여 분류기 <span class="math inline">\(\widehat{f}\)</span>를 학습했다고 하자. 이때 분류기의 성능을 가장 간단하게 평가하는 방법은 훈련 데이터에 대해 발생한 오분류의 비율을 계산하는 것이다. 이를 훈련 오차율(training error rate)이라 하며, 다음과 같이 정의된다.</p>
<p><span class="math display">\[\frac{1}{n}\overset{n}{\sum_{i = 1}}I(y_{i} \neq {\widehat{y}}_{i})\]</span></p>
<p>여기서 <span class="math inline">\({\widehat{y}}_{i}\)</span>는 i번째 관측값에 대해 분류기가 예측한 범주 레이블이고,</p>
<p><span class="math inline">\(I(y_{i} \neq {\widehat{y}}_{i})\)</span>는 실제 값과 예측 값이 다를 경우 1, 같을 경우 0을 취하는 지시변수이다. 따라서 훈련 오차율은 학습에 사용된 데이터 중 잘못 분류된 관측값의 비율을 의미한다.</p>
<p>훈련 오차율은 계산이 간단하고 항상 구할 수 있다는 장점이 있다. 그러나 통계적 학습의 관점에서 훈련 오차는 모형의 실제 성능을 평가하는 데 적합한 지표라고 보기는 어렵다. 이는 훈련 오차가 이미 관측한 데이터에 대해 계산된 값이기 때문이다. 특히 모형의 복잡도가 높아질수록, 모형은 데이터의 일반적인 구조뿐 아니라 표본에 포함된 우연한 변동까지 학습할 수 있으며, 그 결과 훈련 오차는 지나치게 작아질 수 있다.</p>
<p>우리가 실제로 관심을 가지는 것은 학습에 사용되지 않은 새로운 관측값에 대해 분류기가 얼마나 잘 작동하는가이다. 이러한 관점에서 정의되는 성능 지표가 테스트 오차율(test error rate)이다. 테스트 관측값 <span class="math inline">\((x_{0},y_{0})\)</span>에 대해 테스트 오차율은 다음과 같이 정의된다.</p>
<p><span class="math display">\[\text{Ave}(I(y_{0} \neq {\widehat{y}}_{0}))\]</span></p>
<p>여기서 <span class="math inline">\({\widehat{y}}_{0}\)</span>는 새로운 입력 <span class="math inline">\(x_{0}\)</span>에 대해 분류기가 예측한 범주 레이블이다. 좋은 분류기란 훈련 오차가 작은 분류기가 아니라, 테스트 오차가 작은 분류기이다. 즉, 통계적 학습의 궁극적인 목표는 훈련 데이터에 대한 적합도를 높이는 것이 아니라, 새로운 데이터에 대한 오차를 최소화하는 데 있다.</p>
<p>문제는 테스트 오차율이 정의상 학습에 사용되지 않은 데이터에 대해 계산되는 값이라는 점이다. 모집단 분포를 알 수 없는 현실적인 상황에서는 충분히 큰 테스트 데이터셋을 확보하기가 어렵고, 따라서 테스트 오차를 직접 계산하는 것은 대부분의 경우 불가능하다. 이로 인해 훈련 오차와 테스트 오차 사이에는 본질적인 간극이 존재한다.</p>
<p>이 간극을 메우기 위해 등장한 방법이 재표본(resampling) 방법이다. 재표본 방법은 훈련 데이터의 일부를 의도적으로 학습 과정에서 제외한 뒤, 이를 새로운 데이터인 것처럼 사용하여 오차를 계산한다. 이렇게 계산된 오차는 훈련 오차보다 덜 낙관적이며, 테스트 오차에 대한 추정치로 해석될 수 있다.</p>
<p>요약하면, 훈련 오차는 항상 계산 가능하지만 일반화 성능을 과대평가하는 경향이 있고, 테스트 오차는 우리가 진정으로 최소화하고자 하는 대상이지만 직접 계산할 수 없다. 재표본 방법은 이 둘 사이의 간극을 체계적으로 연결함으로써, 유한한 표본만을 이용해 일반화 성능을 평가할 수 있게 해주는 통계적 학습의 핵심 도구이다.</p>
</section>
<section id="교차검증" class="level4">
<h4 class="anchored" data-anchor-id="교차검증">2. 교차검증</h4>
<section id="개념" class="level5">
<h5 class="anchored" data-anchor-id="개념">(1) 개념</h5>
<p>테스트 오차는 통계적 학습 방법을 사용하여 새로운 관측값, 즉 모형 학습에 사용되지 않은 데이터에 대한 반응변수를 예측할 때 발생하는 평균적인 오차를 의미한다. 주어진 데이터셋에 대해 특정 통계적 학습 방법을 사용하는 것이 타당하다고 판단되기 위해서는 테스트 오차가 작아야 한다.</p>
<p>만약 별도의 테스트 데이터셋이 존재한다면, 테스트 오차는 비교적 쉽게 계산할 수 있다. 그러나 현실적인 분석 상황에서는 이러한 테스트 데이터가 충분히 확보되는 경우가 드물다. 반면, 훈련 오차는 학습에 사용된 관측값에 동일한 통계적 학습 방법을 적용함으로써 쉽게 계산할 수 있다. 하지만 훈련 오차는 테스트 오차와 상당히 다를 수 있으며, 특히 테스트 오차를 크게 과소추정하는 경향이 있다.</p>
<p>충분히 큰 테스트 데이터셋이 없어 테스트 오차를 직접 추정할 수 없는 경우, 이용 가능한 훈련 데이터를 활용하여 테스트 오차를 추정하는 다양한 방법들이 사용된다. 본 절에서는 학습 과정에서 일부 관측값을 의도적으로 제외한 뒤, 해당 관측값에 대해 모형을 적용함으로써 테스트 오차를 추정하는 방법들을 살펴본다.</p>
</section>
<section id="검증-세트-방법-the-validation-set-approach" class="level5">
<h5 class="anchored" data-anchor-id="검증-세트-방법-the-validation-set-approach">(2) 검증 세트 방법 (The Validation Set Approach)</h5>
<p>특정 통계적 학습 방법을 하나의 데이터셋에 적용할 때 발생하는 테스트 오차를 추정하고자 한다고 가정하자.</p>
<p>검증 세트 방법은 사용 가능한 관측값들을 무작위로 두 부분으로 나누는 절차를 포함한다. 하나는 학습용 데이터셋(training set)이고, 다른 하나는 검증 데이터셋(validation set), 또는 홀드아웃 세트(hold-out set)이다. 모형은 학습 데이터셋을 이용해 적합되며, 적합된 모형은 검증 데이터셋에 포함된 관측값들의 반응변수를 예측하는 데 사용된다. 이때 계산된 검증 세트 오차율은, 연속형 반응변수의 경우 일반적으로 평균제곱오차(MSE)를 사용하여 측정되며, 테스트 오차에 대한 추정치를 제공한다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/mldlmethod_intro_train.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>예제 자료 Auto 데이터셋에 적용하면, mpg와 horsepower 사이의 비선형적 관계를 고려할 때 단순 선형 회귀보다 다항 회귀 모형이 더 적절한지 평가할 수 있다. 이를 위해 전체 392개의 관측값을 무작위로 학습 세트와 검증 세트로 나눈 뒤, 다양한 차수의 다항 회귀 모형을 학습 데이터에 적합하고 검증 데이터에서 평균제곱오차로 성능을 비교한다. 그 결과, 이차 다항 모형은 선형 모형에 비해 검증 세트 MSE가 크게 감소하였으나, 삼차 이상의 다항항을 추가해도 예측 성능은 더 이상 개선되지 않는 것으로 나타났다.</p>
<p>한편, 검증 세트 방법은 데이터 분할 방식에 따라 성능 추정 결과가 달라질 수 있다는 한계를 가진다. 서로 다른 무작위 분할을 반복하면 각 경우마다 검증 세트 MSE가 달라지며, 어떤 모형이 최적이라고 단정하기는 어렵다. 그럼에도 불구하고 반복된 결과를 종합하면, 선형 모형이 이 데이터에 적합하지 않다는 점만큼은 일관되게 확인된다.</p>
<p>검증 세트 방법은 개념적으로 단순하고 구현이 쉽다는 장점을 지닌다. 그러나 두 가지 잠재적인 단점이 존재한다.</p>
<p>첫째, 검증 세트 오차 추정치는 어떤 관측값이 학습 데이터에 포함되고 어떤 관측값이 검증 데이터에 포함되는지에 따라 크게 달라질 수 있다.</p>
<p>둘째, 검증 세트 방법에서는 전체 데이터 중 일부만을 사용하여 모형을 학습한다. 일반적으로 통계적 방법은 더 많은 관측값을 사용하여 학습할수록 성능이 향상되므로, 검증 세트 오차는 전체 데이터를 사용하여 학습한 모형의 테스트 오차를 과대추정하는 경향이 있다.</p>
</section>
<section id="하나를-제외한-교차검증-leave-one-out-cross-validation" class="level5">
<h5 class="anchored" data-anchor-id="하나를-제외한-교차검증-leave-one-out-cross-validation">(3) 하나를 제외한 교차검증 (Leave-One-Out Cross-Validation)</h5>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/mldlmethod_intro_loocv.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>검증 세트 방법과 마찬가지로, LOOCV 역시 전체 관측값을 두 부분으로 나누어 사용한다. 그러나 검증 세트 방법에서 두 부분이 비교적 비슷한 크기를 갖는 것과 달리, LOOCV에서는 단 하나의 관측값 <span class="math inline">\((x_{1},y_{1})\)</span>만을 검증 데이터로 사용하고, 나머지 n-1개의 관측값 <span class="math inline">\(\{(x_{2},y_{2}),\ldots,(x_{n},y_{n})\}\)</span>을 학습 데이터로 사용한다. 통계적 학습 방법은 이 n-1개의 관측값에 대해 적합되며, 제외된 관측값에 대해 예측값 <span class="math inline">\({\widehat{y}}_{1}\)</span>이 계산된다.</p>
<p>이때 <span class="math inline">\((x_{1},y_{1})\)</span>은 학습 과정에 사용되지 않았으므로, <span class="math inline">\(\text{MSE}_{1} = (y_{1} - {\widehat{y}}_{1})^{2}\)</span>은 테스트 오차에 대한 거의 비편향(unbiased) 추정값으로 해석할 수 있다. 그러나 <span class="math inline">\(\text{MSE}_{1}\)</span>은 단 하나의 관측값에 기반한 값이므로 변동성이 매우 크며, 그 자체로는 신뢰할 만한 추정치라고 보기 어렵다.</p>
<p>이 과정을 두 번째 관측값 <span class="math inline">\((x_{2},y_{2})\)</span>에 대해서도 반복할 수 있다. 즉, <span class="math inline">\((x_{2},y_{2})\)</span>를 검증 데이터로 두고, 나머지 n-1개의 관측값 <span class="math inline">\(\{(x_{1},y_{1}),(x_{3},y_{3}),\ldots,(x_{n},y_{n})\}\)</span>을 학습 데이터로 사용하여 모형을 적합한 뒤, <span class="math inline">\(\text{MSE}_{2} = (y_{2} - {\widehat{y}}_{2})^{2}\)</span>를 계산한다. 이와 같은 절차를 모든 관측값에 대해 반복하면, 총 n개의 제곱오차 <span class="math inline">\(\text{MSE}_{1},\ldots,\text{MSE}_{n}\)</span>를 얻게 된다.</p>
<p>LOOCV에서의 테스트 평균제곱오차 추정치는 이 값들의 평균으로 정의된다.</p>
<p><span class="math display">\[\text{CV}_{(n)} = \frac{1}{n}\overset{n}{\sum_{i = 1}}\text{MSE}_{i}\]</span></p>
<p>LOOCV는 검증 세트 방법에 비해 몇 가지 중요한 장점을 가진다. 첫째, 편향이 훨씬 작다. LOOCV에서는 매번 n-1개의 관측값을 사용하여 모형을 학습하므로, 이는 전체 데이터셋을 사용한 경우와 거의 동일한 규모의 학습에 해당한다. 반면 검증 세트 방법에서는 학습 데이터가 전체 데이터의 절반 정도로 줄어드는 경우가 많아, 테스트 오차를 과대추정하는 경향이 있다. 이러한 이유로 LOOCV는 검증 세트 방법보다 테스트 오차에 대한 편향이 훨씬 작다.</p>
<p>둘째, LOOCV는 반복 수행 시 항상 동일한 결과를 제공한다. 검증 세트 방법은 학습/검증 데이터 분할이 무작위로 이루어지기 때문에, 분할 방식에 따라 결과가 달라질 수 있다. 반면 LOOCV에서는 각 관측값이 정확히 한 번씩 검증 데이터로 사용되므로, 분할에 따른 임의성이 존재하지 않는다.</p>
<p>LOOCV의 단점은 계산 비용이 크다는 점이다. LOOCV에서는 모형을 총 n번 적합해야 하므로, 관측값의 수가 크거나 각 모형의 적합에 많은 시간이 소요되는 경우 계산 부담이 매우 커질 수 있다.</p>
<p>그러나 최소제곱 선형 회귀나 다항 회귀의 경우에는 놀라운 계산적 단축 방법이 존재하여, LOOCV의 계산 비용을 단일 모형 적합과 거의 동일한 수준으로 줄일 수 있다. 이 경우 다음 식이 성립한다.</p>
<p><span class="math inline">\(\text{CV}_{(n)} = \frac{1}{n}\overset{n}{\sum_{i = 1}}\left( \frac{y_{i} - {\widehat{y}}_{i}}{1 - h_{i}} \right)^{2}\)</span>, 여기서 <span class="math inline">\({\widehat{y}}_{i}\)</span>는 전체 데이터에 대해 적합한 최소제곱 회귀모형에서의 i번째 적합값이며, <span class="math inline">\(h_{i}\)</span>는 레버리지(leverage) 값이다. 레버리지는 1/n과 1 사이의 값을 가지며, 특정 관측값이 자기 자신의 적합값에 얼마나 큰 영향을 미치는지를 나타낸다. 이 식에서는 레버리지가 큰 관측값에 대한 잔차가 적절히 보정되어 반영된다.</p>
<p>LOOCV는 매우 일반적인 방법으로, 로지스틱 회귀나 선형 판별분석 등 다양한 예측 모형에 적용할 수 있다.</p>
</section>
<section id="k-겹-교차검증-k-fold-cross-validation" class="level5">
<h5 class="anchored" data-anchor-id="k-겹-교차검증-k-fold-cross-validation">(4) k-겹 교차검증 (k-Fold Cross-Validation)</h5>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/mldlmethod_intro_kfold.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>LOOCV의 대안으로 k-겹 교차검증(k-fold CV)이 있다. 이 방법은 전체 관측값 집합을 크기가 거의 같은 k개의 그룹, 즉 폴드(fold)로 무작위 분할하는 절차를 포함한다. 첫 번째 폴드를 검증 세트로 사용하고, 나머지 k-1개의 폴드를 학습 세트로 사용하여 통계적 학습 방법을 적합한다. 이후 제외된 폴드에 포함된 관측값들에 대해 평균제곱오차 <span class="math inline">\(\text{MSE}_{1}\)</span>를 계산한다.</p>
<p>이 절차를 총 k번 반복하며, 매번 서로 다른 폴드가 검증 세트로 사용된다. 그 결과 테스트 오차에 대한 k개의 추정값 <span class="math inline">\(\text{MSE}_{1},\text{MSE}_{2},\ldots,\text{MSE}_{k}\)</span>를 얻게 된다. k-겹 교차검증에 의한 테스트 오차 추정치는 이 값들의 평균으로 정의된다.</p>
<p><span class="math display">\[\text{CV}_{(k)} = \frac{1}{k}\overset{k}{\sum_{i = 1}}\text{MSE}_{i}\]</span></p>
<p>LOOCV는 k=n인 k-겹 교차검증의 특수한 경우로 볼 수 있다. 실제 응용에서는 보통 k=5 또는 k=10을 사용한다. 그렇다면 k=n 대신 k=5나 k=10을 사용하는 장점은 무엇일까? 가장 분명한 장점은 계산 효율성이다. LOOCV는 학습 방법을 총 n번 적합해야 하므로, 계산 비용이 매우 클 수 있다. 반면 10-겹 교차검증은 학습을 10번만 수행하면 되므로, 훨씬 현실적인 계산 비용으로 적용할 수 있다.</p>
<p>교차검증을 수행하는 목적은 상황에 따라 다를 수 있다. 어떤 경우에는 독립적인 데이터에 대해 해당 학습 방법이 얼마나 잘 작동할지를 평가하기 위해 테스트 MSE의 정확한 추정치에 관심을 가질 수 있다. 그러나 다른 경우에는 여러 학습 방법이나 동일한 방법의 서로 다른 유연성 수준을 비교하여, 테스트 오차를 최소화하는 설정을 선택하는 것이 목적일 수 있다. 이 경우에는 추정된 테스트 MSE의 정확한 값보다는, 테스트 MSE 곡선에서 최소점이 위치하는 지점이 더 중요하다.</p>
<p>교차검증 곡선이 때로는 참된 테스트 MSE를 과소 또는 과대추정하더라도, 대부분의 경우 테스트 MSE를 최소화하는 유연성 수준을 비교적 정확하게 식별해 준다. 이는 교차검증이 모형 선택을 위한 도구로서 매우 효과적임을 의미한다.</p>
<p><strong>k-겹 교차검증에서의 편향–분산 절충</strong></p>
<p>k&lt;n인 k-겹 교차검증이 LOOCV에 비해 계산상 유리하다는 점을 언급하였다. 그러나 계산 비용을 제외하더라도, k-겹 교차검증이 LOOCV보다 테스트 오차율을 더 정확하게 추정하는 경우가 많다는 점은 덜 직관적이지만 잠재적으로 더 중요한 장점이다. 이는 k-겹 교차검증에서 나타나는 편향–분산 절충과 관련이 있다.</p>
<p>LOOCV에서는 각 학습 세트가 n-1개의 관측값을 포함하므로, 전체 데이터셋의 크기와 거의 동일한 규모로 학습이 이루어진다. 따라서 LOOCV는 테스트 오차에 대해 거의 비편향에 가까운 추정치를 제공한다. 반면, k=5 또는 k=10과 같은 k-겹 교차검증에서는 각 학습 세트가 대략 (k-1)n/k개의 관측값을 포함하므로, LOOCV보다는 적지만 검증 세트 방법보다는 훨씬 많은 데이터를 사용하게 된다. 이로 인해 k-겹 교차검증은 편향의 관점에서 중간 정도의 특성을 갖는다. 따라서 편향을 최소화하는 측면에서는 LOOCV가 k-겹 교차검증보다 유리하다고 할 수 있다.</p>
<p>그러나 오차 추정에서 편향만이 유일한 고려 요소는 아니다. 분산 또한 중요한 역할을 한다. 실제로 LOOCV는 k&lt;n인 k-겹 교차검증보다 더 큰 분산을 가지는 것으로 알려져 있다. 그 이유는 LOOCV에서 평균을 내는 대상이 되는 n개의 모형들이 거의 동일한 학습 데이터를 사용하여 적합되기 때문이다. 이 경우 각 모형의 결과는 서로 강한 양의 상관관계를 가지게 되며, 이러한 상관된 값들의 평균은 분산이 크게 나타난다.</p>
<p>반면, k&lt;n인 k-겹 교차검증에서는 각 모형의 학습 세트 간 중복이 상대적으로 적어, 서로 다른 모형들의 결과가 LOOCV에 비해 덜 상관되어 있다. 일반적으로 서로 높은 상관을 가지는 값들의 평균은, 상관이 낮은 값들의 평균보다 분산이 더 크다. 이로 인해 LOOCV에서 얻은 테스트 오차 추정치는 k-겹 교차검증에서 얻은 추정치보다 분산이 더 크게 나타나는 경향이 있다.</p>
<p>요약하면, k-겹 교차검증에서 k의 선택에는 명확한 편향–분산 절충이 존재한다. 일반적으로 이러한 점들을 종합적으로 고려할 때, k=5 또는 k=10을 사용하는 것이 경험적으로 바람직한 것으로 알려져 있다. 이러한 값들은 과도하게 큰 편향이나 매우 큰 분산을 동시에 피하면서, 안정적인 테스트 오차 추정치를 제공하는 것으로 확인되어 왔다.</p>
</section>
<section id="분류-문제에서의-교차검증" class="level5">
<h5 class="anchored" data-anchor-id="분류-문제에서의-교차검증">(5) 분류 문제에서의 교차검증</h5>
<p>지금까지 이 장에서는 반응변수 Y가 연속형인 회귀 문제를 중심으로 교차검증의 사용법을 설명하였으며, 테스트 오차를 정량화하기 위해 평균제곱오차(MSE)를 사용하였다. 그러나 반응변수가 범주형인 분류 문제에서도 교차검증은 매우 유용한 방법이 될 수 있다. 이 경우에도 교차검증의 절차 자체는 앞서 설명한 내용과 동일하며, 다만 테스트 오차를 측정하는 지표만 달라진다. 즉, 분류 문제에서는 MSE 대신 잘못 분류된 관측값의 개수를 사용하여 오차를 정의한다.</p>
<p>예를 들어 분류 문제에서 LOOCV에 의한 오차율은 다음과 같은 형태를 갖는다.</p>
<p><span class="math inline">\(\text{CV}_{(n)} = \frac{1}{n}\overset{n}{\sum_{i = 1}}\text{Err}_{i}\)</span>, 여기서 <span class="math inline">\(\text{Err}_{i} = I(y_{i} \neq {\widehat{y}}_{i})\)</span>이며, 이는 i번째 관측값이 잘못 분류되었을 경우 1, 올바르게 분류되었을 경우 0의 값을 갖는 지시변수이다. k-겹 교차검증과 검증 세트 방법에서의 분류 오차율 역시 이와 동일한 방식으로 정의된다.</p>
<p>로지스틱 회귀는 회귀 문제에서와 마찬가지로 설명변수의 다항 함수를 포함시켜 비선형 결정경계를 갖도록 확장할 수 있다. 예를 들어, 다음과 같은 이차 로지스틱 회귀 모형을 고려할 수 있다.</p>
<p><span class="math display">\[\log\left( \frac{p}{1 - p} \right) = \beta_{0} + \beta_{1}X_{1} + \beta_{2}X_{1}^{2} + \beta_{3}X_{2} + \beta_{4}X_{2}^{2}\]</span></p>
<p>실제 데이터 분석 상황에서는 베이즈 결정경계나 참된 테스트 오차율을 알 수 없다. 아래 제시된 네 가지 로지스틱 회귀 모형 중 어떤 모형을 선택해야 할지를 판단하는 문제는 교차검증을 통해 해결할 수 있다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/mldlmethod_intro_cv01.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>아래 제시된 이차원 분류 데이터에 대해 계산된 테스트 오차(갈색), 훈련 오차(파란색), 그리고 10-겹 교차검증 오차(검은색)를 나타낸 것이다. 왼쪽 패널은 설명변수들의 다항함수를 사용한 로지스틱 회귀 모형의 결과를 보여주며, 가로축에는 사용된 다항식의 차수가 표시되어 있다. 오른쪽 패널은 서로 다른 K 값에 대한 KNN 분류기의 결과를 나타내며, 여기서 K는 KNN 분류기에 사용된 이웃의 수를 의미한다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/mldlmethod_intro_cv02.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
</section>
<section id="분류-문제에서의-교차검증-오차-지표" class="level5">
<h5 class="anchored" data-anchor-id="분류-문제에서의-교차검증-오차-지표">(6) 분류 문제에서의 교차검증 오차 지표</h5>
<p>분류 문제에서 교차검증의 목적은 학습에 사용되지 않은 새로운 관측값에 대해 분류기가 얼마나 잘 작동하는지를 평가하는 데 있다. 이를 위해 회귀 문제에서 평균제곱오차(MSE)를 사용하듯, 분류 문제에서는 반응변수의 특성에 맞는 오차 지표를 사용한다. 어떤 지표를 선택하느냐에 따라 교차검증의 해석과 모형 선택 결과가 달라질 수 있다.</p>
<p><strong>1. 오차율 (Misclassification Error Rate)</strong></p>
<p>가장 직관적이고 널리 사용되는 분류 오차 지표는 오차율이다. 오차율은 전체 관측값 중에서 잘못 분류된 비율로 정의된다.</p>
<p><span class="math display">\[\text{Error Rate} = \frac{1}{n}\overset{n}{\sum_{i = 1}}I(y_{i} \neq {\widehat{y}}_{i})\]</span></p>
<p>여기서 <span class="math inline">\(I( \cdot )\)</span>는 지시변수이며, 예측값과 실제 값이 다를 경우 1, 같을 경우 0을 취한다. 교차검증에서는 각 검증 세트에서 계산된 오차율을 평균하여 테스트 오차율의 추정치로 사용한다.</p>
<p>오차율은 해석이 매우 간단하다는 장점이 있으나, 예측 확률의 크기나 불확실성은 반영하지 못한다. 예를 들어, 매우 확신을 가지고 틀린 예측과 거의 우연에 가까운 예측 실패를 동일하게 취급한다는 한계를 가진다.</p>
<p><strong>2. 로그손실 (Log Loss, Cross-Entropy Loss)</strong></p>
<p>로그손실은 분류기가 출력한 확률 예측의 품질을 평가하는 지표로, 특히 확률 기반 분류기에서 중요하다. 이항 분류의 경우 로그손실은 다음과 같이 정의된다.</p>
<p><span class="math display">\[\text{Log Loss} = - \frac{1}{n}\overset{n}{\sum_{i = 1}}\left\lbrack y_{i}\log({\widehat{p}}_{i}) + (1 - y_{i})\log(1 - {\widehat{p}}_{i}) \right\rbrack\]</span></p>
<p>여기서 <span class="math inline">\({\widehat{p}}_{i} = P(Y = 1 \mid X = x_{i})\)</span>는 분류기가 예측한 확률이다. 다중 분류의 경우에는 softmax 출력과 함께 일반화된 형태의 교차엔트로피 손실을 사용한다.</p>
<p>로그손실은 잘못된 예측뿐만 아니라, 얼마나 확신을 가지고 예측했는지까지 함께 반영한다. 따라서 확률 추정이 중요한 문제, 예를 들어 위험 예측이나 의사결정 문제에서 특히 유용하다. 반면 값의 크기가 직관적으로 해석되기 어렵다는 단점이 있다.</p>
<p><strong>3. 이진 교차엔트로피와 다중 클래스 교차엔트로피</strong></p>
<p>로그손실은 신경망과 같은 딥러닝 분류 모형에서 손실함수로 직접 사용되며, 교차검증에서도 동일한 기준으로 활용된다.</p>
<ul>
<li>이진 분류: Binary Cross-Entropy</li>
<li>다중 분류: Categorical Cross-Entropy</li>
</ul>
<p>교차검증에서는 각 폴드에서 계산된 교차엔트로피 손실을 평균하여 테스트 손실의 추정치로 사용한다. 이 지표는 오차율보다 미세한 모형 차이를 감지하는 데 유리하다.</p>
<p><strong>4. ROC-AUC 기반 지표</strong></p>
<p>ROC 곡선 아래 면적(AUC)은 분류 임계값에 의존하지 않는 성능 지표로, 확률 예측의 순위 품질을 평가한다. 교차검증에서는 각 폴드에서 AUC를 계산한 뒤 평균 AUC를 사용한다.</p>
<p>AUC는 클래스 불균형 문제가 있는 경우에도 비교적 안정적인 지표라는 장점이 있다. 다만 이는 엄밀한 의미의 손실 함수는 아니며, 직접적인 확률 예측 오차를 측정하지는 않는다.</p>
<p><strong>5. Precision, Recall, F1-score 기반 지표</strong></p>
<p>불균형 데이터에서 단순 오차율은 오해를 불러일으킬 수 있으므로, 정밀도(precision), 재현율(recall), 그리고 이들의 조화평균인 F1-score가 사용된다. 교차검증에서는 각 폴드에서 해당 지표를 계산하고 평균값을 사용한다.</p>
<p>이들 지표는 특정 클래스에 대한 성능을 강조하고자 할 때 유용하지만, 하나의 단일 손실 함수로 해석하기는 다소 어렵다.</p>
</section>
</section>
<section id="부트스트랩" class="level4">
<h4 class="anchored" data-anchor-id="부트스트랩">3. 부트스트랩</h4>
<p>부트스트랩은 주어진 추정량이나 통계적 학습 방법에 수반되는 불확실성을 정량화하는 데 사용할 수 있는, 매우 강력하고 폭넓게 적용 가능한 통계적 도구이다. 간단한 예로, 부트스트랩은 선형회귀 모형에서 회귀계수의 표준오차를 추정하는 데 사용될 수 있다. 그러나 선형회귀의 경우에는 \통계 소프트웨어가 이러한 표준오차를 자동으로 제공하므로, 부트스트랩의 활용 가치가 크지 않을 수 있다. 그럼에도 불구하고 부트스트랩의 진정한 장점은, 통계 소프트웨어가 자동으로 변동성 정보를 제공하지 않거나 이론적 계산이 어려운 다양한 통계적 학습 방법에도 손쉽게 적용할 수 있다는 점에 있다.</p>
<p>이제 두 개의 금융 자산 X와 Y에 고정된 금액을 투자한다고 가정하자. 이때 X와 Y는 각각 확률변수로서 수익률을 나타낸다. 우리는 전체 투자금의 <span class="math inline">\(\alpha\)</span> 비율을 자산 X에 투자하고, 나머지 <span class="math inline">\(1 - \alpha\)</span>를 자산 Y에 투자한다. 두 자산의 수익률에는 변동성이 존재하므로, 우리는 투자 전체의 위험, 즉 분산을 최소화하는 <span class="math inline">\(\alpha\)</span>를 선택하고자 한다. 이는 다음 분산을 최소화하는 문제로 표현된다.</p>
<p><span class="math inline">\(\text{Var}(\alpha X + (1 - \alpha)Y)\)</span>. 이 분산을 최소화하는 <span class="math inline">\(\alpha\)</span>는 다음과 같이 주어진다. <span class="math inline">\(\alpha = \frac{\sigma_{Y}^{2} - \sigma_{XY}}{\sigma_{X}^{2} + \sigma_{Y}^{2} - 2\sigma_{XY}}\)</span>, 여기서 <span class="math inline">\(\sigma_{X}^{2} = \text{Var}(X),\sigma_{Y}^{2} = \text{Var}(Y),\sigma_{XY} = \text{Cov}(X,Y)\)</span>이다.</p>
<p>현실적으로 <span class="math inline">\(\sigma_{X}^{2},\sigma_{Y}^{2},\sigma_{XY}\)</span>는 알려져 있지 않다. 대신 우리는 과거의 X와 Y 수익률을 포함한 데이터셋을 이용해 이들에 대한 추정값 <span class="math inline">\({\widehat{\sigma}}_{X}^{2},{\widehat{\sigma}}_{Y}^{2},{\widehat{\sigma}}_{XY}\)</span>를 계산할 수 있다. 이를 대입하면, 투자 분산을 최소화하는 <span class="math inline">\(\alpha\)</span>의 추정값은 다음과 같이 얻어진다.</p>
<p><span class="math display">\[\widehat{\alpha} = \frac{{\widehat{\sigma}}_{Y}^{2} - {\widehat{\sigma}}_{XY}}{{\widehat{\sigma}}_{X}^{2} + {\widehat{\sigma}}_{Y}^{2} - 2{\widehat{\sigma}}_{XY}}\]</span></p>
<p>이제 우리는 <span class="math inline">\(\widehat{\alpha}\)</span>의 정확도를 정량화하고자 한다. 이를 위해, X와 Y의 관측값 100쌍을 생성하고 <span class="math inline">\(\widehat{\alpha}\)</span>를 계산하는 과정을 1,000번 반복하였다. 그 결과 1,000개의 <span class="math inline">\(\widehat{\alpha}\)</span> 추정값을 얻을 수 있다. 이들 추정값의 평균은</p>
<p><span class="math inline">\(\overline{\alpha} = \frac{1}{1000}\overset{1000}{\sum_{r = 1}}{\widehat{\alpha}}_{r}\)</span>, 추정값들의 표준편차는 <span class="math inline">\(\sqrt{\frac{1}{1000 - 1}\overset{1000}{\sum_{r = 1}}({\widehat{\alpha}}_{r} - \overline{\alpha})^{2}}\)</span>으로 계산된다.</p>
<p>그러나 실제 데이터 분석에서는 이러한 모의실험 절차를 수행할 수 없다. 현실에서는 모집단으로부터 새로운 표본을 반복적으로 생성할 수 없기 때문이다. 이때 부트스트랩 접근법은 컴퓨터를 이용해 새로운 표본을 생성하는 과정을 모의함으로써, 추가적인 데이터 없이도 <span class="math inline">\(\widehat{\alpha}\)</span>의 변동성을 추정할 수 있게 해준다.</p>
<section id="부트스트랩-알고리즘-요약" class="level5">
<h5 class="anchored" data-anchor-id="부트스트랩-알고리즘-요약">부트스트랩 알고리즘 요약</h5>
<p>부트스트랩은 하나의 관측 데이터셋을 이용해 표본 추출 과정을 반복적으로 모의함으로써, 추정량의 변동성과 불확실성을 평가하는 방법이다. 절차는 다음과 같이 정리할 수 있다.</p>
<p><strong>1단계: 원자료 준비</strong></p>
<p>크기 n인 원래 데이터셋 <span class="math inline">\(Z = \{(x_{1},y_{1}),\ldots,(x_{n},y_{n})\}\)</span>을 준비한다. 이 데이터는 모집단으로부터 추출된 하나의 표본으로 간주한다.</p>
<p><strong>2단계: 부트스트랩 표본 생성</strong></p>
<p>원자료 Z로부터 크기 n의 표본을 복원추출하여 하나의 부트스트랩 데이터셋 <span class="math inline">\(Z^{*1}\)</span>을 생성한다. 이때 동일한 관측값이 여러 번 선택될 수도 있고, 어떤 관측값은 전혀 선택되지 않을 수도 있다.</p>
<p><strong>3단계: 관심 통계량 계산</strong></p>
<p>부트스트랩 표본 <span class="math inline">\(Z^{*1}\)</span>을 이용해 관심 있는 통계량 또는 추정량 <span class="math inline">\({\widehat{\theta}}^{*1}\)</span>을 계산한다. 예를 들어 회귀계수, 예측값, 최적 파라미터 등이 이에 해당한다.</p>
<p><strong>4단계: 반복 수행</strong></p>
<p>2단계와 3단계를 총 B번 반복하여, <span class="math inline">\({\widehat{\theta}}^{*1},{\widehat{\theta}}^{*2},\ldots,{\widehat{\theta}}^{*B}\)</span>와 같은 B개의 부트스트랩 추정값을 얻는다.</p>
<p><strong>5단계: 변동성 추정</strong></p>
<p>얻어진 부트스트랩 추정값들의 분포를 이용해 표준오차, 분산, 신뢰구간 등을 계산한다. 예를 들어 표준오차는 다음과 같이 추정된다.</p>
<p><span class="math display">\[\text{SE}_{B}(\widehat{\theta}) = \sqrt{\frac{1}{B - 1}\overset{B}{\sum_{r = 1}}\left( {\widehat{\theta}}^{*r} - \frac{1}{B}\overset{B}{\sum_{r' = 1}}{\widehat{\theta}}^{*r'} \right)^{2}}\]</span></p>
<p><strong>6단계: 해석</strong></p>
<p>계산된 표준오차나 분포를 바탕으로, 원래 데이터에서 계산된 추정량 <span class="math inline">\(\widehat{\theta}\)</span>의 불확실성과 안정성을 해석한다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/mldlmethod_intro_bootstrap.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
</section>
<section id="부트스트랩과-교차검증의-개념적-차이" class="level5">
<h5 class="anchored" data-anchor-id="부트스트랩과-교차검증의-개념적-차이">부트스트랩과 교차검증의 개념적 차이</h5>
<p>부트스트랩과 교차검증은 모두 재표본(resampling)에 기반한 방법이지만, 두 방법이 해결하고자 하는 문제와 그 철학은 본질적으로 다르다. 교차검증은 주어진 모형의 일반화 성능을 추정하는 데 초점을 맞추는 반면, 부트스트랩은 추정량이나 학습 결과에 수반되는 불확실성을 정량화하는 데 목적이 있다.</p>
</section>
<section id="교차검증-이-모형은-새로운-데이터에서-얼마나-잘" class="level5">
<h5 class="anchored" data-anchor-id="교차검증-이-모형은-새로운-데이터에서-얼마나-잘">교차검증: <span dir="rtl">”</span>이 모형은 새로운 데이터에서 얼마나 잘</h5>
<p>작동하는가”</p>
<p>교차검증은 학습 데이터의 일부를 의도적으로 제외한 뒤, 해당 데이터를 새로운 관측값처럼 사용하여 테스트 오차를 추정하는 방법이다. 핵심 관심사는 예측 성능이며, 특히 훈련 데이터에 포함되지 않은 관측값에 대해 모형이 얼마나 잘 일반화되는지를 평가하는 데 있다.</p>
<p>이 과정에서 각 관측값은 학습과 평가의 역할을 번갈아 수행하며, 이를 통해 훈련 오차와 구분되는 테스트 오차의 추정치를 얻는다. 따라서 교차검증은 주로 모형 선택이나 하이퍼파라미터 튜닝과 같이, 여러 후보 모형 중에서 어떤 모형이 더 나은지를 판단하는 데 사용된다.</p>
<p>요약하면, 교차검증은 <span dir="rtl">”</span>어떤 모형이 더 잘 맞는가”라는 질문에 답하기 위한 도구이다.</p>
</section>
<section id="부트스트랩-이-추정값은-얼마나-불확실한가" class="level5">
<h5 class="anchored" data-anchor-id="부트스트랩-이-추정값은-얼마나-불확실한가">부트스트랩: <span dir="rtl">”</span>이 추정값은 얼마나 불확실한가”</h5>
<p>부트스트랩은 하나의 데이터셋으로부터 복원추출을 반복함으로써, 동일한 모집단에서 여러 표본이 관측되는 상황을 모의하는 방법이다. 여기서 관심의 대상은 예측 성능이 아니라, 추정량 자체의 변동성이다.</p>
<p>부트스트랩은 특정 모형이나 통계량이 표본에 따라 얼마나 달라질 수 있는지를 평가하는 데 사용된다. 예를 들어, 회귀계수의 표준오차, 예측값의 변동성, 혹은 복잡한 학습 알고리즘의 출력이 얼마나 안정적인지를 파악하는 데 유용하다. 이는 추가적인 표본을 실제로 수집할 수 없는 상황에서도 불확실성을 정량화할 수 있게 해준다.</p>
<p>요약하면, 부트스트랩은 <span dir="rtl">”</span>이 추정값을 얼마나 믿을 수 있는가”라는 질문에 답하기 위한 도구이다.</p>
</section>
<section id="관점의-차이" class="level5">
<h5 class="anchored" data-anchor-id="관점의-차이">관점의 차이</h5>
<p>교차검증과 부트스트랩의 가장 큰 차이는, 재표본을 사용하는 이유에 있다. 교차검증은 학습 과정에서 일부 데이터를 제거함으로써 미래의 데이터 상황을 모의한다. 반면, 부트스트랩은 하나의 데이터셋을 반복적으로 재구성함으로써 동일한 표본 추출 과정을 모의한다.</p>
<p>이로 인해 교차검증은 모형의 예측 성능에 대한 평가와 선택에 적합하며, 부트스트랩은 추정량의 분산이나 표준오차를 추정하는 데 적합하다.</p>
</section>
</section>
</section>
<section id="chapter-5.-재표본-사례" class="level3">
<h3 class="anchored" data-anchor-id="chapter-5.-재표본-사례">Chapter 5. 재표본 사례</h3>
<section id="부스트랩" class="level4">
<h4 class="anchored" data-anchor-id="부스트랩">1. 부스트랩</h4>
<section id="사례1" class="level5">
<h5 class="anchored" data-anchor-id="사례1">사례1</h5>
<p>관측값 <span class="math inline">\(X_{1},\ldots,X_{n}\)</span>의 표본평균 <span class="math inline">\(\overline{X}\)</span>에 대해 표본 하나만 주어졌을 <span class="math inline">\(\overline{X}\)</span>의 불확실성(표준오차)을 어떻게 추정할 수 있는가?</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. 원자료 생성 (예제용)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.random.normal(loc<span class="op">=</span><span class="dv">0</span>, scale<span class="op">=</span><span class="dv">1</span>, size<span class="op">=</span><span class="dv">50</span>)  <span class="co"># n=50 표본</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(X)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 원래 표본 평균</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>theta_hat <span class="op">=</span> np.mean(X)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. 부트스트랩 수행</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> <span class="dv">1000</span>  <span class="co"># 부트스트랩 반복 횟수</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>theta_star <span class="op">=</span> np.empty(B)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> b <span class="kw">in</span> <span class="bu">range</span>(B):</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    X_star <span class="op">=</span> np.random.choice(X, size<span class="op">=</span>n, replace<span class="op">=</span><span class="va">True</span>)  <span class="co"># 복원추출</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    theta_star[b] <span class="op">=</span> np.mean(X_star)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. 부트스트랩 표준오차</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>bootstrap_se <span class="op">=</span> np.std(theta_star, ddof<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"원래 표본 평균 = </span><span class="sc">{</span>theta_hat<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"부트스트랩 표준오차 = </span><span class="sc">{</span>bootstrap_se<span class="sc">:.4f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>원래 표본 평균 = -0.2255 <br> 부트스트랩 표준오차 = 0.1334</p>
</section>
<section id="사례2" class="level5">
<h5 class="anchored" data-anchor-id="사례2">사례2</h5>
<p>선형회귀 <span class="math inline">\(Y = \beta_{0} + \beta_{1}X + \varepsilon\)</span> 에서 <span class="math inline">\({\widehat{\beta}}_{1}\)</span>의 불확실성을 부트스트랩으로 평가한다.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. 데이터 생성</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">0</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.random.normal(size<span class="op">=</span>n)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span><span class="op">*</span>X <span class="op">+</span> np.random.normal(scale<span class="op">=</span><span class="dv">1</span>, size<span class="op">=</span>n)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>X_mat <span class="op">=</span> sm.add_constant(X)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co"># 원래 회귀계수</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> sm.OLS(Y, X_mat).fit()</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>beta_hat <span class="op">=</span> model.params[<span class="dv">1</span>]</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. 부트스트랩</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>beta_star <span class="op">=</span> np.empty(B)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> b <span class="kw">in</span> <span class="bu">range</span>(B):</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">=</span> np.random.choice(np.arange(n), size<span class="op">=</span>n, replace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    X_star <span class="op">=</span> X_mat[idx]</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    Y_star <span class="op">=</span> Y[idx]</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    model_star <span class="op">=</span> sm.OLS(Y_star, X_star).fit()</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    beta_star[b] <span class="op">=</span> model_star.params[<span class="dv">1</span>]</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. 부트스트랩 표준오차</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>bootstrap_se <span class="op">=</span> np.std(beta_star, ddof<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"원래 회귀계수 추정값 = </span><span class="sc">{</span>beta_hat<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"부트스트랩 표준오차 = </span><span class="sc">{</span>bootstrap_se<span class="sc">:.4f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>원래 회귀계수 추정값 = 3.1147 <br> 부트스트랩 표준오차 = 0.0947</p>
</section>
</section>
<section id="검증세트-방법-loocv-k-겹-교차검증" class="level4">
<h4 class="anchored" data-anchor-id="검증세트-방법-loocv-k-겹-교차검증">2. 검증세트 방법, LOOCV, k-겹 교차검증</h4>
<p>seaborn auto 데이터의 mpg(Y)와 horsepower(X)의 함수 관계가 1차, 2차, 3차 관계 중 최소 MSE를 갖는 함수 관계는? 3 방법 모두 2차 함수관계가 최적 모형이다.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split, LeaveOneOut, KFold, cross_val_score</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> Pipeline</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> PolynomialFeatures</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LinearRegression</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> mean_squared_error</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co"># 1) 데이터 로드: seaborn mpg (Auto와 유사)</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> sns.load_dataset(<span class="st">"mpg"</span>)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="co"># horsepower 결측 제거 후 mpg, horsepower만 사용</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df[[<span class="st">"mpg"</span>, <span class="st">"horsepower"</span>]].dropna()</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> df[[<span class="st">"horsepower"</span>]].values</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> df[<span class="st">"mpg"</span>].values</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>degrees <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_model(deg: <span class="bu">int</span>):</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Pipeline([</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        (<span class="st">"poly"</span>, PolynomialFeatures(degree<span class="op">=</span>deg, include_bias<span class="op">=</span><span class="va">False</span>)),</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        (<span class="st">"lr"</span>, LinearRegression())</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> []</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="co"># 2) 검증 세트 방법(Validation Set Approach): 한 번만 랜덤 분할</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>X_tr, X_val, y_tr, y_val <span class="op">=</span> train_test_split(</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    X, y, test_size<span class="op">=</span><span class="fl">0.5</span>, random_state<span class="op">=</span><span class="dv">42</span>, shuffle<span class="op">=</span><span class="va">True</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> d <span class="kw">in</span> degrees:</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> make_model(d)</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>    model.fit(X_tr, y_tr)</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>    pred_val <span class="op">=</span> model.predict(X_val)</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>    mse_val <span class="op">=</span> mean_squared_error(y_val, pred_val)</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>    results.append({<span class="st">"method"</span>: <span class="st">"Validation set (50/50 split)"</span>, <span class="st">"degree"</span>: d, <span class="st">"MSE"</span>: mse_val})</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a><span class="co"># 3) LOOCV</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>loo <span class="op">=</span> LeaveOneOut()</span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> d <span class="kw">in</span> degrees:</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> make_model(d)</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>    scores <span class="op">=</span> cross_val_score(model, X, y, cv<span class="op">=</span>loo, scoring<span class="op">=</span><span class="st">"neg_mean_squared_error"</span>)</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>    mse_loo <span class="op">=</span> <span class="op">-</span>scores.mean()</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>    results.append({<span class="st">"method"</span>: <span class="st">"LOOCV"</span>, <span class="st">"degree"</span>: d, <span class="st">"MSE"</span>: mse_loo})</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a><span class="co"># 4) k-겹 교차검증 (예: 10-fold)</span></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>kf <span class="op">=</span> KFold(n_splits<span class="op">=</span>k, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> d <span class="kw">in</span> degrees:</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> make_model(d)</span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>    scores <span class="op">=</span> cross_val_score(model, X, y, cv<span class="op">=</span>kf, scoring<span class="op">=</span><span class="st">"neg_mean_squared_error"</span>)</span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>    mse_kfold <span class="op">=</span> <span class="op">-</span>scores.mean()</span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>    results.append({<span class="st">"method"</span>: <span class="ss">f"</span><span class="sc">{</span>k<span class="sc">}</span><span class="ss">-fold CV"</span>, <span class="st">"degree"</span>: d, <span class="st">"MSE"</span>: mse_kfold})</span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a><span class="co"># 5) 결과 정리</span></span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> pd.DataFrame(results).sort_values([<span class="st">"method"</span>, <span class="st">"degree"</span>]).reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(res)</span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">방법별 최소 MSE(가장 좋은 차수):"</span>)</span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a>best <span class="op">=</span> res.loc[res.groupby(<span class="st">"method"</span>)[<span class="st">"MSE"</span>].idxmin(), [<span class="st">"method"</span>, <span class="st">"degree"</span>, <span class="st">"MSE"</span>]]</span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(best.sort_values(<span class="st">"method"</span>).reset_index(drop<span class="op">=</span><span class="va">True</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>method degree MSE <br> 0 10-fold CV 1 24.199808 <br> 1 10-fold CV 2 19.228637 <br> 2 10-fold CV 3 19.266265</p>
<p>3 LOOCV 1 24.231514 <br> 4 LOOCV 2 19.248213 <br> 5 LOOCV 3 19.334984</p>
<p>6 Validation set (50/50 split) 1 25.573878 <br> 7 Validation set (50/50 split) 2 22.218020 <br> 8 Validation set (50/50 split) 3 22.667675 <br></p>
<p>방법별 최소 MSE(가장 좋은 차수): <br> method degree MSE <br> 0 10-fold CV 2 19.228637 <br> 1 LOOCV 2 19.248213 <br> 2 Validation set (50/50 split) 2 22.218020</p>
<section id="p-value와-resampling-비교" class="level5">
<h5 class="anchored" data-anchor-id="p-value와-resampling-비교">p-value와 resampling 비교</h5>
<p>statsmodels로 1차/2차/3차 다항회귀를 적합하고 p-value(특히 최고차 항의 p-value)를 확인한 뒤 동일한 세 모형에 대해 10-fold CV MSE를 계산하여 <span dir="rtl">”</span>p-value 기반 선택”과 <span dir="rtl">”</span>CV 기반 선택”을 한눈에 비교한다.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> KFold, cross_val_score</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> Pipeline</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> PolynomialFeatures</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LinearRegression</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 1) 데이터 준비</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> sns.load_dataset(<span class="st">"mpg"</span>)[[<span class="st">"mpg"</span>, <span class="st">"horsepower"</span>]].dropna()</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> df[<span class="st">"mpg"</span>].to_numpy()</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> df[<span class="st">"horsepower"</span>].to_numpy()</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>degrees <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span class="co"># 2) statsmodels: p-value 기반(중첩모형) 비교</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="co">#    - 1차: mpg ~ hp</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a><span class="co">#    - 2차: mpg ~ hp + hp^2</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a><span class="co">#    - 3차: mpg ~ hp + hp^2 + hp^3</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>sm_rows <span class="op">=</span> []</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> d <span class="kw">in</span> degrees:</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.column_stack([x<span class="op">**</span>k <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, d<span class="op">+</span><span class="dv">1</span>)])</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> sm.add_constant(X)  <span class="co"># 절편 포함</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> sm.OLS(y, X).fit()</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 최고차항 p-value(예: 2차면 hp^2의 p-value)</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    top_term_p <span class="op">=</span> model.pvalues[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>    sm_rows.append({</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>        <span class="st">"degree"</span>: d,</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>        <span class="st">"AIC"</span>: model.aic,</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>        <span class="st">"BIC"</span>: model.bic,</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>        <span class="st">"R2"</span>: model.rsquared,</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Adj_R2"</span>: model.rsquared_adj,</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Top-term p-value"</span>: <span class="bu">float</span>(top_term_p)</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>sm_table <span class="op">=</span> pd.DataFrame(sm_rows).sort_values(<span class="st">"degree"</span>)</span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"=== statsmodels (p-value / information criteria) ==="</span>)</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sm_table.to_string(index<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a><span class="co"># 3) sklearn: 10-fold CV MSE 비교</span></span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>X_skl <span class="op">=</span> df[[<span class="st">"horsepower"</span>]].to_numpy()</span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> poly_model(deg: <span class="bu">int</span>):</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Pipeline([</span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>        (<span class="st">"poly"</span>, PolynomialFeatures(degree<span class="op">=</span>deg, include_bias<span class="op">=</span><span class="va">False</span>)),</span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>        (<span class="st">"lr"</span>, LinearRegression())</span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>kf <span class="op">=</span> KFold(n_splits<span class="op">=</span><span class="dv">10</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a>cv_rows <span class="op">=</span> []</span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> d <span class="kw">in</span> degrees:</span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> poly_model(d)</span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>    scores <span class="op">=</span> cross_val_score(model, X_skl, y, cv<span class="op">=</span>kf, scoring<span class="op">=</span><span class="st">"neg_mean_squared_error"</span>)</span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a>    cv_rows.append({</span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>        <span class="st">"degree"</span>: d,</span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a>        <span class="st">"10-fold CV MSE (mean)"</span>: <span class="bu">float</span>(<span class="op">-</span>scores.mean()),</span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a>        <span class="st">"10-fold CV MSE (std)"</span>: <span class="bu">float</span>(scores.std())  <span class="co"># neg MSE의 std이므로 부호 유의: 아래에서 절대값 처리해도 됨</span></span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a>cv_table <span class="op">=</span> pd.DataFrame(cv_rows).sort_values(<span class="st">"degree"</span>)</span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a><span class="co"># std는 부호가 섞일 수 있어 MSE 기준으로 보기 쉽게 변환</span></span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a>cv_table[<span class="st">"10-fold CV MSE (std)"</span>] <span class="op">=</span> np.<span class="bu">abs</span>(cv_table[<span class="st">"10-fold CV MSE (std)"</span>])</span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">=== 10-fold CV (MSE) ==="</span>)</span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(cv_table.to_string(index<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true" tabindex="-1"></a><span class="co"># 4) 한 표로 합치기 (p-value vs CV)</span></span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true" tabindex="-1"></a>merged <span class="op">=</span> sm_table.merge(cv_table, on<span class="op">=</span><span class="st">"degree"</span>)</span>
<span id="cb4-85"><a href="#cb4-85" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">=== Combined: p-value vs CV ==="</span>)</span>
<span id="cb4-86"><a href="#cb4-86" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(merged.to_string(index<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb4-87"><a href="#cb4-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-88"><a href="#cb4-88" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb4-89"><a href="#cb4-89" aria-hidden="true" tabindex="-1"></a><span class="co"># 5) 선택 기준 예시 출력</span></span>
<span id="cb4-90"><a href="#cb4-90" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb4-91"><a href="#cb4-91" aria-hidden="true" tabindex="-1"></a><span class="co"># p-value 기준: 최고차항 p-value가 유의하지 않으면 더 높은 차수는 불필요하다고 보는 단순 규칙</span></span>
<span id="cb4-92"><a href="#cb4-92" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb4-93"><a href="#cb4-93" aria-hidden="true" tabindex="-1"></a>pv_choice <span class="op">=</span> merged.loc[merged[<span class="st">"Top-term p-value"</span>] <span class="op">&lt;</span> alpha, <span class="st">"degree"</span>].<span class="bu">max</span>()</span>
<span id="cb4-94"><a href="#cb4-94" aria-hidden="true" tabindex="-1"></a>pv_choice <span class="op">=</span> <span class="bu">int</span>(pv_choice) <span class="cf">if</span> pd.notna(pv_choice) <span class="cf">else</span> <span class="dv">1</span></span>
<span id="cb4-95"><a href="#cb4-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-96"><a href="#cb4-96" aria-hidden="true" tabindex="-1"></a><span class="co"># CV 기준: 평균 CV MSE 최소</span></span>
<span id="cb4-97"><a href="#cb4-97" aria-hidden="true" tabindex="-1"></a>cv_choice <span class="op">=</span> <span class="bu">int</span>(merged.loc[merged[<span class="st">"10-fold CV MSE (mean)"</span>].idxmin(), <span class="st">"degree"</span>])</span>
<span id="cb4-98"><a href="#cb4-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-99"><a href="#cb4-99" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">=== Simple choices ==="</span>)</span>
<span id="cb4-100"><a href="#cb4-100" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"p-value rule (alpha=</span><span class="sc">{</span>alpha<span class="sc">}</span><span class="ss">): choose degree = </span><span class="sc">{</span>pv_choice<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-101"><a href="#cb4-101" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"CV rule (min mean CV MSE): choose degree = </span><span class="sc">{</span>cv_choice<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>=== statsmodels (p-value / information criteria) === <br> degree AIC BIC R2 Adj_R2 Top-term p-value <br> 1 2361.323658 2369.266182 0.605948 0.604938 7.031989e-81 <br> 2 2272.353522 2284.267308 0.687559 0.685953 2.196340e-21 <br> 3 2273.531297 2289.416344 0.688214 0.685803 3.672973e-01</p>
<p>=== 10-fold CV (MSE) === <br> degree 10-fold CV MSE (mean) 10-fold CV MSE (std) <br> 1 24.199808 4.902966 <br> 2 19.228637 4.783560 <br> 3 19.266265 4.818808</p>
<p>=== Combined: p-value vs CV ===</p>
<p>degree AIC BIC R2 Adj_R2 Top-term p-value 10-fold CV MSE (mean) 10-fold CV MSE (std) <br> 1 2361.323658 2369.266182 0.605948 0.604938 7.031989e-81 24.199808 4.902966 <br> 2 2272.353522 2284.267308 0.687559 0.685953 2.196340e-21 19.228637 4.783560 <br> 3 2273.531297 2289.416344 0.688214 0.685803 3.672973e-01 19.266265 4.818808</p>
<p>=== Simple choices === <br> p-value rule (alpha=0.05): choose degree = 2 <br> CV rule (min mean CV MSE): choose degree = 2</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>