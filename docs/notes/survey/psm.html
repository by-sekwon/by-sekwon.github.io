<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>조사방법론. 8. 성향점수매칭(Propensity Score Matching, PSM) – 세상의 모든 통계 이야기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-44962e3d41ec9ccc254fd50f1af5efbe.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">세상의 모든 통계 이야기</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../notes/math_stat/index.html"> 
<span class="menu-text">기초수학·수리통계</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../notes/intro_stat/index.html" aria-current="page"> 
<span class="menu-text">기초통계·조사방법</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/linear_model/index.html"> 
<span class="menu-text">회귀·다변량</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl_intro/index.html"> 
<span class="menu-text">MLDL개념</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl_prediction/index.html"> 
<span class="menu-text">MLDL예측</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl_classification/index.html"> 
<span class="menu-text">MLDL분류</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/data_reduction/index.html"> 
<span class="menu-text">차원축소</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl_clustering/index.html"> 
<span class="menu-text">MLDL군집</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cardnews/index.html"> 
<span class="menu-text">카드뉴스</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../consult.html"> 
<span class="menu-text">통계상담</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../notes/survey/psm.html">📄 PSM 성향점수매칭</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/intro_stat/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">【기초통계】</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/intro_stat/concept_of_stat.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 통계학의 개념</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/intro_stat/data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 데이터와 통계</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/intro_stat/univariate.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 일변량 분석</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/intro_stat/crosstab.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 교차표 분석</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/intro_stat/goodness_of_fits.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 적합성 검정</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/intro_stat/normality.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 정규성 검정</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/intro_stat/correlation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 상관분석</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/intro_stat/anova.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 분산분석(ANOVA)</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/intro_stat/time_series.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 시계열 분석</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/survey/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">【조사방법론】</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/survey/survey_intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 조사방법 기초</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/survey/sample_design.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 표본설계</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/survey/questionnaire.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 설문지</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/survey/nonresponse.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 무응답 대체</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/survey/data_process.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 데이터 처리</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/survey/survey_scale.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 조사지 척도</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/survey/delphi_ahp_conjoint.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 델파이·AHP·컨조인트</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/survey/psm.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">📄 PSM 성향점수매칭</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#psm-개념" id="toc-psm-개념" class="nav-link active" data-scroll-target="#psm-개념">1. psm 개념</a></li>
  <li><a href="#성향점수매칭-절차" id="toc-성향점수매칭-절차" class="nav-link" data-scroll-target="#성향점수매칭-절차">2. 성향점수매칭 절차</a></li>
  <li><a href="#psm-사례연구" id="toc-psm-사례연구" class="nav-link" data-scroll-target="#psm-사례연구">3. psm 사례연구</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-body" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">조사방법론. 8. 성향점수매칭(Propensity Score Matching, PSM)</h1>
</div>



<div class="quarto-title-meta column-body">

    
  
    
  </div>
  


</header>


<section id="psm-개념" class="level4">
<h4 class="anchored" data-anchor-id="psm-개념">1. psm 개념</h4>
<section id="성향점수매칭propensity-score-matching-psm-배경" class="level5">
<h5 class="anchored" data-anchor-id="성향점수매칭propensity-score-matching-psm-배경">(1) 성향점수매칭(Propensity Score Matching, PSM) 배경</h5>
<p>정책 평가, 경제학 및 사회과학 분야에서 개입(처치, treatment)의 효과를 정량적으로 추정하는 것은 인과적 관계를 분석하는 데 있어 핵심적인 연구 과제이다. 이상적인 실험 설계는 무작위 배정을 통해 처치 그룹과 통제 그룹 간의 동질성을 보장하는 것이지만, 현실적으로 RCT를 수행하는 것은 윤리적·경제적·실무적 제약으로 인해 어려운 경우가 많다.</p>
<p>성향점수매칭은 관찰 연구에서 사용되는 준실험적 통계 기법으로, 무작위 대조군 연구의 수행이 불가능하거나 비현실적인 경우, 특정 처치나 중재의 효과를 추정하는 데 활용된다. PSM의 핵심 목표는 처치 그룹과 통제 그룹 간의 비교 가능성을 높여, 처치 효과의 인과적 추론을 보다 엄밀하게 수행하는 것이다. 이를 위해, 처치 여부에 영향을 미칠 수 있는 변수들(즉, 교란 변수)에 의해 발생하는 선택 편향을 최소화한다.</p>
<p>PSM은 개체가 처치를 받을 확률을 성향 점수로 추정한 후, 해당 점수가 유사한 개체들 간의 매칭을 수행하여 처치 효과를 분석한다. 이를 통해, 관찰 연구에서도 실험 연구와 유사한 조건을 조성함으로써 처치 효과가 결과 변수(예: 질병 발생, 사망률 등)에 미치는 영향을 보다 신뢰성 있게 평가할 수 있도록 한다. 다만, PSM은 관찰된 변수에 의한 선택 편향만을 조정할 수 있으며, 관찰되지 않은 변수에 의한 편향은 여전히 문제로 남을 수 있다는 점에서 한계를 가진다.</p>
<p>PSM의 핵심은 성별, 나이 등과 같은 관측된 특성을 기반으로 특정 개체가 치료 또는 중재를 받을 확률인 성향 점수를 추정하는 것이다. 이를 계산하기 위해 일반적으로 로지스틱 회귀분석이 활용되며, 개체별 성향 점수가 산출되면, 해당 점수를 기준으로 치료를 받은 집단과 받지 않은 집단 간의 매칭이 이루어진다. 이러한 과정은 두 집단 간의 관찰된 차이를 최소화하여 보다 유사한 비교군을 형성하고, 이후 치료나 중재가 결과 변수에 미치는 인과적 효과를 보다 정확하게 평가할 수 있도록 한다.</p>
</section>
<section id="psm-원리" class="level5">
<h5 class="anchored" data-anchor-id="psm-원리">(2) PSM 원리</h5>
<p>PSM은 개입을 받은 개체(처치 그룹)와 개입을 받지 않은 개체(통제 그룹)를 유사한 특성을 가진 개체끼리 매칭하여 비교하는 방법이다. 하지만, 모든 변수의 값이 동일한 개체를 찾는 것은 현실적으로 불가능하므로 성향점수라는 개념을 활용한다.</p>
<p>성향점수는 특정 개체가 개입을 받을 확률을 관찰된 변수의 함수로 추정한 값을 의미한다. 즉, <span class="math inline">\(P(D = 1|X)\)</span>, 여기서 <span class="math inline">\(D = 1\)</span>은 개입을 받은 여부, <span class="math inline">\(X\)</span>는 관찰된 개체의 특성 벡터를 의미한다.</p>
<p>각 개체의 성향 점수를 계산한 후, 성향 점수가 유사한 처치 그룹과 통제 그룹의 개체를 짝지어 매칭한다. 이후, 매칭된 개체들 간의 평균 결과 차이를 비교하여 개입 효과를 추정한다.</p>
</section>
<section id="주요-가정" class="level5">
<h5 class="anchored" data-anchor-id="주요-가정">(3) 주요 가정</h5>
<p>PSM이 올바른 인과적 추론을 수행하기 위해서는 다음 중요한 가정이 필요하다.</p>
<p><strong>조건부 독립성 가정</strong></p>
<p>개입 여부는 관찰된 변수 <span class="math inline">\(X\)</span>를 통제하면 결과와 독립적이어야 한다. 즉, <span class="math inline">\(Y(1),Y(0)\bot D|X\)</span> 여기서, <span class="math inline">\(Y(1)\)</span>과 <span class="math inline">\(Y(0)\)</span>은 각각 개입을 받은 경우와 받지 않은 경우의 잠재적 결과이다. 이 가정이 성립해야 개입 여부가 결과에 미치는 순수한 효과를 확인할 수 있다. 만약 관찰되지 않은 요인이 개입과 결과를 동시에 결정한다면, PSM은 편향된 결과를 초래할 수 있다.</p>
<p><strong>공통 지원 영역</strong></p>
<p>처치 그룹과 통제 그룹이 비교 가능한 영역에서 존재해야 한다. 즉, <span class="math inline">\(0 &lt; P(X) &lt; 1\)</span>. 이 가정은 처치 그룹과 통제 그룹이 성향 점수의 분포에서 겹치는 부분이 있어야 한다는 의미를 가진다. 만약 성향 점수가 처치 그룹과 통제 그룹 간에 크게 차이가 난다면, 비교할 수 있는 개체가 없어 매칭이 어려워지고, 결과의 신뢰성이 낮아질 수 있다.따라서, 성향 점수 분포가 겹치는 공통 지원 영역을 설정하여 분석을 수행해야 한다.</p>
</section>
</section>
<section id="성향점수매칭-절차" class="level4">
<h4 class="anchored" data-anchor-id="성향점수매칭-절차">2. 성향점수매칭 절차</h4>
<section id="샘플-선정-및-데이터-확보" class="level5">
<h5 class="anchored" data-anchor-id="샘플-선정-및-데이터-확보">(1) 샘플 선정 및 데이터 확보</h5>
<p>PSM을 수행하기 위해서는 먼저 측정할 개입 효과가 무엇인지 명확히 정의하고, 해당 효과를 분석할 수 있는 적절한 데이터 샘플을 선정해야 한다.</p>
<p><strong>효과 평가 변수 결정</strong></p>
<p>분석의 핵심은 특정 개입이 결과 변수에 미치는 영향을 추정하는 것이다. 예를 들어, 특정 약물 사용 여부가 환자의 질병 발생률이나 사망률에 미치는 영향을 평가하고자 할 경우, 약물 사용 여부를 기준으로 처치 그룹과 통제 그룹을 구분한 후 매칭을 수행해야 한다. 즉, 개입 변수를 명확히 정의한 후, 그 효과를 분석하기 위한 데이터 구조를 설계해야 한다.</p>
<p><strong>개입 그룹과 비교 가능한 통제 그룹 확보</strong></p>
<p>처치 그룹과 통제 그룹을 비교하기 위해 충분한 샘플 크기를 확보하는 것이 필수적이다. 데이터는 성향 점수를 예측할 수 있도록 개체의 주요 특성(예: 성별, 연령, 건강 상태, 사회경제적 요인 등)을 포함해야 한다. 가능하다면 동일한 데이터 출처를 활용하여 두 그룹 간 측정 편향을 최소화하는 것이 바람직하다.</p>
<p>이러한 데이터 확보 과정을 거쳐야 PSM이 정확한 인과적 효과를 추정할 수 있으며, 분석 결과의 신뢰성을 높일 수 있다.</p>
</section>
<section id="성향-점수-추정" class="level5">
<h5 class="anchored" data-anchor-id="성향-점수-추정">(2) 성향 점수 추정</h5>
<p>로짓(Logit) 또는 프로빗(Probit) 모델을 사용하여 개입을 받을 확률(성향점수)을 추정한다. <span class="math inline">\(P(Y = 1) = \frac{e^{\beta_{0} + \beta_{1}X_{1} + \ldots + \beta_{k}X_{k}}}{1 + e^{\beta_{0} + \beta_{1}X_{1} + \ldots + \beta_{k}X_{k}}}\)</span>, 여기서 <span class="math inline">\(X_{i}\)</span>는 개체의 관찰된 특성이다.</p>
</section>
<section id="매칭-수행" class="level5">
<h5 class="anchored" data-anchor-id="매칭-수행">(3) 매칭 수행</h5>
<p>성향 점수가 가장 가까운 개체를 매칭하는 방법을 사용한다. 매칭 개념은 다음과 같다.</p>
<ul>
<li><p>각 개체에 대해 성향 점수, <span class="math inline">\(P(X)\)</span>를 추정한다.</p></li>
<li><p>처치군(개입 그룹)의 개체를 하나 선택한다.</p></li>
<li><p>통제군(비개입 그룹)에서 해당 처치군 개체와 가장 가까운 성향 점수를 가진 개체를 찾아 매칭한다.</p></li>
<li><p>모든 처치군 개체에 대해 동일한 과정을 반복한다.</p></li>
<li><p>매칭이 완료되면 처치군과 통제군의 결과를 비교하여 개입 효과를 추정한다.</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/psm점수.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:60.0%"></p>
</figure>
</div>
<p>공통지지영역(Region of Common Support)이란, 처치집단과 비교집단의 성향점수 분포가 실제로 겹치는 구간을 의미한다. 이 영역은, 주어진 공변량에 대해 처치를 받은 개체와 받지 않은 개체가 모두 존재하는 성향점수 범위를 말한다. 따라서 이 영역 내에서는 서로 유사한 특성을 지닌 처치자와 비처치자를 짝지을 수 있으며, 이를 통해 공정한 비교가 가능해진다.</p>
<p>반면, 공통지지영역을 벗어난 사례들—즉 성향점수가 지나치게 낮거나 높아 비교 가능한 상대가 존재하지 않는 경우—에는 적절한 매칭이 불가능하므로, 분석 대상에서 제외하는 것이 일반적이다. 이러한 사례를 억지로 포함할 경우, 매칭의 정밀도가 떨어지고 처치효과 추정의 신뢰성 역시 손상될 수 있다.</p>
<p>결과적으로, 공통지지영역의 존재 여부와 그 폭은 성향점수 매칭의 적용 가능성과 결과의 타당성을 판단하는 데 있어 핵심적인 요소라 할 수 있다.</p>
<p>처치 그룹을 기준으로 비처치 그룹을 매칭하므로, 비처치 그룹의 크기가 충분히 커야 한다. 일반적으로 비처치 그룹의 크기는 처치 그룹의 최소 3배 이상이 되는 것이 바람직하다. 이는 매칭할 수 있는 후보 개체를 충분히 확보하여 매칭 품질을 높이고, 매칭되지 않는 처치군 개체의 발생을 최소화하기 위함이다.</p>
<p>그러나, 반드시 3배수를 원칙으로 해야 하는 것은 아니며, 연구 설계와 데이터 가용성에 따라 다를 수 있다. 비처치 그룹의 크기가 작을 경우, 복원 매칭을 고려할 수도 있지만, 특정 개체에 대한 과도한 의존이 발생할 수 있으므로 주의해야 한다.</p>
<p><strong>최근접 이웃 매칭(Nearest Neighbor Matching)</strong></p>
<p>최근접 이웃 매칭은 처치 그룹(개입을 받은 그룹)의 개체를 기준으로, 비처치 그룹(개입을 받지 않은 그룹)에서 가장 가까운 성향 점수를 가진 개체를 매칭하는 방법이다. 이 방법은 PSM에서 가장 널리 사용되는 매칭 기법 중 하나로, 처치군과 통제군 간의 비교 가능성을 높이고, 선택 편향을 최소화하는데 유용하다.</p>
<p><strong>1:1 최근접 이웃 매칭 (One-to-One Nearest Neighbor Matching)</strong></p>
<ul>
<li><p>처치군 개체 1개당 비처치군 개체 1개를 매칭하는 방식.</p></li>
<li><p>성향 점수 차이가 가장 작은 개체를 찾아 매칭함.</p></li>
<li><p>비복원 매칭: 한 개체는 한 번만 매칭됨 (더 공정한 비교 가능).</p></li>
<li><p>복원 매칭: 한 개체가 여러 번 매칭될 수 있음 (표본크기 유지 가능하나 권고하지 않음).</p></li>
</ul>
<p><strong>칼리퍼 매칭(Caliper Matching)</strong></p>
<p>처치군(개입 그룹)과 통제군(비개입 그룹) 간의 성향 점수 차이가 일정한 임계값(Threshold, 칼리퍼) 이하인 경우에만 매칭을 허용하는 방법이다. 즉, 처치군 개체와 가장 가까운 성향 점수를 가진 통제군 개체를 찾되, 성향 점수 차이가 너무 큰 경우에는 매칭을 허용하지 않는 방식이다. 칼리퍼 매칭은 잘못된 매칭을 방지하여 분석 결과의 신뢰도를 높이는 효과가 있지만, 매칭될 수 있는 개체 수가 줄어들 수 있다는 단점도 있다.</p>
<p>처치군 개체 <span class="math inline">\(i\)</span>의 성향 점수를 <span class="math inline">\(P(X_{i})\)</span>, 비처치군 개체 <span class="math inline">\(j\)</span>의 성향 점수를 <span class="math inline">\(P(X_{j})\)</span>라고 하면, <span class="math inline">\(|P(X_{i}) - P(X_{j})| &lt; C\)</span>, 여기서 C 는 칼리퍼 값(허용 임계값)이다. 만약 칼리퍼 값 = 0.05 → 성향 점수 차이가 0.05 이하인 경우에만 매칭 허용한다. 일반적으로 칼리퍼 값은 성향 점수 표준 편차의 0.2~0.5배 사이에서 설정하는 것이 권장된다.</p>
</section>
<section id="공변량-균형성-확인" class="level5">
<h5 class="anchored" data-anchor-id="공변량-균형성-확인">(4) 공변량 균형성 확인</h5>
<p>성향점수 매칭의 핵심은, 비실험자료에서도 마치 무작위 실험과 유사한 비교가 가능하도록, 처치집단과 비교집단 간의 공변량 분포를 정렬하는 데 있다. 따라서 매칭 이후에는 두 집단의 공변량 분포가 실제로 유사해졌는지를 검토하는 절차가 필수적으로 따라야 한다. 이러한 검토 과정을 공변량 균형성 확인(balance checking)이라 한다.</p>
<p>매칭 이전의 관찰자료에서는 일반적으로 처치집단과 비교집단의 특성이 서로 다르다. 예컨대, 고소득자일수록 특정 프로그램에 참여할 가능성이 높다면, 단순한 평균 비교만으로는 프로그램의 순수한 효과를 분리해낼 수 없다. 이에 따라, 성향점수를 이용하여 유사한 특성을 가진 비교 대상을 짝지은 후, 그 효과를 비교하려는 것이 PSM의 기본 원리이다. 그러나 이 짝짓기 과정이 얼마나 효과적으로 작동했는지를 판단하지 않으면, 매칭의 신뢰성은 담보될 수 없다.</p>
<p>공변량 균형성은 주로 다음과 같은 방법으로 평가된다. 첫째, 가장 널리 사용되는 지표는 표준화 평균 차이(Standardized Mean Difference, SMD)이다. 이는 두 집단의 각 공변량 평균 차이를 표준편차로 나눈 값으로, 표본 크기나 단위에 영향을 받지 않으므로 비교가 용이하다. SMD 값이 0에 가까울수록 두 집단의 분포가 유사하다는 것을 의미하며, 일반적으로 |SMD|가 0.1 미만이면 ‘양호한 균형’, 0.1 이상 0.2 미만이면 ‘수용 가능’, 0.2 이상이면 ’균형 부족’으로 해석된다.</p>
<p>둘째, 공변량의 분포를 시각적으로 확인하는 방법도 중요하다. 예를 들어, 각 공변량에 대해 처치집단과 비교집단의 밀도곡선(density plot)이나 박스플롯(box plot)을 중첩하여 나타냄으로써, 두 집단 간 분포의 유사성을 직관적으로 확인할 수 있다. 또한 QQ-플롯이나 누적분포함수(CDF) 비교도 유용한 시각적 도구로 활용된다.</p>
<p>한편, 일부 연구에서는 매칭 전후의 공변량에 대해 통계적 유의성 검정(t-test, χ² 검정 등)을 시행하기도 하나, 이는 권장되지 않는다. 그 이유는, 매칭 후 표본 크기가 작아짐에 따라 통계적 검정력이 급격히 낮아지거나 반대로, 표본 수가 매우 크면 사소한 차이도 유의하게 나타날 수 있기 때문이다. 따라서 공변량 균형성 평가는 주로 SMD와 시각적 분석을 병행하는 것이 바람직하다.</p>
</section>
<section id="처치효과-추정" class="level5">
<h5 class="anchored" data-anchor-id="처치효과-추정">(5) 처치효과 추정</h5>
<p>공변량 균형성이 확보되면, 다음 단계는 처치가 결과 변수에 미치는 영향을 추정하는 것이다. 성향점수 매칭을 통해 짝지어진 처치자와 비처치자의 결과 변수를 비교함으로써, 우리는 해당 처치의 인과적 효과(causal effect)를 도출할 수 있다.</p>
<p>처치효과 추정은 일반적으로 두 가지 방식으로 구분된다.</p>
<ol type="1">
<li><p>ATT (Average Treatment Effect on the Treated) 실제로 처치를 받은 집단에 대해, 해당 처치를 받지 않았을 경우의 반사실적 결과(counterfactual outcome)를 추정하고 그 차이를 계산한 것이다. <span class="math inline">\(ATT = E[Y(1) - Y(0) | D=1]\)</span> 실무에서는, 매칭된 쌍(pair) 간 결과값의 평균 차이로 ATT를 계산한다.</p></li>
<li><p>ATE (Average Treatment Effect) 전체 집단(처치자 + 비처치자)에 대해 처치가 있을 경우와 없을 경우의 결과 차이를 추정하는 것으로, 보다 강한 가정을 필요로 한다. 특히 모든 개체가 처치와 비처치 상태 모두에 노출될 수 있었던(overlap) 가능성을 전제해야 한다. ATE는 종종 성향점수 기반 가중치(weighting)를 통해 추정된다.</p></li>
</ol>
<p>처치효과 추정 시 고려해야 할 중요한 점은 다음과 같다.</p>
<ul>
<li><p>공통지지영역 밖의 표본 제거: 성향점수가 지나치게 높은 혹은 낮은 사례는 매칭이 불가능하므로 분석에서 제외한다.</p></li>
<li><p>매칭 방법의 선택: 최근접 이웃 매칭(nearest neighbor), 다대일 매칭(many-to-one), 칼리퍼 매칭(caliper matching) 등 다양한 방법 중 선택해야 하며, 매칭 방식은 결과의 편향과 분산에 영향을 미친다.</p></li>
<li><p>추론의 방법: 매칭된 데이터는 독립 표본이 아니므로, 표준 오차와 신뢰구간 추정 시 부트스트랩 등의 방법을 사용하는 것이 적절하다.</p></li>
</ul>
</section>
</section>
<section id="psm-사례연구" class="level4">
<h4 class="anchored" data-anchor-id="psm-사례연구">3. psm 사례연구</h4>
<section id="연구-목적" class="level5">
<h5 class="anchored" data-anchor-id="연구-목적">(1) 연구 목적</h5>
<p>Jalan &amp; Ravallion(2003)은 인도의 농촌 지역에서 파이프 수돗물 공급이 아동의 건강(특히 설사병 발병률)에 미치는 영향을 평가하기 위해 연구를 수행하였다.</p>
<ul>
<li><p>수돗물이 공급된 가구의 아동이 설사병 발생 위험이 낮은가?</p></li>
<li><p>소득수준이나 부모교육수준이 수돗물의 효과에 영향을 미치나?</p></li>
<li><p>수돗물 혜택이 특정 사회경제적 계층에 따라 다르게 나타나나?</p></li>
</ul>
<p>무작위 배정이 불가능한 상황에서, 연구자들은 성향점수 매칭을 사용하여 관찰된 데이터에서 최대한 인과적 효과를 추정하고자 하였다.</p>
</section>
<section id="데이터-및-성향-점수-추정" class="level5">
<h5 class="anchored" data-anchor-id="데이터-및-성향-점수-추정">(2) 데이터 및 성향 점수 추정</h5>
<p>연구에서는 1993-1994년 인도 국가 대표 가구 조사 데이터를 활용하였다. 총 33,000개 농촌 가구(1,765개 마을)에 대한 데이터를 분석하였으며, 다음과 같은 변수를 이용하여 성향 점수를 추정하였다.</p>
<p><strong>개입 변수(Treatment Variable)</strong></p>
<p>개입(처치)은 가구가 파이프 수돗물을 이용하는지 여부로 정의되었다. 따라서, 파이프 수돗물을 이용하는 가구(처치 그룹) vs.&nbsp;이용하지 않는 가구(통제 그룹)을 비교 대상으로 삼았다.</p>
<p><strong>성향 점수 추정을 위한 독립 변수(관찰된 특성, Covariates)</strong></p>
<p>파이프 수돗물 공급 여부에 영향을 미칠 수 있는 변수를 고려하여, 로지스틱 회귀분석을 사용해 성향 점수를 추정하였다.</p>
<p>① 마을 수준 변수(Village-Level Variables)</p>
<ul>
<li><p>마을 규모(인구)</p></li>
<li><p>관개된 농지 면적</p></li>
<li><p>공공 인프라(학교, 병원, 도로, 철도역, 버스 정류장 등)</p></li>
</ul>
<p>② 가구 수준 변수(Household-Level Variables)</p>
<ul>
<li><p>사회경제적 지위 (자산 보유: 자전거, 라디오, 탈곡기 등)</p></li>
<li><p>가구주의 교육 수준 (문맹 여부, 초등·중등 교육 여부)</p></li>
<li><p>종교 및 카스트 (힌두교, 이슬람교 등)</p></li>
<li><p>가구원 수 및 연령 구조</p></li>
</ul>
<p>이러한 변수들을 활용하여, 개별 가구가 파이프 수돗물을 사용할 확률(성향 점수)을 추정하였다.</p>
</section>
<section id="매칭-방법" class="level5">
<h5 class="anchored" data-anchor-id="매칭-방법">(3) 매칭 방법</h5>
<p>성향 점수가 계산된 후, 연구자들은 처치 그룹(파이프 수돗물 이용 가구)과 통제 그룹(이용하지 않는 가구)을 유사한 성향 점수를 가진 개체끼리 매칭하였다. 연구에서는 최근접 이웃 매칭 및 칼리퍼 매칭을 사용하였다.</p>
<p>최근접 이웃 매칭: 성향 점수가 가장 가까운 처치군-통제군 개체를 1:1로 매칭한다.</p>
<p>칼리퍼 매칭: 성향 점수 차이가 일정 임계값 이하인 경우에만 매칭한다.</p>
<p>매칭이 수행된 후, 공통 지원 영역(Common Support)을 확인하여 성향 점수가 지나치게 차이 나는 개체들은 분석에서 제외하였다.</p>
</section>
<section id="결과-분석-및-개입-효과-추정" class="level5">
<h5 class="anchored" data-anchor-id="결과-분석-및-개입-효과-추정">(4) 결과 분석 및 개입 효과 추정</h5>
<p>매칭이 완료된 후, 연구자들은 처치 그룹과 통제 그룹 간의 아동 설사병 발생률 차이를 분석하였다.</p>
<p>파이프 수돗물을 이용하는 가구의 아동은 설사병 발생률이 21% 낮았다. 즉, 파이프 수돗물이 없었다면, 설사병 발생률이 21% 더 높았을 것으로 추정됨.</p>
<p>소득 수준이 높은 가구와 부모의 교육 수준이 높은 가구에서 더 큰 건강 개선 효과가 나타났다. 고소득층 가구일수록 파이프 수돗물을 통한 혜택을 더욱 크게 누림. 교육 수준이 높은 부모일수록 위생 관리가 철저하여 추가적인 건강 효과를 봄.</p>
<p>저소득층 가구에서는 파이프 수돗물이 오히려 설사병 발생 증가와 연관됨. 연구자들은 물 저장 방식의 차이가 주요 원인일 것으로 해석함. 저소득층 가구에서는 깨끗한 물을 공급받더라도 올바르게 저장하지 못하면 오염 위험이 증가할 수 있음.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>