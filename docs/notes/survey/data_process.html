<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>조사방법론. 5. 데이터 처리 – 세상의 모든 통계 이야기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-d24c3880db9ce3ca4ea2d5bb002bea1f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">세상의 모든 통계 이야기</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">기초수학</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-">    
        <li>
    <a class="dropdown-item" href="../../notes/math/function.html">
 <span class="dropdown-text">함수</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math/derivate_integral.html">
 <span class="dropdown-text">미분적분</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math/vector.html">
 <span class="dropdown-text">벡터</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math/matrix.html">
 <span class="dropdown-text">행렬</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--1" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">수리통계</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--1">    
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/probability.html">
 <span class="dropdown-text">확률</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/random_variable.html">
 <span class="dropdown-text">확률변수</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/famous_distribution.html">
 <span class="dropdown-text">유명한분포</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/multi_variate.html">
 <span class="dropdown-text">다변량확률변수</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/random_sample.html">
 <span class="dropdown-text">확률표본_난수생성</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/estimation.html">
 <span class="dropdown-text">추정</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/hypothesis_testing.html">
 <span class="dropdown-text">가설검정_신뢰구간</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--2" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">조사방법론</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--2">    
        <li>
    <a class="dropdown-item" href="../../notes/survey/survey_intro.html">
 <span class="dropdown-text">조사방법 기초</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/sample_design.html">
 <span class="dropdown-text">표본설계</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/questionnaire.html">
 <span class="dropdown-text">설문지</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/nonresponse.html">
 <span class="dropdown-text">무응답 대체</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/data_process.html">
 <span class="dropdown-text">데이터 처리</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/survey_scale.html">
 <span class="dropdown-text">조사지 척도</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/delphi_ahp_conjoint.html">
 <span class="dropdown-text">델파이_AHP_컨조인트</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/psm.html">
 <span class="dropdown-text">PSM 성향점수매칭</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--3" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">일변량분석</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--3">    
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/concept_of_stat.html">
 <span class="dropdown-text">일변량분석 개념</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/data.html">
 <span class="dropdown-text">데이터와 통계</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/univariate.html">
 <span class="dropdown-text">일변량분석</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/crosstab.html">
 <span class="dropdown-text">교차표분석</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/goodness_of_fits.html">
 <span class="dropdown-text">적합성검정</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/normality.html">
 <span class="dropdown-text">정규변환</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/correlation.html">
 <span class="dropdown-text">상관분석</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/anova.html">
 <span class="dropdown-text">실험설계 분산분석</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/time_series.html">
 <span class="dropdown-text">시계열분석</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--4" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">회귀분석</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--4">    
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_concept.html">
 <span class="dropdown-text">개념&amp;추정</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_selection.html">
 <span class="dropdown-text">변수선택</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_multicolin.html">
 <span class="dropdown-text">다중공선성</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_diagnosis.html">
 <span class="dropdown-text">회귀진단</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_logistic.html">
 <span class="dropdown-text">로지스틱회귀</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../cardnews/index.html"> 
<span class="menu-text">카드뉴스</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../consult.html"> 
<span class="menu-text">통계상담</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--5" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">📡스트리밍</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--5">    
        <li>
    <a class="dropdown-item" href="https://by-sekwonappio-esqshnv7wueapp4da6jrizn.streamlit.app" target="_blank">
 <span class="dropdown-text">실시간주가[5대종목]</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://by-sekwonappio-k5e5n7wasvj3kveyqbwmgc.streamlit.app/" target="_blank">
 <span class="dropdown-text">대전유성구 일기예보</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#chapter-1.-데이터-처리-개요" id="toc-chapter-1.-데이터-처리-개요" class="nav-link active" data-scroll-target="#chapter-1.-데이터-처리-개요"><span class="header-section-number">0.1</span> <span style="color:green">chapter 1. 데이터 처리 개요</span></a>
  <ul>
  <li><a href="#데이터-코딩" id="toc-데이터-코딩" class="nav-link" data-scroll-target="#데이터-코딩"><span class="header-section-number">0.1.1</span> <span style="color:blue">1. 데이터 코딩</span></a></li>
  <li><a href="#수치-데이터를-파일에-입력하기" id="toc-수치-데이터를-파일에-입력하기" class="nav-link" data-scroll-target="#수치-데이터를-파일에-입력하기"><span class="header-section-number">0.1.2</span> <span style="color:blue">2. 수치 데이터를 파일에 입력하기</span></a></li>
  <li><a href="#데이터-편집-editing" id="toc-데이터-편집-editing" class="nav-link" data-scroll-target="#데이터-편집-editing"><span class="header-section-number">0.1.3</span> <span style="color:blue">3. 데이터 편집 editing</span></a></li>
  </ul></li>
  <li><a href="#chapter-2.-가중치-산정" id="toc-chapter-2.-가중치-산정" class="nav-link" data-scroll-target="#chapter-2.-가중치-산정"><span class="header-section-number">0.2</span> <span style="color:green">chapter 2. 가중치 산정</span></a>
  <ul>
  <li><a href="#단계-비율-조정-가중치" id="toc-단계-비율-조정-가중치" class="nav-link" data-scroll-target="#단계-비율-조정-가중치"><span class="header-section-number">0.2.1</span> <span style="color:blue">1. 단계 비율 조정 가중치</span></a></li>
  <li><a href="#차등-선택-확률-가중치" id="toc-차등-선택-확률-가중치" class="nav-link" data-scroll-target="#차등-선택-확률-가중치"><span class="header-section-number">0.2.2</span> <span style="color:blue">2. 차등 선택 확률 가중치</span></a></li>
  <li><a href="#단위-무응답-조정을-위한-가중치" id="toc-단위-무응답-조정을-위한-가중치" class="nav-link" data-scroll-target="#단위-무응답-조정을-위한-가중치"><span class="header-section-number">0.2.3</span> <span style="color:blue">3. 단위 무응답 조정을 위한 가중치</span></a></li>
  <li><a href="#사후-가중치" id="toc-사후-가중치" class="nav-link" data-scroll-target="#사후-가중치"><span class="header-section-number">0.2.4</span> <span style="color:blue">4. 사후 가중치</span></a></li>
  </ul></li>
  <li><a href="#chapter-3.-결측치-대체" id="toc-chapter-3.-결측치-대체" class="nav-link" data-scroll-target="#chapter-3.-결측치-대체"><span class="header-section-number">0.3</span> <span style="color:green">chapter 3. 결측치 대체</span></a>
  <ul>
  <li><a href="#결측값을-처리하는-방법" id="toc-결측값을-처리하는-방법" class="nav-link" data-scroll-target="#결측값을-처리하는-방법"><span class="header-section-number">0.3.1</span> <span style="color:blue">1. 결측값을 처리하는 방법</span></a></li>
  <li><a href="#대체방법" id="toc-대체방법" class="nav-link" data-scroll-target="#대체방법"><span class="header-section-number">0.3.2</span> <span style="color:blue">2. 대체방법</span></a></li>
  </ul></li>
  <li><a href="#chapter-4.-복합표본-분산-추정" id="toc-chapter-4.-복합표본-분산-추정" class="nav-link" data-scroll-target="#chapter-4.-복합표본-분산-추정"><span class="header-section-number">0.4</span> <span style="color:green">chapter 4. 복합표본 분산 추정</span></a>
  <ul>
  <li><a href="#테일러-급수-근사법taylor-series-approximation" id="toc-테일러-급수-근사법taylor-series-approximation" class="nav-link" data-scroll-target="#테일러-급수-근사법taylor-series-approximation"><span class="header-section-number">0.4.1</span> <span style="color:blue">1. 테일러 급수 근사법(Taylor Series Approximation)</span></a></li>
  <li><a href="#균형-반복-복제법balanced-repeated-replication-brr" id="toc-균형-반복-복제법balanced-repeated-replication-brr" class="nav-link" data-scroll-target="#균형-반복-복제법balanced-repeated-replication-brr"><span class="header-section-number">0.4.2</span> <span style="color:blue">2. 균형 반복 복제법(Balanced Repeated Replication, BRR)</span></a></li>
  <li><a href="#잭나이프-반복-복제법jackknife-repeated-replication-jrr" id="toc-잭나이프-반복-복제법jackknife-repeated-replication-jrr" class="nav-link" data-scroll-target="#잭나이프-반복-복제법jackknife-repeated-replication-jrr"><span class="header-section-number">0.4.3</span> <span style="color:blue">3. 잭나이프 반복 복제법(Jackknife Repeated Replication, JRR)</span></a></li>
  <li><a href="#방법-비교" id="toc-방법-비교" class="nav-link" data-scroll-target="#방법-비교"><span class="header-section-number">0.4.4</span> <span style="color:blue">4. 방법 비교</span></a></li>
  </ul></li>
  <li><a href="#chapter-5.-조사-데이터-문서화-및-메타-데이터" id="toc-chapter-5.-조사-데이터-문서화-및-메타-데이터" class="nav-link" data-scroll-target="#chapter-5.-조사-데이터-문서화-및-메타-데이터"><span class="header-section-number">0.5</span> <span style="color:green">chapter 5. 조사 데이터 문서화 및 메타 데이터</span></a>
  <ul>
  <li><a href="#메타-데이터" id="toc-메타-데이터" class="nav-link" data-scroll-target="#메타-데이터"><span class="header-section-number">0.5.1</span> <span style="color:blue">1. 메타 데이터</span></a></li>
  <li><a href="#파라-데이터" id="toc-파라-데이터" class="nav-link" data-scroll-target="#파라-데이터"><span class="header-section-number">0.5.2</span> <span style="color:blue">2. 파라 데이터</span></a></li>
  <li><a href="#메타데이터-vs-파라데이터-비교" id="toc-메타데이터-vs-파라데이터-비교" class="nav-link" data-scroll-target="#메타데이터-vs-파라데이터-비교"><span class="header-section-number">0.5.3</span> <span style="color:blue">3. 메타데이터 vs 파라데이터 비교</span></a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/by-sekwon/by-sekwon.github.io/edit/main/notes/survey/data_process.qmd" class="toc-action"><i class="bi bi-github"></i>편집</a></li><li><a href="https://github.com/by-sekwon/by-sekwon.github.io/issues/new" class="toc-action"><i class="bi empty"></i>이슈 보고</a></li><li><a href="https://github.com/by-sekwon/by-sekwon.github.io/blob/main/notes/survey/data_process.qmd" class="toc-action"><i class="bi empty"></i>소스코드 보기</a></li></ul></div></nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">조사방법론. 5. 데이터 처리</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><br></p>
<section id="chapter-1.-데이터-처리-개요" class="level3" data-number="0.1">
<h3 data-number="0.1" class="anchored" data-anchor-id="chapter-1.-데이터-처리-개요"><span class="header-section-number">0.1</span> <span style="color:green">chapter 1. 데이터 처리 개요</span></h3>
<p>설문조사 데이터 처리 단계는 전체 분석의 신뢰성과 타당성을 확보하기 위한 일련의 핵심 절차로, 수집된 원자료(raw data)를 정제하고 분석 가능한 형식으로 전환하는 과정이다. 이 단계는 단순히 데이터를 저장하거나 정리하는 수준을 넘어, 조사 설계의 오류를 최소화하고 결과 해석의 타당성을 높이는 데 목적이 있다.</p>
<p>우선, 데이터 수집은 설문 응답을 체계적으로 취합하는 초기 단계로, 온라인 조사, 전화 인터뷰, 대면 면접, 우편 설문 등 다양한 방법을 통해 이루어진다. 이때 수집된 응답은 원자료 형태로 존재하며, 즉각적인 분석보다는 사전 정제와 구조화가 필요하다. 그다음 단계인 텍스트 데이터 코딩은 자유응답형(예: 기타 의견 서술) 응답을 분류 기준에 따라 범주화하고, 이를 수치형 코드로 전환하여 정형 데이터와 통합할 수 있도록 한다. 이 과정은 주관적 해석이 개입될 수 있으므로 사전 정의된 코딩 기준이 필수적이다.</p>
<p>데이터 입력은 응답 정보를 전산화된 데이터베이스로 옮기는 단계로, 자동화 시스템을 사용하더라도 이중 입력 검증, 일관성 점검 등을 통해 정확성을 확보해야 한다. 이어서 편집 및 오류 확인 단계에서는 응답 값 간 논리적 불일치, 이상치, 무응답 값 등 오류 가능성을 점검하고, 필요한 경우 수정하거나 주석을 붙인다. 이 과정은 설문 설계상의 문제를 사후적으로 보완하는 역할도 수행한다.</p>
<p>결측값 대체는 응답 누락으로 인해 생기는 데이터 불완전성을 해소하기 위한 과정으로, 단순 평균 대체, 회귀 추정, 다중 대체(Multiple Imputation) 등의 통계적 기법이 사용된다. 결측값을 어떻게 다루느냐에 따라 분석 결과의 신뢰도와 일반화 가능성이 달라질 수 있으므로, 대체 방법의 선택은 신중해야 한다.</p>
<p>가중치 생성은 조사 표본이 실제 모집단을 얼마나 잘 대표하는지를 보정하기 위한 단계로, 층화 변수(예: 성별, 연령, 지역) 기반의 보정 가중치, 비응답 보정, 사후 층화(post-stratification) 등이 사용된다. 이는 특히 비확률 표본이거나 응답률이 낮은 조사에서 필수적인 절차이다.</p>
<p>마지막으로 분산 추정은 분석 결과의 불확실성을 측정하는 단계로, 표준 오차, 신뢰구간 등을 산출한다. 복잡 표본 설계(예: 층화, 군집)가 사용된 경우, 단순 무작위 표본 추출을 가정한 일반 분석 방법이 적합하지 않기 때문에 설계 효과(design effect)를 고려한 분산 추정 기법을 적용해야 한다. 이로써 표본 추정치의 통계적 정확도를 보다 정교하게 평가할 수 있다.</p>
<p>전체적으로 이 과정은 단순한 데이터 정리의 수준을 넘어서, 분석의 정합성과 재현 가능성을 높이기 위한 필수 절차로 기능하며, 설문조사의 신뢰성과 타당성을 실질적으로 결정짓는 핵심 단계라 할 수 있다.</p>
<section id="데이터-코딩" class="level4" data-number="0.1.1">
<h4 data-number="0.1.1" class="anchored" data-anchor-id="데이터-코딩"><span class="header-section-number">0.1.1</span> <span style="color:blue">1. 데이터 코딩</span></h4>
<p>설문 조사에서 코딩은 응답 데이터를 정형화하여 분석 가능한 형태로 전환하는 과정으로, 전체 데이터 품질과 해석의 정확성을 좌우하는 핵심 단계다. 폐쇄형 질문의 경우, 미리 정의된 선택지에 따라 각 응답을 숫자로 부호화하는 것이 일반적이며, 이는 비교적 간단하고 자동화가 용이하다. 예를 들어, “귀하의 현재 고용 상태는 무엇입니까?”라는 질문에 대해 ‘정규직’, ‘비정규직’, ‘실업’, ‘학생’ 등의 응답 항목이 있을 경우, 각각을 1, 2, 3, 4 등으로 코드화할 수 있다.</p>
<p>반면, 개방형 질문은 응답자가 자신의 생각을 자유롭게 서술하는 형태로, 훨씬 더 복잡한 코딩 절차를 요구한다. 동일한 의미를 전달하더라도 표현 방식이 제각각이기 때문에, 일관된 분류 체계를 적용하기 위해서는 사전에 코딩 기준표(codebook)를 개발하고, 훈련된 코더가 이를 토대로 수작업 혹은 반자동화 방식으로 응답을 분류해야 한다. 예를 들어, “귀하가 생각하는 현재 경제의 가장 큰 문제는 무엇입니까?”라는 질문에 대해 ‘물가 상승’, ‘인플레이션’, ’가격이 너무 비쌈’이라는 응답이 들어왔다면, 이들을 하나의 범주로 묶어 같은 코드값을 부여해야 한다.</p>
<p>이 과정에서 주관적 판단이 개입될 수 있으므로, 동일한 응답에 대해 다른 코더가 동일한 코드를 부여하도록 하는 코딩 일치도(inter-coder reliability) 점검이 필요하다. 또한 산업, 직업, 질병 분류 등과 같이 공공 표준 분류체계(KSIC, ISCO 등)를 사용하는 경우에는 더 정교한 매핑 작업이 요구된다.</p>
<p>결과적으로, 코딩은 단순한 기술적 작업이 아니라 설문 응답의 의미를 체계적으로 해석하고 분석 가능하게 만드는 중요한 지적 과정이다. 특히 개방형 응답이나 복잡한 다중응답 항목에서는 코딩의 품질이 조사 전체의 신뢰성과 타당성에 직결되므로, 코딩 기준의 명확성, 코더의 훈련, 품질 점검 절차가 필수적이다.</p>
<ul>
<li><p><strong>예비 분석</strong>: 수집된 응답을 검토하여 공통 패턴을 파악한다. 응답 내용을 기반으로 주요 범주를 설정한다.</p></li>
<li><p><strong>코드북 개발</strong>: 응답을 분류할 코드 체계를 설계한다. 각 코드에 대한 명확한 정의를 포함한다. 예를 들어, 산림 활용 관련 개방형 질문이 있다면, 1 = 목재 생산, 2 = 레크리에이션(산림욕, 캠핑 등), 3 = 환경 보호, 4 = 연구 및 교육, 5 = 기타</p></li>
<li><p><strong>응답 매핑</strong>: 개별 응답을 코드북에 따라 적절한 코드로 변환한다. 응답이 여러 개의 범주에 해당할 경우, 우선순위 규칙을 적용하거나 다중 코드를 허용할 수 있다.</p></li>
<li><p><strong>신뢰성 검토</strong>: 여러 명의 분석자가 같은 응답을 동일한 코드로 부여하는지 확인한다. 코딩 일관성 검증을 위해 상호 신뢰도 테스트를 수행한다.</p></li>
</ul>
<section id="코딩의-본질" class="level5" data-number="0.1.1.1">
<h5 data-number="0.1.1.1" class="anchored" data-anchor-id="코딩의-본질"><span class="header-section-number">0.1.1.1</span> (1) 코딩의 본질</h5>
<p>코딩은 단순히 텍스트를 숫자로 바꾸는 기계적 과정이 아니라, 조사 응답 내용을 분석이 가능한 형태로 요약하고 구조화하는 핵심 작업이다. 개별 응답을 의미 있는 범주로 분류함으로써, 방대한 데이터를 정리하고 비교 가능한 자료로 전환할 수 있다. 즉, 코딩은 원자료를 해석 가능하고 통계 처리에 적합한 형태로 가공하는 과정이며, 응답자의 다양한 의견을 정제된 분석 단위로 추출해내는 역할을 한다.</p>
<p>효과적인 코딩 시스템을 구축하기 위해서는 몇 가지 필수 요소가 갖추어져야 한다. 첫째, 모든 코드는 통계 분석 과정에서 고유하게 식별될 수 있도록 독립된 숫자 값으로 설정되어야 하며, 이는 데이터 처리의 정확성과 효율성에 직결된다. 둘째, 각 코드에는 응답 내용을 명확하게 설명해주는 텍스트 라벨이 함께 제공되어야 해, 코드가 어떤 의미를 담고 있는지를 쉽게 파악할 수 있도록 해야 한다. 셋째, 코딩 구조는 포괄적이어야 하며, 응답자의 어떤 답변도 최소한 하나의 코드에 포함될 수 있어야 한다. 넷째, 각 코드는 서로 겹치지 않도록 상호 배타적으로 구성되어야 하며, 동일한 응답이 중복해서 분류되는 일이 없어야 한다. 마지막으로, 코드 범주는 분석의 목적과 샘플 크기에 맞추어 실용적인 수준으로 유지되어야 하며, 지나치게 세분화된 코드는 분석의 복잡성을 높일 수 있다.</p>
<p>이러한 코딩의 원칙은 산림 관련 조사를 포함한 다양한 주제의 조사에 적용될 수 있다. 예를 들어, 응답자가 “건강을 위해 산에 자주 간다”고 응답한 경우, 이 내용을 ‘산림 복지 이용’이라는 범주로 정의하고 ‘2’라는 숫자 코드를 부여할 수 있다. 마찬가지로 “목재를 직접 채취해서 사용한다”는 응답은 ‘1=목재 생산’ 코드에 포함시킬 수 있다. 이처럼 명확한 코딩 구조는 응답자의 서술형 답변을 체계적으로 정리하고, 정량적 분석의 기반을 다지는 데 필수적인 도구로 작동한다.</p>
<p><strong>코드 구조의 지속적인 검토와 개선</strong></p>
<p>코딩 과정에서는 사전에 정의된 코드 체계를 기반으로 응답을 분류하지만, 실제 조사 현장에서 수집되는 응답은 예외적이거나 복합적인 경우가 많아 기존 코드 구조에 완벽히 부합하지 않을 수 있다. 특히 개방형 문항이나 새로운 사회 현상을 반영한 응답에서는, 기존의 분류 기준으로는 설명이 어려운 경우가 발생한다. 이러한 상황을 해결하기 위해 초기 응답 데이터를 활용하여 코드 체계의 타당성을 사전에 검토하고, 필요 시 코딩 카테고리를 수정하거나 보완하는 절차가 필요하다.</p>
<p>예를 들어, 기존의 산림 이용 목적을 ‘목재 생산’, ‘관광’, ‘사유림 보존’ 등으로 분류하던 코드 체계는 ’탄소중립을 위한 산림 보전’과 같은 새로운 응답 내용을 충분히 설명하지 못할 수 있다. 이런 경우 기존 코드를 억지로 적용하기보다는, 새로운 분류를 도입하거나 세부 카테고리를 추가하여 코드 구조를 유연하게 재편성하는 것이 바람직하다.</p>
<p>이처럼 코딩 구조는 한 번 설정하고 끝나는 것이 아니라, 응답 자료의 다양성과 변화하는 조사 환경에 맞춰 지속적으로 검토하고 개선해야 한다. 이를 통해 코딩의 정확성과 응답 분류의 적절성을 높일 수 있으며, 조사 결과의 해석도 보다 정밀해진다. 따라서 코딩 체계는 고정된 틀이라기보다, 실질적인 데이터와 맥락에 맞춰 유기적으로 진화해야 하는 작업으로 이해되어야 한다.</p>
<p>모든 응답을 포괄할 수 있는 코딩 체계를 설계하는 것은 데이터의 완전성과 분석의 정확성을 확보하는 데 필수적이다. 조사 과정에서는 응답자가 질문에 명확하게 답변하는 경우만 있는 것이 아니라, 무응답, 해당 없음, 거부 응답 등 다양한 예외 상황이 발생한다. 이러한 모든 경우를 체계적으로 반영할 수 있도록 코딩 구조는 사전에 신중하게 설계되어야 한다.</p>
<p>첫 번째 전략은 응답이 없는 경우를 위한 코드 설정이다. 응답자가 질문에 아무런 답변을 하지 않았을 때, 이를 단순한 누락으로 처리하면 분석 과정에서 혼란이 발생할 수 있다. 따라서 이 경우에는 “미확인”이라는 의미의 별도 코드를 부여하여, 해당 응답이 의도적으로 빠졌음을 명확히 표시한다. 예를 들어, 단일 숫자 체계에서는 9, 두 자리 숫자 체계에서는 99를 사용할 수 있다.</p>
<p>두 번째로는 특정 질문이 응답자에게 적용되지 않는 경우이다. 이는 설문 흐름상 논리적으로 해당 질문이 불필요한 경우인데, 이를 구분 없이 단순 결측으로 처리하면 응답자의 특성을 왜곡할 수 있다. 따라서 “적용 불가”라는 의미의 고유 코드(예: 0 또는 00)를 사용하여, 분석자가 이를 명확히 식별하고 분석 대상에서 제외하거나 별도로 처리할 수 있도록 해야 한다.</p>
<p>세 번째는 기타 특수 응답의 처리이다. 예를 들어, “답변을 거부함”, “잘 모르겠다”와 같은 응답은 설문 문항에 대한 반응이긴 하지만, 내용적으로 유효한 데이터로 보기 어려운 경우가 많다. 이 역시 별도의 코드를 부여하여 정규 응답과 구분하는 것이 바람직하다. 이를 통해 분석자는 이러한 특수 응답을 전체 응답률 계산에서 제외하거나, 추가 분석 시 변수로 활용할 수 있다.</p>
<p>이러한 보조 응답 코드들을 미리 정의하고, 설문지 설계 시점부터 적용하는 것은 조사 자료의 품질을 높이고, 추후 분석 시 오류나 혼동을 줄이는 데 중요한 역할을 한다. 특히 대규모 표본조사나 반복조사에서는 이러한 표준화된 코딩 체계가 일관성과 비교 가능성을 보장하는 데 필수적이다.</p>
<p><strong>결론 및 시사점</strong> 코딩은 단순히 응답을 숫자로 변환하는 기술적 절차를 넘어, 조사 목적에 맞는 응답 내용을 요약하고 구조화하는 해석적 과정이다. 이를 위해 코드의 수와 범주 분류 체계는 분석 목표에 부합하도록 신중하게 설계되어야 하며, 이 과정에서 상호 배타성과 포괄성이라는 원칙을 동시에 충족해야 한다. 즉, 하나의 응답이 두 개 이상의 코드에 중복되지 않도록 하면서도, 어떤 응답도 누락되지 않도록 체계를 갖추는 것이 중요하다.</p>
<p>연구자가 설정한 가설이나 분석 목적에 따라 코드 체계는 유연하게 설계되어야 하며, 통계적으로 의미 있는 비교와 해석이 가능하도록 조정되어야 한다. 특히 새로운 데이터가 기존 코드 체계와 맞지 않을 경우, 해당 구조가 여전히 유효한지 재검토하고 필요한 경우 수정하는 과정이 필수적이다. 이를 통해 변화하는 응답 경향과 사회적 맥락에 맞춰 설문의 분석력을 유지할 수 있다.</p>
<p>또한, “응답 없음”, “미확인”, “적용 불가” 등과 같은 예외 응답들을 위한 별도 코드 체계를 마련하는 것은 데이터 누락이나 분석 왜곡을 방지하는 데 큰 역할을 한다. 이러한 부가 응답 코드는 설문 응답의 전체 구조를 온전하게 반영할 수 있게 해주며, 분석 시 결과의 신뢰성을 높여준다.</p>
<p>결론적으로, 코딩 체계의 설계와 유지보수는 단순한 데이터 정리 작업이 아니라, 조사 데이터의 질을 결정짓는 핵심적인 과정으로 이해되어야 하며, 그 중요성은 설문 설계 초기 단계부터 반영되어야 한다.</p>
</section>
<section id="필드-코딩" class="level5" data-number="0.1.1.2">
<h5 data-number="0.1.1.2" class="anchored" data-anchor-id="필드-코딩"><span class="header-section-number">0.1.1.2</span> (2) 필드 코딩</h5>
<p><strong>필드 코딩의 개념</strong></p>
<p>필드 코딩은 설문조사 현장에서 개방형 질문의 장점과 폐쇄형 질문의 효율성을 결합한 방식으로, 조사원이 응답자의 자유로운 진술을 들은 직후, 해당 응답을 사전에 정의된 코드 범주 중 하나로 분류하는 실시간 코딩 기법이다. 응답자는 자신의 언어로 서술형 답변을 제공하되, 조사원은 이미 준비된 코딩 체계에 따라 즉시 해당 응답을 구조화된 데이터로 전환한다.</p>
<p>이러한 방식은 사후에 별도로 개방형 응답을 수집하고 코딩하는 번거로움을 줄이고, 조사 현장에서 코딩 기준이 일관되게 적용될 수 있다는 장점을 지닌다. 특히 대규모 조사를 수행하거나 반복적인 질문이 많은 경우, 시간과 인력의 효율성을 크게 향상시킨다. 단, 조사원의 코딩 판단이 결과에 직접 영향을 미치기 때문에, 사전 교육과 명확한 코드북 제공이 필수적이며, 조사 중 혼란이 발생하지 않도록 지속적인 모니터링과 품질 점검이 필요하다.</p>
<p><strong>필드 코딩의 절차</strong></p>
<ul>
<li>응답자에게 개방형 질문을 제시 → 자유롭게 서술형 응답을 하도록 유도한다.</li>
<li>조사원이 즉시 응답을 해석 → 해당 응답이 포함될 수 있는 코드 범주를 검토한다.</li>
<li>사전 정의된 코드 리스트와 비교하여 적절한 코드 선택 → 가장 적합한 카테고리에 배정한다.</li>
<li>코딩을 완료하고 데이터 저장 → 이후 데이터 분석에서 활용 가능하도록 정리한다.</li>
</ul>
<p><strong>필드 코딩 장단점</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 31%">
<col style="width: 52%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">구분</td>
<td style="text-align: center;">항목</td>
<td style="text-align: center;">설명</td>
</tr>
<tr class="even">
<td rowspan="3" style="text-align: center;">장점</td>
<td style="text-align: center;">즉각적인 코딩 가능</td>
<td style="text-align: center;">응답을 수집하면서 동시에 코딩을 수행하여 사후 코딩 과정이 불필요</td>
</tr>
<tr class="odd">
<td style="text-align: center;">질문에 대한 깊이 있는 탐색 가능</td>
<td style="text-align: center;">인터뷰어가 응답 내용을 추가로 탐색하여 보다 정확한 분류 가능</td>
</tr>
<tr class="even">
<td style="text-align: center;">응답자의 자유도 보장</td>
<td style="text-align: center;">완전한 폐쇄형 질문과 달리, 응답자의 입장에서 보다 자연스러운 답변 제공 가능</td>
</tr>
<tr class="odd">
<td rowspan="3" style="text-align: center;">단점</td>
<td style="text-align: center;">인터뷰어의 해석에 따른 오류 발생 가능</td>
<td style="text-align: center;">같은 응답이라도 조서자마다 코드 부여 방식이 다를 수 있음</td>
</tr>
<tr class="even">
<td style="text-align: center;">실시간 처리의 부담</td>
<td style="text-align: center;">조사원이 실시간으로 응답을 분석하고 코드화해야 하므로 부담이 클 수 있음</td>
</tr>
<tr class="odd">
<td style="text-align: center;">복잡한 코드 체계의 경우 어려움</td>
<td style="text-align: center;">코드의 수가 많거나 복잡하면 인터뷰어가 즉시 적절한 범주를 선택하기 어려울 수 있음</td>
</tr>
</tbody>
</table>
<p><strong>필드 코딩과 사후 코딩 비교</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 36%">
<col style="width: 43%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">구분</td>
<td style="text-align: center;">필드 코딩</td>
<td style="text-align: center;">오피스 코딩</td>
</tr>
<tr class="even">
<td style="text-align: center;">코딩 시점</td>
<td style="text-align: center;">실시간 코딩 (인터뷰 진행 중)</td>
<td style="text-align: center;">조사 후 코딩 (설문 응답을 저장한 후)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">책임자</td>
<td style="text-align: center;">조사원이 직접 코드화</td>
<td style="text-align: center;">전문 코더가 응답을 해석하여 코드화</td>
</tr>
<tr class="even">
<td style="text-align: center;">장점</td>
<td style="text-align: center;">즉각적인 데이터 정리 가능, 추가 탐색 가능</td>
<td style="text-align: center;">보다 체계적이고 일관성 있는 코딩 가능</td>
</tr>
<tr class="odd">
<td style="text-align: center;">단점</td>
<td style="text-align: center;">인터뷰어의 주관 개입 가능, 실시간 처리 부담</td>
<td style="text-align: center;">시간이 많이 소요됨, 사후 코드 검토 필요</td>
</tr>
</tbody>
</table>
</section>
<section id="코딩-품질-지표" class="level5" data-number="0.1.1.3">
<h5 data-number="0.1.1.3" class="anchored" data-anchor-id="코딩-품질-지표"><span class="header-section-number">0.1.1.3</span> (3) 코딩 품질 지표</h5>
<p>코딩 과정에서 발생할 수 있는 개념적 오류나 실행의 비일관성은 설문조사 데이터의 신뢰성과 타당성에 중대한 영향을 미친다. 개념적 오류는 질문의 의도와 코딩 범주 간의 불일치에서 비롯되며, 응답자의 진술을 잘못 해석하거나 본래의 의미와 다르게 분류하는 경우 발생한다. 예를 들어, 응답자가 “산림을 가족과 함께 쉬러 간다”고 했을 때, 이를 단순히 ’여가활동’으로만 코딩하면 ’가족 중심 활동’이라는 사회문화적 맥락이 누락될 수 있다.</p>
<p>또한 실행의 비일관성은 동일한 응답이 조사원마다 서로 다른 코드로 분류되는 경우로, 코딩 지침이 모호하거나 조사원 교육이 충분하지 않을 때 자주 발생한다. 이는 데이터의 비교 가능성을 떨어뜨리고 분석 결과의 왜곡을 초래할 수 있다. 따라서 일관된 코딩 기준을 마련하고, 정기적인 코딩 검토 및 품질 관리를 통해 이러한 오류를 최소화하는 것이 중요하다.</p>
<p><strong>코딩 구조의 취약점</strong></p>
<p>코딩 구조가 취약하게 설계될 경우, 의미적으로 서로 다른 응답이 동일한 코드 범주에 포함되어 분석 결과에 왜곡을 초래할 수 있다. 이는 단순한 분류상의 실수가 아니라, 체계적인 오분류로 이어져 분석의 신뢰성을 떨어뜨리는 요인이 된다. 특히 응답 항목 간의 차이가 미묘하거나 사회문화적 맥락이 개입되는 경우, 이러한 위험은 더욱 커진다.</p>
<p>예를 들어, 학력을 기준으로 소득을 분석할 때 “고등학교 졸업”이라는 항목에 정규 고등학교 졸업자와 검정고시 합격자가 동일하게 포함되면, 두 집단 간 경험과 사회적 배경의 차이를 간과하게 된다. 더 나아가, ’3년 전 졸업’과 ’최근 검정고시 합격’은 시간적, 교육적 맥락에서도 차이가 있으므로 별도의 코딩 처리가 필요하다. 따라서 코딩 구조는 분석 목적과 변수의 의미를 충분히 반영하도록 정교하게 설계되어야 하며, 애매하거나 복합적인 응답에 대해 세분화된 코드 범주를 마련하는 것이 체계적인 오류를 줄이는 핵심이다.</p>
<p><strong>코더 변량 coder variance</strong></p>
<p>코더 변량(coder variance)은 동일한 응답에 대해 서로 다른 코더들이 다르게 코딩함으로써 발생하는 데이터의 변동성을 의미한다. 이는 주관적인 판단이 개입되는 개방형 질문이나 복잡한 분류 작업에서 자주 나타나며, 조사 결과의 일관성과 신뢰도를 저하시킬 수 있다.</p>
<p>코더 변량은 조사 데이터의 전체 오차 중 ’코딩 단계’에서 발생하는 오차를 구성하며, 설문 응답 그 자체의 내용이나 응답자의 특성이 아닌 코더의 해석이나 경험, 숙련도에 따라 달라질 수 있다. 예를 들어, 동일한 “기타 의견” 응답을 어떤 코더는 ’환경 보호’로, 다른 코더는 ’산림 복지’로 분류할 경우, 해당 항목에 대한 통계적 추정치에 차이가 발생하게 된다.</p>
<p>따라서 코더 변량을 줄이기 위해서는 명확한 코딩 지침서 제공, 사전 훈련, 사후 일관성 검사 등의 조치가 필요하며, 가능한 경우 자동화된 코딩 시스템이나 복수 코더 간의 교차 검토 절차를 도입하는 것이 바람직하다. 이처럼 코더 변량은 조사 설계의 품질 관리와 데이터 정합성을 확보하는 데 반드시 고려되어야 하는 요소이다.</p>
<p><strong>코더마다 같은 코딩 구조를 다르게 사용할 가능성이 있음</strong></p>
<p>코딩 과정에서 각 코더가 동일한 코딩 구조를 다르게 해석하고 사용하는 경우가 발생할 수 있다. 이는 코더마다 특정 코드 범주를 선택하는 경향성이 다르기 때문이며, 조사 데이터의 일관성과 정확성에 영향을 미치는 주요 요인 중 하나다.</p>
<p>예를 들어, 어떤 코더는 애매한 응답에 대해 “기타”나 “명확히 지정되지 않음”과 같은 잔여 코드를 자주 사용하는 반면, 다른 코더는 더 구체적인 범주에 억지로라도 할당하려는 경향을 보일 수 있다. 또한, 동일한 응답 내용에 대해 해석 방식이 달라 각기 다른 코드가 부여되는 경우도 발생한다. 이러한 차이는 코더의 경험, 훈련 수준, 또는 주관적 판단 기준에서 기인할 수 있다.</p>
<p>결과적으로, 이러한 비일관성은 동일한 응답이 상황에 따라 다르게 처리되어 통계 분석의 왜곡을 초래할 수 있으므로, 코더 간의 해석 차이를 줄이기 위한 명확한 지침과 코딩 기준의 일관된 적용이 필수적이다.</p>
<p><strong>코더별 코딩 편차를 측정하는 방법</strong></p>
<p>코더별 코딩 편차는 조사 데이터의 품질을 정량적으로 평가하기 위해 중요한 분석 대상이다. 이를 측정하는 대표적인 방법 중 하나는 내집단 상관계수(interclass correlation coefficient, ICC)를 활용하여 코더 간의 일관성을 분석하는 것이다. 이 계수는 동일한 응답에 대해 여러 코더가 얼마나 유사한 코드를 부여했는지를 수치로 표현하며, 값이 1에 가까울수록 높은 일치도를 의미한다.</p>
<p>실제 사례로, 영국에서 수행된 한 연구에서는 코더 간 ICC 평균값이 0.001로 보고되었다. 이는 매우 낮은 값으로, 코더 간 일치도가 크지 않다는 것을 보여준다. 비록 이 수치는 일반적으로 조사원(interviewer) 효과보다 작은 수준이지만, 여전히 조사 통계의 변동성과 신뢰도에 영향을 줄 수 있다.</p>
<p>따라서, 코딩 과정에서 코더 간 편차를 최소화하고, 통계 결과의 왜곡을 방지하기 위해서는 코더 훈련 강화, 코드북의 명확화, 정기적인 모니터링과 평가가 필요하다.</p>
<p><strong>코더 변량이 조사 통계에 미치는 영향</strong></p>
<p>코더 변량은 코딩 과정에서 각 코더가 동일한 응답을 해석하고 분류하는 방식의 차이로 인해 발생하는 변동성으로, 이로 인해 조사 통계의 정확도와 신뢰도에 영향을 미칠 수 있다. 특히 개방형 질문이나 복잡한 분류 기준이 있는 항목의 경우, 코더 간 해석 차이는 미묘한 코딩 편차를 초래할 수 있으며, 이러한 편차가 누적되면 전체 통계 추정치에 영향을 줄 수 있다.</p>
<p>예를 들어, 특정 직업을 “전문직”으로 분류할지 “기술직”으로 분류할지를 놓고 코더마다 판단이 다르면, 직업군별 분포나 관련 변수와의 연관성 분석에서 통계적으로 유의미한 차이가 나타날 수 있다. 비록 개별 코딩의 차이는 작을지라도, 표본 규모가 크고 코더 수가 많을수록 이 편차가 전체 조사 결과의 분산을 증가시키고, 결과적으로 통계적 해석의 불확실성을 높일 수 있다.</p>
<p>코더 변량이 조사 통계의 분산에 미치는 영향을 나타내는 공식: <span class="math inline">\(Deff = 1 + \rho_{c}(m - 1)(1 - r)\)</span>, 여기서 <span class="math inline">\(\rho_{c}\)</span>은 코더의 내집단 상관계수, <span class="math inline">\(m\)</span>은 개별 코더가 코딩한 평균 사례 수, <span class="math inline">\(r\)</span>은 특정 코드의 신뢰도이다.</p>
<p><strong>코더 변량이 조사 결과에 미치는 영향</strong></p>
<p>코더 변량이 조사 결과에 미치는 영향은 작지만 무시할 수 없는 수준이다. 비록 동일한 코드 구조를 사용하더라도, 코더는 개인의 판단과 해석 방식에 따라 동일한 응답을 다르게 분류할 수 있다. 이러한 차이는 특히 자유응답형(open-ended) 문항이나 복잡한 범주 체계를 사용하는 경우 두드러지며, 결과적으로 조사 추정치의 일관성과 신뢰성을 저해할 수 있다.</p>
<p>훈련된 코더는 일반적으로 코딩 결정에서 더 높은 일관성을 보이며, 조사원에 비해 상대적으로 작은 변동성을 유발한다. 그러나 한 명의 코더가 처리하는 응답 수는 대개 매우 많기 때문에, 적은 수준의 코더 변량도 전체 표본 추정치에 영향을 줄 수 있다. 이는 표준 오차의 증가로 이어져 결과 해석 시 통계적 불확실성을 높이는 요인이 된다. 따라서 코딩 매뉴얼의 명확화, 반복 교육, 이중 코딩(double coding)을 통한 검증 과정이 중요하다.</p>
</section>
</section>
<section id="수치-데이터를-파일에-입력하기" class="level4" data-number="0.1.2">
<h4 data-number="0.1.2" class="anchored" data-anchor-id="수치-데이터를-파일에-입력하기"><span class="header-section-number">0.1.2</span> <span style="color:blue">2. 수치 데이터를 파일에 입력하기</span></h4>
<p><strong>데이터 입력의 개념</strong></p>
<p>데이터 입력, 또는 데이터 캡처는 설문조사 과정에서 수집된 정보를 전자적 형태로 전환하는 단계로, 분석을 위한 기초 작업 중 하나이다. 이 과정은 수집된 응답을 컴퓨터 파일에 체계적으로 입력하여 이후 통계 처리와 해석이 가능하도록 준비하는 것을 의미한다. 데이터 입력 방식은 설문조사의 수행 방식에 따라 다양하게 결정된다.</p>
<p>예를 들어, 컴퓨터 지원 면접 조사(CAPI, Computer-Assisted Personal Interviewing)의 경우, 조사원이나 응답자가 설문 소프트웨어를 통해 직접 데이터를 입력함으로써 별도의 입력 과정 없이 응답과 동시에 데이터가 수집된다. 전화 응답 시스템에서는 터치톤 입력 또는 음성 인식을 통해 응답자가 직접 입력한 정보가 자동으로 기록되며, 이는 인터뷰어 없이도 데이터 입력이 이루어지는 자동화 방식이다.</p>
<p>반면 종이 설문지를 사용하는 전통적인 조사에서는 데이터 입력자가 일일이 수기로 응답 내용을 전산 시스템에 입력해야 한다. 이 과정은 시간이 많이 소요되며 오류 가능성이 존재하기 때문에, 최근에는 마크 문자 인식(Mark Recognition) 또는 광학 문자 인식(OCR, Optical Character Recognition) 기술을 활용하여 입력 속도를 높이고 정확성을 개선하려는 노력이 증가하고 있다.</p>
<p>결국, 데이터 입력은 수집된 응답을 디지털 자산으로 전환하는 핵심 과정이며, 입력 방식의 선택은 조사 방식, 예산, 시간, 데이터 정확성 요구 수준 등에 따라 결정된다.</p>
<p><strong>인간 데이터 입력 방식의 한계</strong></p>
<p>인간이 직접 수행하는 데이터 입력 방식은 설문조사에서 전통적으로 사용되어 왔으나, 여러 가지 한계를 가지고 있다. 가장 큰 문제는 높은 인건비와 시간 소요이다. 사람이 응답지를 일일이 검토하고 숫자화하는 과정은 정확도를 확보하기 위해 반복 검증이 요구되며, 이는 전반적인 조사 비용을 크게 증가시키는 요인이 된다.</p>
<p>보통 이러한 방식에서는 데이터 정확성을 확보하기 위해 100% 재입력(Double Data Entry) 또는 2인 검증 등의 절차가 수행된다. 하지만 이러한 노력에도 불구하고 사람의 실수로 인한 오류 가능성은 완전히 제거되지 않는다. 특히 대규모 조사에서는 수만 건의 응답을 처리해야 하므로, 누락, 중복, 오타 등 다양한 입력 오류가 발생할 수 있다.</p>
<p>이러한 한계를 극복하고자 최근에는 컴퓨터 지원 데이터 수집(CAPI, CAWI 등) 방식이 선호되고 있다. 이는 입력 작업을 자동화함으로써 입력 오류를 줄이고, 동시에 비용과 시간을 절감하는 효과를 기대할 수 있다. 결과적으로, 설문조사의 효율성과 정확성을 동시에 확보하기 위해 사람의 수작업보다 디지털 기반 입력 방식이 점차 주류로 자리잡고 있는 추세다.</p>
</section>
<section id="데이터-편집-editing" class="level4" data-number="0.1.3">
<h4 data-number="0.1.3" class="anchored" data-anchor-id="데이터-편집-editing"><span class="header-section-number">0.1.3</span> <span style="color:blue">3. 데이터 편집 editing</span></h4>
<p><strong>데이터 편집의 개념</strong></p>
<p>데이터 편집은 설문조사에서 수집된 응답 자료가 통계 분석에 적합하도록 정제하는 초기 단계로, 데이터의 정확성과 논리적 일관성을 확보하는 데 필수적인 과정이다. 수집된 데이터는 종종 응답 누락, 상호 모순된 답변, 비현실적인 값 등 다양한 오류를 포함할 수 있기 때문에, 분석 전에 반드시 점검과 수정이 필요하다.</p>
<p>이 과정은 인터뷰어가 현장에서 수기로 응답을 확인하거나, 조사 감독자가 응답지를 검토하며 오류를 찾아내는 방식으로 진행될 수 있다. 또한, 데이터 입력 과정에서 입력 담당자가 입력값을 확인하고, 전문 연구자가 조사 설계와 비교하여 논리적 타당성을 점검하는 작업도 포함된다. 최근에는 자동화된 컴퓨터 소프트웨어를 활용한 논리적 규칙 기반 검증 시스템을 통해 일관성 없는 응답이나 허용 범위를 벗어난 값을 자동으로 탐지하고 수정하는 방식이 널리 사용되고 있다.</p>
<p>편집의 목적은 단순히 오류를 제거하는 데 그치지 않고, 원래 설계된 질문 의도에 부합하는 응답 체계를 회복하는 데 있다. 이를 통해 분석 결과의 신뢰성을 높이고, 조사 데이터의 품질을 한층 더 향상시킬 수 있다.</p>
<p><strong>편집의 주요 내용</strong></p>
<p>편집의 주요 내용은 다음과 같은 세 가지 요소로 요약할 수 있다.</p>
<p>첫째, 편집은 조사원이나 응답자가 기록한 원자료를 점검하고 보정함으로써 데이터 품질을 향상시키는 데 중점을 둔다. 응답자가 실수로 잘못 기입했거나 조사원이 부정확하게 기록한 항목을 수정하여, 수집된 데이터가 현실을 보다 정확하게 반영하도록 한다.</p>
<p>둘째, 코딩과 결측값 대체도 편집의 일환으로 포함된다. 특히 개방형 응답을 범주화하여 수치 코드로 변환하는 코딩 작업과, 누락된 값을 적절한 통계기법으로 보완하는 대체 작업은 편집 과정 중 핵심적인 절차에 해당한다.</p>
<p>셋째, 편집은 무엇보다도 데이터가 논리적 정합성을 유지하도록 정리하는 데 목적이 있다. 예를 들어, 연령이 5세인데 직업이 있다고 응답한 경우처럼 명백히 논리적으로 모순된 자료를 탐지하고 수정함으로써, 전체 분석 결과의 타당성과 신뢰도를 확보할 수 있다. 이러한 논리적 일관성은 단일 항목 내에서도 중요하지만, 항목 간 관계에서도 일관되게 유지되어야 한다.</p>
<p><strong>데이터 편집 주요 유형</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 24%">
<col style="width: 34%">
<col style="width: 38%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">편집 유형</td>
<td style="text-align: center;">설명</td>
<td style="text-align: center;">예시</td>
</tr>
<tr class="even">
<td style="text-align: center;">범위 편집</td>
<td style="text-align: center;">데이터 값이 허용된 범위 내에 있는지 확인</td>
<td style="text-align: center;">연령 값이 1개월 이상, 120년 이하인지 검사</td>
</tr>
<tr class="odd">
<td style="text-align: center;">비율 편집</td>
<td style="text-align: center;">특정 값 간 비율이 논리적으로 맞는지 확인</td>
<td style="text-align: center;">농장에서 생산된 우유 갤런 수와 젖소의 수 비율이 적절한지 확인</td>
</tr>
<tr class="even">
<td style="text-align: center;">이력 데이터 비교</td>
<td style="text-align: center;">이전 조사 데이터와 비교하여 일관성을 점검</td>
<td style="text-align: center;">1차 조사와 2차 조사에서 가구원 수가 유사한지 확인</td>
</tr>
<tr class="odd">
<td style="text-align: center;">균형 편집</td>
<td style="text-align: center;">여러 변수의 합이 일정해야 하는 경우 확인</td>
<td style="text-align: center;">집, 직장, 기타 장소에서 보낸 시간의 합이 100%인지 검사</td>
</tr>
<tr class="even">
<td style="text-align: center;">최대·최소 값 확인</td>
<td style="text-align: center;">비정상적으로 큰 값이나 작은 값이 존재하는지 검사</td>
<td style="text-align: center;">극단적인 소득 값이 존재하는지 확인</td>
</tr>
<tr class="odd">
<td style="text-align: center;">일관성 편집</td>
<td style="text-align: center;">논리적 관계가 성립하는지 점검</td>
<td style="text-align: center;">12세 미만 응답자의 혼인 상태는 '미혼'이어야 함</td>
</tr>
</tbody>
</table>
<p><strong>CAPI와 편집</strong></p>
<p>컴퓨터 지원 면접조사(CAPI: Computer-Assisted Personal Interviewing)의 도입은 편집 과정을 설문 응답 단계에서 실시간으로 수행할 수 있게 해 주었다. 이러한 방식은 설문 응답이 완료되기 전부터 오류 탐지 및 수정 작업을 자동화함으로써, 전체 데이터 품질을 크게 향상시킬 수 있다는 장점이 있다.</p>
<p>예를 들어, 응답자가 나이를 “5세”로 입력하고 직업을 “회사원”으로 응답했을 경우, CAPI 시스템은 논리적 오류를 탐지하고 즉시 경고 메시지를 띄워 인터뷰어나 응답자가 해당 항목을 다시 확인하도록 유도할 수 있다. 이처럼 실시간 편집은 응답 도중 오류를 줄이고, 후속 데이터 정제 부담을 줄이는 데 효과적이다.</p>
<p>CAPI에서 사용하는 오류 점검 방식은 일반적으로 두 가지로 구분된다. 첫째는 강제 체크(hard edit check)로, 명백한 오류가 발생했을 때 설문 진행이 중단되며 반드시 수정이 이루어져야 한다. 둘째는 소프트 체크(soft edit check)로, 값이 비정상적으로 보이긴 하지만 이론적으로 허용 가능한 범위 내에 있을 경우 경고 메시지만 제공하고 응답을 유지할 수 있도록 한다.</p>
<p>그러나 이러한 시스템이 항상 응답자의 실제 상황을 완벽하게 반영하는 것은 아니다. 응답자가 비표준적인 특수 사례에 속하거나, 반복적으로 유사한 방식으로 응답을 고집하는 경우, 인터뷰어가 시스템의 논리에 따라 응답을 수정하도록 유도하다 보면 실제 상황과 불일치가 발생할 수 있다. 따라서 실시간 편집 기능은 설문 설계자의 전문적 판단과 병행되어야 하며, 시스템 오류 경고에 과도하게 의존하지 않는 균형이 필요하다.</p>
<p><strong>데이터 편집 발전</strong></p>
<p>데이터 편집의 방식은 전통적인 수작업 중심에서 점점 더 규칙 기반(rule-based) 및 컴퓨터 지원 방식으로 진화하고 있다. 이러한 전환은 데이터 품질을 보다 체계적이고 일관되게 관리할 수 있도록 하며, 전체 조사 비용을 절감하는 데도 기여하고 있다.</p>
<p>자동화된 편집 시스템은 설문 응답이 데이터베이스에 입력되는 즉시 미리 정의된 논리 규칙에 따라 오류를 탐지하고 수정 가능성을 평가한다. 예를 들어, 응답자의 연령과 직업이 논리적으로 맞지 않는 경우, 시스템은 사전에 설정된 규칙에 따라 경고를 띄우거나 자동으로 수정 여부를 제안할 수 있다. 이러한 규칙 기반 편집은 복잡한 변수 간 논리 관계를 빠르게 탐지하고, 반복적인 오류를 자동 처리함으로써 사후 편집의 필요성을 크게 줄인다.</p>
<p>특히 최근에는 데이터 수집 단계에서 편집 절차를 선제적으로 통합하는 경향이 두드러지고 있다. 이는 실시간 오류 수정 기능(CAPI, CAWI 등)과 연계되어, 조사 중에 잘못된 응답이 입력되는 것을 방지하거나 수정하도록 유도하는 방식이다. 이처럼 편집이 데이터 수집과 동시에 이루어지면, 조사 이후의 대규모 오류 수정 작업이 불필요해질 수 있다.</p>
<p>더 나아가, 최신 편집 시스템은 점차 전문가 지식과 인공지능(AI) 기반 알고리즘을 활용하는 방향으로 발전하고 있다. 예컨대, 과거 편집 사례에서 학습한 패턴을 기반으로 오류 가능성을 자동 예측하거나, 비정상적 응답에 대해 맥락 기반 추천을 제시하는 기능이 개발되고 있다. 이는 전문가 개입 없이도 더 정교하고 신뢰할 수 있는 편집이 가능하게 하며, 편집 작업의 일관성과 효율성을 한층 높일 수 있다.</p>
</section>
</section>
<section id="chapter-2.-가중치-산정" class="level3" data-number="0.2">
<h3 data-number="0.2" class="anchored" data-anchor-id="chapter-2.-가중치-산정"><span class="header-section-number">0.2</span> <span style="color:green">chapter 2. 가중치 산정</span></h3>
<p>조사 표본에서 가중치는 통계적 추정의 정확성을 높이고, 모집단을 보다 대표할 수 있도록 설계상의 왜곡과 응답 편향을 보정하는 데 사용된다. 특히 현실의 많은 표본조사에서는 단순무작위추출(SRS)을 적용하기 어렵고, 실제로는 층화(stratification), 집락(clustering), 비확률(nonresponse) 등의 복잡한 설계가 포함되기 때문에, 이에 대한 보정이 필수적이다.</p>
<p>예를 들어, 특정 연령대나 지역 집단이 과도하게 추출되었거나, 응답률이 낮은 집단이 있을 경우, 해당 집단의 실제 비중을 반영하기 위해 가중치를 조정해야 한다. 또한, 조사 응답자가 표본설계 당시 예상했던 분포와 다르게 분포되었을 경우에도 보정이 필요하다. 이때 가중치는 개별 응답자의 수치를 모집단 전체에 합리적으로 확장하는 기능을 하며, ’확장 계수(expansion factor)’로 불리기도 한다.</p>
<p>가중치는 단일 방식으로 계산되지 않으며, 조사 설계의 복잡도와 조사 목적에 따라 다양한 조정 절차가 적용된다. 예를 들어, 층화 및 군집 표본 설계에 따른 기본 가중치(base weight), 비응답 조정을 위한 보정 가중치(nonresponse adjustment weight), 외부 모집단 분포와의 정합성을 맞추기 위한 보정 계수(post-stratification or calibration weight) 등이 순차적으로 적용될 수 있다. 이렇게 다단계로 조정된 최종 가중치는 분석 단계에서 반드시 반영되어야 하며, 그렇지 않으면 모집단을 왜곡하는 결과를 초래할 수 있다.</p>
<p>이와 같은 가중치 조정의 이론적 토대와 실무 적용에 대해서는 Kalton(1981)의 표본조사 기법에 대한 논의와 Bethlehem(2002)의 응답 편향 보정 연구가 대표적인 참고 문헌으로 자주 인용된다. 두 연구는 표본조사에서의 가중치 조정이 단순한 비율 조정이 아니라, 정교한 통계 모델링과 설계 기반 추정 절차의 일부임을 강조한다.</p>
<section id="단계-비율-조정-가중치" class="level4" data-number="0.2.1">
<h4 data-number="0.2.1" class="anchored" data-anchor-id="단계-비율-조정-가중치"><span class="header-section-number">0.2.1</span> <span style="color:blue">1. 단계 비율 조정 가중치</span></h4>
<p>다단계 표본 설계에서는 모집단 전체를 한 번에 추출하지 않고, 여러 단계를 거쳐 표본을 선택한다. 가장 일반적인 예는 1단계에서 지역 단위의 기본 표본 단위(PSU)를 선택하고, 그 안에서 가구 또는 개인을 다시 추출하는 방식이다. 이때 PSU는 모집단의 특정 속성(예: 인구 수, 가구 수 등)을 나타내는 크기 척도에 비례하여 추출된다. 즉, 규모가 큰 PSU일수록 선택될 확률이 높다.</p>
<p>이러한 방식으로 표본을 추출하면, 각 단위의 선택 확률이 서로 다르게 되므로, 이를 보정하기 위한 가중치가 필요하다. 이 가중치는 보통 “확률의 역수”로 정의되며, 어떤 단위가 선택될 확률이 작을수록 더 큰 가중치를 갖는다. 이를 통해 각 단위가 모집단 전체를 대표할 수 있도록 보정한다.</p>
<p>또한, 모집단의 실제 크기가 아닌 대체 가능한 보조 지표(예: 인구센서스, 행정자료 등)를 통해 PSU를 선정하는 경우가 많기 때문에, 가중치 산정 시 이 지표에 대한 신뢰성과 대표성을 충분히 고려해야 한다. 이처럼 단계 비율 조정 가중치는 복잡 설계에서 모집단 전체를 대표하는 데 필수적인 절차이며, 분석 단계에서 반드시 반영되어야 한다.</p>
<p><strong>1단계 비율 조정 가중치 개념</strong></p>
<p>1단계 비율 조정 가중치는 다단계 표본 설계에서 균등 확률 표본(EPSM: Equal Probability Sample)을 실현하기 위해 사용되는 보정 방식이다. 이 방식의 핵심은, 최종적으로 추출된 표본이 각 층의 모집단 크기에 비례하도록 가중치를 부여하는 것이다.</p>
<p>예를 들어, 어떤 층이 전체 모집단에서 차지하는 비율이 0.5%라면, 이 층에서는 전체 표본의 약 0.5%가 추출되도록 설계되어야 한다. 그러나 실제로는 조사비용이나 가용 인력, 지역 간 접근성 등의 이유로 층별 표본 수가 균형 있게 배분되지 않을 수 있다. 이런 경우, 1단계에서 선택된 기본 표본 단위(PSU, 예: 시군구)에 대해 가중치를 조정하여 층별 대표성을 확보하게 된다.</p>
<p>이때 사용되는 가중치는 각 층 내 PSU가 선택될 확률의 역수를 기반으로 하며, 모집단 내 각 층의 상대적 규모를 고려하여 조정된다. 이를 통해 결과적으로, 조사 결과가 전체 모집단의 구조를 더 정확하게 반영할 수 있게 된다. 이러한 비율 조정은 모집단 크기에 대한 외부 보조 정보(예: 인구총조사, 등록 자료 등)를 바탕으로 수행되며, EPSM 설계 원칙에 따라 각 층의 비중이 전체 추정치에 제대로 반영되도록 한다. <span class="math display">\[\text{Estimated Stratum Population Total} = \frac{\text{Population Total in Selected PSU}}{\text{Probability of Selecting PSU}}\]</span></p>
<p>즉, 1단계 비율 조정 가중치의 핵심은 층 전체의 모집단 규모를 반영하여, 실제로 선택된 PSU(Primary Sampling Unit, 예: 시군구)의 모집단 총계를 기반으로 층 내 대표성을 확보하는 것이다.</p>
<p>이는 선택된 PSU가 그 층의 전체를 제대로 대표하지 못하는 경우라도, 해당 PSU의 모집단 규모를 활용하여 가중치를 조정함으로써 층 전체의 특성을 보다 정확히 추정할 수 있도록 한다. 다시 말해, 어떤 특정 PSU가 선택되었든지 간에 그 층의 다른 PSU가 선택되었을 때와 유사한 결과가 도출되도록 설계하는 것이다.</p>
<p>이러한 가중 조정 방식은 층 내 비선택 PSU들이 포함하는 모집단의 정보까지도 간접적으로 반영하는 역할을 하며, 복잡한 표본 설계에서도 추정의 일관성과 신뢰성을 유지하는 데 중요한 기법이다.</p>
<p><strong>실질적인 가중치 적용</strong></p>
<p>실질적인 가중치 적용 단계에서는, 1단계에서 선택된 PSU(Primary Sampling Unit, 예: 시군구 등)에 포함된 모든 조사 대상자(응답자)에게 동일한 1단계 비율 조정 가중치가 부여된다. 이때 생성되는 새로운 가중치 변수는 <span class="math inline">\(W_{i1}\)</span> 로 표시되며, 여기서 첨자 1은 이 가중치가 여러 단계 중 첫 번째 조정 단계에서 부여된 값임을 의미하고, 대문자 W는 이 가중치가 표본 데이터가 아닌 프레임 모집단(설계 당시 모집단)의 구조를 반영한 것임을 나타낸다.</p>
<p>즉, <span class="math inline">\(W_{i1}\)</span> 은 선택된 PSU의 모집단 규모와 표본 추출 비율에 따라 계산된 값이며, 해당 PSU 내 모든 응답자에게 동일하게 적용된다. 이 과정은 PSU가 포함된 층 전체의 대표성을 확보하는 데 필수적인 절차로, 이후 단계에서 추가 가중치 조정이 이루어질 경우, 이 <span class="math inline">\(W_{i1}\)</span> 이 기초 가중치로서 출발점이 된다.</p>
</section>
<section id="차등-선택-확률-가중치" class="level4" data-number="0.2.2">
<h4 data-number="0.2.2" class="anchored" data-anchor-id="차등-선택-확률-가중치"><span class="header-section-number">0.2.2</span> <span style="color:blue">2. 차등 선택 확률 가중치</span></h4>
<p>예를 들어, 성폭력 피해 경험 조사를 수행할 때 전체 모집단이 1,000명이고 이 중 남성이 600명, 여성이 400명이라고 하자. 이 경우, 전체 인구 비율을 반영한다면 표본도 남성 120명, 여성 80명으로 구성되어야 모집단의 비율과 일치한다. 그러나 연구자는 여성의 피해 경험을 보다 정밀하게 분석하고자 여성 응답자를 120명, 남성을 80명으로 선정했다면, 이는 여성을 과대표본(over-sampling) 한 셈이다.</p>
<p>이처럼 각 계층이 모집단 내 실제 비율과 다르게 추출된 경우, 분석 결과는 전체 모집단을 제대로 반영하지 못할 수 있다. 이러한 대표성 왜곡을 보정하기 위해 차등 선택 확률 가중치를 부여한다. 이 가중치는 모집단 내 각 집단의 비율과 표본에서의 비율을 비교하여 계산된다. 예를 들어, 남성은 모집단의 60%를 차지하지만 표본에서는 40%에 불과하므로, 이 차이를 보정하기 위해 남성 응답자에게는 더 높은 가중치가 부여된다. 반대로 여성은 과대표집 되었으므로 상대적으로 낮은 가중치를 받게 된다.</p>
<p>결과적으로, 차등 선택 확률 가중치는 표본 설계의 불균형을 보정하여, 표본으로부터 계산한 통계량이 실제 모집단의 특성을 보다 정확하게 반영할 수 있도록 돕는다.</p>
<p><strong>비례 배분(EPSEM, Equal Probability Selection Method)</strong></p>
<p>표본이 모집단의 주요 특성 분포를 그대로 반영하도록 설계된 추출 방식이다. 예를 들어, 모집단의 성비가 남성 60%, 여성 40%인 경우, 200명의 표본을 추출할 때 이를 그대로 반영하여 남성 120명, 여성 80명으로 구성하는 방식이다. 이때 각 성별이 동일한 확률로 선택되며, 이는 모집단의 구성 비율에 비례한다는 점에서 “비례 배분”이라고 부른다.</p>
<p>이러한 방식에서는 모든 단위가 동일한 선택 확률을 가지므로, 결과적으로 표본 설계 자체가 모집단을 잘 대표하게 된다. 따라서 분석 과정에서 추가적인 가중치를 적용할 필요가 없다. 모든 표본 단위의 가중치는 동일하며, 예를 들어 1,000명의 모집단에서 200명을 추출했다면 각 표본의 가중치는 <span class="math inline">\(1/(1/5) = 5\)</span>가 된다. 남녀 모두 동일한 5의 가중치를 가지므로 통계 추정에 있어 왜곡이 발생하지 않는다.</p>
<p>즉, 비례 배분 방식은 설계 자체가 균형을 유지하므로 별도의 보정 없이도 신뢰할 수 있는 분석 결과를 제공하는 장점이 있다. 하지만, 소수 집단이나 관심 집단의 표본 수가 너무 적어 분석이 어려울 경우에는 비례 배분보다 과표집(over-sampling) 방식이 필요하며, 이때는 앞서 설명한 차등 선택 확률 가중치가 적용되어야 한다.</p>
<p><strong>차등 배분(Disproportionate Allocation)</strong></p>
<p>차등 배분(disproportionate allocation)은 표본 추출 시 특정 집단의 표본 수를 인위적으로 조정하는 방식으로, 특히 드문 특성을 조사할 때 통계적 정밀도를 확보하기 위해 사용된다. 예를 들어, 성폭력 피해율처럼 일반적으로 여성에게 더 많이 나타나는 현상을 분석할 때, 여성 응답자의 수를 늘려 보다 정확한 추정치를 확보하려는 경우다.</p>
<p>모집단이 남성 600명, 여성 400명으로 구성되어 있다고 가정하고, 전체 표본을 200명으로 설정할 때, 단순히 모집단 비율에 따라 추출한다면 남성 120명, 여성 80명을 선택하게 된다. 이는 <strong>비례 배분(equal allocation)</strong>이며, 따로 가중치 조정이 필요하지 않다.</p>
<p>그러나 여성 피해자의 수를 늘려 보다 정밀한 분석을 수행하기 위해, 남성과 여성을 각각 100명씩 조사하는 차등 배분을 실시한다고 가정하자. 이 경우, 모집단 대비 표본 비율은 다음과 같다: • 남성: 600명 중 100명 → 표본 비율 1/6 → 가중치 6 • 여성: 400명 중 100명 → 표본 비율 1/4 → 가중치 4</p>
<p>즉, 각 응답자의 응답은 그가 속한 집단의 모집단 대비 표본 비율의 역수만큼 가중치를 부여받는다.</p>
<p>조사 결과, 다음과 같은 피해율이 관찰되었다고 가정하자: • 남성: 10% (100명 중 10명) • 여성: 30% (100명 중 30명)</p>
<p>이때, 가중치를 적용한 전체 모집단의 추정 피해율은 다음과 같이 계산된다.</p>
<p><span class="math inline">\({\overline{Y}}_{w} = \frac{\sum w_{i}Y_{i}}{\sum w_{i}}\)</span>, <span class="math inline">\(w_{i}\)</span> 성별 총 가중치, 남성 (100x6), 여성 (100x4)</p>
<p><span class="math display">\[\text{추정 피해율} = \frac{(10\% \times 600) + (30\% \times 400)}{600 + 400} = 18\%\]</span></p>
<p>즉, 단순 표본 평균(20%)이 아닌, 모집단 구조를 반영한 추정값은 18%가 된다. 이처럼 차등 배분은 분석의 정확도를 높이는 동시에, 대표성 유지를 위해 가중치 조정이 필수적이라는 점을 잘 보여준다.</p>
<p><strong>가중치 조정이 필요한 이유</strong></p>
<p>차등 배분을 활용한 조사에서는 특정 집단의 표본 수를 인위적으로 늘려 분석의 정밀도를 확보할 수 있지만, 그만큼 가중치 조정이 반드시 필요하다. 예를 들어 성폭력 피해율처럼 여성에게서 더 빈번히 나타나는 현상을 조사할 경우, 여성 응답자의 수를 늘리는 것은 더 많은 사례 확보와 정밀한 분석이라는 측면에서 바람직하다.</p>
<p>하지만 이렇게 여성 표본이 과대표본(over-represented) 상태가 되면, 그 자체로는 모집단의 실제 구조를 왜곡하게 된다. 이 경우 여성의 피해율이 과장되어 전체 피해율이 실제보다 높게 추정될 수 있다. 따라서, 남성과 여성의 실제 모집단 비율에 맞춰 가중치를 적용함으로써, 편향된 표본 구성을 보정할 수 있다.</p>
<p>가중치는 표본에서 각 집단이 차지하는 비중을 조정하는 역할을 하며, 이를 통해 모집단 전체를 대표할 수 있는 평균값(가중 평균)을 산출할 수 있다. 예를 들어 남성 가중치를 6, 여성 가중치를 4로 설정하면, 실제 인구 구성(남성 600명, 여성 400명)에 비례한 결과를 계산할 수 있게 된다.</p>
<p>이처럼 성폭력 피해 조사에서 차등 선택 확률 가중치는 두 가지 측면에서 반드시 필요하다.</p>
<ul>
<li>분석 정밀도 확보: 여성 응답자 수를 늘려 피해율의 신뢰도를 높일 수 있음</li>
<li>대표성 회복: 가중치를 적용하여 실제 인구 구조를 반영한 추정치를 산출</li>
</ul>
<p>결과적으로, 가중치 조정은 조사 결과의 타당성과 일반화 가능성을 동시에 확보하기 위한 필수적인 절차다.</p>
</section>
<section id="단위-무응답-조정을-위한-가중치" class="level4" data-number="0.2.3">
<h4 data-number="0.2.3" class="anchored" data-anchor-id="단위-무응답-조정을-위한-가중치"><span class="header-section-number">0.2.3</span> <span style="color:blue">3. 단위 무응답 조정을 위한 가중치</span></h4>
<section id="무응답의-문제와-표본-구성" class="level5" data-number="0.2.3.1">
<h5 data-number="0.2.3.1" class="anchored" data-anchor-id="무응답의-문제와-표본-구성"><span class="header-section-number">0.2.3.1</span> (1) 무응답의 문제와 표본 구성</h5>
<p>성폭력 피해 조사는 주제의 민감성으로 인해 응답률이 낮을 수 있으며, 특히 성별에 따라 응답률이 상이하게 나타나는 경향이 있다. 위의 예시에서와 같이 모집단은 남성 600명(60%), 여성 400명(40%)으로 구성되어 있고, 이 구조를 반영한 비례 배분으로 표본 200명을 선정하여 남성 120명, 여성 80명이 포함되었다고 가정하자.</p>
<p>그러나 실제 조사에 응답한 인원은 성별 응답률에 따라 다음과 같이 달라진다.</p>
<ul>
<li>남성 응답률: 90% → 120명 중 108명 응답</li>
<li>여성 응답률: 75% → 80명 중 60명 응답</li>
</ul>
<p>결과적으로 실제 응답자 중 성별 분포는 다음과 같다: - 전체 응답자 수: 168명 - 남성 비율: 108 / 168 ≈ 64.3% - 여성 비율: 60 / 168 ≈ 35.7%</p>
<p>이렇게 되면 여성은 원래 모집단에서 40%를 차지했음에도 불구하고, 실제 응답자 중에서는 35.7%로 과소 대표되는 문제가 발생한다. 만약 이를 보정하지 않으면, 여성 집단의 특성이 전체 피해율 추정에 충분히 반영되지 않아 편향된 결과가 도출될 수 있다.</p>
</section>
<section id="무응답-조정-가중치-계산" class="level5" data-number="0.2.3.2">
<h5 data-number="0.2.3.2" class="anchored" data-anchor-id="무응답-조정-가중치-계산"><span class="header-section-number">0.2.3.2</span> (2) 무응답 조정 가중치 계산</h5>
<p>각 집단의 응답률의 역수를 사용하여 가중치를 설정한다.</p>
<p><span class="math display">\[W_{male} = \frac{1}{\text{응답률}_{male}} = \frac{1}{0.9} = 1.11\]</span></p>
<p><span class="math display">\[W_{female} = \frac{1}{\text{응답률}_{female}} = \frac{1}{0.75} = 1.33\]</span></p>
</section>
<section id="가중-평균-적용" class="level5" data-number="0.2.3.3">
<h5 data-number="0.2.3.3" class="anchored" data-anchor-id="가중-평균-적용"><span class="header-section-number">0.2.3.3</span> (3) 가중 평균 적용</h5>
<p>조사 응답 결과에 따르면, 남성 응답자 108명 중 약 10%인 10.8명이 성폭력 피해를 경험하였고, 여성 응답자 60명 중 30%에 해당하는 18명이 피해 경험이 있는 것으로 나타났다. 그러나 이 응답자 구성은 실제 모집단의 성비를 반영하지 않으며, 특히 여성의 응답률이 낮아 원래보다 적은 수가 응답에 포함되었기 때문에, 피해율이 과소 추정될 가능성이 있다.</p>
<p>이러한 문제를 해결하기 위해 무응답 조정 가중치를 적용한다. 남성의 응답률이 90%이므로 가중치는 1 / 0.9 = 1.11, 여성은 응답률이 75%이므로 가중치는 1 / 0.75 = 1.33으로 설정한다. 이에 따라 가중치를 적용한 전체 피해자 수는 다음과 같이 계산된다.</p>
<ul>
<li>남성 피해자 가중치 총합: 10.8 = 11.988</li>
<li>여성 피해자 가중치 총합: 18 = 23.94</li>
<li>전체 피해자 가중치 총합: 11.988 + 23.94 = 35.928</li>
</ul>
<p>한편, 가중치를 반영한 응답자 수는 다음과 같다. • 남성 응답자 총 가중치: 108 = 119.88 • 여성 응답자 총 가중치: 60 = 79.8 • 전체 응답자 가중치 합계: 119.88 + 79.8 = 199.68</p>
<p>따라서 무응답 조정 가중치를 적용한 피해율은 다음과 같이 계산된다.</p>
<p><span class="math inline">\(\text{추정 피해율} = \frac{(10\% \times 119.88) + (30\% \times 79.8)}{199.68} = \frac{11.988 + 23.94}{199.68} \approx 0.1799 = 17.99\%\)</span></p>
<p>이는 단순 응답자의 피해율 평균인 (10% + 30%) / 2 = 20%보다 낮은 수치로, 모집단 성비와 응답률 차이를 반영해 보다 현실적인 피해율을 제시한다.</p>
</section>
</section>
<section id="사후-가중치" class="level4" data-number="0.2.4">
<h4 data-number="0.2.4" class="anchored" data-anchor-id="사후-가중치"><span class="header-section-number">0.2.4</span> <span style="color:blue">4. 사후 가중치</span></h4>
<section id="사후-층화-가중치-개념" class="level5" data-number="0.2.4.1">
<h5 data-number="0.2.4.1" class="anchored" data-anchor-id="사후-층화-가중치-개념"><span class="header-section-number">0.2.4.1</span> (1) 사후 층화 가중치 개념</h5>
<p>사후 층화 가중치(post-stratification weight)는 조사 과정에서 마지막으로 수행되는 가중치 조정 절차로, 조사 표본이 실제 모집단 분포와 최대한 일치하도록 조정하는 데 목적이 있다. 특히 성별, 연령대, 지역 등 인구 통계학적 특성이 외부의 신뢰할 수 있는 자료(예: 국가 통계청, 인구총조사)와 비교해 불일치할 경우, 그 차이를 보정하기 위해 사용된다.</p>
<p>예를 들어, 성폭력 피해 실태조사를 수행한 후, 비례 배분, 차등 선택 확률 가중치, 무응답 조정 가중치 등을 단계적으로 적용하여 조사 표본을 보정했다고 하자. 그 결과, 최종적으로 남성과 여성의 가중치 총합이 각각 전체의 50%로 나타났다고 가정할 수 있다. 그런데 외부의 신뢰할 수 있는 모집단 자료에 따르면, 실제 모집단은 여성 52%, 남성 48%로 구성되어 있다면, 이 가중치 분포는 모집단과 일치하지 않는다.</p>
<p>이처럼 기존의 모든 가중치 조정을 적용한 뒤에도 여전히 조사 표본의 가중 분포가 모집단과 불일치할 수 있다. 이 경우, 사후 층화(post-stratification)를 통해 응답자의 가중치를 다시 조정하여, 성별 비율이 48:52로 되도록 재보정한다.</p>
<p>사후 층화는 응답자 특성에 따라 사후적으로 층(stratum)을 구분하고, 각 층별로 모집단 분포와 표본 분포를 비교하여 비례에 따라 가중치를 조정하는 방식이다. 예를 들어, 남성 응답자에게는 가중치를 0.96배, 여성 응답자에게는 1.04배 곱하여 가중치 총합이 48:52가 되도록 한다.</p>
<ul>
<li>사후 층화는 모집단 외부 정보를 기준으로 최종적으로 가중치를 조정하는 방식이다.</li>
<li>기존 가중치 적용만으로는 실제 모집단 분포와 완전히 일치하지 않을 수 있으며, 그 차이를 보정하기 위해 필수적이다.</li>
<li>대표성을 더욱 높이고자 하는 실증연구나 공공통계 생산에서 정확하고 현실적인 추정값을 제공하는 데 중요한 역할을 한다.</li>
</ul>
</section>
<section id="사후-층화-가중치-적용-방법" class="level5" data-number="0.2.4.2">
<h5 data-number="0.2.4.2" class="anchored" data-anchor-id="사후-층화-가중치-적용-방법"><span class="header-section-number">0.2.4.2</span> (2) 사후 층화 가중치 적용 방법</h5>
<ol type="1">
<li><p>현재 조사 표본의 성별 가중치 비율 확인 조사 결과에서 남성과 여성의 총 가중치 합이 각각 50%씩 동일한 상태라고 가정한다. 이는 표본 내 가중치 분포가 남녀 각각 600:400으로 구성되어 있을 때 비례 가중치를 적용한 결과일 수 있다.</p></li>
<li><p>모집단의 실제 성비 확인 및 비교 외부 인구통계 자료에 따르면, 모집단은 남성 48%, 여성 52%로 구성되어 있다. 이와 비교하면, 조사 데이터에서 남성이 과대표본되었고 여성이 과소표본되었음을 알 수 있다.</p></li>
<li><p>가중치 조정 비율 계산 표본과 모집단 간의 차이를 반영하기 위해 다음과 같은 비율로 가중치를 조정한다.</p></li>
</ol>
<ul>
<li>남성 가중치 감소: <span class="math inline">\(\frac{0.48}{0.50} = 0.96\)</span></li>
<li>여성 가중치 증가: <span class="math inline">\(\frac{0.52}{0.50} = 1.04\)</span></li>
</ul>
<p>이는 남성의 가중치를 4% 줄이고, 여성의 가중치를 4% 증가시키는 조정이다.</p>
<ol start="4" type="1">
<li>조정된 가중치를 적용한 총 가중치 합 계산</li>
</ol>
<ul>
<li><p>남성 총 가중치 조정 후 합: <span class="math inline">\(0.96 \times 600 = 576.0\)</span></p></li>
<li><p>여성 총 가중치 조정 후 합: <span class="math inline">\(1.04 \times 400 = 416.0\)</span></p></li>
</ul>
<ol start="5" type="1">
<li>가중 평균을 통한 성폭력 피해율 추정</li>
</ol>
<p>남성과 여성의 피해율이 각각 10%, 30%일 경우, 사후 층화 가중치를 반영한 최종 성폭력 피해율은 다음과 같이 계산된다. <span class="math display">\[\text{추정 피해율} = \frac{(10\% \times 576.0) + (30\% \times 416.0)}{576.0 + 416.0} = 18.39\%\]</span></p>
</section>
</section>
</section>
<section id="chapter-3.-결측치-대체" class="level3" data-number="0.3">
<h3 data-number="0.3" class="anchored" data-anchor-id="chapter-3.-결측치-대체"><span class="header-section-number">0.3</span> <span style="color:green">chapter 3. 결측치 대체</span></h3>
<p>조사에서 <strong>항목 무응답(item nonresponse)</strong>은 응답자가 전체 설문에는 참여했지만 특정 문항에는 답변하지 않는 현상을 의미한다. 이는 응답자가 질문을 민감하게 느껴 의도적으로 답변을 거부하거나, 설문 진행 과정에서 실수로 특정 문항을 건너뛰는 등의 이유로 발생한다. 예를 들어, 성폭력 피해 조사에서 응답자는 ‘피해 경험 유무’에는 답했지만, ‘가해자와의 관계’나 ‘자신의 소득 수준’ 등 민감한 항목에는 응답하지 않는 경우가 이에 해당한다.</p>
<p>이처럼 항목 무응답이 누적되면 해당 변수에 대한 분석이 어려워지고, 전체 조사 결과의 신뢰도와 대표성에도 영향을 미칠 수 있다. 특히 특정 집단에서 무응답이 체계적으로 발생할 경우, 표본이 왜곡되어 모집단의 특성을 제대로 반영하지 못할 위험이 있다. 이를 방지하고 분석 가능성을 높이기 위해 결측값 대체(Imputation) 기법이 활용된다.</p>
<p>결측값 대체는 단순히 빈칸을 임의의 값으로 채우는 것이 아니라, 응답자의 특성이나 다른 문항과의 관계를 고려하여 가장 적절한 값을 통계적으로 추정하는 과정이다. 예컨대, 소득 항목이 누락된 경우 유사한 성별, 연령, 직업을 가진 응답자의 평균 소득을 활용하거나, 회귀모형을 이용해 예측값을 산출하여 채워 넣는 방식이 있다. 보다 정교한 방법으로는 여러 번의 예측을 수행해 불확실성을 반영하는 다중 대체(Multiple Imputation)가 있으며, 최근에는 조사 데이터 분석에서 점차 널리 사용되고 있다.</p>
<p>결론적으로 항목 무응답은 조사 데이터 품질을 저하시킬 수 있는 중요한 문제이며, 이를 보완하기 위한 체계적이고 신뢰성 있는 대체 기법의 적용은 필수적인 분석 준비 절차라 할 수 있다.</p>
<section id="결측값을-처리하는-방법" class="level4" data-number="0.3.1">
<h4 data-number="0.3.1" class="anchored" data-anchor-id="결측값을-처리하는-방법"><span class="header-section-number">0.3.1</span> <span style="color:blue">1. 결측값을 처리하는 방법</span></h4>
<p><strong>결측값을 무시하는 방법</strong></p>
<p>결측값을 무시하는 방법은 조사 데이터에서 특정 항목에 응답하지 않은 사례를 통째로 제외하고 나머지 완전한 응답만을 가지고 분석을 수행하는 방식이다. 이는 완전 사례 분석(complete case analysis) 혹은 사례 삭제(casewise deletion)라고 불린다.</p>
<p>예를 들어, 성폭력 피해 경험에 관한 조사를 실시하고, 응답자들의 나이, 성별, 소득 수준을 바탕으로 피해율을 분석한다고 가정해보자. 이때, 응답자가 소득 수준에 대해 응답하지 않았다면, 해당 항목만 생략하지 않고 전체 응답을 분석에서 제거하게 된다. 즉, 분석에 필요한 모든 변수를 완전히 응답한 사례만을 선택하여 분석을 수행한다.</p>
<p>이 방법의 장점은 분석이 매우 단순하고 직관적이라는 데 있다. 별도의 통계적 가정이나 복잡한 계산 없이, 응답이 완전한 자료만을 사용해 분석할 수 있으므로 절차가 간단하고 구현이 용이하다. 또한, 추가적인 대체값 생성이나 추정 과정이 없기 때문에 분석 결과 해석이 비교적 명확하다.</p>
<p>그러나 단점도 뚜렷하다. 첫째, 결측값이 있는 응답을 통째로 제거하므로 분석에 사용 가능한 표본 크기가 줄어들게 되며, 이로 인해 통계적 검정의 정확도와 신뢰도가 저하될 수 있다. 둘째, 더 큰 문제는 결측이 무작위로 발생하지 않을 경우, 즉 특정 응답자 집단에서 결측이 집중된다면, 표본의 대표성이 왜곡될 수 있다. 예컨대, 고소득층이나 심각한 피해 경험을 가진 응답자가 소득을 밝히지 않는 경향이 있다면, 이들을 제거하는 과정에서 해당 집단이 과소표집되어 분석 결과가 편향될 위험이 있다.</p>
<p>따라서 결측값을 무시하는 방식은 가장 단순한 처리 방법이지만, 결측의 발생 원인과 패턴을 충분히 고려한 후 적용해야 하며, 무작위 결측(missing completely at random, MCAR) 조건이 충족되지 않을 경우에는 대체 방법의 도입이 바람직하다.</p>
<p><strong>결측값을 보완하는 방법</strong></p>
<p>결측값을 보완하는 방법은 분석 대상 데이터에서 누락된 값을 합리적인 방식으로 예측하거나 추정하여 채우는 절차를 말하며, 이를 일반적으로 결측값 대체(imputation)라고 한다. 이 방법은 단순히 결측 사례를 제거하는 것보다 분석의 신뢰성과 표본의 대표성을 유지하는 데 유리하다.</p>
<p>결측값을 무시하고 분석할 경우 표본 수가 줄어들어 분석의 정밀도가 떨어지며, 특정 집단이 과소대표될 수 있다. 반면, 결측값을 대체하면 기존의 정보는 유지하면서도 누락된 부분을 보완할 수 있기 때문에 분석 결과의 왜곡을 줄이고 더 나은 추정을 가능하게 만든다.</p>
<p>예를 들어, 성폭력 피해 경험에 관한 설문에서 일부 응답자가 소득 수준을 누락했다면, 같은 연령대, 성별, 지역 등의 응답 정보를 바탕으로 해당 소득 값을 추정해 채워 넣을 수 있다. 이렇게 하면 해당 응답자의 다른 정보는 그대로 유지되므로 분석 대상에서 제외되지 않으며, 보다 풍부하고 정확한 분석이 가능해진다.</p>
<section id="결측값-대체-방법" class="level5" data-number="0.3.1.1">
<h5 data-number="0.3.1.1" class="anchored" data-anchor-id="결측값-대체-방법"><span class="header-section-number">0.3.1.1</span> (3) 결측값 대체 방법</h5>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 33%">
<col style="width: 38%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">대체 방법</td>
<td style="text-align: center;">장점</td>
<td style="text-align: center;">단점</td>
</tr>
<tr class="even">
<td style="text-align: center;">완전 사례 분석</td>
<td style="text-align: center;">단순하고 직관적이며, 추가적인 가정 없이 분석 가능</td>
<td style="text-align: center;">데이터 손실 발생 가능, 모집단 대표성이 감소할 위험</td>
</tr>
<tr class="odd">
<td style="text-align: center;">평균 대체</td>
<td style="text-align: center;">계산이 간단하고 빠르며, 데이터 손실 없음</td>
<td style="text-align: center;">분산 감소로 인해 데이터 변동성이 왜곡될 가능성 있음</td>
</tr>
<tr class="even">
<td style="text-align: center;">확률적 대체</td>
<td style="text-align: center;">변동성을 유지하여 데이터 왜곡을 방지</td>
<td style="text-align: center;">무작위성이 도입되어 결과 변동성이 증가할 수 있음</td>
</tr>
<tr class="odd">
<td style="text-align: center;">회귀 대체</td>
<td style="text-align: center;">다른 변수와의 관계를 고려하여 현실적인 값 대체 가능</td>
<td style="text-align: center;">모델이 잘못 설정되면 왜곡된 값이 대체될 위험 있음</td>
</tr>
<tr class="even">
<td style="text-align: center;">핫덱 대체</td>
<td style="text-align: center;">실제 응답자의 데이터를 활용하여 자연스러운 대체 가능</td>
<td style="text-align: center;">적절한 유사 기준을 설정하는 것이 중요, 표본 크기 작으면 부적절한 대체 발생 가능</td>
</tr>
<tr class="odd">
<td style="text-align: center;">다중 대체</td>
<td style="text-align: center;">불확실성을 반영하여 보다 신뢰성 높은 결과 제공</td>
<td style="text-align: center;">계산량이 많고 통계적 해석이 다소 복잡할 수 있음</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="대체방법" class="level4" data-number="0.3.2">
<h4 data-number="0.3.2" class="anchored" data-anchor-id="대체방법"><span class="header-section-number">0.3.2</span> <span style="color:blue">2. 대체방법</span></h4>
<section id="평균-대체-mean-imputation" class="level5" data-number="0.3.2.1">
<h5 data-number="0.3.2.1" class="anchored" data-anchor-id="평균-대체-mean-imputation"><span class="header-section-number">0.3.2.1</span> (1) 평균 대체 mean imputation</h5>
<p>평균 대체(mean imputation)는 결측값을 처리하는 가장 단순한 방식 중 하나로, 누락된 값을 해당 변수의 평균값으로 채워 넣는 방법이다. 예를 들어, 성폭력 피해 조사에서 응답자의 가족 소득 정보를 수집했는데 일부 응답자가 해당 질문에 답하지 않은 경우, 그 결측된 소득 값을 다른 응답자들의 평균 소득으로 대체하는 식이다. 이 방식은 계산이 간단하고, 결측값이 있다고 해서 해당 응답을 분석에서 제외하지 않아도 되므로 표본 수를 유지할 수 있다는 장점이 있다.</p>
<p>하지만 평균 대체는 몇 가지 중요한 한계를 갖는다. 모든 결측값이 동일한 평균값으로 채워지기 때문에, 원래 데이터가 가지고 있던 자연스러운 변동성이 줄어들게 된다. 결과적으로 변수 간 상관관계나 회귀 분석 결과 등이 왜곡될 수 있으며, 데이터의 분산도 인위적으로 낮아질 수 있다. 또한 평균 대체는 결측이 발생한 원인이나 맥락을 전혀 고려하지 않기 때문에, 결측값이 체계적인 이유로 발생한 경우에는 적절한 대처 방식이 되지 못한다. 따라서 평균 대체는 응답률이 높고 결측이 무작위로 발생한 경우에만 제한적으로 사용하는 것이 바람직하며, 보다 정교한 대체 기법과 병행하여 활용하는 것이 권장된다.</p>
</section>
<section id="확률적-대체-stochastic-imputation" class="level5" data-number="0.3.2.2">
<h5 data-number="0.3.2.2" class="anchored" data-anchor-id="확률적-대체-stochastic-imputation"><span class="header-section-number">0.3.2.2</span> (2) 확률적 대체 stochastic imputation</h5>
<p>확률적 대체(stochastic imputation)는 평균 대체가 가지는 변동성 손실 문제를 보완하기 위해 고안된 방식으로, 평균값을 중심으로 하되 무작위성을 부여하여 보다 현실적인 데이터를 생성한다. 이 방법에서는 결측값을 단순히 전체 평균으로 채우는 것이 아니라, 해당 변수의 분포—일반적으로 정규분포—를 가정하고, 평균과 표준편차를 기준으로 난수를 생성해 그 값을 결측값에 채운다. 이를 통해 원래 데이터의 분산과 패턴을 보다 충실히 보존할 수 있다.</p>
<p>예를 들어, 응답자 100명이 보고한 월소득의 평균이 500만원, 표준편차가 100만원인 상황을 가정해보자. 이때, 5명의 응답자가 소득 항목에 응답하지 않아 결측이 발생하였다면, 평균 대체 방식에서는 이 5명을 모두 500만원으로 채우게 된다. 하지만 확률적 대체 방식은 평균값 500만원을 중심으로 하는 정규분포 N(500, 100^2) 에서 임의의 값을 5개 추출하여 각 응답자의 결측값에 입력하게 된다. 이렇게 하면 소득 데이터의 자연스러운 분산이 유지되고, 분석 시 통계량이 왜곡될 위험도 줄어든다.</p>
<p>다만 이 방법은 무작위 요소를 포함하기 때문에, 대체할 때마다 결과가 달라질 수 있다는 점에서 분석의 재현성과 일관성에 주의가 필요하다. 또한, 정규분포와 같은 통계적 가정이 적절하지 않다면 오히려 왜곡을 유발할 수도 있다. 따라서 확률적 대체는 결측의 성격과 변수의 분포를 충분히 고려한 후 신중하게 적용해야 한다.</p>
</section>
<section id="회귀-대체-regression-imputation" class="level5" data-number="0.3.2.3">
<h5 data-number="0.3.2.3" class="anchored" data-anchor-id="회귀-대체-regression-imputation"><span class="header-section-number">0.3.2.3</span> (3) 회귀 대체 regression imputation</h5>
<p><strong>회귀 대체(Regression Imputation)</strong>는 결측값을 보완하는 보다 정교한 방법으로, 해당 변수와 관련 있는 다른 변수들을 활용하여 결측값을 예측하는 방식이다. 이 방법은 단순히 평균이나 확률적 수치로 채우는 것보다, 데이터 내 변수 간의 관계를 반영하여 보다 현실성 있는 추정값을 산출할 수 있다는 장점이 있다.</p>
<p>예를 들어, 응답자의 소득 정보에 결측이 있는 경우, 같은 응답자가 응답한 나이(Age), 교육 수준(Education Level), 직업(Job Type) 등의 정보를 바탕으로 회귀모형을 설정할 수 있다. 이 회귀모형은 소득이 응답된 응답자들의 데이터를 기반으로 회귀계수를 추정하고, 해당 계수를 이용해 소득이 누락된 응답자들의 소득을 예측한다. 회귀식은 다음과 같다. <span class="math display">\[y_{i(r)} = \alpha + \beta_{1}\text{Age}_{i(r)} + + \beta_{2}\text{Edu}_{i(r)} + \beta_{3}\text{Job}_{i(r)} + e_{i(r)}\]</span></p>
<p>여기서 <span class="math inline">\(\hat{y}{i(r)}\)</span> 는 소득이 결측된 i번째 응답자의 예측 소득이고, <span class="math inline">\(\alpha, \beta_1, \beta_2, \beta_3\)</span> 는 회귀계수이며, <span class="math inline">\(e{i(r)}\)</span> 는 오차항이다.</p>
<p>이 방법의 장점은, 단순 대체보다 훨씬 더 응답자 개인의 특성을 반영한 맞춤형 대체가 가능하다는 점이다. 예컨대, 고학력자이면서 특정 직종에 종사하는 중년의 응답자는 실제로도 소득이 높을 가능성이 있기 때문에, 단순 평균이 아닌 회귀 예측을 통한 값이 더 설득력 있다.</p>
<p>하지만 단점도 존재한다. 회귀모형이 잘못 설정되면 편향된 추정치가 생성될 수 있으며, 대체된 값들이 모형의 구조를 따르기 때문에 실제 데이터보다 변동성이 작고 지나치게 규칙적인 값을 보일 수 있다. 이는 전체 데이터 분석에서 과도한 일관성을 유발하여 통계적 검정이나 분산 추정에 오류를 가져올 수 있다.</p>
<p>따라서 회귀 대체는 변수 간 관계가 명확하고 모형이 잘 적합될 때 강력한 결측 보정 방법이지만, 그만큼 모형 설정과 변수 선택에 대한 신중한 검토가 필수적이다.</p>
</section>
<section id="핫덱-대체-hot-deck-imputation" class="level5" data-number="0.3.2.4">
<h5 data-number="0.3.2.4" class="anchored" data-anchor-id="핫덱-대체-hot-deck-imputation"><span class="header-section-number">0.3.2.4</span> (4) 핫덱 대체 Hot-Deck imputation</h5>
<p>핫덱 대체(Hot-Deck Imputation)는 결측값을 비슷한 특성을 가진 응답자의 실제 데이터로 대체하는 방법이다. 이는 결측값이 있는 항목과 유사한 특성을 가진 다른 응답자의 값을 찾아 채워 넣는 방식으로, 조사 데이터에서 유사한 패턴을 유지하면서도 데이터의 신뢰도를 높일 수 있는 장점이 있다.</p>
<p>예를 들어, 성폭력 피해 조사에서 피해자의 나이, 성별, 지역 등이 유사한 다른 응답자의 데이터를 참조하여 결측값을 채운다면 보다 현실적인 대체가 가능하며, 데이터의 변동성을 유지하면서도 모집단을 반영할 수 있다. 핫덱 대체는 통계적 방법뿐만 아니라 설문 조사 및 행정 데이터 분석에서도 널리 사용되는 결측값 처리 기법이다.</p>
<p>이 방법의 장점은 평균 대체나 회귀 대체보다 현실적인 값이 채워질 가능성이 크다는 점이다. 그러나 적절한 유사 기준을 설정하는 것이 중요하며, 표본 크기가 작을 경우에는 적절한 대체값을 찾기 어려울 수 있다는 단점도 존재한다.</p>
<p><strong>핫덱 Hot-Deck</strong></p>
<p>핫덱(Hot-Deck) 대체는 동일한 조사 데이터셋 내에서 결측값이 있는 응답자와 유사한 특성을 가진 다른 응답자의 값을 가져와 결측값을 대체하는 방식이다. 이 방법은 동일한 조건을 가진 응답자가 충분히 많을 때 특히 효과적이며, 현실적인 값을 유지하면서도 데이터의 구조와 분포를 보존할 수 있다는 장점이 있다.</p>
<p>핫덱 대체는 성별, 연령, 지역, 교육 수준 등 주요 변수들이 일치하거나 유사한 응답자를 기준으로 결측값을 채워 넣기 때문에, 평균 대체나 회귀 대체보다 더 실제적인 데이터 보완이 가능하다. 또한 외부 자료 없이도 자체 데이터만으로 대체가 가능하므로, 조사 대상자가 많은 대규모 조사에서 활용도가 높다.</p>
<p><strong>콜드덱 Cold-Deck</strong></p>
<p>콜드덱(Cold-Deck) 대체는 과거의 다른 데이터셋이나 외부 자료에서 값을 가져와 결측값을 대체하는 방식이다. 이 방법은 현재 조사에서 유사한 특성을 가진 응답자가 부족하거나, 결측값을 직접적으로 대체할 수 있는 정보가 내부 데이터에 없는 경우에 활용된다.</p>
<p>콜드덱 방식은 이미 수집된 자료를 바탕으로 하므로 대체 기준이 명확할 수 있고, 반복되는 조사에서 일관성을 유지하는 데 유리하다. 예를 들어, 전년도에 수행된 동일한 주제의 조사에서 유사한 응답자의 값을 가져와 결측값을 보완하는 경우가 이에 해당한다.</p>
<p>그러나 이 방법은 사용하는 데이터가 과거 자료이거나 시차가 있는 외부 자료이기 때문에, 현재 상황과 불일치할 가능성이 있으며, 시대적 변화나 환경의 차이가 반영되지 않을 위험이 있다. 따라서 콜드덱 대체는 데이터의 맥락을 충분히 고려한 신중한 적용이 필요하다.</p>
<p><strong>핫덱 대체 과정</strong></p>
<p>핫덱(Hot-Deck) 대체는 동일한 데이터셋 내에서 유사한 특성을 가진 응답자의 값을 활용하여 결측값을 보완하는 방식이다. 이 과정은 몇 가지 단계를 거쳐 체계적으로 이루어진다.</p>
<p>첫째, 데이터 정렬 및 유사 집단 형성 단계에서는 응답자들의 연령, 성별, 교육 수준, 지역 등의 변수에 따라 그룹화를 수행한다. 예컨대, ’20~29세 여성, 서울 거주’와 같이 세부 집단을 정의하여 응답자 간 유사성을 확보한다.</p>
<p>둘째, 결측값이 있는 응답자 식별 단계에서는 특정 변수에서 값이 누락된 사례들을 찾아낸다. 예를 들어, ‘소득 수준’ 항목에서 결측된 응답자를 선별한다.</p>
<p>셋째, 적절한 응답 값 선택 단계에서는 동일한 그룹 내에서 결측 항목을 갖지 않은 응답자의 데이터를 참조하여, 해당 결측값을 채운다. 이때 일반적으로 가장 유사한 응답자의 값을 사용하지만, 유사한 응답자가 여럿일 경우 무작위로 선택하여 대체할 수도 있다.</p>
<p>넷째, 결측값 대체 수행 단계에서는 선택된 응답자의 값을 결측값이 있는 변수에 그대로 적용하여 데이터를 완성한다.</p>
<p>핫덱 대체는 내부 데이터 기반으로 결측을 보완하므로 현실성이 높고, 데이터의 분포나 구조를 잘 보존할 수 있다는 장점이 있다. 다만, 적절한 유사 기준을 설정하고, 충분한 표본이 확보되어야 효과적인 적용이 가능하다.</p>
</section>
<section id="다중-대체-multiple-imputation" class="level5" data-number="0.3.2.5">
<h5 data-number="0.3.2.5" class="anchored" data-anchor-id="다중-대체-multiple-imputation"><span class="header-section-number">0.3.2.5</span> (5) 다중 대체 multiple imputation</h5>
<p>다중 대체(Multiple Imputation)는 하나의 결측값에 대해 하나의 추정값만을 사용하는 기존의 단일 대체 방식과 달리, 여러 개의 대체값을 생성하여 각각의 데이터셋을 구성하고 독립적으로 분석한 후, 이들의 결과를 종합하는 방법이다. 이 방식은 결측값에 내재된 불확실성을 반영하고자 하는 목적에서 출발한다.</p>
<p>예를 들어, 성폭력 피해 조사에서 소득 정보를 응답하지 않은 사례가 있을 때, 이 결측값에 대해 평균 대체, 회귀 대체, 핫덱 대체 등 다양한 방식으로 3~5개의 서로 다른 대체값을 생성하여 각각의 대체값을 포함하는 데이터 세트를 만든다. 각 데이터 세트를 별도로 분석한 뒤, 최종 분석 결과는 이들 결과의 평균이나 조합을 통해 도출된다. 이렇게 하면 대체 과정에서 발생할 수 있는 편향과 추정의 불확실성을 함께 고려할 수 있다.</p>
<p>다중 대체의 장점은 단일 대체보다 더 신뢰할 수 있는 통계 추정치를 제공하며, 결측값으로 인한 분석의 왜곡을 줄일 수 있다는 것이다. 특히 표준오차와 같은 추정의 정확도에 대한 정보를 함께 제공할 수 있어, 불확실성을 정량화할 수 있는 장점이 있다.</p>
<p>반면, 다중 대체는 계산량이 많고 구현이 복잡하다는 단점이 있다. 특히 대체 방법의 설정, 반복 횟수, 결과의 통합 방식 등에 대한 통계적 이해와 숙련된 기술이 필요하다. 그럼에도 불구하고 최근에는 통계 소프트웨어에서 다중 대체 기능을 쉽게 사용할 수 있게 되어, 복잡한 조사나 사회과학 데이터 분석에서 점점 널리 활용되고 있다.</p>
</section>
</section>
</section>
<section id="chapter-4.-복합표본-분산-추정" class="level3" data-number="0.4">
<h3 data-number="0.4" class="anchored" data-anchor-id="chapter-4.-복합표본-분산-추정"><span class="header-section-number">0.4</span> <span style="color:green">chapter 4. 복합표본 분산 추정</span></h3>
<p>조사 데이터는 실제 수집 과정에서 단순한 무작위 추출 방식이 아닌, 층화(stratification), 군집(clustering), 다단계 추출(multi-stage sampling), 가중치(weighting), 결측값 대체(imputation) 등의 다양한 절차가 적용되기 때문에 복잡한 구조를 지닌다. 이러한 복합 설계는 표본 추출 단위 간의 독립성을 약화시키고, 집단 내 응답자들 간의 유사성을 증가시켜 표본 분산에 영향을 준다.</p>
<p>예를 들어, 동일한 지역에서 다수의 가구를 선택하는 클러스터 표본의 경우, 해당 지역 내 응답자들은 비슷한 사회경제적 특성을 가질 가능성이 높아 서로 상관관계가 형성된다. 이로 인해 실제 분산은 단순 확률 표본보다 작거나 클 수 있으며, 만약 이를 무시하고 일반적인 분산 추정 방식을 사용하면 표준 오차가 부정확하게 추정될 위험이 있다.</p>
<p>따라서, 통계 분석에서는 단순한 표본 설계 가정이 아닌, 조사에서 실제 사용된 복합 표본 설계 정보를 반영한 분산 추정 방법(예: Taylor 선형화, 재표집 기법, Balanced Repeated Replication 등)을 적용해야 하며, 이를 통해 보다 정확한 신뢰구간과 유의성 검정이 가능해진다. 이 과정은 특히 정책 결정이나 민감한 사회 이슈를 다루는 조사에서 필수적인 절차라 할 수 있다.</p>
<section id="테일러-급수-근사법taylor-series-approximation" class="level4" data-number="0.4.1">
<h4 data-number="0.4.1" class="anchored" data-anchor-id="테일러-급수-근사법taylor-series-approximation"><span class="header-section-number">0.4.1</span> <span style="color:blue">1. 테일러 급수 근사법(Taylor Series Approximation)</span></h4>
<p>테일러 급수 근사법(Taylor Series Linearization)은 비선형 통계량—예를 들어 비율, 평균 대비 비율, 오즈비(odds ratio)와 같은 복잡한 함수형 통계량—의 분산을 추정할 때 널리 사용되는 대표적인 방법이다. 이러한 통계량은 단순한 합산이나 평균 연산으로는 분산을 직접 계산할 수 없기 때문에, 함수 형태를 일차 선형화하여 근사하는 방식이 필요하다.</p>
<p><strong>테일러 급수 근사법 핵심 개념</strong></p>
<p>테일러 급수 근사법은 분석 대상 통계량을 주어진 모수(parameter)에 대한 함수로 보고, 이 함수를 일차 테일러 급수로 전개하여 근사한 후 분산을 추정하는 기법이다. 다시 말해, 복잡한 비선형 함수를 선형 함수로 근사하여 분산 추정이 가능한 형태로 바꾸는 것이다.</p>
<p><strong>테일러 급수 근사를 이용한 가중 평균의 분산</strong></p>
<p>조사 데이터에서 가중 평균(<span class="math inline">\({\overline{Y}}_{w})\)</span>을 사용하여 분산을 추정하는 방법은 다음과 같다.</p>
<p><span class="math display">\[\overline{Y}w = \frac{\sum{i = 1}^{n}w_{i}y_{i}}{\sum_{i = 1}^{n}w_{i}}\]</span></p>
<p>테일러 급수 근사법을 사용하면, 해당 가중 평균의 분산은 다음과 같이 표현된다.</p>
<p><span class="math display">\[\frac{1}{(\sum w_{i})^{2}}\left\lbrack Var(\sum w_{i}y_{i}) + {\overline{Y}}_{w}^{2}Var(\sum w_{i}) - 2{\overline{Y}}_{w}Cov(\sum w_{i}y_{i},\sum w_{i}) \right\rbrack\]</span></p>
<p>이는 단순한 분산 계산보다 복잡하지만, 복합 표본 설계에서의 정확한 분산 추정을 위해 필수적인 접근법이다.</p>
<p><strong>테일러 급수 근사법 특징</strong></p>
<p>테일러 급수 근사법은 현재 복합 표본 설계 데이터를 분석할 때 가장 널리 사용되는 분산 추정 방법 중 하나다. 여러 통계 소프트웨어 패키지—예: SAS, Stata, SUDAAN—에서 기본 옵션으로 제공되며, 그만큼 신뢰성과 적용성이 높다.</p>
<p>이 방법은 비율, 평균, 회귀 계수와 같은 다양한 통계량에 적용 가능하며, 특히 비선형 함수 형태를 선형 근사로 바꾸어 처리할 수 있기 때문에 활용 범위가 넓다. 무엇보다도, 단순 무작위 표본이 아닌 층화, 군집화, 가중치 부여 등 복합 표본 설계의 구조적 특성을 반영할 수 있어 표본 설계로 인한 분산 과소 추정을 방지하고 정확한 표준오차 계산을 가능하게 한다.</p>
<p>따라서, 조사 통계 분석에서 테일러 근사는 복잡한 설계의 현실을 반영한 정밀한 분산 추정 기법으로 자리잡고 있다.</p>
</section>
<section id="균형-반복-복제법balanced-repeated-replication-brr" class="level4" data-number="0.4.2">
<h4 data-number="0.4.2" class="anchored" data-anchor-id="균형-반복-복제법balanced-repeated-replication-brr"><span class="header-section-number">0.4.2</span> <span style="color:blue">2. 균형 반복 복제법(Balanced Repeated Replication, BRR)</span></h4>
<p>균형 반복 복제법(BRR)은 복합 표본 설계에서 분산을 추정하기 위해 널리 사용되는 방법 중 하나로, 전체 표본을 여러 개의 하위 표본(Replicates)으로 나누어, 각 하위 표본에 대해 통계량을 계산한 뒤 이들의 변동성을 이용해 모집단 통계량의 분산을 추정한다.</p>
<p>가장 기본적인 방식은 전체 표본을 두 개의 하위 표본으로 나누는 작업을 반복하면서 여러 개의 균형 잡힌 복제(Replicate)를 생성하는 것이다. 이러한 반복 분할은 표본 설계의 층화 구조를 고려하여 체계적으로 수행되며, 각 복제본에 대해 통계량을 계산하고 그 결과의 분산을 기반으로 전체 분산을 추정한다.</p>
<p>BRR의 핵심은 다음과 같다.</p>
<ul>
<li>각 복제본은 전체 표본의 하위 집합이며, 균형 잡힌 방식으로 구성된다.</li>
<li>전체 표본의 통계량과 복제 통계량 간의 차이를 통해 분산을 계산한다.</li>
<li>보통 Fay’s BRR처럼 가중치를 부드럽게 조정하는 변형 방식도 존재한다.</li>
</ul>
<p>이 방법은 특히 2차 단위 선택이 없는 이단계 층화 설계에서 유용하며, 여러 통계 소프트웨어(SAS, Stata, SUDAAN 등)에서 BRR 지원 기능이 제공된다.</p>
<p>각 표본에서 평균(<span class="math inline">\({\overline{Y}}_{r}\)</span>)을 계산하고, 그 평균의 변동성을 기반으로 전체 표본의 분산을 추정한다.</p>
<p><span class="math display">\[\overline{Y} = \frac{1}{c}\overset{c}{\sum_{r = 1}}{\overline{Y}}_{r}\]</span></p>
<p>분산은 다음과 같이 계산된다.</p>
<p><span class="math display">\[Var(\overline{Y}) = \frac{1}{c(c - 1)}\overset{c}{\sum_{r = 1}}({\overline{Y}}_{r} - \overline{Y})^{2}\]</span></p>
<p><strong>균형 반복 복제법(BRR)의 특징</strong></p>
<p>균형 반복 복제법(BRR)은 복합 표본 설계에서 분산을 추정하기 위해 널리 사용되는 방법 중 하나이다. 이 기법은 전체 표본을 여러 개의 하위 표본(복제본, replicates)으로 나누어 반복적으로 통계량을 계산하고, 이들 간의 변동성을 통해 전체 통계량의 분산을 추정하는 방식이다. 특히, 층화된 복합 표본 설계에서 매우 효과적으로 활용될 수 있으며, 2단계 이상의 다단계 표본 설계에도 적절하게 적용된다.</p>
<p>BRR의 가장 큰 장점은 복잡한 조사 설계의 구조를 반영하면서도 실제 표본의 변동성을 잘 반영할 수 있다는 점이다. 이는 단순한 이론적 공식보다 더 현실적인 분산 추정을 가능하게 한다. 그러나 BRR을 적용하려면 각 층(stratum)마다 두 개의 1차 표본 단위(PSU)가 존재해야 하며, 복제본을 만들기 위해 층별로 적절히 균형을 맞추는 것이 필요하다. 표본 설계가 지나치게 복잡하거나 PSU 수가 부족한 경우에는 이러한 균형을 유지하기 어려워, BRR의 적용이 제한될 수 있다. 이처럼 BRR은 강력한 분산 추정 도구이지만, 설계와 구현에 있어 정교한 구조 설정이 요구된다.</p>
</section>
<section id="잭나이프-반복-복제법jackknife-repeated-replication-jrr" class="level4" data-number="0.4.3">
<h4 data-number="0.4.3" class="anchored" data-anchor-id="잭나이프-반복-복제법jackknife-repeated-replication-jrr"><span class="header-section-number">0.4.3</span> <span style="color:blue">3. 잭나이프 반복 복제법(Jackknife Repeated Replication, JRR)</span></h4>
<p>잭나이프 반복 복제법(Jackknife Repeated Replication, JRR)은 복합 표본 설계에서 분산을 추정하는 데 널리 사용되는 기법으로, 데이터에서 하나의 표본 또는 클러스터를 순차적으로 제거하면서 반복적으로 통계량을 계산하는 방식이다. 이 기법의 핵심은 표본 전체를 사용하는 것이 아니라, 매 반복마다 하나의 단위를 제거한 후 통계량(예: 평균)을 계산하고, 이렇게 얻은 여러 개의 통계량을 바탕으로 그 변동성을 측정함으로써 전체 표본의 분산을 추정하는 데 있다.</p>
<p>잭나이프 방법은 계산이 비교적 단순하다는 장점을 가지며, 특히 비선형 통계량(예: 비율, 오즈비 등)의 분산 추정에도 안정적인 결과를 제공할 수 있다. 반복 복제 방식으로 인해 복잡한 분포를 따르는 표본에서도 적용이 가능하며, 다양한 통계 소프트웨어에서 지원된다.</p>
<p>다만, 잭나이프 방법은 표본 수가 충분히 많을 때 그 효과가 극대화되며, 표본 크기가 작을 경우 반복 횟수가 제한되어 분산 추정의 정확도와 신뢰도가 낮아질 수 있다는 한계도 존재한다. 그럼에도 불구하고, 단순함과 안정성 덕분에 복잡한 조사 설계에서도 유용하게 사용되는 방법 중 하나이다.</p>
</section>
<section id="방법-비교" class="level4" data-number="0.4.4">
<h4 data-number="0.4.4" class="anchored" data-anchor-id="방법-비교"><span class="header-section-number">0.4.4</span> <span style="color:blue">4. 방법 비교</span></h4>
<p>복합 표본 설계에서 분산을 추정하는 주요 방법들은 각각의 장점과 제한점을 가지고 있으며, 적용 환경에 따라 적절한 방법을 선택하는 것이 중요하다.</p>
<p>테일러 급수 근사법은 가장 널리 사용되는 방식으로, 비선형 통계량(비율, 회귀 계수 등)을 근사화하여 분산을 추정한다. 이 방법은 계산이 비교적 효율적이고, 대부분의 통계 소프트웨어(SAS, Stata, SUDAAN 등)에서 기본값으로 제공되므로 실무 활용도가 높다.</p>
<p>균형 반복 복제법(BRR)은 층화된 복합 표본 설계에서 특히 높은 정확도를 보인다. 전체 표본을 반복적으로 절반씩 나누어 복제 통계량을 계산함으로써 분산을 추정하며, 구조가 일정하고 표본 크기가 충분할 때 신뢰도가 높다. 하지만 설계 구조가 복잡하거나 층화 기준이 불균형할 경우 적용에 제한이 있을 수 있다.</p>
<p>잭나이프 반복 복제법(JRR)은 표본이나 클러스터를 하나씩 제거하여 복제 통계량을 계산하는 방식으로, 계산 구조가 단순하다는 장점이 있다. 특히 비선형 통계량에도 안정적으로 적용 가능하나, 복잡한 다단계 표본 설계에서는 반복 횟수 부족이나 표본 구조의 제약으로 인해 한계를 보일 수 있다.</p>
<p>따라서, 테일러 급수 근사법은 일반적인 기본값으로 활용되고, BRR은 층화 구조가 명확할 때, 잭나이프는 구조가 단순하거나 반복 제거 방식이 적합할 때 선택적으로 사용된다.</p>
</section>
</section>
<section id="chapter-5.-조사-데이터-문서화-및-메타-데이터" class="level3" data-number="0.5">
<h3 data-number="0.5" class="anchored" data-anchor-id="chapter-5.-조사-데이터-문서화-및-메타-데이터"><span class="header-section-number">0.5</span> <span style="color:green">chapter 5. 조사 데이터 문서화 및 메타 데이터</span></h3>
<p>조사 데이터는 단 한 번의 분석을 위해 수집되는 것이 아니다. 데이터 수집 이후에도 다양한 연구자가 수년에 걸쳐 반복적으로 재분석하고, 새로운 분석 목적에 맞추어 지속적으로 활용된다. 이러한 재사용 가능성을 높이기 위해서는 조사 데이터를 체계적으로 문서화하고, 그 의미와 구조를 명확하게 설명하는 정보가 반드시 필요하다.</p>
<p>이때 활용되는 핵심 정보가 바로 <strong>메타데이터(metadata)</strong>이다. 메타데이터는 데이터 자체가 아니라 데이터를 설명하는 데이터로, 변수의 정의, 측정 단위, 응답 범주, 결측 처리 방식, 코딩 기준 등 연구자가 데이터 분석 전에 반드시 이해해야 할 기본 속성을 포함한다. 메타데이터는 연구자 간 일관된 해석을 가능하게 하고, 데이터의 맥락을 제공함으로써 정확한 분석과 비교 연구를 지원한다.</p>
<p>한편, 설문조사 과정에서 자동으로 수집되는 보조적 데이터인 <strong>파라데이터(paradata)</strong>도 함께 중요한 역할을 한다. 이는 설문 응답 자체가 아니라 응답이 생성되는 과정을 설명하는 데이터로, 예를 들어 문항별 응답 시간, 응답 수정 여부, 조사 기기의 종류, 응답자의 이동 경로, 면접자의 질문 방식 등이 해당된다. 파라데이터는 설문 문항의 난이도나 응답자의 이해 수준을 파악하거나, 성의 없는 응답이나 비정상적인 응답 패턴을 식별하는 데 유용하다.</p>
<p>따라서 조사 데이터의 품질과 활용도를 높이기 위해서는 메타데이터와 파라데이터를 함께 수집하고 체계적으로 관리하는 것이 필수적이다. 이 두 정보는 단순한 부속 자료를 넘어, 조사 데이터의 해석과 재사용 가능성을 결정짓는 핵심 도구로 기능한다.</p>
<section id="메타-데이터" class="level4" data-number="0.5.1">
<h4 data-number="0.5.1" class="anchored" data-anchor-id="메타-데이터"><span class="header-section-number">0.5.1</span> <span style="color:blue">1. 메타 데이터</span></h4>
<p>메타데이터란 조사 데이터에 대한 정보(<span dir="rtl">”</span>데이터에 대한 데이터”)를 의미하며 연구자가 데이터를 이해하고 활용할 수 있도록 제공하는 모든 정보를 포함한다.</p>
<p>메타데이터의 주요 목적은 조사 데이터의 속성을 명확하게 설명하여 연구자가 데이터를 효과적으로 활용할 수 있도록 하는 것이다.</p>
<p>특정 연구자가 아닌, 전 세계 누구나 데이터의 의미를 쉽게 이해할 수 있도록 표준화된 문서화를 제공하는 것이 핵심이다.</p>
<p><strong>메타데이터의 주요 유형</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 32%">
<col style="width: 64%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">메타데이터 유형</td>
<td style="text-align: center;">설명</td>
</tr>
<tr class="even">
<td style="text-align: center;">정의적 메타데이터</td>
<td style="text-align: center;">조사 대상 모집단, 표본 설계, 질문 문구, 코딩 용어 등을 설명</td>
</tr>
<tr class="odd">
<td style="text-align: center;">절차적 메타데이터</td>
<td style="text-align: center;">조사원 교육 절차, 표본 선정 방법, 데이터 수집 과정 등 조사 프로토콜을 설명</td>
</tr>
<tr class="even">
<td style="text-align: center;">운영적 메타데이터</td>
<td style="text-align: center;">결측 데이터 비율, 데이터 수정 실패율, 평균 조사 시간, 조사원이 완료한 케이스 수 등 조사 품질 평가 정보 포함</td>
</tr>
<tr class="odd">
<td style="text-align: center;">시스템 메타데이터</td>
<td style="text-align: center;">데이터 파일 형식, 파일 위치, 데이터 검색 및 호출 방법, 변수 정의 등을 설명</td>
</tr>
</tbody>
</table>
<p><strong>메타데이터 예시</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 27%">
<col style="width: 70%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">항목</td>
<td style="text-align: center;">설명</td>
</tr>
<tr class="even">
<td style="text-align: center;">변수명</td>
<td style="text-align: center;">AR21 (피해 보고 항목)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">질문 문구</td>
<td style="text-align: center;">당신의 재산이 손상되었거나 파괴된 적이 있습니까?'</td>
</tr>
<tr class="even">
<td style="text-align: center;">데이터 위치</td>
<td style="text-align: center;">컬럼 140, 너비 1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">결측값 처리</td>
<td style="text-align: center;">-9 (무응답), -0 (모름)</td>
</tr>
<tr class="even">
<td style="text-align: center;">데이터 수준</td>
<td style="text-align: center;">가구 데이터 또는 개인 데이터</td>
</tr>
<tr class="odd">
<td style="text-align: center;">추가 메타데이터</td>
<td style="text-align: center;">표시(X)하여 해당하는 모든 항목을 선택하세요.'</td>
</tr>
</tbody>
</table>
<p>메타데이터 설계의 중요성</p>
<p>메타데이터의 발전은 조사 방법론 연구자에게 새로운 기회와 도전 과제를 동시에 제공한다.</p>
<p>조사 품질 평가 및 사용자 확장: 조사 품질을 측정하는 재조사 연구, 응답 분산 추정 등의 정보가 쉽게 제공될 수 있다. 이를 통해, 조사 데이터의 신뢰성을 높이고, 다양한 연구자들이 데이터를 활용할 수 있도록 지원한다.</p>
<p>설문지 개발 과정에서의 연계: 특정 문항에 대해 과거 연구에서의 활용 방식, 문항 재설계 사례, 응답자 행동 데이터(Behavior Coding) 등과 연계하여 문항 개발이 가능하다.</p>
<p>연구자의 데이터 활용 지원: 연구자가 분석을 수행하기 전, 특정 변수가 과거 연구에서 어떻게 활용되었는지를 쉽게 확인할 수 있도록 설계할 수 있다. 이를 통해 조사 데이터의 신뢰성을 유지하면서도, 보다 효율적인 데이터 분석을 지원할 수 있다.</p>
<p>메타데이터는 단순한 부가 정보가 아니라, 조사 데이터를 보다 효과적으로 활용할 수 있도록 지원하는 핵심 요소이다. 특히, 대규모 조사 데이터에서는 메타데이터의 체계적인 관리와 전자 문서화가 필수적이다.</p>
<p>메타데이터는 조사 데이터의 활용도를 높이고, 연구자가 데이터를 쉽게 이해할 수 있도록 돕는 중요한 역할을 한다.</p>
<p>전통적인 코드북에서 벗어나, 전자 문서화와 웹 기반 시스템이 발전하면서 보다 효율적인 데이터 관리가 가능해지고 있다.</p>
<p>조사 설계 단계에서부터 메타데이터의 체계적인 구성을 고려하는 것이 중요하며, 이를 통해 조사 품질을 높이고 연구자들이 보다 쉽게 데이터를 활용할 수 있도록 해야 한다.</p>
<p>결국, 좋은 조사 데이터는 메타데이터가 잘 정리되어 있어야 한다. 조사 데이터를 체계적으로 문서화하고, 연구자들이 손쉽게 접근할 수 있도록 메타데이터를 설계하는 것이 향후 조사 연구의 핵심 과제가 될 것이다.</p>
</section>
<section id="파라-데이터" class="level4" data-number="0.5.2">
<h4 data-number="0.5.2" class="anchored" data-anchor-id="파라-데이터"><span class="header-section-number">0.5.2</span> <span style="color:blue">2. 파라 데이터</span></h4>
<p>조사 데이터 문서화 체계에서 파라데이터(paradata)는 설문 응답이라는 결과물이 생성되는 과정을 실시간으로 추적하고 기록한 행태적(behavioral) 및 기술적(technical) 정보의 집합이다. 이는 응답자가 어떤 답변을 했는지에 대한 내용적 정보가 아니라, 그 답변을 어떻게 도출했는지에 대한 과정 정보로서, 설문 조사 품질을 정밀하게 평가하고 설계 오류를 사전에 진단할 수 있는 중요한 도구로 기능한다.</p>
<p><strong>파라데이터의 구체적 예</strong></p>
<p><strong>웹 기반 자기기입식 설문(CAWI)</strong>에서는 다음과 같은 항목이 대표적인 파라데이터로 수집된다.</p>
<ul>
<li>각 문항에 소요된 응답 시간</li>
<li>응답자가 뒤로 가기(back) 버튼을 눌러 응답을 수정한 횟수</li>
<li>문항 미응답 또는 건너뛰기 횟수</li>
<li>키보드 입력의 정정 횟수 (backspace, delete 키 입력 빈도)</li>
<li>응답 순서 변경 패턴</li>
<li>디바이스 정보(PC, 모바일, 태블릿 등)</li>
<li>브라우저 및 운영체제 정보</li>
<li>응답자의 위치 정보(IP 또는 GPS 기반) 등</li>
</ul>
<p><strong>면접조사(CAPI, CATI 등)</strong>에서는 다음과 같은 파라데이터가 활용된다.</p>
<ul>
<li>면접자가 질문을 읽는 데 걸린 시간</li>
<li>응답자가 주저하거나 이해하지 못하는 구간의 음성/행동 코딩</li>
<li>면접 환경(예: 소음, 제3자 존재 여부)</li>
<li>질문 순서를 건너뛴 경우나 보완 질문 삽입 여부</li>
<li>면접 시작 및 종료 시각, 소요 시간</li>
<li>면접 중 발생한 기술적 문제 로그 등</li>
</ul>
<p><strong>파라데이터의 활용 목적</strong></p>
<ul>
<li><p><strong>응답 품질 진단</strong>: 지나치게 짧은 응답 시간이나 동일 패턴 반복(예: 한쪽 극단값만 선택)은 무성의한 응답자의 특징일 수 있다. 문항별 응답시간 분포가 비정상적으로 길 경우, 문항 이해가 어려웠음을 시사한다.</p></li>
<li><p><strong>설문 설계 개선</strong>: 반복적으로 건너뛰는 문항이나 수정 빈도가 높은 문항은 설계의 문제(문항 길이, 복잡성, 용어 선택 등)를 내포할 가능성이 있다. 파라데이터를 분석함으로써 특정 문항이 응답자의 인지 부담을 초래하는지 파악할 수 있다.</p></li>
<li><p><strong>면접자 모니터링 및 교육</strong>: 면접자의 응답 시간 패턴, 질문 생략 여부 등을 통해 조사 수행의 일관성과 품질을 평가할 수 있다. 특정 면접자가 다른 면접자에 비해 비정상적인 면접 패턴을 보일 경우, 교육 강화나 재훈련이 필요할 수 있다.</p></li>
<li><p><strong>데이터 후처리 및 가중치 조정</strong>: 응답 완결성, 무응답 패턴, 설문 중단률 등을 기준으로 분석에 포함할 응답자 범위를 결정하거나, 가중치를 부여하는 데 활용된다.</p></li>
</ul>
<p><strong>파라데이터의 의의</strong></p>
<p>파라데이터는 단순히 “보조적 로그 정보”를 넘어, 응답자가 설문에 어떻게 접근했는지, 설문 시스템이 어떻게 작동했는지, 그리고 데이터 생성의 맥락이 무엇이었는지를 입증하는 정량적 기록이다. 따라서 현대 조사 연구에서 파라데이터는 데이터 품질 관리의 핵심 요소로 간주되며, 점차 정밀한 설문 설계를 위한 기반 자료로 적극 활용되고 있다. 특히 빅데이터 분석, 응답자 분류, AI 기반 설문 인터페이스 개발 등에서도 파라데이터의 활용 범위는 계속 확장되고 있다.</p>
<p>결론적으로, 파라데이터는 응답자의 행동적 궤적을 가시화하는 데이터이며, 이는 설문조사의 타당성과 신뢰도를 평가하고 향후 조사 설계를 개선하는 데 없어서는 안 될 핵심 자원이라 할 수 있다.</p>
</section>
<section id="메타데이터-vs-파라데이터-비교" class="level4" data-number="0.5.3">
<h4 data-number="0.5.3" class="anchored" data-anchor-id="메타데이터-vs-파라데이터-비교"><span class="header-section-number">0.5.3</span> <span style="color:blue">3. 메타데이터 vs 파라데이터 비교</span></h4>
<table class="caption-top table">
<colgroup>
<col style="width: 11%">
<col style="width: 43%">
<col style="width: 44%">
</colgroup>
<thead>
<tr class="header">
<th>구분</th>
<th>메타데이터 (Metadata)</th>
<th>파라데이터 (Paradata)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>정의</td>
<td>조사 데이터에 대한 기술적 정보 (데이터에 대한 데이터)</td>
<td>조사 과정 중 생성되는 부차적 정보 (조사 절차의 부산물)</td>
</tr>
<tr class="even">
<td>주요 내용</td>
<td>변수명, 질문 문항, 응답 코드, 데이터 유형 등</td>
<td>응답 시간, 응답 순서, 설문 경로, 중단 여부, 장치 종류 등</td>
</tr>
<tr class="odd">
<td>사용 목적</td>
<td>데이터의 해석 및 분석 지원, 일관성 유지</td>
<td>응답 품질 평가, 비표본오차 분석, 조사 설계 개선</td>
</tr>
<tr class="even">
<td>생성 시점</td>
<td>설문 설계 및 자료 구축 단계에서 생성</td>
<td>조사 수행(수집) 과정 중 자동적으로 생성</td>
</tr>
<tr class="odd">
<td>관리 주체</td>
<td>조사 설계자, 데이터 관리자</td>
<td>조사 시스템, 조사 소프트웨어, 응답 로그 등 자동 기록 시스템</td>
</tr>
<tr class="even">
<td>활용 예시</td>
<td>분석 시 변수 라벨 확인, 코드북 제작, 설문 설계 문서 활용</td>
<td>응답 시간 분석을 통한 신뢰도 판단, 반복 응답 여부 확인</td>
</tr>
<tr class="odd">
<td>형식 예시</td>
<td><code>Q1 = 성별 (1: 남자, 2: 여자)</code>, <code>Q2 = 연령 (숫자형)</code></td>
<td><code>Q1 응답 시간: 15초</code>, <code>설문 중 3번 중단</code>, <code>모바일 응답</code></td>
</tr>
</tbody>
</table>
<p><em>【참고】</em> 메타데이터는 주로 <em>분석 전 준비 정보</em>, 파라데이터는 <em>분석 및 품질평가 보조 정보</em>로 구분된다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "복사완료!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "복사완료!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© 2025 Kwon</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/by-sekwon/by-sekwon.github.io/edit/main/notes/survey/data_process.qmd" class="toc-action"><i class="bi bi-github"></i>편집</a></li><li><a href="https://github.com/by-sekwon/by-sekwon.github.io/issues/new" class="toc-action"><i class="bi empty"></i>이슈 보고</a></li><li><a href="https://github.com/by-sekwon/by-sekwon.github.io/blob/main/notes/survey/data_process.qmd" class="toc-action"><i class="bi empty"></i>소스코드 보기</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>Built with Quarto</p>
</div>
  </div>
</footer>




</body></html>