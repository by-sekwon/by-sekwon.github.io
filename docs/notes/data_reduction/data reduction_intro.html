<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>차원축소: 개념 및 필요성 – 세상의 모든 통계 이야기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-44962e3d41ec9ccc254fd50f1af5efbe.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">세상의 모든 통계 이야기</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../notes/math_stat/index.html"> 
<span class="menu-text">기초수학·수리통계</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/intro_stat/index.html"> 
<span class="menu-text">기초통계·조사방법</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/linear_model/index.html"> 
<span class="menu-text">회귀·다변량</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl_intro/index.html"> 
<span class="menu-text">MLDL개념</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl_prediction/index.html"> 
<span class="menu-text">MLDL예측</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl_classification/index.html"> 
<span class="menu-text">MLDL분류</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../notes/data_reduction/index.html" aria-current="page"> 
<span class="menu-text">차원축소</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl_clustering/index.html"> 
<span class="menu-text">MLDL군집</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cardnews/index.html"> 
<span class="menu-text">카드뉴스</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../consult.html"> 
<span class="menu-text">통계상담</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../notes/data_reduction/data reduction_intro.html">📄 차원축소 개념|필요성</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/data_reduction/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">【머신·딥러닝 차원축소】</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/data_reduction/data reduction_intro.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">📄 차원축소 개념|필요성</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/data_reduction/data reduction_statmethod.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 차원축소 통계적방법</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/data_reduction/data reduction_unsupervised.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 차원축소 비지도학습</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#chapter-1.-고차원-데이터란" id="toc-chapter-1.-고차원-데이터란" class="nav-link active" data-scroll-target="#chapter-1.-고차원-데이터란">Chapter 1. 고차원 데이터란?</a>
  <ul>
  <li><a href="#고차원-데이터-개념" id="toc-고차원-데이터-개념" class="nav-link" data-scroll-target="#고차원-데이터-개념">1. 고차원 데이터 개념</a></li>
  <li><a href="#고차원에서-무엇이-잘못되는가" id="toc-고차원에서-무엇이-잘못되는가" class="nav-link" data-scroll-target="#고차원에서-무엇이-잘못되는가">2. 고차원에서 무엇이 잘못되는가?</a></li>
  <li><a href="#고차원-데이터와-과적합" id="toc-고차원-데이터와-과적합" class="nav-link" data-scroll-target="#고차원-데이터와-과적합">3. 고차원 데이터와 과적합</a></li>
  <li><a href="#고차원에서의-회귀" id="toc-고차원에서의-회귀" class="nav-link" data-scroll-target="#고차원에서의-회귀">4. 고차원에서의 회귀</a></li>
  <li><a href="#고차원에서-결과-해석하기" id="toc-고차원에서-결과-해석하기" class="nav-link" data-scroll-target="#고차원에서-결과-해석하기">5. 고차원에서 결과 해석하기</a></li>
  </ul></li>
  <li><a href="#chapter-2.-차원축소의-필요성" id="toc-chapter-2.-차원축소의-필요성" class="nav-link" data-scroll-target="#chapter-2.-차원축소의-필요성">Chapter 2. 차원축소의 필요성</a>
  <ul>
  <li><a href="#다중공선성-왜-추정이-불안정해지는가" id="toc-다중공선성-왜-추정이-불안정해지는가" class="nav-link" data-scroll-target="#다중공선성-왜-추정이-불안정해지는가">1. 다중공선성: 왜 추정이 불안정해지는가</a></li>
  <li><a href="#차원의-저주-거리밀도표본크기-관점-직관" id="toc-차원의-저주-거리밀도표본크기-관점-직관" class="nav-link" data-scroll-target="#차원의-저주-거리밀도표본크기-관점-직관">2. 차원의 저주: 거리/밀도/표본크기 관점 직관</a></li>
  <li><a href="#계산-안정성-역행렬-조건수-수치오차와-정규화의-연결" id="toc-계산-안정성-역행렬-조건수-수치오차와-정규화의-연결" class="nav-link" data-scroll-target="#계산-안정성-역행렬-조건수-수치오차와-정규화의-연결">3. 계산 안정성: 역행렬, 조건수, 수치오차와 정규화의 연결</a></li>
  <li><a href="#시각화노이즈-제거일반화-왜-줄이면-더-잘-맞나" id="toc-시각화노이즈-제거일반화-왜-줄이면-더-잘-맞나" class="nav-link" data-scroll-target="#시각화노이즈-제거일반화-왜-줄이면-더-잘-맞나">4. 시각화·노이즈 제거·일반화: <span dir="rtl">”</span>왜 줄이면 더 잘 맞나”</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-body" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">차원축소: 개념 및 필요성</h1>
</div>



<div class="quarto-title-meta column-body">

    
  
    
  </div>
  


</header>


<section id="chapter-1.-고차원-데이터란" class="level3">
<h3 class="anchored" data-anchor-id="chapter-1.-고차원-데이터란">Chapter 1. 고차원 데이터란?</h3>
<section id="고차원-데이터-개념" class="level4">
<h4 class="anchored" data-anchor-id="고차원-데이터-개념">1. 고차원 데이터 개념</h4>
<p>회귀와 분류를 위한 대부분의 전통적 통계 기법은 관측치의 개수 n이 특징(변수)의 개수 p보다 훨씬 큰 저차원 상황을 전제로 설계된 방법이다. 이는 통계학의 역사 대부분에서 통계를 사용해야 했던 과학적 문제의 상당수가 저차원 문제였기 때문이기도 하다.</p>
<p>예를 들어 한 병원이 흉부 CT 영상을 이용해 폐암 여부를 예측하는 모형을 만든다고 하자. 한 장의 영상은 수많은 픽셀로 구성되며, 각 픽셀 값을 하나의 예측변수로 취급하면 예측변수의 수 p는 수십만에서 수백만 수준이 될 수 있다. 반면 라벨이 확정된 환자 영상은 비용과 판독 인력의 제약 때문에 수백 명 정도만 확보될 수도 있다. 따라서 <span class="math inline">\(p \gg n\)</span>인 고차원 상황이 되며, 이 문제는 고차원 문제이다. 여기서 차원이라는 말은 p의 크기를 의미한다.</p>
<p>지난 20년 동안 새로운 기술은 금융, 마케팅, 의학처럼 다양한 분야에서 데이터가 수집되는 방식을 바꾸었다. 이제는 거의 무제한에 가까운 수의 특징 측정치를 수집하는 일이 흔해졌다(p가 매우 큰 상황이다). p가 극도로 커질 수 있는 반면, 관측치 수 n은 비용, 표본 확보 가능성, 또는 다른 제약 때문에 종종 제한된다. 예시는 다음과 같다.</p>
<p>제조업 설비 고장 예측의 예시이다. 한 공장에서는 설비에 부착된 센서로부터 초당 수백에서 수천 개의 신호(진동, 전류, 온도, 음향 등)를 연속적으로 수집하는 상황이다. 이 원시 신호로부터 시간 구간별 통계량, 주파수 영역 특징, 웨이블릿 계수, 상호상관 지표 등 파생변수를 생성하면 설비 한 대의 한 구간에 대해 특징 수 p가 수만에서 수십만 개까지 커질 수 있는 상황이다. 반면 실제 고장은 드물게 발생하므로 고장 라벨이 확정된 구간의 수 n은 수백 건 수준에 머물 수 있는 상황이다. 따라서 p가 매우 큰데 n은 제한되는 <span class="math inline">\(p \gg n\)</span>의 고차원 문제로 정리되는 예시이다.</p>
<p>신용카드 이상거래 탐지 예시이다. 카드사는 한 거래에 대해 가맹점, 위치, 시간, 금액, 단말기 정보, 사용자 행동 로그, 과거 거래 패턴 파생변수 등을 만들면 변수 수 p가 수만 개까지 확장될 수 있다. 그러나 신규 서비스이거나 특정 유형의 사기(라벨)가 희귀하면, 해당 유형에 대해 라벨이 확정된 관측치 n은 수백~수천 건으로 제한될 수 있다.</p>
<p>텍스트 기반 민원·상담 분류 예시이다. 콜센터나 민원 데이터를 분류하려고 할 때, 단어·형태소·n-gram·문서 임베딩 이전의 희소 표현을 사용하면 특징 수 p는 어휘 수에 비례해 수십만 이상이 될 수 있다. 반면 특정 분야(예: 특정 정책 민원)만 골라 라벨링한 데이터는 비용 때문에 수천 건 수준에 그칠 수 있다. 따라서 n이 제한된 상태에서 p가 매우 커지는 고차원 예시가 된다.</p>
<p>의료 웨어러블 시계열 예시이다. 심전도, PPG, 활동량, 수면 단계 같은 연속 신호에서 시간창별 통계량, 주파수 특징, 비선형 지표를 대량 생성하면 개인당 특징 수 p가 매우 커질 수 있다. 그러나 특정 질환의 확진 사례(라벨)를 가진 환자 수 n은 모집이 어려워 제한될 수 있다. 이 경우도 고차원 상황이 되는 예시이다.</p>
<p>이런 예시들의 공통점은 <span dir="rtl">”</span>기술 발전으로 특징 생성은 거의 무제한이 되었지만, 라벨이 확정된 관측치 확보는 비용과 희귀성 때문에 제한된다”는 구조이며, 결과적으로 p\gg n 문제가 자주 발생하는 상황이라는 점이다.</p>
<p>관측치보다 특징이 더 많은 데이터셋은 흔히 고차원(high-dimensional)이라고 부른다. 최소제곱 선형회귀 같은 고전적 접근은 이런 상황에 적절하지 않다. 고차원 데이터 분석에서 나타나는 많은 이슈는 이 책 앞부분에서 이미 논의한 것들이며, 그 이유는 n&gt;p인 경우에도 그런 이슈가 존재하기 때문이다.</p>
<p>대표적으로 편향–분산 트레이드오프와 과적합 위험이 있다. 이러한 이슈들은 언제나 관련이 있지만, 특징의 수가 관측치 수에 비해 매우 클 때 특히 더 중요해질 수 있다.</p>
<p>특징의 수 p가 관측치 수 n보다 큰 경우를 고차원 상황으로 정의한다. 다만 p가 n보다 약간 작더라도 아래에서 논의할 고려사항들은 여전히 적용되며, 지도학습을 수행할 때 항상 염두에 두는 것이 바람직하다.</p>
</section>
<section id="고차원에서-무엇이-잘못되는가" class="level4">
<h4 class="anchored" data-anchor-id="고차원에서-무엇이-잘못되는가">2. 고차원에서 무엇이 잘못되는가?</h4>
<p><span class="math inline">\(p &gt; n\)</span>일 때 회귀와 분류를 위해 추가적인 주의와 특화된 기법이 필요함을 보이기 위해, 고차원 상황을 전제로 설계되지 않은 통계 기법을 적용했을 때 무엇이 잘못되는지를 살펴본다. 이를 위해 최소제곱 회귀를 살펴본다. 다만 동일한 개념은 로지스틱 회귀, 선형판별분석, 그 밖의 고전적 통계 접근에도 적용된다.</p>
<p>특징의 수 p가 관측치 수 n만큼 크거나 더 크면, 최소제곱은 수행할 수 없거나(추정해야 하는 모수의 수보다 방정식의 개수가 적으므로 모수를 추정하려면 모수에 대한 제약식이 필요함) 그런 방식으로 수행하는 것이 부적절하다. 이유는 단순하다. 특징과 반응 사이에 실제 관계가 있든 없든, 최소제곱은 잔차가 0이 되도록 하는 완벽 적합을 만들어내는 계수 추정치를 산출할 수 있기 때문이다.</p>
<p>예를 들어, 하나의 설명변수와 절편을 포함한 단순 선형회귀에서 표본 크기가 한 경우는 관측치가 20개이고 다른 경우는 관측치가 2개뿐인 상황을 비교해 보자.</p>
<p>관측치가 20개인 경우에는 n&gt;p이므로 최소제곱 회귀선이 모든 점을 정확히 통과할 필요가 없으며, 데이터 전체의 경향을 가장 잘 근사하는 방향으로 직선이 정해지는 상황이다. 이때는 잔차가 남는 것이 정상이며, 회귀선은 개별 관측치를 <span dir="rtl">”</span>외우는” 것이 아니라 평균적 관계를 추정하는 역할을 하는 상황이다.</p>
<p>반면 관측치가 2개뿐이면 직선을 결정하는 데 필요한 정보가 최소한만 존재하므로, 두 점을 정확히 통과하는 직선이 항상 존재하고 최소제곱은 그 직선을 선택하게 되는 상황이다. 이때 훈련 데이터에서는 잔차가 0이 되어 완벽 적합이 발생하지만, 이는 두 점에 포함된 우연한 변동까지 그대로 따라간 결과이므로 일반화 성능이 매우 불안정해지는 상황이다.</p>
<p>따라서 훈련 데이터를 완벽히 맞출 수 있다는 사실은 좋은 모형의 증거가 아니며, 특히 <span class="math inline">\(p &gt; n\)</span>이거나 <span class="math inline">\(p \approx n\)</span>인 상황에서는 단순한 선형모형조차 훈련 데이터에 과도하게 맞춰져 독립적인 데이터에서 성능이 급격히 나빠질 가능성이 커지는 상황이다.</p>
<p>최소제곱 회귀를 고차원 상황에 가깝게 적용할 때 훈련 적합도 지표가 얼마나 쉽게 오도될 수 있는지를 알아보자. 관측치 수를 n=20으로 고정한 뒤, 반응변수와 전혀 관련이 없는 예측변수를 1개부터 20개까지 점차 늘려가며 회귀모형을 적합하는 상황을 생각한다.</p>
<p>이때 변수를 추가할수록 모형의 자유도가 증가하므로, 최소제곱은 훈련 데이터에 대해 점점 더 유연하게 적합할 수 있게 된다. 그 결과 반응과 무관한 변수만 추가했음에도 불구하고 훈련 데이터에서의 <span class="math inline">\(R^{2}\)</span>는 계속 증가하며 결국 1에 가까워지고, 훈련 MSE는 계속 감소하여 0에 가까워지는 현상이 나타나는 상황이다. 즉 훈련 데이터만 놓고 보면 <span dir="rtl">”</span>변수를 많이 넣을수록 더 좋은 모형”처럼 보이는 상황이 만들어진다.</p>
<p>그러나 독립적인 테스트셋에서 성능을 평가하면 정반대의 결과가 나타나는 상황이다. 무관한 변수를 계속 추가하면 계수 추정이 불필요하게 복잡해지고, 표본의 우연한 요동까지 설명하려는 방향으로 계수가 맞춰지면서 추정의 분산이 크게 증가하는 상황이 된다. 그 결과 테스트셋 MSE는 변수 수가 늘수록 오히려 커지며, 일반화 성능이 악화되는 현상이 나타나는 상황이다. 따라서 테스트 성능의 관점에서 보면 최선의 모형은 많아야 몇 개의 변수만 포함하는 단순한 모형인 경우가 많다는 결론으로 이어지는 상황이다.</p>
<p>이 예가 주는 핵심 메시지는 훈련 <span class="math inline">\(R^{2}\)</span>나 훈련 MSE는 고차원 또는 고유연성 상황에서 거의 언제든지 좋아질 수 있으므로, 그것만으로 모형의 우수성을 판단하면 쉽게 잘못된 결론에 도달한다는 점이다. 따라서 변수가 많거나 모형이 유연한 상황일수록, 독립 테스트셋 성능 또는 교차검증 오차를 기준으로 모형을 평가하고 선택해야 한다는 결론이 되는 설명이다.</p>
</section>
<section id="고차원-데이터와-과적합" class="level4">
<h4 class="anchored" data-anchor-id="고차원-데이터와-과적합">3. 고차원 데이터와 과적합</h4>
<p>고차원 데이터와 과적합의 관계는 p가 커질수록 모형이 <span dir="rtl">”</span>훈련 데이터를 맞추는 방법”을 너무 많이 갖게 되어, 신호뿐 아니라 잡음까지 학습하기 쉬워진다는 관계이다. 여기서 고차원은 보통 <span class="math inline">\(p \approx n\)</span> 또는 <span class="math inline">\(p &gt; n\)</span> 인 상황을 의미하는 경우가 많다.</p>
<p>첫째, <span class="math inline">\(p \approx n\)</span> 또는 <span class="math inline">\(p &gt; n\)</span>이면 훈련 데이터 완벽 적합이 쉬워지는 구조이다</p>
<p>선형회귀 <span class="math inline">\(y = X\beta + \varepsilon\)</span>에서 최소제곱은 <span class="math inline">\(\widehat{\beta} = (X^{\top}X)^{- 1}X^{\top}y\)</span> 형태로 정의되지만, <span class="math inline">\(p \geq n\)</span>이면 <span class="math inline">\(X^{\top}X\)</span>가 특이해져 역행렬이 존재하지 않거나, 잔차를 0으로 만드는 해가 여러 개 존재할 수 있는 구조이다. 이때 훈련 오차(RSS, 훈련 MSE)는 0에 가깝게 만들 수 있지만, 이것은 훈련 데이터의 우연한 변동까지 설명한 결과이므로 일반화 성능이 나빠질 가능성이 커지는 구조이다.</p>
<p>둘째, 잡음 변수가 많아질수록 <span dir="rtl">”</span>우연한 상관”이 늘어나는 구조이다 고차원에서는 실제로는 반응과 무관한 변수라도, 표본이 유한하면 어떤 변수는 우연히 반응과 상관이 있어 보일 수 있다. 변수가 많아질수록 이런 우연한 상관을 가진 변수가 나타날 확률이 커지고, 모형은 그 변수를 신호로 오인해 계수를 부여하게 되는 구조이다. 훈련에서는 성능이 좋아지지만 테스트에서는 재현되지 않아 성능이 떨어지는 전형적 과적합이 발생하는 구조이다.</p>
<p>셋째, 다중공선성과 분산 폭증이 과적합을 강화하는 구조이다 고차원에서는 변수 간 상관이 필연적으로 커지기 쉬우며 <span class="math inline">\(X^{\top}X\)</span>의 조건수가 커지는 경향이 있다. 그러면 <span class="math inline">\(Var(\widehat{\beta}) = \sigma^{2}(X^{\top}X)^{- 1}\)</span>에서 보듯 계수 추정 분산이 커지고, 작은 데이터 변화가 예측을 크게 흔드는 불안정성이 증가하는 구조이다. 이 불안정성은 테스트 성능 악화로 이어지기 쉬운 구조이다.</p>
<p>넷째, 편향–분산 관점에서 과적합은 <span dir="rtl">”</span>분산이 너무 큰 상태”이다. 고차원에서 복잡한 모형을 쓰면 편향은 줄어들 수 있지만 분산이 크게 증가한다. 결과적으로 테스트 오차는 <span class="math inline">\(\mathbb{E}\lbrack(y - \widehat{f}(x))^{2}\rbrack = \text{편향}^{2} + \text{분산} + \sigma^{2}\)</span>에서 분산 항이 커져 증가하는 구조이다. 고차원일수록 정규화나 차원축소가 필요한 이유가 여기에 있는 구조이다.</p>
<p>마지막으로, 해결 방향은 <span dir="rtl">”</span>유효 차원”을 줄이는 것이다. 고차원에서 과적합을 줄이는 핵심은 모형을 덜 유연하게 만드는 것이다. 대표적으로 라쏘·릿지 같은 정규화, 변수 선택, PCA/주성분회귀 같은 차원축소, 또는 교차검증 기반의 튜닝이 사용되는 구조이다. 특히 평가를 훈련 적합도(R^2, 훈련 MSE)가 아니라 교차검증/테스트 성능으로 해야 과적합을 피할 수 있는 구조이다.</p>
<p>정리하면, 고차원 데이터에서는 훈련 데이터를 잘 맞추는 것이 너무 쉬워지고, 우연한 패턴을 신호로 학습할 가능성이 커지며, 다중공선성으로 추정이 불안정해지기 때문에 과적합 위험이 급격히 커지는 구조이다.</p>
</section>
<section id="고차원에서의-회귀" class="level4">
<h4 class="anchored" data-anchor-id="고차원에서의-회귀">4. 고차원에서의 회귀</h4>
<p>전진 단계적 선택, 릿지 회귀, 라쏘, 주성분회귀는 p가 크고 n이 제한된 고차원 상황에서 회귀를 수행할 때 특히 유용한 방법이다. 이 방법들의 공통점은 최소제곱처럼 모든 변수를 자유롭게 사용하여 훈련 데이터를 최대한 맞추는 방식이 아니라, 변수 수를 줄이거나 계수를 수축시키거나 저차원 부분공간에서만 적합하도록 만들어 모형의 유연성을 의도적으로 낮춘다는 점이다. 이 <span dir="rtl">”</span>유연성 감소”가 과적합을 줄이고 일반화 성능을 확보하는 핵심 장치가 된다.</p>
<p>라쏘의 성능을 설명하기 위해 다음과 같은 모의 상황을 생각한다. 훈련 관측치는 n=100개이며, 후보 특징의 수 p는 20, 50, 2,000으로 달라지는 세 가지 경우를 고려한다. 중요한 설정은 p개의 특징 중 실제로 반응과 관련된 신호 특징은 20개뿐이고, 나머지는 반응과 무관한 잡음 특징이라는 점이다. 이때 라쏘를 적합하고, 예측 성능은 훈련 데이터가 아닌 독립적인 테스트셋의 평균제곱오차 MSE로 평가한다고 하자.</p>
<p>이 실험에서 먼저 나타나는 현상은 p가 커질수록 테스트셋 오차가 증가하는 경향이다. 이유는 단순히 <span dir="rtl">”</span>변수가 많아진다”가 아니라, 그 중 상당수가 신호가 아닌 잡음일 때 잡음이 학습 과정에 끼어들어 과적합을 유발하기 때문이다. 훈련셋에서는 우연한 상관 때문에 잡음 변수에도 계수가 배정될 수 있고, 이는 테스트셋에서는 재현되지 않아 오차 증가로 이어지는 구조이다.</p>
<p>두 번째로 중요한 현상은 최적의 정규화 강도 <span class="math inline">\(\lambda\)</span>가 p에 따라 달라진다는 점이다. p=20처럼 변수 수가 비교적 작고 대부분이 신호에 가깝다면, 강한 수축이 필요하지 않아 작은 <span class="math inline">\(\lambda\)</span>에서 좋은 성능이 나올 수 있다. 반면 p=50처럼 잡음 변수가 더 섞이기 시작하면, 불필요한 변수를 억제하기 위해 더 큰 <span class="math inline">\(\lambda\)</span>가 필요해지는 경향이 있다. p가 더 커지면 커질수록, 즉 후보 변수가 폭증할수록 <span dir="rtl">”</span>아무 제약 없이 학습하는 것”은 매우 위험해지므로 정규화의 역할이 더 중요해지는 구조이다. 라쏘에서는 <span class="math inline">\(\lambda\)</span>가 커질수록 0이 아닌 계수의 수가 줄어드는 경향이 있으며, 이를 자유도로 해석하면 <span dir="rtl">”</span>실제로 남겨서 쓰는 변수 개수”가 줄어드는 것으로 이해되는 구조이다.</p>
<p>세 번째로 p=2,000처럼 변수가 극단적으로 많고 그중 신호가 20개뿐인 상황에서는 라쏘가 정규화를 하더라도 성능이 전반적으로 좋지 않을 수 있다. 이는 표본 크기 n=100이 너무 작아, 거대한 후보 공간에서 신호 변수 20개를 안정적으로 찾아내기 어렵기 때문인 구조이다. 즉 정규화가 과적합을 줄이는 데 도움은 되지만, <span dir="rtl">”</span>신호 대비 잡음이 압도적으로 큰 상황”에서는 정규화만으로 충분하지 않을 수 있다는 의미이다.</p>
<p>이 설명이 강조하는 핵심 요지는 세 가지로 정리된다. 첫째, 고차원에서는 정규화나 수축이 필수적인 안정화 장치라는 점이다. 둘째, 좋은 예측 성능을 위해서는 \lambda 같은 튜닝 파라미터를 교차검증 등으로 적절히 선택해야 한다는 점이다. 셋째, 추가된 특징이 실제로 신호가 아니라 잡음이라면, 차원 p가 커질수록 테스트 오차가 증가하는 경향이 나타난다는 점이다.</p>
<p>마지막 세 번째 요지는 고차원 분석의 핵심 원리로서 차원의 저주라는 이름으로 요약된다. 변수를 많이 모으면 정보가 늘어 성능이 좋아질 것이라고 기대하기 쉽지만, 실제로는 <span dir="rtl">”</span>유의미한 신호 특징을 추가할 때만” 성능이 개선되는 구조이다. 반대로 잡음 특징을 추가하면 모형이 훈련 데이터의 우연한 패턴까지 학습하게 되어 분산이 커지고, 그 결과 테스트셋 오차가 증가하는 구조가 된다. 따라서 대규모 특징 수집 기술은 문제에 관련된 신호를 충분히 포함하면 강력한 무기가 되지만, 관련 없는 특징이 대량으로 포함되면 오히려 성능을 악화시키는 양날의 검이라는 결론으로 정리되는 설명이다.</p>
</section>
<section id="고차원에서-결과-해석하기" class="level4">
<h4 class="anchored" data-anchor-id="고차원에서-결과-해석하기">5. 고차원에서 결과 해석하기</h4>
<p>고차원 상황에서 라쏘, 릿지 회귀 또는 다른 회귀 절차를 수행할 때에는, 얻어진 결과를 보고하는 방식에 특히 주의해야 한다. 고차원 상황에서 다중공선성 문제는 극단적이다. 모형에 포함된 어떤 변수든 모형 안의 다른 모든 변수들의 선형결합으로 표현될 수 있기 때문이다.</p>
<p>본질적으로 이는 결과를 진정으로 예측하는 변수가 정확히 무엇인지(있다면 무엇인지)를 결코 확실하게 알 수 없고, 회귀에 사용할 <span dir="rtl">’</span>최선의<span dir="rtl">’</span> 계수를 결코 식별할 수 없음을 의미한다. 우리가 할 수 있는 최선은 결과를 진정으로 예측하는 변수들과 상관된 변수들에 큰 회귀계수를 부여하는 정도를 기대하는 것이다.</p>
<p>예를 들어 50만 개의 SNP를 바탕으로 혈압을 예측하려고 하며, 전진 단계적 선택이 그중 17개의 SNP가 훈련 데이터에서 좋은 예측모형을 만든다고 알려 주었다고 하자. 이때 이 17개의 SNP가 모형에 포함되지 않은 다른 SNP들보다 혈압을 더 효과적으로 예측한다고 결론내리는 것은 옳지 않다.</p>
<p>선택된 모형만큼이나 혈압을 잘 예측하는 17개 SNP의 다른 조합이 많이 존재할 가능성이 크다. 독립 데이터셋을 얻어 그 데이터셋에서 전진 단계적 선택을 수행하면, 서로 다른 SNP 집합을 포함하는 모형을 얻을 가능성이 크며, 심지어 선택된 SNP들과 전혀 겹치지 않는 집합을 얻을 수도 있다.</p>
<p>그렇다고 해서 얻어진 모형의 가치가 사라지는 것은 아니다. 예를 들어 그 모형이 독립 환자 집합에서 혈압을 매우 효과적으로 예측하여 임상적으로 유용할 수도 있다. 그러나 얻어진 결과를 과장하지 않도록 주의해야 하며, 우리가 식별한 것은 혈압 예측을 위한 가능한 많은 모형 중 하나일 뿐이고, 독립 데이터셋에서 추가 검증이 필요함을 명확히 해야 한다.</p>
<p>또한 고차원 상황에서 오류나 적합도 측도를 보고할 때에도 특히 신중해야 한다. p&gt;n이면 잔차가 0인 쓸모없는 모형을 쉽게 얻을 수 있음을 이미 보았다. 따라서 고차원 상황에서 훈련 데이터에 대한 좋은 적합의 증거로 제곱오차합, p-값, <span class="math inline">\(R^{2}\)</span> 통계량, 또는 다른 전통적 훈련 적합도 지표를 절대로 사용해서는 안 된다.</p>
<p>예를 들어 <span class="math inline">\(p &gt; n\)</span>이면 <span class="math inline">\(R^{2} = 1\)</span>인 모형을 쉽게 얻을 수 있다. 이 사실을 보고하면 통계적으로 타당하고 유용한 모형을 얻었다고 다른 사람들을 오도할 수 있지만, 실제로 이것은 설득력 있는 모형이라는 증거를 전혀 제공하지 않는다.</p>
<p>대신 독립 테스트셋에서의 결과 또는 교차검증 오차를 보고하는 것이 중요하다. 예를 들어 독립 테스트셋에서의 MSE나 <span class="math inline">\(R^{2}\)</span>는 모형 적합의 타당한 척도이지만, 훈련셋에서의 MSE는 그렇지 않다.</p>
</section>
</section>
<section id="chapter-2.-차원축소의-필요성" class="level3">
<h3 class="anchored" data-anchor-id="chapter-2.-차원축소의-필요성">Chapter 2. 차원축소의 필요성</h3>
<p>차원축소는 고차원 데이터에서 정보를 요약하여 더 안정적인 추정과 더 나은 일반화를 얻기 위한 방법론이다. 관측 데이터 행렬을 <span class="math inline">\(X \in \mathbb{R}^{n \times p}\)</span>라 할 때, 차원축소는 p개의 원변수를 <span class="math inline">\(k \ll p\)</span>개의 표현 <span class="math inline">\(Z \in \mathbb{R}^{n \times k}\)</span>로 바꾸는 과정이다.</p>
<p>선형 차원축소에서는 보통 <span class="math inline">\(Z = XW\)</span>형태로 나타나며, 여기서 <span class="math inline">\(W \in \mathbb{R}^{p \times k}\)</span>는 투영 행렬이다. 이 절은 차원축소가 필요한 이유를 다중공선성, 차원의 저주, 계산 안정성, 그리고 시각화·노이즈 제거·일반화라는 네 가지 관점에서 설명한다.</p>
<section id="다중공선성-왜-추정이-불안정해지는가" class="level4">
<h4 class="anchored" data-anchor-id="다중공선성-왜-추정이-불안정해지는가">1. 다중공선성: 왜 추정이 불안정해지는가</h4>
<p>다중공선성은 설명변수들 사이의 강한 선형 의존성이 추정의 분산을 키우고 계수 해석을 불안정하게 만드는 현상이다. 선형회귀 모형이 <span class="math inline">\(y = X\beta + \varepsilon\)</span>로 주어질 때, 최소제곱추정량은 <span class="math inline">\(\widehat{\beta} = (X^{\top}X)^{- 1}X^{\top}y\)</span>로 정의되는 형태이다.</p>
<p>이때 <span class="math inline">\(X^{\top}X\)</span>가 거의 특이행렬에 가까우면 <span class="math inline">\((X^{\top}X)^{- 1}\)</span>이 매우 큰 값을 가지게 되어, 표본의 작은 변화가 <span class="math inline">\(\widehat{\beta}\)</span>의 큰 변화로 증폭되는 구조이다. 이는 <span class="math inline">\(Var(\widehat{\beta}) = \sigma^{2}(X^{\top}X)^{- 1}\)</span> 관계에서 직접 확인되는 사실이다.</p>
<p>즉 <span class="math inline">\(X^{\top}X\)</span>의 역행렬이 커지는 방향으로 불안정해지는 순간, 추정량의 분산이 커지고 신뢰구간이 넓어지며 계수 부호가 쉽게 바뀌는 현상이 나타나는 구조이다.</p>
<p>다중공선성이 심한 경우, 예측 자체는 그럭저럭 유지되더라도 <span dir="rtl">”</span>어떤 변수가 얼마나 중요한가”라는 해석이 붕괴하는 경향이 강한 구조이다. 이는 <span class="math inline">\(X\beta\)</span>는 유사하게 유지되지만 <span class="math inline">\(\beta\)</span>의 분해가 유일하지 않거나 수치적으로 민감해지기 때문인 구조이다.</p>
<p>차원축소는 상관이 강한 변수들이 공유하는 변동을 몇 개의 축으로 묶어 <span class="math inline">\(Z = XW\)</span>로 재표현하는 방식으로, 사실상 중복 정보를 제거하고 문제의 유효 차원을 낮추는 접근이다. 이 과정은 <span class="math inline">\((X^{\top}X)\)</span>의 불안정한 방향을 제거하거나 약화시켜, 추정량의 분산을 줄이는 방향으로 작동하는 구조이다.</p>
</section>
<section id="차원의-저주-거리밀도표본크기-관점-직관" class="level4">
<h4 class="anchored" data-anchor-id="차원의-저주-거리밀도표본크기-관점-직관">2. 차원의 저주: 거리/밀도/표본크기 관점 직관</h4>
<p>차원의 저주는 차원이 증가할수록 데이터가 희소해지고 거리와 밀도의 직관이 무너지며 필요한 표본크기가 급격히 증가하는 현상을 의미하는 개념이다.</p>
<p>첫째, 거리 관점에서 고차원에서는 점들 간 거리가 서로 비슷해지는 경향이 나타나는 구조이다. 예를 들어 성분들이 독립이고 <span class="math inline">\(\mathbb{E}(X_{j}) = 0,Var(X_{j}) = 1\)</span>인 벡터 <span class="math inline">\(X = (X_{1},\ldots,X_{p})\)</span>에 대해 <span class="math inline">\(\parallel X \parallel^{2} = \overset{p}{\sum_{j = 1}}X_{j}^{2}\)</span>는 평균이 <span class="math inline">\(p\)</span>이고 분산이 <span class="math inline">\(2p\)</span>인 크기로 커지는 형태이다.</p>
<p>따라서 <span class="math inline">\(\parallel X \parallel\)</span>는 대략 <span class="math inline">\(\sqrt{p}\)</span> 근처에 집중되는 경향이 강해지는 구조이다. 이 집중 현상은 서로 다른 점들 사이의 거리도 비슷해지게 하여, 최근접 이웃과 최원거리 이웃의 차이가 상대적으로 작아지는 문제로 이어지는 구조이다. 거리 기반 방법론에서 <span dir="rtl">”</span>가깝다”라는 개념이 약해지는 이유가 여기에 있는 구조이다.</p>
<p>둘째, 밀도 관점에서 고차원에서는 공간을 <span dir="rtl">”</span>충분히 촘촘하게” 채우기 위해 필요한 표본수가 폭발하는 구조이다. 각 차원을 동일 간격으로 <span class="math inline">\(m\)</span>등분하여 공간을 커버한다고 가정하면, 필요한 격자점 수는 <span class="math inline">\(m^{p}\)</span>가 되는 형태이다.</p>
<p><span class="math inline">\(p\)</span>가 커질수록 표본 요구량이 기하급수적으로 증가하는 것이 차원의 저주의 핵심 특징이다. 이는 비모수 밀도추정이나 국소적 구조를 사용하는 방법론이 고차원에서 급격히 어려워지는 이유이다.</p>
<p>셋째, 기하학적 관점에서도 고차원에서는 <span dir="rtl">”</span>중심부”가 사라지는 현상이 나타나는 구조이다. <span class="math inline">\(\lbrack - 1,1\rbrack^{p}\)</span> 하이퍼큐브의 부피가 <span class="math inline">\(2^{p}\)</span>인 반면, 반지름 1 하이퍼스피어의 부피는 <span class="math inline">\(V_{p} = \pi^{\frac{p}{2}}/\Gamma(p/2 + 1)\)</span>인 형태이다.</p>
<p>부피 비율 <span class="math inline">\(\frac{V_{p}}{2^{p}}\)</span>는 <span class="math inline">\(p\)</span>가 커질수록 빠르게 0에 가까워지는 구조이다. 즉 차원이 커질수록 구 형태의 <span dir="rtl">”</span>중심” 영역이 전체 공간에서 차지하는 비중이 급격히 작아지는 구조이다. 차원축소는 데이터가 실제로는 저차원 구조에 가깝다는 가정 아래, 학습이 이루어지는 공간을 <span class="math inline">\(k \ll p\)</span>로 줄여 희소성과 거리 붕괴 문제를 완화하는 전략이다.</p>
</section>
<section id="계산-안정성-역행렬-조건수-수치오차와-정규화의-연결" class="level4">
<h4 class="anchored" data-anchor-id="계산-안정성-역행렬-조건수-수치오차와-정규화의-연결">3. 계산 안정성: 역행렬, 조건수, 수치오차와 정규화의 연결</h4>
<p>계산 안정성은 통계적 추정과 학습이 수치적으로 얼마나 신뢰 가능하게 수행되는지를 의미하는 관점이다. 통계 모델링에서는 역행렬, 고유값 분해, 선형연립방정식 풀이와 같은 연산이 빈번히 등장하는 구조이다.</p>
<p>선형회귀의 <span class="math inline">\((X^{\top}X)^{- 1}\)</span>뿐 아니라, 공분산 행렬 <span class="math inline">\(S = \frac{1}{n - 1}X^{\top}X\)</span>의 고유값 분해, 가우시안 모형에서 <span class="math inline">\(\Sigma^{- 1},\log|\Sigma|\)</span> 계산 등이 대표적 사례이다.</p>
<p>이때 행렬 <span class="math inline">\(A\)</span>의 조건수 <span class="math inline">\(\kappa(A) = \parallel A \parallel \parallel A^{- 1} \parallel\)</span>가 크면, 입력의 작은 오차가 출력에 크게 증폭되는 구조이다. 실데이터에는 측정오차와 반올림오차가 항상 존재하는 구조이므로, 조건수가 큰 문제는 본질적으로 불안정해지는 구조이다.</p>
<p>특히 고차원에서는 p가 n에 비해 커지기 쉬우며, <span class="math inline">\(p \geq n\)</span>이면 <span class="math inline">\(X^{\top}X\)</span>는 특이행렬이 되어 역행렬이 존재하지 않는 구조이다. 이 상황은 최소제곱추정이 정의되지 않거나 무수히 많은 해를 갖는 문제로 연결되는 구조이다.</p>
<p>정규화는 이러한 문제를 완화하는 대표적 방법이다. 예를 들어 릿지 회귀는 <span class="math inline">\({\widehat{\beta}}_{\lambda} = (X^{\top}X + \lambda I)^{- 1}X^{\top}y\)</span>로 주어지는 형태이며, <span class="math inline">\(\lambda I\)</span>를 더함으로써 고유값이 작은 방향을 부풀려 조건수를 개선하는 구조이다.</p>
<p>차원축소는 정규화와 동일한 목적을 다른 방식으로 달성하는 접근이다. 즉 불안정성을 유발하는 작은 고유값 방향을 제거하거나, <span class="math inline">\(Z = XW\)</span>로 문제의 차원을 줄여 이후 연산을 더 작은 공간에서 수행하게 만들어 수치오차 민감도를 낮추는 구조이다.</p>
</section>
<section id="시각화노이즈-제거일반화-왜-줄이면-더-잘-맞나" class="level4">
<h4 class="anchored" data-anchor-id="시각화노이즈-제거일반화-왜-줄이면-더-잘-맞나">4. 시각화·노이즈 제거·일반화: <span dir="rtl">”</span>왜 줄이면 더 잘 맞나”</h4>
<p>차원축소는 시각화와 탐색적 분석을 가능하게 하는 실용적 도구이기도 하다. <span class="math inline">\(p\)</span>가 큰 데이터는 원공간에서 구조를 보기 어려우므로, <span class="math inline">\(k = 2or3\)</span>으로 줄인 표현 Z를 통해 군집, 이상치, 경향성을 확인하는 절차가 유효한 접근이다. 이는 모델 학습 이전에 데이터의 구조적 가설을 세우는 데 중요한 역할을 하는 방식이다.</p>
<p>또한 차원축소는 노이즈 제거의 방법이기도 하다. 관측 변수는 보통 신호와 잡음이 섞여 있는 형태이며, 잡음은 상대적으로 작은 분산 또는 불규칙한 방향으로 나타나는 경향이 있는 구조이다.</p>
<p>PCA 관점에서는 큰 고유값을 갖는 몇 개의 주성분이 주요 신호를 설명하고, 작은 고유값 방향은 잡음에 가까운 경우가 많다는 직관이 성립하는 구조이다. 따라서 상위 k개 성분만 남기면 데이터가 매끄러워지고 모델이 잡음을 따라가지 않게 되는 효과가 발생하는 구조이다.</p>
<p>일반화 성능 측면에서 <span dir="rtl">”</span>차원을 줄였더니 오히려 성능이 좋아지는” 현상은 편향-분산 관점으로 설명되는 구조이다. 표현을 Z로 바꾸는 것은 모델의 입력 차원을 줄여 유효 복잡도를 낮추는 조치이다.</p>
<p>이는 분산을 줄이는 방향으로 작동하는 구조이며, 원데이터의 불필요한 변동을 제거하는 과정과 결합되면 테스트 성능이 향상될 수 있는 구조이다. 즉 차원축소는 정보 손실이라는 비용을 지불하지만, 그 대가로 추정의 안정성, 계산 가능성, 노이즈 강건성, 그리고 일반화 성능을 얻는 방법론이라는 결론으로 연결되는 절이다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>