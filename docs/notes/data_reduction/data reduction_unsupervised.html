<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>차원축소: 비지도학습 – 세상의 모든 통계 이야기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-44962e3d41ec9ccc254fd50f1af5efbe.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">세상의 모든 통계 이야기</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../notes/math_stat/index.html"> 
<span class="menu-text">기초수학·수리통계</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/intro_stat/index.html"> 
<span class="menu-text">기초통계|조사방법</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/linear_model/index.html"> 
<span class="menu-text">회귀·다변량분석</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl_intro/index.html"> 
<span class="menu-text">MLDL개념</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl_prediction/index.html"> 
<span class="menu-text">MLDL예측</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl_classification/index.html"> 
<span class="menu-text">MLDL분류</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../notes/data_reduction/index.html" aria-current="page"> 
<span class="menu-text">차원축소|군집</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cardnews/index.html"> 
<span class="menu-text">카드뉴스</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../consult.html"> 
<span class="menu-text">통계상담</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../notes/data_reduction/data reduction_unsupervised.html">📄 차원축소 비지도학습</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/data_reduction/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">【차원축소】</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/data_reduction/data reduction_intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 차원축소 개념|필요성</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/data_reduction/data reduction_statmethod.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 차원축소 통계적방법</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/data_reduction/data reduction_unsupervised.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">📄 차원축소 비지도학습</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/data_reduction/data reduction_case.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 차원축소 사례분석</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_clustering/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">【군집・비지도학습】</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_clustering/clustering_intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 군집・비지도학습 개념</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_clustering/clustering_method.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 군집・비지도학습 방법론</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_clustering/clustering_case.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 군집・비지도학습 사례분석</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#chapter-1.-비지도-학습" id="toc-chapter-1.-비지도-학습" class="nav-link active" data-scroll-target="#chapter-1.-비지도-학습">Chapter 1. 비지도 학습</a>
  <ul>
  <li><a href="#비지도학습과-차원축소" id="toc-비지도학습과-차원축소" class="nav-link" data-scroll-target="#비지도학습과-차원축소">1. 비지도학습과 차원축소</a></li>
  <li><a href="#autoencoder-재구성-오차-최소화로-학습되는-표현" id="toc-autoencoder-재구성-오차-최소화로-학습되는-표현" class="nav-link" data-scroll-target="#autoencoder-재구성-오차-최소화로-학습되는-표현">2. Autoencoder: 재구성 오차 최소화로 학습되는 표현</a></li>
  <li><a href="#bottleneck-구조와-차원축소의-대응" id="toc-bottleneck-구조와-차원축소의-대응" class="nav-link" data-scroll-target="#bottleneck-구조와-차원축소의-대응">3. Bottleneck 구조와 차원축소의 대응</a></li>
  <li><a href="#정규화와-변형" id="toc-정규화와-변형" class="nav-link" data-scroll-target="#정규화와-변형">4. 정규화와 변형</a></li>
  <li><a href="#pca-vs-linear-ae-언제-같고-언제-다른가" id="toc-pca-vs-linear-ae-언제-같고-언제-다른가" class="nav-link" data-scroll-target="#pca-vs-linear-ae-언제-같고-언제-다른가">5. PCA vs Linear AE: 언제 같고 언제 다른가</a></li>
  </ul></li>
  <li><a href="#chapter-2.-확률적-표현모형-변분-오토인코더vae-기반" id="toc-chapter-2.-확률적-표현모형-변분-오토인코더vae-기반" class="nav-link" data-scroll-target="#chapter-2.-확률적-표현모형-변분-오토인코더vae-기반">Chapter 2. 확률적 표현모형: 변분 오토인코더(VAE) 기반</a>
  <ul>
  <li><a href="#vae-개념-인코더디코더와-확률적-잠재변수" id="toc-vae-개념-인코더디코더와-확률적-잠재변수" class="nav-link" data-scroll-target="#vae-개념-인코더디코더와-확률적-잠재변수">1. VAE 개념: 인코더–디코더와 확률적 잠재변수</a></li>
  <li><a href="#elbo-직관-재구성-항과-kl-정규화" id="toc-elbo-직관-재구성-항과-kl-정규화" class="nav-link" data-scroll-target="#elbo-직관-재구성-항과-kl-정규화">2. ELBO 직관: 재구성 항과 KL 정규화</a></li>
  <li><a href="#잠재공간-해석-보간-클러스터-disentanglement" id="toc-잠재공간-해석-보간-클러스터-disentanglement" class="nav-link" data-scroll-target="#잠재공간-해석-보간-클러스터-disentanglement">3. 잠재공간 해석: 보간, 클러스터, disentanglement</a></li>
  <li><a href="#표현학습과-생성모형의-경계-왜-샘플링이-가능한가" id="toc-표현학습과-생성모형의-경계-왜-샘플링이-가능한가" class="nav-link" data-scroll-target="#표현학습과-생성모형의-경계-왜-샘플링이-가능한가">4. 표현학습과 생성모형의 경계: 왜 샘플링이 가능한가</a></li>
  </ul></li>
  <li><a href="#chapter-3.-해석성과-표현력" id="toc-chapter-3.-해석성과-표현력" class="nav-link" data-scroll-target="#chapter-3.-해석성과-표현력">Chapter 3. 해석성과 표현력</a>
  <ul>
  <li><a href="#선형-비선형-표현력-증가의-대가" id="toc-선형-비선형-표현력-증가의-대가" class="nav-link" data-scroll-target="#선형-비선형-표현력-증가의-대가">1. 선형 ↔︎ 비선형: 표현력 증가의 대가</a></li>
  <li><a href="#설명-가능성-비교-pca요인분석의-로딩과-aevae의-잠재특성" id="toc-설명-가능성-비교-pca요인분석의-로딩과-aevae의-잠재특성" class="nav-link" data-scroll-target="#설명-가능성-비교-pca요인분석의-로딩과-aevae의-잠재특성">2. 설명 가능성 비교: PCA·요인분석의 로딩과 AE·VAE의 잠재특성</a></li>
  <li><a href="#선택-가이드-데이터-규모-비선형성-목적-규제와-설명책임" id="toc-선택-가이드-데이터-규모-비선형성-목적-규제와-설명책임" class="nav-link" data-scroll-target="#선택-가이드-데이터-규모-비선형성-목적-규제와-설명책임">3. 선택 가이드: 데이터 규모, 비선형성, 목적, 규제와 설명책임</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-body" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">차원축소: 비지도학습</h1>
</div>



<div class="quarto-title-meta column-body">

    
  
    
  </div>
  


</header>


<section id="chapter-1.-비지도-학습" class="level3">
<h3 class="anchored" data-anchor-id="chapter-1.-비지도-학습">Chapter 1. 비지도 학습</h3>
<p>비지도 표현학습은 정답 라벨 y 없이 입력 데이터 x 자체로부터 유용한 표현 z를 학습하는 방법론이다. 이 절에서 다루는 오토인코더(autoencoder)는 입력 <span class="math inline">\(x \in \mathbb{R}^{p}\)</span>를 저차원 잠재표현 <span class="math inline">\(z \in \mathbb{R}^{k}\)</span>로 인코딩한 뒤 다시 <span class="math inline">\(\widehat{x} \in \mathbb{R}^{p}\)</span>로 복원하도록 신경망을 학습시키는 구조이다. 오토인코더는 차원축소의 관점에서 <span class="math inline">\(x \rightarrow z\)</span>가 표현학습이며, <span class="math inline">\(z \rightarrow \widehat{x}\)</span>가 정보 보존을 강제하는 제약으로 작동하는 구조이다. 따라서 오토인코더는 단순히 변수를 줄이는 절차가 아니라, 데이터가 갖는 구조를 보존하는 방식으로 저차원 표현을 자동으로 학습하는 방법이다.</p>
<section id="비지도학습과-차원축소" class="level4">
<h4 class="anchored" data-anchor-id="비지도학습과-차원축소">1. 비지도학습과 차원축소</h4>
<p>비지도학습의 핵심 목표 중 하나가 <span dir="rtl">”</span>라벨 없이 데이터의 구조를 요약한 저차원 표현 Z”를 만드는 일이기 때문이다. 즉 차원축소는 비지도학습이 가장 전형적으로 수행하는 과제 중 하나이며, 많은 비지도 기법이 결과적으로 <span class="math inline">\(X \rightarrow Z\)</span> 형태의 표현을 만든다는 점에서 자연스럽게 같은 장에서 다루게 된다.</p>
<p>첫째, 라벨이 없을 때 가장 확실한 학습 목표가 <span dir="rtl">”</span>구조 보존 요약”이기 때문이다. 지도학습은 y가 주어지므로 <span dir="rtl">”</span>예측 오차 최소화”라는 목표가 명확하다. 반면 비지도학습은 y가 없으므로, 데이터 자체의 규칙성을 학습해야 한다. 이때 가장 기본적인 목표가 분산, 거리, 재구성, 밀도 같은 데이터의 내부 구조를 보존하면서 더 간단한 표현으로 압축하는 것이다. PCA는 분산을, 오토인코더는 재구성을, VAE는 확률적 재구성과 잠재공간 정규화를 통해 이를 수행하는 방법이다.</p>
<p>둘째, 차원축소는 <span dir="rtl">”</span>표현학습”(representation learning)의 가장 표준적인 형태이기 때문이다. 차원축소는 원변수 공간의 정보를 <span class="math inline">\(k \ll p\)</span>인 잠재표현으로 옮기는 과정이며, 이는 곧 표현학습 이다. 특히 오토인코더와 VAE는 비지도 표현학습의 대표 방법이며, 병목 구조는 차원축소의 직접적 구현이다. 따라서 비지도학습을 차원축소 장에서 다루면 PCA→AE→VAE로 이어지는 표현학습의 확장 흐름을 자연스럽게 구성할 수 있다.</p>
<p>셋째, 다운스트림 ML 성능의 출발점이 입력 표현이기 때문이다. 실무에서는 비지도 방식으로 먼저 Z를 만든 다음, 그 Z로 분류·회귀를 수행하는 파이프라인이 흔하다. 이때 차원축소는 과적합 완화, 계산 안정화, 노이즈 제거, 시각화의 역할을 동시에 하며, 비지도학습이 그 기반 표현을 제공하는 역할을 한다.</p>
<p>넷째, 군집화·시각화·이상치탐지도 차원축소와 결합되기 때문이다. 고차원에서는 거리 기반 군집화나 이상치 탐지가 불안정해지기 쉬우므로, 먼저 저차원 표현으로 옮긴 뒤 구조를 분석하는 방식이 흔하다. 따라서 차원축소는 비지도학습의 여러 과제를 가능하게 하는 전처리이자 핵심 구성요소가 된다.</p>
<p>정리하면, 비지도학습을 차원축소에서 설명하는 이유는 라벨이 없을 때 데이터를 학습하는 가장 대표적인 방식이 <span dir="rtl">”</span>저차원 표현을 학습하는 것”이며, 그 표현이 이후 분석과 예측의 기반이 되기 때문이다.</p>
</section>
<section id="autoencoder-재구성-오차-최소화로-학습되는-표현" class="level4">
<h4 class="anchored" data-anchor-id="autoencoder-재구성-오차-최소화로-학습되는-표현">2. Autoencoder: 재구성 오차 최소화로 학습되는 표현</h4>
<p>오토인코더는 인코더 <span class="math inline">\(f_{\phi}( \cdot )\)</span>와 디코더 <span class="math inline">\(g_{\theta}( \cdot )\)</span>로 구성되는 신경망 모형이다. 입력 x가 주어졌을 때 잠재표현은</p>
<p><span class="math inline">\(z = f_{\phi}(x)\)</span>로 정의되는 구조이며, 복원값은 <span class="math inline">\(\widehat{x} = g_{\theta}(z) = g_{\theta}(f_{\phi}(x))\)</span>로 정의되는 구조이다.</p>
<p>학습 목표는 <span class="math inline">\(\widehat{x}\)</span>가 x와 최대한 같아지도록 만드는 것이며, 이를 위해 재구성 손실(reconstruction loss)을 최소화하는 방식이다. 일반적인 목적함수는 <span class="math inline">\(\min_{\phi,\theta}\frac{1}{n}\overset{n}{\sum_{i = 1}}\ell(x_{i},{\widehat{x}}_{i}) = \min_{\phi,\theta}\frac{1}{n}\overset{n}{\sum_{i = 1}}\ell(x_{i},g_{\theta}(f_{\phi}(x_{i})))\)</span>인 형태이다.</p>
<p>손실함수 <span class="math inline">\(\ell( \cdot , \cdot )\)</span>는 데이터 타입에 따라 달라지는 구조이다. 연속형 실수 데이터에서는 <span class="math inline">\(\ell(x,\widehat{x}) = \parallel x - \widehat{x} \parallel_{2}^{2}\)</span>와 같은 제곱오차가 자연스러운 선택인 구조이다. 이진 데이터에서는 베르누이 우도에 대응하는 크로스엔트로피 형태가 자주 사용되는 구조이다.</p>
<p>오토인코더의 학습 결과로 얻어지는 핵심 산출물은 잠재표현 z이며, 이 z가 이후 분류, 회귀, 군집, 이상치 탐지 등의 다운스트림 과제에 투입되는 특징으로 사용되는 구조이다.</p>
<p>오토인코더는 비지도 학습이지만, 학습 과정에서의 <span dir="rtl">”</span>정답”은 입력 x 자체이므로 자기지도(self-supervised) 구조를 갖는다고도 이해되는 방법이다. 즉 입력을 예측하도록 만드는 과정을 통해 데이터의 구조를 압축한 표현을 얻는 방식이다.</p>
</section>
<section id="bottleneck-구조와-차원축소의-대응" class="level4">
<h4 class="anchored" data-anchor-id="bottleneck-구조와-차원축소의-대응">3. Bottleneck 구조와 차원축소의 대응</h4>
<p>오토인코더가 유의미한 표현을 학습하려면 <span dir="rtl">”</span>그냥 복사하기”가 어렵도록 제약이 필요하다. 이때 가장 기본적인 제약이 병목(bottleneck) 구조이다. 병목 구조는 잠재차원 k를 입력차원 p보다 작게 두는 설정이며, <span class="math inline">\(k &lt; p\)</span>를 강제하는 구조이다.</p>
<p>이 경우 인코더는 p차원의 정보를 k차원으로 압축해야 하고, 디코더는 그 압축된 정보로 p차원의 입력을 복원해야 하므로, z는 입력의 핵심 요약을 담을 수밖에 없는 구조이다. 이 점에서 병목 오토인코더는 차원축소와 직접 대응되는 구조이다.</p>
<p>다만 <span class="math inline">\(k &lt; p\)</span>라는 제약만으로 항상 좋은 표현이 보장되는 것은 아닌 구조이다. 신경망의 표현력이 지나치게 크면, 매우 복잡한 비선형 함수를 통해 사실상 훈련 데이터를 암기하는 형태로 재구성 손실을 줄일 수 있는 구조이다. 따라서 병목은 차원 제약을 제공하지만, 일반화 가능한 표현을 얻기 위해서는 추가 정규화가 함께 요구되는 구조이다.</p>
</section>
<section id="정규화와-변형" class="level4">
<h4 class="anchored" data-anchor-id="정규화와-변형">4. 정규화와 변형</h4>
<p>오토인코더는 <span dir="rtl">”</span>재구성을 잘 하는 것”이 목표이지만, 재구성을 지나치게 잘 하면 오히려 일반화가 떨어질 수 있는 구조이다. 따라서 오토인코더는 재구성 성능과 표현의 일반화 사이의 균형을 위해 다양한 정규화 방식과 변형이 사용되는 구조이다.</p>
<section id="denoising-autoencoder" class="level5">
<h5 class="anchored" data-anchor-id="denoising-autoencoder">Denoising Autoencoder</h5>
<p>Denoising AE는 입력 x에 의도적으로 잡음을 섞은 \tilde x를 만들고, 그로부터 원래의 x를 복원하도록 학습하는 방식이다. 즉 <span class="math inline">\(\overset{˜}{x} \sim q(\overset{˜}{x} \mid x),\widehat{x} = g_{\theta}(f_{\phi}(\overset{˜}{x}))\)</span>로 두고 <span class="math inline">\(\min_{\phi,\theta}\frac{1}{n}\overset{n}{\sum_{i = 1}}\ell(x_{i},g_{\theta}(f_{\phi}({\overset{˜}{x}}_{i})))\)</span>를 최소화하는 구조이다. 이 방식은 입력의 작은 변형에 불변인 표현을 학습하게 하며, 잡음에 강건한 특징을 얻도록 유도하는 구조이다. 결과적으로 데이터의 국소적 구조를 따라가면서도 우연한 변동을 무시하는 표현이 강화되는 구조이다.</p>
</section>
<section id="sparse-autoencoder" class="level5">
<h5 class="anchored" data-anchor-id="sparse-autoencoder">Sparse Autoencoder</h5>
<p>Sparse AE는 잠재표현 z의 많은 성분이 0에 가까워지도록 희소성을 유도하는 방식이다. 대표적으로 <span class="math inline">\(\min_{\phi,\theta}\frac{1}{n}\overset{n}{\sum_{i = 1}}\ell(x_{i},{\widehat{x}}_{i}) + \lambda\Omega(z_{i})\)</span>형태로 목적함수에 정규화 항을 추가하는 구조이다. <span class="math inline">\(\Omega( \cdot )\)</span>는 <span class="math inline">\(L_{1}\)</span> 패널티 <span class="math inline">\(\parallel z \parallel_{1}\)</span> 또는 평균 활성화가 특정 값에 가깝도록 만드는 KL 기반 페널티 등이 사용되는 구조이다. 희소성은 <span dir="rtl">”</span>몇 개의 특징만 켜져서 입력을 설명한다”는 표현을 만들며, 해석가능한 부분표현을 형성하는 데 유리한 경향이 있는 구조이다.</p>
</section>
<section id="contractive-autoencoder" class="level5">
<h5 class="anchored" data-anchor-id="contractive-autoencoder">Contractive Autoencoder</h5>
<p>Contractive AE는 입력 x가 조금 변할 때 잠재표현 <span class="math inline">\(z = f_{\phi}(x)\)</span>가 크게 변하지 않도록, 인코더의 민감도를 직접 벌점으로 두는 방식이다. 대표적으로 인코더의 야코비안에 대한 정규화를 포함하여 <span class="math inline">\(\min_{\phi,\theta}\frac{1}{n}\overset{n}{\sum_{i = 1}}\ell(x_{i},{\widehat{x}}_{i}) + \lambda{\parallel \frac{\partial f_{\phi}(x_{i})}{\partial x_{i}} \parallel}_{F}^{2}\)</span>형태로 학습하는 구조이다. 이 방식은 국소적으로 매끄러운 표현을 유도하여, 작은 입력 변동에 강건한 잠재공간을 형성하는 구조이다.</p>
</section>
<section id="잠재차원-k-선택과-과적합언더핏-신호" class="level5">
<h5 class="anchored" data-anchor-id="잠재차원-k-선택과-과적합언더핏-신호">잠재차원 k 선택과 과적합·언더핏 신호</h5>
<p>잠재차원 k는 오토인코더의 표현력과 정보손실을 결정하는 핵심 하이퍼파라미터이다. k가 너무 작으면 병목이 과도해져 중요한 정보를 담지 못하고 재구성 손실이 크게 남는 언더핏이 나타나는 구조이다. 이때 훈련 손실과 검증 손실이 모두 높고, 학습이 진행되어도 손실이 충분히 내려가지 않는 형태가 나타나는 구조이다.</p>
<p>반대로 k가 너무 크거나 모델이 과도하게 복잡하면 훈련 손실은 매우 낮아지지만 검증 손실이 충분히 내려가지 않거나 다시 증가하는 과적합이 나타나는 구조이다. 이는 모델이 데이터의 일반적 구조보다 표본 특이적 세부를 암기하는 방향으로 학습되기 때문인 구조이다.</p>
<p>따라서 k 선택은 재구성 손실의 교차검증 또는 홀드아웃 검증을 통해 수행하는 것이 타당한 구조이다. 또한 다운스트림 과제가 존재하면, 각 k에 대해 학습된 z를 이용해 분류·회귀 성능을 비교하여 선택하는 방식이 실용적인 구조이다.</p>
</section>
</section>
<section id="pca-vs-linear-ae-언제-같고-언제-다른가" class="level4">
<h4 class="anchored" data-anchor-id="pca-vs-linear-ae-언제-같고-언제-다른가">5. PCA vs Linear AE: 언제 같고 언제 다른가</h4>
<p>오토인코더가 선형이고 손실이 제곱오차일 때, PCA와 매우 밀접한 관계를 갖는 구조이다. 선형 오토인코더는 인코더와 디코더를 <span class="math inline">\(f_{\phi}(x) = W^{\top}x,g_{\theta}(z) = Wz\)</span>와 같은 선형 형태로 두는 설정이다. 중심화된 데이터 행렬 X에 대해 이 경우 재구성은 <span class="math inline">\(\widehat{X} = XWW^{\top}\)</span>가 되는 구조이며, 목적함수는 <span class="math inline">\(\min_{W^{\top}W = I_{k}} \parallel X - XWW^{\top} \parallel_{F}^{2}\)</span>형태로 정리되는 구조이다.</p>
<p>이는 PCA의 재구성 관점 최적화와 동일한 문제이며, 해는 <span class="math inline">\(X^{\top}X\)</span>의 상위 k개 고유벡터로 주어지는 구조이다. 따라서 선형 오토인코더, 제곱오차, 그리고 적절한 직교 제약이 결합되면, 오토인코더가 학습하는 부분공간은 PCA가 찾는 주성분 부분공간과 같아지는 구조이다.</p>
<p>그러나 실제 구현에서는 두 방법이 달라질 수 있는 요인이 존재하는 구조이다. 첫째, 선형 오토인코더에 직교 제약이 없으면, W가 PCA와 같은 형태로 정렬되지 않을 수 있으며, 동일한 부분공간을 다른 기저로 표현하는 해가 나타날 수 있는 구조이다.</p>
<p>둘째, 최적화 방식이 다르다. PCA는 고유값 분해로 전역해를 얻는 반면, 오토인코더는 경사하강 기반 학습을 하므로 초기값과 학습 설정에 따라 수렴 양상이 달라질 수 있는 구조이다.</p>
<p>셋째, 비선형 오토인코더는 PCA와 본질적으로 다른 방법이다. 비선형 활성함수와 깊은 네트워크를 사용하면, 오토인코더는 선형 부분공간이 아니라 비선형 다양체(manifold)에 가까운 구조를 학습할 수 있는 구조이다. 이때 z는 PCA로는 포착하기 어려운 비선형 구조를 표현할 수 있으며, 데이터가 비선형 구조를 갖는 경우 재구성과 다운스트림 성능에서 PCA를 능가할 수 있는 구조이다.</p>
<p>정리하면, PCA와 선형 오토인코더는 모두 재구성 기반 차원축소라는 공통점을 가지며, 선형·제곱오차·직교 제약 조건에서 동일한 부분공간을 산출하는 구조이다. 그러나 제약의 유무, 최적화 절차, 그리고 비선형성 도입 여부에 따라 두 방법은 같아지기도 하고 달라지기도 하는 방법이라는 결론으로 정리되는 절이다.</p>
</section>
</section>
<section id="chapter-2.-확률적-표현모형-변분-오토인코더vae-기반" class="level3">
<h3 class="anchored" data-anchor-id="chapter-2.-확률적-표현모형-변분-오토인코더vae-기반">Chapter 2. 확률적 표현모형: 변분 오토인코더(VAE) 기반</h3>
<p>확률적 표현모형은 입력 x를 하나의 고정된 잠재벡터 z로 압축하는 대신, z를 확률변수로 두고 그 분포를 학습하는 방식의 표현학습이다. 오토인코더가 <span class="math inline">\(x \rightarrow z \rightarrow \widehat{x}\)</span>의 결정론적 경로로 재구성 오차를 최소화하는 구조라면, 변분 오토인코더 VAE는 z를 잠재확률변수로 설정하고 x가 어떤 잠재분포로부터 생성된 관측치라는 생성 관점을 함께 도입하는 구조이다. 여기서는 VAE의 인코더–디코더 구조, ELBO의 직관, 잠재공간 해석, 그리고 샘플링이 가능한 이유를 개념 중심으로 정리한다.</p>
<section id="vae-개념-인코더디코더와-확률적-잠재변수" class="level4">
<h4 class="anchored" data-anchor-id="vae-개념-인코더디코더와-확률적-잠재변수">1. VAE 개념: 인코더–디코더와 확률적 잠재변수</h4>
<p>VAE는 데이터 생성과 표현학습을 동시에 다루는 모형이다. 기본 아이디어는 잠재변수 <span class="math inline">\(z \in \mathbb{R}^{k}\)</span>가 먼저 생성되고, 그 z로부터 관측 <span class="math inline">\(x \in \mathbb{R}^{p}\)</span>가 생성된다고 가정하는 것이다. 이를 확률모형으로 쓰면 <span class="math inline">\(z \sim p(z),x \sim p_{\theta}(x \mid z)\)</span>의 형태이다.</p>
<p>여기서 p(z)는 잠재변수의 사전분포이며 보통 표준정규분포 <span class="math inline">\(p(z) = \mathcal{N}(0,I)\)</span>로 두는 구조이다. <span class="math inline">\(p_{\theta}(x \mid z)\)</span>는 디코더가 매개변수화하는 조건부분포이며, <span class="math inline">\(\theta\)</span>는 디코더 신경망의 파라미터이다. 이때 디코더는 z를 입력으로 받아 x의 분포를 출력하는 생성기 역할을 하는 구조이다. 연속형 데이터에서는 <span class="math inline">\(p_{\theta}(x \mid z) = \mathcal{N}(\mu_{\theta}(z),\sigma^{2}I)\)</span>처럼 평균을 신경망이 출력하도록 두는 경우가 많고, 이진 데이터에서는 베르누이 분포를 두는 구조이다.</p>
<p>표현학습의 관점에서 중요한 것은 인코더이다. 관측 x가 주어졌을 때 잠재변수의 사후분포 <span class="math inline">\(p_{\theta}(z \mid x)\)</span>를 구하고 싶지만, 일반적으로 이는 계산이 어렵다. VAE는 이를 근사하기 위해 인코더가 <span class="math inline">\(q_{\phi}(z \mid x)\)</span>라는 근사 사후분포를 출력하도록 두는 구조이다.</p>
<p>보통 <span class="math inline">\(q_{\phi}(z \mid x) = \mathcal{N}(\mu_{\phi}(x),diag(\sigma_{\phi}^{2}(x)))\)</span>로 두며, 인코더 신경망이 평균 <span class="math inline">\(\mu_{\phi}(x)\)</span>와 분산 <span class="math inline">\(\sigma_{\phi}^{2}(x)\)</span>를 출력하는 구조이다. 따라서 VAE의 잠재표현은 <span dir="rtl">”</span>점”이 아니라 <span dir="rtl">”</span>분포”이며, 관측치마다 잠재공간에서 평균과 불확실성을 함께 갖는 표현이라는 점이 핵심인 구조이다.</p>
</section>
<section id="elbo-직관-재구성-항과-kl-정규화" class="level4">
<h4 class="anchored" data-anchor-id="elbo-직관-재구성-항과-kl-정규화">2. ELBO 직관: 재구성 항과 KL 정규화</h4>
<p>VAE 학습의 목표는 관측 데이터의 주변우도 <span class="math inline">\(p_{\theta}(x)\)</span>를 크게 만드는 것이다. 즉 데이터 <span class="math inline">\(x_{1},\ldots,x_{n}\)</span>에 대해 <span class="math inline">\(\max_{\theta}\overset{n}{\sum_{i = 1}}\log p_{\theta}(x_{i})\)</span>를 하고 싶지만, <span class="math inline">\(p_{\theta}(x) = \int p_{\theta}(x \mid z)p(z)dz\)</span>의 적분이 고차원에서 어렵기 때문에 직접 최적화가 곤란한 구조이다.</p>
<p>VAE는 변분추론을 통해 <span class="math inline">\(\log p_{\theta}(x)\)</span>의 하한을 최대화하는 방식으로 학습한다. 그 하한이 ELBO이며, 다음과 같은 형태로 정리되는 구조이다. <span class="math inline">\(\log p_{\theta}(x) \geq \mathbb{E}_{q_{\phi}(z \mid x)}\lbrack\log p_{\theta}(x \mid z)\rbrack - KL(q_{\phi}(z \mid x) \parallel p(z))\)</span>. 이 식의 오른쪽이 ELBO이다. 학습은 <span class="math inline">\(\theta,\phi\)</span>에 대해 ELBO를 최대화하는 구조이다.</p>
<p>첫 번째 항 <span class="math inline">\(\mathbb{E}_{q_{\phi}(z \mid x)}\lbrack\log p_{\theta}(x \mid z)\rbrack\)</span>는 재구성 항으로 해석되는 구조이다. 디코더가 잠재변수로부터 원래의 x를 얼마나 그럴듯하게 생성하는지를 측정하는 항이다. 연속형 데이터에서 <span class="math inline">\(p_{\theta}(x \mid z)\)</span>를 가우시안으로 두고 분산을 상수로 두면, 이 항은 제곱재구성오차와 사실상 대응되는 구조이다.</p>
<p>두 번째 항 <span class="math inline">\(KL(q_{\phi}(z \mid x) \parallel p(z))\)</span>는 정규화 항으로 해석되는 구조이다. 인코더가 출력하는 잠재분포가 사전분포 p(z)와 너무 멀어지지 않도록 벌점을 주는 항이다. 이 항은 잠재공간을 <span dir="rtl">”</span>정리”하는 역할을 하며, 각 데이터 포인트의 잠재분포가 표준정규 근처에 놓이도록 유도하는 구조이다.</p>
<p>따라서 ELBO는 재구성을 잘하면서도 잠재분포를 규칙적인 형태로 유지하려는 균형의 목적함수이다. 재구성 항은 데이터 충실도를 높이고, KL 항은 잠재공간을 연속적이고 샘플링 가능한 형태로 만들며 과도한 암기를 방지하는 방향으로 작동하는 구조이다. 이 두 항의 균형이 VAE 표현의 성질을 결정하는 핵심이라는 결론이 되는 절이다.</p>
</section>
<section id="잠재공간-해석-보간-클러스터-disentanglement" class="level4">
<h4 class="anchored" data-anchor-id="잠재공간-해석-보간-클러스터-disentanglement">3. 잠재공간 해석: 보간, 클러스터, disentanglement</h4>
<p>VAE의 잠재공간 해석은 <span dir="rtl">”</span>잠재벡터의 조작이 데이터 의미의 조작으로 이어지는가”를 보는 과정이다. 이는 표현학습의 질을 평가하는 핵심 직관이기도 하다.</p>
<p>첫째, 보간은 두 관측치 <span class="math inline">\(x^{(a)},x^{(b)}\)</span>의 잠재평균 <span class="math inline">\(\mu^{(a)},\mu^{(b)}\)</span>를 구한 뒤, <span class="math inline">\(z(t) = (1 - t)\mu^{(a)} + t\mu^{(b)},t \in \lbrack 0,1\rbrack\)</span>로 잠재공간에서 선형 보간한 값을 디코더에 넣어 <span class="math inline">\(\widehat{x}(t) \sim p_{\theta}(x \mid z(t))\)</span>를 생성해 보는 절차이다. 보간 결과가 부드럽게 변화하면 잠재공간이 연속적인 의미 구조를 학습한 것으로 해석되는 구조이다. 오토인코더에서는 잠재공간이 훈련 데이터 주변에서만 의미 있고 중간 영역이 비어 있을 수 있으나, VAE는 KL 정규화로 인해 보간 경로가 더 자연스럽게 나타날 가능성이 커지는 구조이다.</p>
<p>둘째, 클러스터 구조는 잠재공간에서 유사한 관측치가 가까이 모이는지를 보는 관점이다. 예를 들어 동일한 범주나 유사한 속성을 가진 데이터가 z 공간에서 군집을 형성하면, 잠재표현이 유사성을 보존하는 의미를 갖는 구조이다. 이는 z를 이용해 군집화나 시각화가 가능해지는 이유이기도 하다.</p>
<p>셋째, disentanglement는 잠재변수의 각 차원이 서로 다른 의미 요인을 분리해 담는 정도를 의미하는 개념이다. 예를 들어 한 잠재차원은 밝기, 다른 잠재차원은 형태처럼 서로 다른 요인이 분리되어 표현되면, 잠재공간의 해석 가능성이 높아지는 구조이다. VAE는 잠재변수에 독립적인 사전분포 <span class="math inline">\(p(z) = \mathcal{N}(0,I)\)</span>를 두는 경우가 많아, 요인 분리에 유리한 성질을 가질 수 있으나, 일반 VAE가 항상 disentanglement를 보장하는 것은 아닌 구조이다. 그럼에도 <span dir="rtl">”</span>잠재차원을 조금 움직였을 때 어떤 의미적 속성이 변하는가”는 VAE 해석에서 중요한 실험적 도구가 되는 구조이다.</p>
</section>
<section id="표현학습과-생성모형의-경계-왜-샘플링이-가능한가" class="level4">
<h4 class="anchored" data-anchor-id="표현학습과-생성모형의-경계-왜-샘플링이-가능한가">4. 표현학습과 생성모형의 경계: 왜 샘플링이 가능한가</h4>
<p>VAE가 오토인코더와 구분되는 가장 중요한 지점은 샘플링이 가능한 생성모형이라는 점이다. 오토인코더는 <span class="math inline">\(z = f_{\phi}(x)\)</span>가 훈련 데이터로부터만 얻어지는 표현이며, 임의의 z를 넣었을 때 그 결과가 의미 있는 x가 된다는 보장이 약한 구조이다. 이는 잠재공간이 데이터가 놓인 부분만 <span dir="rtl">”</span>조각나게” 채워질 수 있기 때문인 구조이다.</p>
<p>VAE에서는 z에 대한 사전분포 p(z)를 명시하고, 학습 과정에서 <span class="math inline">\(KL(q_{\phi}(z \mid x) \parallel p(z))\)</span>를 통해 각 데이터의 잠재분포가 p(z)와 가까워지도록 강제하는 구조이다. 그 결과 학습이 잘 되면 잠재공간 전체가 p(z)의 질량이 놓이는 영역에서 비교적 규칙적으로 채워지는 구조가 된다.</p>
<p>따라서 학습 후에는 <span class="math inline">\(z \sim p(z),x \sim p_{\theta}(x \mid z)\)</span>의 두 단계로 새로운 데이터를 생성할 수 있는 구조이다. 이것이 VAE에서 샘플링이 가능한 이유이며, 표현학습이 생성모형으로 확장되는 지점이다.</p>
<p>정리하면, VAE는 재구성 능력을 유지하면서도 잠재공간을 확률적으로 정규화하여 샘플링 가능한 구조를 만든다는 점에서 확률적 표현모형의 대표적 사례이다. 이 절의 요지는 재구성 항이 데이터 충실도를 담당하고, KL 항이 잠재공간의 연속성과 생성 가능성을 담당한다는 구조적 이해에 있다.</p>
</section>
</section>
<section id="chapter-3.-해석성과-표현력" class="level3">
<h3 class="anchored" data-anchor-id="chapter-3.-해석성과-표현력">Chapter 3. 해석성과 표현력</h3>
<p>차원축소와 표현학습의 핵심 선택은 해석성 해석 가능성과 표현력 표현 능력 사이의 균형을 어디에 둘 것인가의 문제이다. 선형 차원축소는 구조가 단순하여 해석이 명확한 장점이 있는 반면, 복잡한 비선형 구조를 충분히 담지 못하는 한계가 있는 방법이다.</p>
<p>비선형 표현학습은 복잡한 패턴을 포착하는 능력이 크지만, 학습된 표현이 무엇을 의미하는지 설명하기 어렵고, 데이터와 학습 설정에 따라 불안정해질 수 있는 위험이 있는 방법이다. 이 절은 선형과 비선형의 차이를 표현력 증가의 대가 관점에서 정리하고, PCA·요인분석과 AE·VAE의 설명 가능성을 비교하며, 실제 적용에서의 선택 기준을 제시하는 절이다.</p>
<section id="선형-비선형-표현력-증가의-대가" class="level4">
<h4 class="anchored" data-anchor-id="선형-비선형-표현력-증가의-대가">1. 선형 ↔︎ 비선형: 표현력 증가의 대가</h4>
<p>선형 차원축소는 관측 <span class="math inline">\(x \in \mathbb{R}^{p}\)</span>를 선형 변환으로 저차원 표현 <span class="math inline">\(z \in \mathbb{R}^{k}\)</span>로 만드는 방식이다. PCA는 <span class="math inline">\(z = W^{\top}x\)</span> 형태이며, 요인분석은 <span class="math inline">\(x = \Lambda f + \varepsilon\)</span>형태로 공통요인을 가정하는 방식이다. 선형 방법은 표현이 선형결합이므로 구조가 투명하고, 계산이 안정적이며, 표본이 크지 않아도 비교적 견고하게 작동하는 장점이 있는 방법이다.</p>
<p>비선형 표현학습은 <span class="math inline">\(z = f_{\phi}(x)\)</span>가 비선형 함수가 되는 방식이다. 오토인코더와 VAE는 다층 신경망을 통해 복잡한 비선형 변환을 학습하여, 선형 부분공간이 아니라 비선형 다양체 구조를 포착할 수 있는 방법이다. 이때 표현력의 증가는 데이터가 실제로 비선형 구조를 가질 때 재구성 성능과 다운스트림 예측 성능을 개선할 수 있는 가능성을 제공하는 장점이 있는 방법이다.</p>
<p>그러나 표현력 증가에는 대가가 따르는 구조이다. 첫째, 표본 요구량이 커지는 구조이다. 비선형 모형은 파라미터가 많고 함수공간이 넓으므로, 안정적으로 일반화하려면 충분한 표본과 적절한 정규화가 필요해지는 구조이다.</p>
<p>둘째, 최적화 불확실성이 증가하는 구조이다. PCA는 고유값 분해로 전역해가 주어지지만, 신경망 기반 오토인코더는 경사하강 기반 학습이므로 초기값, 학습률, 배치 구성에 따라 수렴 결과가 달라질 수 있는 구조이다.</p>
<p>셋째, 과적합 위험이 증가하는 구조이다. 비선형 모델은 재구성 손실을 매우 낮추는 방식으로 훈련 데이터를 암기할 수 있으며, 이는 일반화된 표현을 얻는 목적과 충돌할 수 있는 구조이다.</p>
<p>넷째, 해석 가능성이 감소하는 구조이다. 선형 로딩은 변수 기여도를 직접 보여주지만, 비선형 잠재표현은 동일한 수준의 직접 해석이 어렵고 사후 분석이 필요해지는 구조이다.</p>
<p>정리하면 선형에서 비선형으로 이동하는 것은 더 강한 표현력을 얻는 대신, 더 큰 데이터 요구, 더 강한 정규화 필요, 더 큰 최적화 불확실성, 더 낮은 해석 가능성을 감수하는 선택이라는 결론이 되는 절이다.</p>
</section>
<section id="설명-가능성-비교-pca요인분석의-로딩과-aevae의-잠재특성" class="level4">
<h4 class="anchored" data-anchor-id="설명-가능성-비교-pca요인분석의-로딩과-aevae의-잠재특성">2. 설명 가능성 비교: PCA·요인분석의 로딩과 AE·VAE의 잠재특성</h4>
<p>PCA와 요인분석은 로딩 행렬을 중심으로 해석이 가능한 방법이다. PCA에서는 <span class="math inline">\(Z = XW\)</span>에서 W의 각 열 <span class="math inline">\(w_{m}\)</span>이 m번째 주성분의 로딩이며, 원변수들이 그 주성분에 어떻게 기여하는지가 계수로 드러나는 구조이다.</p>
<p>요인분석에서는 <span class="math inline">\(\Lambda\)</span>가 요인적재이며, 변수 <span class="math inline">\(x_{j}\)</span>가 요인 <span class="math inline">\(f_{m}\)</span>과 어떤 관계를 갖는지가 <span class="math inline">\(\lambda_{jm}\)</span>로 나타나는 구조이다. 또한 공통성 <span class="math inline">\(h_{j}^{2} = \sum_{m}\lambda_{jm}^{2}\)</span>와 고유성 <span class="math inline">\(\psi_{j}\)</span> 같은 지표로 변수 수준에서 설명되는 분산과 남는 분산이 구분되는 구조이다. 회전을 통해 단순구조를 만들면 요인 해석이 더 명확해지는 장점이 있는 방법이다.</p>
<p>오토인코더와 VAE는 잠재표현이 신경망의 내부 표현으로 정의되는 방식이다. 오토인코더에서는 <span class="math inline">\(z = f_{\phi}(x)\)</span>가 어떤 비선형 조합으로 형성되므로, 로딩처럼 <span dir="rtl">”</span>변수 기여도”를 직접 읽어내기 어려운 구조이다.</p>
<p>따라서 잠재특성의 해석은 보통 간접적 방법으로 이루어지는 구조이다. 예를 들어 잠재차원 하나를 변화시키며 디코더 출력이 어떻게 바뀌는지를 보는 민감도 분석, 입력 변수에 대한 기여도를 근사하는 방법, 또는 잠재공간에서의 군집 구조를 라벨과 비교하는 방법이 사용되는 구조이다.</p>
<p>VAE는 오토인코더와 달리 잠재변수 z를 확률변수로 두고 <span class="math inline">\(q_{\phi}(z \mid x)\)</span>를 학습하므로, 잠재표현에 불확실성이 포함되는 특징이 있는 방법이다. 잠재공간의 해석은 보간, 샘플링, 잠재차원 조작을 통해 수행되는 경우가 많으며, 이는 로딩 기반 해석과 성격이 다르다.</p>
<p>즉 PCA·요인분석의 해석은 로딩이라는 선형 계수의 해석이고, AE·VAE의 해석은 잠재공간에서의 조작과 생성 결과를 통해 의미를 추론하는 해석이라는 구분이 성립하는 구조이다.</p>
<p>정리하면 PCA·요인분석은 구조적 해석이 강한 반면, AE·VAE는 표현력은 강하지만 해석은 사후적이며 실험적이라는 성격이 강한 방법이라는 결론이 되는 절이다.</p>
</section>
<section id="선택-가이드-데이터-규모-비선형성-목적-규제와-설명책임" class="level4">
<h4 class="anchored" data-anchor-id="선택-가이드-데이터-규모-비선형성-목적-규제와-설명책임">3. 선택 가이드: 데이터 규모, 비선형성, 목적, 규제와 설명책임</h4>
<p>방법 선택은 목적과 제약을 동시에 고려하는 의사결정 문제이다. 다음 기준이 실무적으로 핵심인 구조이다.</p>
<p>첫째, 데이터 규모 n과 변수 수 p의 관계가 중요하다. 표본이 작거나 중간 규모이며 안정성이 우선이면 PCA나 요인분석 같은 선형 방법이 유리한 경우가 많다. 표본이 충분히 크고 데이터의 구조가 복잡할 가능성이 크면 오토인코더나 VAE 같은 비선형 표현학습이 유리해질 수 있는 구조이다. 특히 이미지, 음성, 텍스트처럼 고차원 비선형 구조가 강한 데이터에서는 비선형 표현학습의 이점이 커질 수 있는 구조이다.</p>
<p>둘째, 비선형성의 정도가 중요하다. 데이터가 본질적으로 선형 부분공간에 가깝다면 PCA가 간단하고 강력한 선택이 되는 구조이다. 데이터가 비선형 다양체 구조를 갖는다면, 선형 축소는 중요한 변동을 놓칠 수 있으며 비선형 오토인코더가 더 나은 재구성과 더 유용한 표현을 제공할 수 있는 구조이다.</p>
<p>셋째, 목적이 무엇인지가 가장 중요하다. 시각화와 탐색이 목적이면 PCA, 그리고 경우에 따라 저차원 잠재표현을 제공하는 오토인코더가 선택지이지만, 해석성과 안정성 측면에서 PCA가 기본 선택이 되는 구조이다. 예측이 목적이면, 선형 축소 뒤의 다운스트림 성능과 비선형 표현학습 뒤의 다운스트림 성능을 교차검증으로 비교해 선택하는 것이 타당한 구조이다. 생성이 목적이면, 오토인코더보다 VAE가 자연스러운 선택이 되는 구조이다. 이는 VAE가 사전분포 p(z)를 통해 샘플링이 가능하도록 잠재공간을 정규화하기 때문인 구조이다.</p>
<p>넷째, 규제와 설명책임이 중요하다. 정책 평가, 공공 의사결정, 의료·금융처럼 설명 가능성이 요구되는 영역에서는 PCA와 요인분석이 유리한 경우가 많다. 로딩과 공통성 같은 지표는 설명 책임을 뒷받침하는 근거로 제시하기 쉬운 구조이다. 반면 AE·VAE는 추가적인 해석 절차와 검증이 요구되며, 설명 책임이 강한 환경에서는 적용 장벽이 높아질 수 있는 구조이다.</p>
<p>다섯째, 운영 안정성과 재현성이 중요하다. PCA는 실행 결과가 안정적이고 재현성이 높지만, 신경망 기반 모델은 학습 설정에 따라 결과가 달라질 수 있으므로 고정된 실무 운영에서 품질 관리가 필요해지는 구조이다.</p>
<p>정리하면, 해석성과 안정성이 우선인 상황에서는 PCA·요인분석이 기본 선택이 되는 구조이다. 데이터가 크고 비선형성이 강하며 예측·생성이 핵심이면 AE·VAE가 유리해질 수 있는 구조이다. 최종 선택은 목적에 맞는 평가 기준을 정하고, 교차검증과 외부 검증을 통해 표현의 유용성과 안정성을 확인하는 방식으로 수행되는 것이 타당하다는 결론이 되는 절이다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>