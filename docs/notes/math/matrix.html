<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>matrix – 세상의 모든 통계 이야기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-a14e3238c51140e99ccc48519b6ed9ce.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">세상의 모든 통계 이야기</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">홈</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">강의노트</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-">    
        <li>
    <a class="dropdown-item" href="../../notes/math/index.html">
 <span class="dropdown-text">수학 기초</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/index.html">
 <span class="dropdown-text">조사 방법론</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/inference/index.html">
 <span class="dropdown-text">추론 통계</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/index.html">
 <span class="dropdown-text">기초 통계</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/advance_stat/index.html">
 <span class="dropdown-text">고급 통계</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/ml/index.html">
 <span class="dropdown-text">머신러닝</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/dl/index.html">
 <span class="dropdown-text">딥러닝</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../python/analysis.html"> 
<span class="menu-text">파이썬 분석</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cards/news01.html"> 
<span class="menu-text">카드뉴스</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../consult.html"> 
<span class="menu-text">통계상담</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<p>Chapter 1. 행렬 기초</p>
<p>1개념</p>
<p>통계학과 행렬</p>
<p>행렬은 통계학에서 데이터를 표현하고 분석하는 데 핵심적인 도구로 사용된다. 행렬은 대규모 데이터의 구조를 간단히 표현하고, 계산을 효율적으로 수행하여 통계학에서 중요한 역할을 한다.</p>
<p>데이터 표현</p>
<p>데이터를 행렬로 저장하여 표 형식으로 표현한다. 다음은 관측값(행)과 변수(열)로 구성된 데이터 행렬이다.</p>
<p><span class="math display">\[X = \begin{bmatrix}
x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1p} \\
x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2p} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
x_{n1} &amp; x_{n2} &amp; \cdots &amp; x_{np}
\end{bmatrix}\]</span></p>
<p>연산의 간결화</p>
<p>여러 변수와 관측값 간의 관계를 분석할 때 행렬식으로 간단히 표현하고 행렬 연산을 이용하여 추정값을 계산한다.</p>
<p><span class="math inline">\(Y = X\beta + \epsilon\)</span>, OLS 추정=<span class="math inline">\(\widehat{\beta} = (X'X)^{- 1}X'Y\)</span></p>
<p>정의</p>
<p>행과 열로 배열된 숫자, 기호 또는 표현식의&nbsp;직사각형 배열을 행렬이라 한다. 행의 차수는 <span class="math inline">\(m\)</span>, 열의 차수는 <span class="math inline">\(n\)</span>이다.</p>
<p><span class="math inline">\(A_{m \times n} = \begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\
a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn}
\end{bmatrix}\)</span> (간편식) <span class="math inline">\(A = \{ a_{ij}\}\)</span></p>
<ol type="1">
<li><p>행렬의 각 셀을 원소 element라 한다.</p></li>
<li><p>행의 차수 <span class="math inline">\(m = 1\)</span>인 행렬을 열 column 벡터이다.</p></li>
<li><p>열의 차수 <span class="math inline">\(n = 1\)</span>인 행렬을 행 row 벡터이다.</p></li>
<li><p>행의 차수, 열의 차수 모두 1인 행렬을 스칼라 scalar이다.</p></li>
<li><p>행렬을 <span class="math inline">\(n\)</span>-열벡터로 표현 : <span class="math inline">\(A_{m \times n} = \begin{bmatrix}
a_{1} &amp; a_{2} &amp; \cdots a_{n}
\end{bmatrix}\)</span></p></li>
<li><p>행렬을 <span class="math inline">\(m\)</span>-헹벡터로 표현 : <span class="math inline">\(A_{m \times n} = \left\lbrack \begin{array}{r}
a_{1} \\
a_{2} \\
\cdots \\
a_{m}
\end{array} \right\rbrack\)</span></p>
<p>동일 행렬이란</p></li>
</ol>
<!-- -->
<ol type="1">
<li><p>행의 차수와 열의 차수가 같다. <span class="math inline">\(A_{m \times n} = B_{m \times n}\)</span></p></li>
<li><p>대응하는 모든 원소 값은 동일하다. <span class="math inline">\(\{ a_{ij} = b_{ij}\} foralli,j\)</span></p></li>
</ol>
<p>2특수한 행렬</p>
<p>영행렬 zero matrix</p>
<p>행렬의 모든 원소가 0인 행렬입니다. 기호 : <span class="math inline">\(0_{m \times n}or0\)</span> 숫자 0에 해당된다.</p>
<p>정방행렬 square matrix</p>
<p>행렬의 행차수와 열차수가 동일한 행렬이다. 기호 : <span class="math inline">\(A_{m \times m} = A_{m}\)</span></p>
<p>대각행렬 diagonal matrix</p>
<p>대각원소를 제외한 모든 원소가 0인 정방행렬이다.<br>
기호 : <span class="math inline">\(A_{ij} = 0fori \neq j\)</span>, <span class="math inline">\(diag(a_{11},a_{22},...,a_{mm})\)</span></p>
<p><span class="math display">\[D = \begin{pmatrix}
- 1 &amp; 0 \\
0 &amp; 7
\end{pmatrix}\]</span></p>
<p>대각합 trace</p>
<p>대각행렬의 대각원소의 합을 대각합이라 한다. <span class="math inline">\(tr(D) = 6\)</span></p>
<p>단위행렬 identity matrix</p>
<p>정방행렬의 대각 원소가 모두 1이고 그외 원소는 0인 행렬로 숫자 1과 같은 역할을 한다. 기호 : <span class="math inline">\(I_{ij} = \{\begin{array}{r}
1i = j \\
0i \neq j
\end{array}\)</span> , <span class="math inline">\(I_{m \times m}orI_{m}\)</span></p>
<p><span class="math inline">\(A = \begin{bmatrix}
1 &amp; 2 &amp; 3 \\
3 &amp; 4 &amp; 5
\end{bmatrix}\)</span>⇨ <span class="math inline">\(A = \begin{bmatrix}
1 &amp; 0 &amp; 1 &amp; 2 &amp; 3 \\
0 &amp; 1 &amp; 3 &amp; 4 &amp; 5 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix} = \begin{bmatrix}
I &amp; A \\
0 &amp; I
\end{bmatrix}\)</span></p>
<p>삼각행렬 triangular matrix</p>
<p>【상삼각행렬】 대각원소 아래 원소가 모두 0인 정방행렬이다.<br>
기호 : <span class="math inline">\(A_{ij} = 0fori &gt; j\)</span></p>
<p>【하삼각행렬】 대각원소 윗 원소가 모두 0인 정방행렬이다.<br>
기호 : <span class="math inline">\(A_{ij} = 0fori &lt; j\)</span></p>
<p>희소행렬 Sparse matrices</p>
<p>행렬 원소의 대부분이 0인 행렬을 의미하며 <span class="math inline">\(nnz(A)\)</span>은 행렬 <span class="math inline">\(A_{m \times n}\)</span>에서 0인 아닌 원소의 개수를 나타내며 <span class="math inline">\(nnz(A)/(m \times n)\)</span>을 행렬의 밀도라 정의한다.</p>
<p>수학자 제임스 H. 윌킨슨(James H. Wilkinson)이 정의 : <span dir="rtl">”</span>행렬이 충분히 많은 0 원소를 포함하고 있어 이를 활용하는 것이 유리한 경우, 그 행렬을 희소 행렬이라 한다.” 희소행렬은 컴퓨터에서 효율적으로 저장하고 조작할 수 있다.</p>
<p>영행렬 &gt; 단위행렬 &gt; 대각행렬 &gt; 삼각행렬 : 대표적인 희소행렬</p>
<p>3행렬 놈</p>
<p>모든 원소의 제곱합의 양의 제곱근: <span class="math inline">\(\parallel A \parallel = \sqrt{\overset{m}{\sum_{i}}\overset{n}{\sum_{j}}a_{ij}}\)</span></p>
<p>행렬의 놈은 스칼라이며 행렬의 크기나 거리를 측정하며 행렬의 평균제곱근(Root Means Square)는 <span class="math inline">\(RMS(A) = \frac{\parallel A \parallel}{\sqrt{mn}}\)</span>이다.</p>
<ol type="1">
<li><span class="math inline">\(\parallel A \parallel \geq 0\)</span> 행렬 놈은 0보다 크거나 같다.</li>
</ol>
<!-- -->
<ol start="7" type="1">
<li><p><span class="math inline">\(\parallel cA \parallel = |c| \parallel A \parallel\)</span></p></li>
<li><p><span class="math inline">\(\parallel A + B \parallel \leq \parallel A \parallel + \parallel B \parallel\)</span></p></li>
<li><p><span class="math inline">\(\parallel A - B \parallel\)</span> : 두 행렬의 유사성(거리)을 나타낸다.</p></li>
<li><p><span class="math inline">\(\parallel A \parallel = \parallel A^{T} \parallel\)</span> : 원행렬 놈과 전치행렬 놈은 동일하다.</p></li>
</ol>
<p>4전치</p>
<p>전치 transpose는 행과 열을 서로 바꾸는 연산: <span class="math inline">\((A^{T})_{ij} = A_{ji}\)</span></p>
<ol type="1">
<li><span class="math inline">\((A^{T})^{T} = A\)</span> : 전치 행렬을 다시 전치하면 원래 행렬이 된다.</li>
</ol>
<!-- -->
<ol start="11" type="1">
<li><p><span class="math inline">\((A + B)^{T} = A^{T} + B^{T}\)</span> : 행렬 합의 전치는 각 행렬의 전치 합과 같다.</p></li>
<li><p><span class="math inline">\((cA)^{T} = cA^{T}\)</span> : 스칼라 곱의 전치는 스칼라 곱과 같다.</p></li>
<li><p><span class="math inline">\((AB)^{T} = B^{T}A^{T}\)</span> : 행렬 곱의 전치는 각 행렬의 전치의 순서를 바꾼 곱과 같다.</p></li>
</ol>
<p>원행렬과 전치행렬과 동일한 행렬은 대칭행렬이다. <span class="math inline">\(A = A^{T}\)</span></p>
<p>Chapter 2. 행렬 연산</p>
<p>1행렬 합 연산</p>
<p>행렬의 합을 구하는 경우 두 행렬의 차수는 동일해야 하며(conformable for addition/substraction: 합 연산 적합) 각 행렬에서 대응하는 원소들의 합을 그 위치에 적으면 된다.</p>
<p><span class="math display">\[(A + B)_{m \times n} = \{ a_{ij} + b_{ij}\}\]</span></p>
<p><span class="math display">\[(A + B)_{m \times n} = \begin{bmatrix}
a_{11} + b_{11} &amp; a_{12} + b_{12} &amp; \cdots &amp; a_{1n} + b_{1n} \\
a_{21} + b_{21} &amp; a_{22} + b_{22} &amp; \cdots &amp; a_{2n} + b_{2n} \\
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\
a_{m1} + b_{m1} &amp; a_{m2} + b_{m2} &amp; \cdots &amp; a_{mn} + b_{mn}
\end{bmatrix}\]</span></p>
<p><span class="math inline">\(A = \begin{bmatrix}
1 &amp; 3 &amp; 5 \\
7 &amp; 3 &amp; 1
\end{bmatrix}\)</span>, <span class="math inline">\(B = \begin{bmatrix}
1 &amp; 0 &amp; 1 \\
- 1 &amp; 1 &amp; 0
\end{bmatrix}\)</span> ⇢ <span class="math inline">\(A + B = \begin{bmatrix}
2 &amp; 3 &amp; 6 \\
6 &amp; 4 &amp; 1
\end{bmatrix}\)</span></p>
<p>성질</p>
<ol type="1">
<li>교환법칙 Commutativity : <span class="math inline">\(A + B = B + A\)</span></li>
</ol>
<!-- -->
<ol start="3" type="1">
<li><p>결합법칙 Associativity : <span class="math inline">\(A + (B + C) = (A + B) + C = A + B + C\)</span></p></li>
<li><p>영행렬과 합 : <span class="math inline">\(A + 0 = 0 + A = A\)</span></p></li>
<li><p>합의 전치 : <span class="math inline">\((A + B)^{T} = A^{T} + B^{T}\)</span></p></li>
</ol>
<p>2스칼라-행렬 곱하기</p>
<p>행렬 모든 원소에 스칼라 곱을 하여 결과는 원행렬과 동일한 차수의 행렬이다. (기호) <span class="math inline">\(cA = \{ ca_{ij}\} = Ac\)</span> 다음의 성질을 갖는다.</p>
<ol type="1">
<li><span class="math inline">\((cA)^{T} = cA^{T}\)</span></li>
</ol>
<!-- -->
<ol start="14" type="1">
<li><span class="math inline">\((c + d)A = cA + dA\)</span></li>
</ol>
<p>3행렬x벡터 곱하기</p>
<p>행렬 <span class="math inline">\(A_{m \times n}\)</span>와 행벡터 <span class="math inline">\(x_{n}\)</span> 곱 연산은 다음과 같이 정의되며 결과는 행벡터 <span class="math inline">\(y_{m \times 1} = A_{m \times n}x_{n \times 1}\)</span>이며 차수는 <span class="math inline">\(m\)</span>이다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image3.png" style="width:2.05315in;height:1.00733in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<p>연산 가능</p>
<p>앞의 행렬(<span class="math inline">\(A_{m \times n}\)</span>)의 열차수와 뒤의 행벡터(<span class="math inline">\(x_{n}\)</span>) 행차수가 동일해야 한다.</p>
<p>행 측면</p>
<p>행렬 <span class="math inline">\(A\)</span>의 <span class="math inline">\(i\)</span>-번째 행벡터을 <span class="math inline">\(a_{i}^{T}\)</span>라 하면 <span class="math inline">\(y_{i} = a_{i}^{T}x\)</span>(내적)이다.</p>
<p>열 측면</p>
<p><span class="math inline">\(A\)</span>의 <span class="math inline">\(k\)</span>-번째 열벡터을 <span class="math inline">\(a_{k}\)</span>라 하면<span class="math inline">\(y = x_{1}a_{1} + x_{2}a_{2} + + ... + x_{n}a_{n}\)</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image4.png" style="width:3.02676in;height:0.97316in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<p>행렬 <span class="math inline">\(A\)</span>의 열벡터 선형독립이다</p>
<p>만약 <span class="math inline">\(x = 0\)</span>인 경우에만 <span class="math inline">\(Ax = 0\)</span>이 성립하면, 열벡터는 선형독립이다.</p>
<p>활용</p>
<ol type="1">
<li>행렬 <span class="math inline">\(A\)</span>가 영행렬이면 <span class="math inline">\(Ax = 0\)</span>는 영벡터이다.</li>
</ol>
<!-- -->
<ol start="15" type="1">
<li><p>행렬 <span class="math inline">\(A\)</span>가 단위행렬이면 <span class="math inline">\(Ax = x\)</span>이다.</p></li>
<li><p>행렬 <span class="math inline">\(A\)</span>의 <span class="math inline">\(j\)</span>-번째 열벡터는 <span class="math inline">\(Ae_{j} = a_{j}\)</span>이다.</p></li>
<li><p>행렬 <span class="math inline">\(A\)</span>의 <span class="math inline">\(i\)</span>-번째 행벡터는 <span class="math inline">\((A^{T}e_{i})^{T}\)</span>이다.</p></li>
</ol>
<p>예제</p>
<p><strong>(</strong>예측데이터 행렬<strong>)</strong> Feature matrix <span class="math inline">\(X_{N \times n}\)</span>는 <span class="math inline">\(N\)</span>개의 객체에 대한 특성 <span class="math inline">\(n\)</span>-벡터, 객체들에 대한 가중치 <span class="math inline">\(w\)</span>-벡터(차수 <span class="math inline">\(N\)</span>)라 하자. <span class="math inline">\(X^{T}w\)</span>는 객체들에 대한 가중 점수 벡터이다.</p>
<p><strong>(</strong>포트폴리오 자산 수익율<strong>)</strong> 포트폴리오 자산 수익율 행렬 <span class="math inline">\(R_{T \times n}\)</span>(<span class="math inline">\(T\)</span> 기간 동안 <span class="math inline">\(n\)</span>개의 자산의 수익률)이라 하고 <span class="math inline">\(w\)</span>을 포트폴리오 <span class="math inline">\(n\)</span>-벡터라 하면 <span class="math inline">\(Rw\)</span>는 <span class="math inline">\(T\)</span>기간 포트폴리오 수익률이다.</p>
<p><strong>(</strong>오디오 믹싱<strong>)</strong> <span class="math inline">\(A\)</span>의 <span class="math inline">\(k\)</span>개 열이 길이 <span class="math inline">\(T\)</span>의 오디오 신호나 트랙을 나타내는 벡터들이고, <span class="math inline">\(w\)</span>가 <span class="math inline">\(k\)</span>-벡터인 경우를 가정하면 <span class="math inline">\(Aw\)</span>는 오디오 신호들을 믹싱한 결과를 나타내는 <span class="math inline">\(T\)</span>-벡터이다.</p>
<p><strong>(</strong>문서 점수화<strong>)</strong> 검색 엔진은 검색 쿼리를 기반으로 w를 선택하여 문서의 점수를 예측한다. <span class="math inline">\(A\)</span>는 <span class="math inline">\(N \times n\)</span>크기의 문서-단어 행렬로, <span class="math inline">\(N\)</span>개의 문서가 <span class="math inline">\(n\)</span>개의 단어 사전을 사용하여 단어의 출현 빈도, <span class="math inline">\(w\)</span>는 <span class="math inline">\(n\)</span>-벡터로, 단어 사전 내 단어들에 대한 가중치로 <span class="math inline">\(Aw\)</span>는 <span class="math inline">\(N\)</span>-벡터로, 각 문서의 점수를 나타낸다.</p>
<p>4행렬x행렬 곱하기</p>
<ol type="1">
<li>정의</li>
</ol>
<p>행렬을 곱하기 위해서는 앞 행렬의 열 차수와 뒤 행렬의 행의 차수와 일치해야 곱이 가능하다. conformable for product 결과의 차수는 앞 행렬의 행 차수, 뒤 행렬의 열 차수를 갖는다.</p>
<p><span class="math inline">\(A_{m \times n}B_{n \times p} = (AB)_{m \times p}\)</span></p>
<p><span class="math inline">\(A = \{ a_{ij}\}\)</span>, <span class="math inline">\(B = \{ b_{ij}\}\)</span> ⇢ <span class="math inline">\(AB = \{\overset{n}{\sum_{k = 1}}a_{ik}b_{kj}\}\)</span><img src="media/image5.tif" style="width:4.30301in;height:2.6064in" alt="pasted-image.tiff"></p>
<p>곱의 성질</p>
<ol type="1">
<li>결합 associate 법칙: <span class="math inline">\((AB)C = A(BC)\)</span></li>
</ol>
<!-- -->
<ol start="6" type="1">
<li><p>배분 distribution 법칙: <span class="math inline">\(A(B + C) = AB + AC\)</span></p></li>
<li><p>전치 : <span class="math inline">\((AB)^{T} = B^{T}A^{T}\)</span></p></li>
<li><p><span class="math inline">\((A + B)(C + D) = AC + AD + BC + BD\)</span></p></li>
<li><p><span class="math inline">\(y^{T}(Ax) = (y^{T}A)x = (A^{T}y)^{T}x\)</span></p>
<p>행렬의 거듭제곱</p></li>
</ol>
<p><span class="math inline">\(A^{2} = AA\)</span>, <span class="math inline">\(A^{3} = AAA\)</span>, <span class="math inline">\(A^{4} = AAAA\)</span>…</p>
<p>directed graph</p>
<p>인접 adjacency 행렬을 다음과 같이 정의하자.</p>
<p><span class="math display">\[A_{ij} = \{\begin{array}{r}
1thereisaedgefromvertexjtovertexi \\
0otherwise
\end{array}\]</span></p>
<p><span class="math inline">\((A^{2})_{ij} = \overset{n}{\sum_{k}}A_{ik}A_{kj}\)</span> <img src="media/image6.png" style="width:1.30988in;height:1.24923in" alt="붙여넣은 동영상.png"><img src="media/image7.png" style="width:3.45858in;height:0.94237in" alt="붙여넣은 동영상.png"></p>
<p>멱등행렬 idempotent</p>
<p>자신의 행렬 곱이 자신이 되는 행렬을 멱등행렬이라 한다. <span class="math inline">\(M^{2} = M^{3} = ... = M\)</span> 자신의 곱이 연산 가능해야 하므로 멱등행렬이려면 정방행렬이어야 한다.</p>
<p>5QR 분해, Q는 직교행렬, R은 상삼각행렬</p>
<p>직교행렬 orthonormal matrix</p>
<p>열벡터 <span class="math inline">\(A_{m \times n}\)</span>의 n-벡터 <span class="math inline">\(a_{1},a_{2},...,a_{m}\)</span>들이 orthonomal 하면, 즉 <span class="math inline">\(A^{T}A = I\)</span>을 만족하는 행렬을 직교정규행렬이라 한다.만약 <span class="math inline">\(A_{m \times n}\)</span>는 직교정규행렬, <span class="math inline">\(x,y\)</span>는 n-벡터라 하고 <span class="math inline">\(f:R^{n} \rightarrow R^{m}\)</span> 함수가 <span class="math inline">\(z\)</span>를 <span class="math inline">\(Az\)</span>로 매핑한다고 가정하자.</p>
<ol type="1">
<li><span class="math inline">\(\parallel Ax \parallel = \parallel x \parallel\)</span> : 함수 <span class="math inline">\(f\)</span>는 놈을 보존한다.</li>
</ol>
<!-- -->
<ol start="18" type="1">
<li><p><span class="math inline">\((Ax)^{T}(Ay) = x^{T}y\)</span> : 함수 <span class="math inline">\(f\)</span>는 두 벡터의 내적을 보존한다.</p></li>
<li><p><span class="math inline">\(\angle(Ax,Ay) = \angle(x,y)\)</span> : 함수 <span class="math inline">\(f\)</span>는 두 벡터의 각도을 보존한다.</p></li>
</ol>
<p>【recall】 Gram-Schmidt 알고리즘</p>
<p>만약 벡터들이 선형 독립이라면, Gram–Schmidt 알고리즘은 다음과 같은 속성을 가진 직교정규 벡터 <span class="math inline">\(q_{1},q_{2},...,q_{k}\)</span> 을 생성한다.</p>
<p>QR분해 <span class="math inline">\(A = QR\)</span></p>
<p>행렬 <span class="math inline">\(A_{n \times k}\)</span>의 n-벡터 <span class="math inline">\(a_{1},a_{2},...,a_{k}\)</span>가 선형 독립인 행렬이다. 여기에 Gram-Schmidt 알고리즘을 적용하여 얻은 직교정규 벡터 <span class="math inline">\(q_{1},q_{2},...,q_{k}\)</span>으로 직교정규 행렬 <span class="math inline">\(Q\)</span>을 생성하자. <span class="math inline">\(Q^{T}Q = I\)</span>이다.</p>
<p><span class="math inline">\(a_{i}\)</span>와 <span class="math inline">\(q_{i}\)</span>의 관계식 : <span class="math inline">\(a_{i} = (q_{1}^{T}a_{i})q_{1} + \cdots + (q_{i - 1}^{T}a_{i})q_{i - 1} + \parallel {\overset{˜}{q}}_{i} \parallel q_{i}\)</span></p>
<p>이를 다시 쓰면 <span class="math inline">\(a_{i} = R_{1i} + \cdots + R_{ii}q_{1}\)</span>이다. <span class="math inline">\(R_{ij} = q_{i}^{T}a_{j}fori &lt; j\)</span>, <span class="math inline">\(R_{ij} = 0fori &gt; j\)</span>, 그리고<span class="math inline">\(R_{ii} = \parallel {\overset{˜}{q}}_{i} \parallel\)</span></p>
<p>그러므로 <span class="math inline">\(A_{n \times k}\)</span> (열이 독립인 행렬)은 직교정규 행렬 <span class="math inline">\(Q_{n \times k}\)</span>과 <span class="math inline">\(R_{k \times k}\)</span> 상삼각행렬로 분해된다.</p>
<p>QR 분해 활용</p>
<p>선형 시스템의 해 구하기, 최소자승 문제, 정규방정식 문제</p>
<p>선형 방정식 <span class="math inline">\(Ax = b\)</span>를 푸는 데 사용될 수 있다. <span class="math inline">\(A = QR\)</span>로 분해하면 <span class="math inline">\(QRx = b\)</span>가 되고 <span class="math inline">\(R_{x} = Q^{T}b\)</span>이므로 <span class="math inline">\(R\)</span>이 상삼각 행렬이므로 후진 대입을 사용하여 해, <span class="math inline">\(x\)</span>를 효율적으로 구할 수 있다.</p>
<p>고유값 계산</p>
<p><span class="math inline">\(QR\)</span> 알고리즘을 이용하여 특정 행렬의 고유값을 계산할 수 있다. <span class="math inline">\(QR\)</span> 분해를 사용한 고유값 계산 알고리즘은 변환 행렬을 상삼각 행렬로 변환하고, 이로부터 고유값을 추출한다.</p>
<p>행렬의 특성 분석</p>
<p><span class="math inline">\(QR\)</span> 분해는 행렬의 특성을 분석하는 데 도움을 준다. 예를 들어, 행렬의 랭크(rank)를 결정하거나, 행렬이 정칙인지(역행렬이 존재하는지) 파악하는데 사용될 수 있다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th><div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image8.tif" style="width:0.84067in;height:0.2745in" class="figure-img"></p>
<figcaption>pasted-image.tiff</figcaption>
</figure>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>import numpy as np</p>
<p># 행렬 A 정의</p>
<p>A = np.array([[1, 1], [1, -1], [1, 1]])</p>
<p># QR 분해</p>
<p>Q, R = np.linalg.qr(A)</p>
<p># 결과 출력</p>
<p>print("Q:")</p>
<p>print(Q)</p>
<p>print("\nR:")</p>
<p>print(R)</p></td>
</tr>
<tr class="even">
<td><div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image9.png" style="width:2.25in;height:1.23175in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div></td>
</tr>
</tbody>
</table>
<p>6역행렬</p>
<p>왼쪽 오른쪽 역행렬</p>
<p>만약 <span class="math inline">\(XA = I\)</span> 만족하는 <span class="math inline">\(X\)</span>가 존재하면 A는 left-invertible 이라 한다. 동일하게 <span class="math inline">\(AX = I\)</span> 만족하는 <span class="math inline">\(X\)</span>가 존재하면 A는 right-invertible 이라 한다.</p>
<p>left-invertible과 열 벡터는 선형독립</p>
<p>만약 행렬 <span class="math inline">\(A\)</span>가 left-inverse 행렬 <span class="math inline">\(C\)</span> 갖는다면 행렬 <span class="math inline">\(A\)</span>의 열벡터는 선형 독립이다. 【증명】 <span class="math inline">\(Ax = 0\)</span>을 만족하는 <span class="math inline">\(x = 0\)</span>이므로 <span class="math inline">\(A\)</span>의 열벡터는 선형 독립이다. <span class="math inline">\(0 = CAx = Ix = x\)</span></p>
<p>left-invertible 행렬(<span class="math inline">\(C\)</span>) 갖는 <span class="math inline">\(A\)</span> 선형방정식 <span class="math inline">\(Ax = b\)</span> 해 구하기</p>
<p><span class="math display">\[C_{m \times m}A_{m \times n}x_{n} = C_{n \times n}b_{n} \rightarrow x_{n} = C_{n \times n}b_{n}\]</span></p>
<p>right-invertible과 행 벡터는 선형독립</p>
<p>만약 행렬 <span class="math inline">\(A\)</span>가 right-inverse 행렬 <span class="math inline">\(B\)</span> 갖는다면 행렬 <span class="math inline">\(A\)</span>의 행벡터는 선형 독립이다.</p>
<p>left, right invertible 관계</p>
<p>행렬 <span class="math inline">\(A\)</span>의 right inverse <span class="math inline">\(B\)</span>을 가지면 <span class="math inline">\(B^{T}\)</span>는 <span class="math inline">\(A^{T}\)</span>의 left inverse 행렬이다.</p>
<p>【증명】 <span class="math inline">\(AB = I \rightarrow (AB)^{T} = I^{T} \rightarrow B^{T}A^{T} = I\)</span></p>
<p>right-invertible 행렬(<span class="math inline">\(B\)</span>) 갖는 <span class="math inline">\(A\)</span> 선형방정식 <span class="math inline">\(Ax = b\)</span> 해 구하기</p>
<p>해는 <span class="math inline">\(x = Bb\)</span>이다. 【증명】 <span class="math inline">\(Ax = A(Bb) = (AB)b = b\)</span></p>
<p>역행렬 구하기</p>
<p>행렬의 역수 개념이다. 3에 어떤 수를 곱하면 1이 될까? 답은 <span class="math inline">\(\frac{1}{3}\)</span>(역수)이다. 마찬가지로 행렬 <span class="math inline">\(A\)</span>에 무엇을 곱하면 항등행렬 <span class="math inline">\(I\)</span>가 될까? 이를 역행렬이라 한다. <span class="math inline">\(AA^{- 1} = A^{- 1}A = I\)</span></p>
<p>행렬식 determinant</p>
<p>행렬식은 정방행렬에서만 계산되며 결과는 스칼라이다. 기호는 <span class="math inline">\(det(A)\)</span>혹은 <span class="math inline">\(|A|\)</span>으로 표현한다. 다음은 행렬식 계산 방법이다.</p>
<p><span class="math inline">\(A_{2 \times 2} = \begin{bmatrix}
a &amp; b \\
c &amp; d
\end{bmatrix}\)</span> ⇢ <span class="math inline">\(det(A) = ad - bc\)</span> <span class="math inline">\(A = \begin{bmatrix}
1 &amp; 3 \\
2 &amp; 4
\end{bmatrix}\)</span>, <span class="math inline">\(|A| = - 2\)</span></p>
<p><img src="media/image10.png" style="width:2.36468in;height:1.28439in" alt="page71image5032176.png"> 실선 + , 점선은 - 이다. <img src="media/image11.png" style="width:1.89142in;height:0.85163in" alt="pasted-image.png"> ➠ <span class="math inline">\(det(A) = 7\)</span></p>
<p>행렬식 성질</p>
<ol type="1">
<li><span class="math inline">\(|A^{T}| = |A|\)</span></li>
</ol>
<!-- -->
<ol start="10" type="1">
<li><p><span class="math inline">\(|AB| = |BA|\)</span></p></li>
<li><p><span class="math inline">\(|AB| = |A||B|\)</span></p></li>
<li><p>한 열에 <span class="math inline">\(k\)</span>배 한 후 다른 열에 더하여도 행렬식은 변하지 않는다.</p></li>
<li><p>한 열이 다른 열의 선형결합으로 표현된다면 행렬식은 0이다.</p></li>
</ol>
<p>소행렬 minor</p>
<p><span class="math inline">\(i\)</span>행, <span class="math inline">\(j\)</span>열은 제외한 행렬을 소행렬(<span class="math inline">\(M_{ij}\)</span>)이라 하고 소행렬의 행렬식을 소행렬식(<span class="math inline">\(|M_{ij}|\)</span>)이라 한다. 일반적으로 소행렬은 소행렬식을 의미한다.</p>
<p><img src="media/image12.tif" style="width:1.99272in;height:0.88566in" alt="pasted-image.tiff">⇢ <span class="math inline">\(M_{2 \times 1} = \begin{bmatrix}
a_{12} &amp; a_{13} \\
a_{32} &amp; a_{33}
\end{bmatrix}\)</span></p>
<p>여인수 cofactor</p>
<blockquote class="blockquote">
<p><span class="math inline">\(C_{ij} = ( - 1)^{i + j}|M_{ij}|\)</span>을 여인수라 한다. 여인수를 이용하여 다음과 같이 행렬식을 구할 수 있다.</p>
<p><span class="math inline">\(|A_{n \times n}| = \overset{n}{\sum_{i = 1}}a_{ij}( - 1)^{i + j}|M_{ij}|\)</span>,<span class="math inline">\(|A_{n \times n}| = \overset{n}{\sum_{j = 1}}a_{ij}( - 1)^{i + j}|M_{ij}|\)</span></p>
</blockquote>
<p>여인수 행렬 / 수반행렬 adjoint</p>
<p><span class="math inline">\(C_{ij} = \begin{bmatrix}
C_{11} &amp; C_{12} &amp; C_{13} \\
C_{21} &amp; C_{22} &amp; C_{23} \\
C_{31} &amp; C_{32} &amp; C_{33}
\end{bmatrix}\)</span>⇢ <span class="math inline">\(adj(A) = \begin{bmatrix}
C_{11} &amp; C_{21} &amp; C_{31} \\
C_{12} &amp; C_{22} &amp; C_{32} \\
C_{13} &amp; C_{23} &amp; C_{33}
\end{bmatrix}\)</span></p>
<p>역행렬 구하기</p>
<p>정방행렬 <span class="math inline">\(A\)</span>에 대하여 <span class="math inline">\(AB = BA = I\)</span>을 만족하는 행렬 <span class="math inline">\(B\)</span>를 <span class="math inline">\(A\)</span>의 역행렬이라 하며 <span class="math inline">\(A^{- 1}\)</span>로 표현한다.</p>
<p><span class="math display">\[A^{- 1} = \frac{1}{|A|}adj(A)\]</span></p>
<p>역행렬 성질</p>
<ol type="1">
<li>역행렬은 유일하고 <span class="math inline">\((A^{- 1})^{- 1} = A\)</span>이 성립한다.</li>
</ol>
<!-- -->
<ol start="14" type="1">
<li><p><span class="math inline">\((AB)^{- 1} = B^{- 1}A^{- 1}\)</span></p></li>
<li><p><span class="math inline">\((A^{T})^{- 1} = (A^{- 1})^{T}\)</span></p></li>
<li><p><span class="math inline">\(|A^{- 1}| = \frac{1}{|A|}\)</span></p></li>
</ol>
<p>계수 rank</p>
<p>차수가 <span class="math inline">\(n\)</span>인 정방행렬 <span class="math inline">\(A_{n \times n}\)</span>의 열벡터에 대하여 <span class="math inline">\(k_{1}\underset{¯}{a_{1}} + k_{2}\underset{¯}{a_{2}} + ... + k_{n}\underset{¯}{a_{n}} = \underset{¯}{0}\)</span> 방정식이 모든 상수 <span class="math inline">\(k_{j}\)</span>가 0일 때만 만족하는 경우 열벡터(<span class="math inline">\(\underset{¯}{a_{j}}\)</span>)는 선형독립 linearly independent이라 한다. 만약 적어도 0이 아닌 상수가 하나라도 존재하면 종속이라 한다.</p>
<p>정방행렬 <span class="math inline">\(A_{n \times n}\)</span>에 대하여 선형 독립인 행의 개수와 열의 개수 중 작은 것을 행렬의 계수라 한다. 행렬의 차수와 계수가 동일하면 이를 full-rank라 한다.</p>
<p>행렬 <span class="math inline">\(A_{n \times n}\)</span>에 대하여 각 열은 동일하다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 45%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">역행렬 <span class="math inline">\(A^{- 1}\)</span>은 존재한다.</th>
<th style="text-align: left;">역행렬 <span class="math inline">\(A^{- 1}\)</span>은 존재하지 않는다.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">행렬식은 0이 아니다. <span class="math inline">\(det(A) \neq 0\)</span></td>
<td style="text-align: left;">행렬식은 0이다. <span class="math inline">\(det(A) = 0\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">full rank이다. <span class="math inline">\(rank(A) = n\)</span></td>
<td style="text-align: left;">full rank 아니다. <span class="math inline">\(rank(A) &lt; n\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">행렬 A는 non-singular이다.</td>
<td style="text-align: left;">행렬 A는 singular이다.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(AX = \underset{¯}{b}\)</span> 해가 존재한다.</td>
<td style="text-align: left;"><span class="math inline">\(AX = \underset{¯}{b}\)</span> 해가 존재하지 않는다.</td>
</tr>
</tbody>
</table>
<p>Chapter 3. 행렬 활용</p>
<p>1연립방정식 해 구하기 <span class="math inline">\(Ax = b\)</span></p>
<p><span class="math inline">\(QR\)</span> 분해 이용</p>
<ol type="1">
<li>행렬 <span class="math inline">\(A\)</span>을 <span class="math inline">\(QR\)</span>분해 한다. <span class="math inline">\(A = QR\)</span></li>
</ol>
<!-- -->
<ol start="20" type="1">
<li><p><span class="math inline">\(Q^{T}b\)</span>을 구한다.</p></li>
<li><p>후진 제거 방법으로 <span class="math inline">\(Rx = Q^{T}b\)</span>을 구한다.</p>
<p>역행렬 계산 <span class="math inline">\(A^{- 1}\)</span></p></li>
</ol>
<p>행렬 <span class="math inline">\(A\)</span>의 역행렬 <span class="math inline">\(A^{- 1}\)</span>을 이용하여 <span class="math inline">\(\widehat{x} = A^{- 1}b\)</span> 해를 구한다.</p>
<p>2최소자승법</p>
<p>최소자승 문제</p>
<p><span class="math inline">\(A_{m \times n}x_{n} = b_{m}\)</span>(단 <span class="math inline">\(m &gt; n\)</span>) 선형방정식에서는 <span class="math inline">\(m\)</span>개의 방정식이 <span class="math inline">\(n\)</span>개 변수보다 많으므로 <span class="math inline">\(b\)</span>가 행렬 <span class="math inline">\(A\)</span>의 열의 선형결합일 때만 해를 갖는다. <span class="math inline">\(b\)</span>을 어떻게 구할 것인가? 잔차 <span class="math inline">\(r = Ax - b\)</span>최소화 하는 <span class="math inline">\(x\)</span>을 찾는 것을 최소자승법이라 한다. <span class="math inline">\(minmize \parallel Ax - b \parallel\)</span></p>
<p><span class="math inline">\(2x_{1} = 1, - x_{1} + x_{2} = 0,2x_{2} = - 1\)</span> : 방정식 3개, 미지수 2개</p>
<p><span class="math inline">\(Ax = b\)</span>: <span class="math inline">\(\begin{bmatrix}
2 &amp; 0 \\
- 1 &amp; 1 \\
0 &amp; 2
\end{bmatrix}\left\lbrack \begin{array}{r}
x_{1} \\
x_{2}
\end{array} \right\rbrack = \begin{bmatrix}
1 &amp; 0 &amp; 1
\end{bmatrix}\)</span></p>
<p>최소자승 해 구하기</p>
<p><span class="math inline">\(minmizef(x) = \parallel Ax - b \parallel^{2}\)</span> 해 <span class="math inline">\(\widehat{x}\)</span>는 <span class="math inline">\(\frac{\partial f}{\partial x_{i}}(\widehat{x}) = 0,i = 1,2,...,n\)</span>을 만족하므로 <span class="math inline">\(\nabla f(x) = 2A^{T}(Ax - b)\)</span> 방정식에서 <span class="math inline">\(\nabla f(\widehat{x}) = 0\)</span>이다.</p>
<p>그러므로 최소자승 해는 <span class="math inline">\(\widehat{x} = (A^{T}A)^{- 1}A^{T}b\)</span>이다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image13.png" style="width:3.02228in;height:1.50625in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<p><span class="math inline">\(A = QR\)</span> 분해 이용</p>
<p><span class="math inline">\(Ax = b\)</span>의 최소자승 해는 <span class="math inline">\(\widehat{x} = R^{- 1}Q^{T}b\)</span>이다.</p>
<p><span class="math display">\[RMS = \sqrt{\parallel b - A\widehat{x} \parallel^{2}}\]</span></p>
<p>매출 광고</p>
<p>행은 사회인구학적 특성 10개이고 열은 3개 광고 채널이고 <span class="math inline">\(R_{ij}\)</span>는 <span class="math inline">\(i\)</span>-사회인구학적특성의 <span class="math inline">\(j\)</span>-광고채널의 1달러당 노출회수(단위: 1000)이다. 만약 각 사회인구학적 특성 집단별로 노출회수를 <span class="math inline">\(10^{3}\)</span>으로 할 경우 광고비는 얼마?</p>
<p><img src="media/image14.png" style="width:1.69444in;height:1.77017in" alt="붙여넣은 동영상.png"> <img src="media/image15.png" style="width:2.42338in;height:2.00107in" alt="붙여넣은 동영상.png"></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image16.png" style="width:1.72222in;height:0.36111in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<p><span class="math inline">\(R_{10 \times 3}x_{3} = 10^{3}1_{3}\)</span>에 대한 최소자승해는 <span class="math inline">\(\widehat{x} = (62,100,1443)\)</span>으로 각 채널당 광고비이다. <span class="math inline">\(RMS = 13.2\%\)</span>이다.</p>
<p>최소자승 데이터 적합</p>
<p><span class="math inline">\(n\)</span>-벡터 <span class="math inline">\(x\)</span>(feature 벡터, 독립변수), 스칼라 <span class="math inline">\(y\)</span>는 다음 근사 함수 관계가 있다고 하자. <span class="math inline">\(f:R^{n} \rightarrow R,y \approx f(x)\)</span></p>
<p>데이터</p>
<p><span class="math display">\[x^{(1)},x^{(2)},...,x^{(N)},y^{(1)},y^{(2)},...,y^{(N)}\]</span></p>
<p>모델 관측치 개수 <span class="math inline">\(N\)</span>, 예측변수 개수 <span class="math inline">\(p\)</span></p>
<p>feature 벡터와 스칼라 벡터 사이 함수 관계는 <span class="math inline">\(f\)</span>(예측함수)은<span class="math inline">\(y \approx \widehat{f}(x),where\widehat{f}:R^{n} \rightarrow R\)</span></p>
<p><span class="math inline">\(\widehat{f}(x)\)</span>는 파라미터 <span class="math inline">\(p\)</span>-벡터 <span class="math inline">\(\theta\)</span>의 선형 함수이다.</p>
<p><span class="math inline">\(\widehat{f}(x) = \theta_{1}f_{1}(x) + \theta_{2}f_{2}(x) + \cdots + \theta_{p}f_{p}(x)\)</span>, where <span class="math inline">\(f_{i}:R^{n} \rightarrow R\)</span></p>
<p>예측값과 예측오차</p>
<p><span class="math inline">\(y^{(i)} \approx \widehat{f}(x^{(i)})\)</span>이고 예측오차(잔차)는 <span class="math inline">\(r^{(i)} = y^{(i)} - {\widehat{y}}^{(i)}\)</span>이다.</p>
<p>최소자승 모델 적합 <span class="math inline">\(i = 1,2,\cdots,N,j = 1,2,\cdots,p\)</span></p>
<p><span class="math inline">\(y^{d} = (y^{(1)},y^{(2)},...,y^{(N)})\)</span>, <span class="math inline">\({\widehat{y}}^{d} = ({\widehat{y}}^{(1)},{\widehat{y}}^{(2)},...,{\widehat{y}}^{(N)})\)</span></p>
<p>예측오차합 <span class="math inline">\(\parallel r^{d} = y^{d} - {\widehat{y}}^{d} \parallel^{2}\)</span>을 최소화 하는 모수 <span class="math inline">\(\theta\)</span>을 찾는다.</p>
<p><span class="math display">\[{\widehat{y}}^{(i)} = A_{i1}\theta_{1} + A_{i1}\theta_{2} + \cdots + A_{i1}\theta_{p},whereA_{ij} = {\widehat{f}}_{j}(x^{(i)})\]</span></p>
<p><span class="math inline">\({\widehat{y}}^{d} = A\theta\)</span>이므로 <span class="math inline">\(\parallel r^{d} \parallel^{2} = \parallel y^{d} - A\theta \parallel^{2}\)</span>이다.</p>
<p>최소자승 추정 : <span class="math inline">\(\widehat{\theta} = (A^{T}A)^{- 1}A^{T}y^{d}\)</span></p>
<p>상수항(절편) 있는 선형함수 최소자승 추정</p>
<p>모든 <span class="math inline">\(x\)</span>에 대하여 <span class="math inline">\(f_{1}(x) = 1\)</span>을 갖는 상수함수를 고려하자. <span class="math inline">\(\widehat{f}(x) = \theta_{1}\)</span>이고 <span class="math inline">\(A_{(N \times 1)} = 1_{N}\)</span>이다.</p>
<p><span class="math display">\[\widehat{\theta} = (A^{T}A)^{- 1}A^{T}y^{d} = N^{- 1}1^{T}y^{d} = avg(y^{d})\]</span></p>
<p>다항식 적합</p>
<p>모형 <span class="math inline">\(\widehat{f}(x) = \theta_{1} + \theta_{2}x + \cdots + \theta_{p}x^{p - 1}\)</span></p>
<p><span class="math display">\[A = \begin{bmatrix}
1 &amp; x^{(1)} &amp; \cdots &amp; (x^{(1)})^{p - 1} \\
1 &amp; x^{(2)} &amp; \cdots &amp; (x^{(2)})^{p - 1} \\
\cdots &amp; &amp; &amp; \\
1 &amp; x^{(N)} &amp; \cdots &amp; (x^{(N)})^{p - 1}
\end{bmatrix}\]</span></p>
<p>Piecewise-Linear Fit 분절선형 적합</p>
<p>절단점 식별: 선의 기울기가 변하는 지점을 결정한다.</p>
<p>선형 구간 적합: 절단점으로 분리된 각 데이터 구간에 선형 모델을 적합한다.</p>
<p>구간 결합: 절단점에서 구간함수를 연결하여 연속적인 분절선형 함수를 형성한다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image17.png" style="width:3.88639in;height:2.97154in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th><img src="media/image8.tif" style="width:0.84067in;height:0.2745in" alt="pasted-image.tiff"> Piecewise-Linear Fit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>import numpy as np</p>
<p># 합성 데이터 생성</p>
<p>np.random.seed(0)</p>
<p>x = np.linspace(0, 10, 100)</p>
<p>y = np.piecewise(x, [x &lt; 4, (x &gt;= 4) &amp; (x &lt; 7), x &gt;= 7],[lambda x: 2 * x + 1 + np.random.normal(size=len(x)),lambda x: -x + 5 + np.random.normal(size=len(x)),lambda x: 0.5 * x - 1 + np.random.normal(size=len(x))])</p>
<p>import matplotlib.pyplot as plt</p>
<p>from scipy.optimize import curve_fit</p>
<p># 분절선형 함수 정의</p>
<p>def piecewise_linear(x, x0, x1, y0, y1, y2, k1, k2, k3):</p>
<p>conds = [x &lt; x0, (x &gt;= x0) &amp; (x &lt; x1), x &gt;= x1]</p>
<p>funcs = [lambda x: k1 * x + y0, lambda x: k2 * x + y1, lambda x: k3 * x + y2]</p>
<p>return np.piecewise(x, conds, funcs)</p>
<p># 초기 파라미터 추정값</p>
<p>p0 = [4, 7, 1, 5, -1, 2, -1, 0.5]</p>
<p># 데이터를 분절선형 함수에 적합시킴</p>
<p>params, _ = curve_fit(piecewise_linear, x, y, p0=p0)</p>
<p># 데이터를 적합한 결과와 함께 플로팅</p>
<p>x_fit = np.linspace(0, 10, 100)</p>
<p>y_fit = piecewise_linear(x_fit, *params)</p>
<p>plt.scatter(x, y, label='Data')</p>
<p>plt.plot(x_fit, y_fit, color='red', label='Piecewise Linear Fit')</p>
<p>plt.xlabel('x')</p>
<p>plt.ylabel('y')</p>
<p>plt.legend()</p>
<p>plt.show()</p></td>
</tr>
</tbody>
</table>
<p>3간선행렬</p>
<p>간선 행렬 Incidence matrix은 그래프 이론에서 사용되는 개념으로, 정점과 vertices 간선 edges, nodes 사이의 관계를 나타내는 행렬입니다.</p>
<p>간선 행렬 <span class="math inline">\(G_{n \times m}\)</span>은 정점이 <span class="math inline">\(n\)</span>개, 간선이 <span class="math inline">\(m\)</span>개이다.</p>
<p><span class="math inline">\(A_{ij} = 1\)</span> : 정점 <span class="math inline">\(i\)</span>와 간선 <span class="math inline">\(j\)</span>와 연결되어 있고 정점 <span class="math inline">\(i\)</span>는 끝 정점이 아니다.</p>
<p><span class="math inline">\(A_{ij} = 1\)</span> : 정점 <span class="math inline">\(i\)</span>와 간선 <span class="math inline">\(j\)</span>와 연결되어 있고 정점 <span class="math inline">\(i\)</span>는 끝 정점이다.</p>
<p><span class="math inline">\(A_{ij} = 0\)</span> : 정점 <span class="math inline">\(i\)</span>와 간선 <span class="math inline">\(j\)</span>와 연결되어 않음</p>
<p><img src="media/image18.png" style="width:1.6318in;height:1.56565in" alt="붙여넣은 동영상.png"> <img src="media/image19.png" style="width:2.5in;height:0.93478in" alt="붙여넣은 동영상.png"></p>
<p>4네트워크</p>
<p>만약 <span class="math inline">\(x\)</span>가 네트워크에서의 흐름을 나타내는 <span class="math inline">\(m\)</span>-벡터라면, <span class="math inline">\(x_{j}\)</span>는 간선 <span class="math inline">\(j\)</span>를 통한 흐름으로 해석된다. 여기서 양의 값은 흐름이 간선 <span class="math inline">\(j\)</span>의 방향으로 이동하고, 음의 값은 흐름이 간선 <span class="math inline">\(j\)</span>의 반대 방향으로 이동함을 의미한다. 네트워크에서 간선이나 링크의 방향은 흐름의 방향을 지정하지 않고 그저 흐름 flow의 방향을 고려하는 것을 나타내는 것이다.</p>
<p>네트워크에서의 흐름 보존은 흐름이 노드와 간선을 통해 어떻게 이동하는지를 설명하며, 각 노드로 들어오는 총 흐름이 노드에서 나가는 총 흐름과 같음을 보장한다.</p>
<p>네트워크 구조를 나타내는 <span class="math inline">\(G_{n \times m}\)</span>를 사용하여</p>
<p><span class="math inline">\(y = Gx\)</span>는 각 노드로 들어오는 순흐름을 나타내는 <span class="math inline">\(n\)</span>-벡터이다.</p>
<p><span class="math inline">\(y_{i}\)</span>는 <span class="math inline">\(i\)</span>-노드로 들어오는 총 흐름에서 <span class="math inline">\(i\)</span>-노드에서 나가는 총 흐름을 뺀 값이다 즉, <span class="math inline">\(i\)</span>-노드에서의 흐름 잉여 surplus이다.</p>
<p>요약하면, <span class="math inline">\(y = Gx\)</span>는 네트워크 이론에서의 흐름 보존 원칙을 요약한 것으로, 각 요소 <span class="math inline">\(y_{i}\)</span>는 노드 <span class="math inline">\(i\)</span>에서의 순 흐름 균형을 나타내며 모든 들어오는 흐름과 나가는 흐름을 고려한다.</p>
<p>만약 <span class="math inline">\(Gx = 0\)</span>인 상태를 각 노드에서 총 들어오는 흐름과 총 나가는 흐름이 일치하기 때문에 흐름 보존이 일어난다고 말한다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image20.png" style="width:3.59933in;height:1.95473in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<p>위의 그래프에 의해 나타낸 네트워크에서 <span class="math inline">\(x = (1, - 1,1,0,1)\)</span>이다. 소스는 source 노드에서 네트워크로 들어오거나 나가지만, 간선을 따라 흐르지는 않습니다. 위 그림에서 보여지는 것처럼 이러한 흐름들은 5-벡터 4소스로 나타낸다. <span class="math inline">\(s_{i}\)</span>를 노드 <span class="math inline">\(i\)</span>에서 외부에서 네트워크로 들어오는 흐름으로 생각할 수 있다. 즉, 어떤 간선을 통해서도 들어오지 않는 것입다. <span class="math inline">\(s_{i} &gt; 0\)</span>일 때 외부흐름은 소스라고 부르며 <span class="math inline">\(s_{i} &lt; 0\)</span>일 때 외부흐름은 싱크라고 부른다.</p>
<p>소스 포함된 흐름 보전 : <span class="math inline">\(Ax + s = 0\)</span></p>
<p>5선형함수 모델</p>
<p>필드에서 발생하는 많은 함수나 변수 간의 관계는 선형 또는 아핀 함수로 근사될 수 있는데, 두 변수 집합 간의 선형 함수를 모형(model) 또는 근사(approximation) 값으로 정의한다.</p>
<p>수요의 가격 탄력성(Price elasticity of demand)</p>
<p>가격이 n개의 상품(서비스)에 의해 결정되는 n-벡터 p로 주어지고, 상품에 대한 수요가 n-벡터 d로 주어진다. n-벡터 <span class="math inline">\(\delta^{price}\)</span>를 가격변화 벡터라 하면 <span class="math inline">\(\delta^{price} = \frac{(p_{i}^{new} - p_{i})}{p_{i}}\)</span>라 하자(<span class="math inline">\(p^{new}\)</span>는 새로운 가격 n-벡터). n-벡터 <span class="math inline">\(\delta^{dem}\)</span>를 수요변화 벡터라 하면 <span class="math inline">\(\delta^{dem} = \frac{(d_{i}^{new} - d_{i})}{d_{i}}\)</span>라 하자.</p>
<p><span class="math inline">\(\delta^{dem} = E^{d}\delta^{price}\)</span>, <span class="math inline">\(E^{d}\)</span>는 (<span class="math inline">\(n \times n\)</span>) 수요 탄력성 행렬이다. <span class="math inline">\(E_{11}^{d} = - 0.4\)</span>, <span class="math inline">\(E_{21}^{d} = 0.2\)</span> 가정해 보자. 이는 첫 번째 상품의 가격이 1% 증가할 때, 다른 가격은 동일한 상태에서 첫 번째 상품의 수요가 0.4% 감소하고, 두 번째 상품의 수요가 0.2% 증가할 것임을 의미한다. 두 번째 상품은 첫 번째 상품의 부분 대체품으로 작용하고 있다.</p>
<p>탄성 변형 Elastic deformation</p>
<p>f 를 구조물에 작용하는 특정 위치(및 방향)에 대한 힘(하중)을 나타내는 n-벡터라고 합시다. 구조물은 하중으로 인해 약간 변형될 것입니다. d는 하중으로 인해 구조물의 m개 지점에서 발생하는 변위(특정 방향으로)를 나타내는 m-벡터입니다. 변위와 하중 사이의 관계는 선형으로 잘 근사된다. d = Cf 여기서 C 는 m × n 컴플라이언스(compliance) 행렬이고 C 의 항목의 단위는 m/N입니다.</p>
<p>테일러 근사</p>
<p>함수 <span class="math inline">\(f:R^{n} \rightarrow R^{n}\)</span>이 1차 미분이 가능하다고 하면 테일러 근사는 <span class="math inline">\(\widehat{f}(x)_{i} = f_{i}(z) + \triangledown f_{i}(z)^{T}(x - z)\)</span>, 단 n-벡터 <span class="math inline">\(z\)</span>는 n-벡터 <span class="math inline">\(x\)</span>와 가까운 값이다.</p>
<p><span class="math inline">\(\widehat{f}(x) = f(z) + Df(z)(x - z)\)</span>, 단.<span class="math inline">\(Df(z)_{ij} = \frac{\partial f_{i}}{\partial x_{i}}(z),i = 1,...,m,j = 1,...,n\)</span></p>
<p>회귀모형</p>
<p>표본 크기 <span class="math inline">\(N\)</span>, 예측변수 벡터 <span class="math inline">\(x^{(1)},x^{(2)},...,x^{(N)}\)</span>이다. <span class="math inline">\(i\)</span>-개체의 예측치는 <span class="math inline">\({\widehat{y}}^{(i)} = (x^{(i)})^{T}\beta + v,i = 1,2,...,N\)</span>이다. 그리고 <span class="math inline">\(X\)</span>는 예측변수 행렬, <span class="math inline">\(y\)</span>는 목표변수 벡터이다.</p>
<p>잔차는 <span class="math inline">\(r^{(i)} = y^{(i)} - {\widehat{y}}^{(i)}\)</span>.</p>
<p>절편 없는 회귀모형 : <span class="math inline">\({\widehat{y}}^{d} = X^{T}\beta + v1\)</span></p>
<p>절편 회귀모형 : <span class="math inline">\({\widehat{y}}^{d} = \left\lbrack \begin{array}{r}
1^{T} \\
X
\end{array} \right\rbrack^{T}\left\lbrack \begin{array}{r}
v \\
\beta
\end{array} \right\rbrack\)</span></p>
<p>6선형 동적 시스템</p>
<p>시간에 따라 변하는 상태 벡터의 선형 관계를 설명하는 모델로 시스템의 현재 상태가 다음 상태를 예측할 수 있는 간단한 수학적 구조이다. <span class="math inline">\(x_{t}\)</span>가 현재 상태인 <span class="math inline">\(x_{1},x_{2},\cdots\)</span> n-벡터 시계열이라 하자. 예를 들면, <span class="math inline">\((x_{5})_{3}\)</span> 3번째 포트폴리오의 5일째 주가가 된다.</p>
<p>입력이 포함된 선형 동적 시스템</p>
<p><span class="math display">\[x_{t + 1} = A_{t}x_{t} + B_{t}u_{t},t = 1,2,...\]</span></p>
<p><span class="math inline">\(u_{t}\)</span> 는 시간 t 에서의 입력벡터이고 .B 는 입력행렬로, 입력 <span class="math inline">\(u_{t}\)</span>(외생 변수라고도 함)가 상태 벡터 <span class="math inline">\(x_{t}\)</span>에 미치는 영향을 설명한다.</p>
<p><span class="math inline">\(K\)</span>-Markov 모형</p>
<p><span class="math display">\[x_{t + 1} = A_{1}x_{t} + \cdots + A_{K}x_{t - K + 1},t = K,K + 1,...\]</span></p>
<p>상태 <strong>State</strong> : 시스템이 존재할 수 있는 모든 가능한 상태들의 집합. 예를 들어, 날씨 예측 모델에서 상태는 <span dir="rtl">”</span>맑음”, <span dir="rtl">”</span>흐림”, <span dir="rtl">”</span>비” 등이 될 수 있다. 시스템이 가질 수 있는 모든 상태들의 집합을 상태 공간 <span class="math inline">\(S\)</span>라 한다.</p>
<p>상태 전이 <strong>State Transition</strong> : 한 상태에서 다른 상태로의 전이. 상태 전이는 확률적으로 이루어지며 <span class="math inline">\(P_{i}\)</span>는 초기상태 확률분포이다.</p>
<p>전이 확률 <strong>Transition Probability</strong> : 현재 상태에서 다음 상태로 전이될 확률을 나타낸다. 이는 <span class="math inline">\(P(x_{t + 1} = s_{j}|x_{t} = s_{i})\)</span>로 표현되며, 현재 상태 <span class="math inline">\(i\)</span>에서 다음 시점에 상태 <span class="math inline">\(j\)</span>로 전이될 확률이다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 54%">
<col style="width: 45%">
</colgroup>
<thead>
<tr class="header">
<th colspan="2"><img src="media/image8.tif" style="width:0.84067in;height:0.2745in" alt="pasted-image.tiff"> Markov model</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td colspan="2"><p>import numpy as np</p>
<p># 전이 행렬 정의</p>
<p>P = np.array([[0.8, 0.2],[0.4, 0.6]])</p>
<p># 초기 상태 분포 정의</p>
<p>pi_0 = np.array([0.6, 0.4])</p>
<p># 상태 이름 정의</p>
<p>states = ["Sunny", "Rainy"]</p>
<p># 시뮬레이션을 위한 시간 단계 수</p>
<p>num_steps = 10</p>
<p># 초기 상태 선택</p>
<p>current_state = np.random.choice(states, p=pi_0)</p>
<p>print(f"Day 0: {current_state}")</p>
<p># 시뮬레이션 시작</p>
<p>for t in range(1, num_steps + 1):</p>
<p>if current_state == "Sunny":</p>
<p>next_state = np.random.choice(states, p=P[0])</p>
<p>else:</p>
<p>next_state = np.random.choice(states, p=P[1])</p>
<p>print(f"Day {t}: {next_state}")</p>
<p>current_state = next_state</p></td>
</tr>
<tr class="even">
<td><div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image21.png" style="width:1.05837in;height:1.73748in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div></td>
<td><p>첫날이 맑을 확률이 0.6, 비가 올 확률이 0.4라고 가정 <span class="math inline">\(\pi_{0}\)</span></p>
<p>(전이확률)<br>
맑은 날이 다음 날에도 맑을 확률: 0.8<br>
맑은 날이 다음 날 비가 올 확률: 0.2<br>
비 오는 날이 다음 날 맑을 확률: 0.4<br>
비 오는 날이 다음 날에도 비가 올 확률: 0.6</p></td>
</tr>
</tbody>
</table>
<p>7인구 동태</p>
<p>100-벡터 <span class="math inline">\((x_{t})_{i}\)</span>는 <span class="math inline">\(t\)</span> 시점의 <span class="math inline">\((i - 1)\)</span>세 인구이다. 100- 벡터 <span class="math inline">\(b\)</span>의 <span class="math inline">\(b_{i}\)</span>는 <span class="math inline">\((i - 1)\)</span>의 평균 출생율이다. 가임 연령을 고려하면 벡터 b의 원소는<span class="math inline">\(b_{I} = 0fori &lt; 13ori &gt; 50\)</span>이다. 만약 사망, 이민 없다고 가정하면 내년 0세 인구는 <span class="math inline">\((x_{t + 1})_{1} = b^{T}x_{t}\)</span>이다.</p>
<p>나이 <span class="math inline">\(i\)</span>세 <span class="math inline">\((t + 1)\)</span> 시점의 인구수는 다음과 같다. <span class="math inline">\(d_{i}\)</span>는 <span class="math inline">\(i\)</span>세 사망자수이다.<span class="math inline">\((x_{t + 1})_{i + 1} = (1 - d_{i})(x_{t})_{i},i = 1,2,\cdots,99\)</span>. 최종적으로 인구 동태 모형은 <span class="math inline">\(x_{t + 1} = Ax_{t},t = 1,2,\cdots\)</span>이다.</p>
<p>전이행렬 <span class="math inline">\(A\)</span></p>
<p><span class="math display">\[A = \begin{bmatrix}
b_{1} &amp; b_{2} &amp; b_{3} &amp; \cdots &amp; b_{98} &amp; b_{99} &amp; b_{100} &amp; \\
1 - d_{1} &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0 &amp; \\
0 &amp; 1 - d_{2} &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0 &amp; \\
\cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1 - d_{98} &amp; 0 &amp; 0 &amp; \\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; &amp; 0 &amp; 1 - d_{99} &amp; 0
\end{bmatrix}\]</span></p>
<p>이민을 고려한 인구 동태 모형</p>
<p><span class="math inline">\(x_{t + 1} = Ax_{t} + u_{t},t = 1,2,\cdots\)</span>, 벡터 <span class="math inline">\((u_{t})_{i}\)</span>는 t-시점에 나이 <span class="math inline">\((i - 1)\)</span>세의 순이민자수이다.</p>
<p>간단한 인구동태 방정식</p>
<p><span class="math display">\[P_{t + 1} = P_{t} + (B_{t} - D_{t}) + M_{t}\]</span></p>
<p><span class="math inline">\(P_{t}\)</span> : <span class="math inline">\(t\)</span> 시점의 인구수, <span class="math inline">\(B_{t}\)</span> : <span class="math inline">\(t\)</span> 시점의 출생자수, <span class="math inline">\(D_{t}\)</span> : <span class="math inline">\(t\)</span> 시점의 사망자수, <span class="math inline">\(M_{t}\)</span> : <span class="math inline">\(t\)</span> 시점의 순 이민자수</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th><img src="media/image8.tif" style="width:0.84067in;height:0.2745in" alt="pasted-image.tiff"> Markov model</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>import numpy as np</p>
<p>import matplotlib.pyplot as plt</p>
<p># 초기 인구와 파라미터 설정 미국 23년 기준</p>
<p>initial_population = 330_000_000</p>
<p>birth_rate = 12.4 / 1000</p>
<p>death_rate = 8.9 / 1000</p>
<p>annual_net_migration = 1_000_000</p>
<p>years = 10</p>
<p># 인구 예측을 위한 배열 초기화</p>
<p>population = np.zeros(years + 1)</p>
<p>population[0] = initial_population</p>
<p># 연도별 인구 예측</p>
<p>for t in range(1, years + 1):</p>
<p>births = population[t - 1] * birth_rate</p>
<p>deaths = population[t - 1] * death_rate</p>
<p>population[t] = population[t - 1] + births - deaths + annual_net_migration</p>
<p># 결과 출력</p>
<p>for t in range(years + 1):</p>
<p>print(f"Year {2023 + t}: {population[t]:,.0f}")</p></td>
</tr>
<tr class="even">
<td>Year 2024: 332,155,000 Year 2025: 334,317,542 Year 2026: 336,487,654 Year 2027: 338,665,361 Year 2028: 340,850,689 Year 2029: 343,043,667 Year 2030: 345,244,320 Year 2031: 347,452,675 Year 2032: 349,668,759Year 2033: 351,892,600</td>
</tr>
</tbody>
</table>
<p>8전염병 동태</p>
<p>전염 역할 모델른 전염병의 전파와 확산을 연구하는 분야로, 이는 질병의 전염 방식과 전파 속도를 이해하고 예측하는 데 중점을 둔다.</p>
<p><span class="math inline">\(SIRD\)</span> 모델 상태</p>
<p><span class="math inline">\(x_{t} = (S,I,R,D),whereS + R + I + D = 1\)</span></p>
<ol type="1">
<li>감염 가능성 Susceptible (S): 현재는 비감염이지만 내일에는 질병에 감염될 수 있는 사람들</li>
</ol>
<!-- -->
<ol start="22" type="1">
<li><p>감염 Infected (I): 현재 질병에 감염된 사람들.</p></li>
<li><p>회복 Recovered (R): 질병을 회복하고 면역을 획득한 사람들.</p></li>
<li><p>사망 Deceased (D): 질병으로 사망한 사람들.</p></li>
</ol>
<p>약학 모델 동력학</p>
<p><span class="math inline">\(\beta\)</span> : 감염 가능성에서 감염으로 전환될 감염율, <span class="math inline">\(\gamma\)</span> : 감염에서 회복으로 전화되는 회복율 <span class="math inline">\(\mu\)</span> : 감염에서 사망으로 전환되는 사망율이라면</p>
<p><span class="math display">\[\begin{matrix}
&amp; \frac{dS}{dt} = - \beta SI,\frac{dI}{dt} = - \beta SI - \gamma I\mu I \\
&amp; \frac{dR}{dt} = - \gamma I,\frac{dD}{dt} = \mu I
\end{matrix}\]</span></p>
<p>사례연구</p>
<p>만약 t기의 SIRD 벡터가 <span class="math inline">\(x_{t} = (0.99,0.01,0,0)\)</span>라 하자. 그리고 감염 가능성 있는 인구 중 30%(<span class="math inline">\(\beta = 0.3\)</span>)는 전염되고 전염자의 2%(<span class="math inline">\(\mu = 0.02\)</span>)는 사망하고 회복율은 10%(<span class="math inline">\(\gamma = 0.1)\)</span>이라 하자. 그러므로 전염 상태로 남아 있는 전염자는 88%이다.</p>
<p><span class="math inline">\(x_{t + 1} = Ax_{t}\)</span> 모형에서 <span class="math inline">\(A = \begin{bmatrix}
0.99 &amp; 0.1 &amp; 0 &amp; 0 \\
0.01 &amp; 0.88 &amp; 0 &amp; 0 \\
0 &amp; 0.1 &amp; 1 &amp; 0 \\
0 &amp; 0.02 &amp; 0 &amp; 1
\end{bmatrix}\)</span></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image22.png" style="width:4.30301in;height:2.78221in" class="figure-img"></p>
<figcaption>붙여넣은 동영상.png</figcaption>
</figure>
</div>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<thead>
<tr class="header">
<th><img src="media/image8.tif" style="width:0.84067in;height:0.2745in" alt="pasted-image.tiff"> 전염병 동태모델 사례</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>import numpy as np</p>
<p>from scipy.integrate import odeint</p>
<p>import matplotlib.pyplot as plt</p>
<p># 초기 조건</p>
<p>S0 = 0.99 # 초기 감수성 인구 비율</p>
<p>I0 = 0.01 # 초기 감염 인구 비율</p>
<p>R0 = 0.0 # 초기 회복 인구 비율</p>
<p>D0 = 0.0 # 초기 사망 인구 비율</p>
<p>initial_conditions = [S0, I0, R0, D0]</p>
<p># 파라미터</p>
<p>beta = 0.3 # 전염율</p>
<p>gamma = 0.1 # 회복율</p>
<p>mu = 0.02 # 사망율</p>
<p># SIRD 모델 미분 방정식</p>
<p>def sird_model(y, t, beta, gamma, mu):</p>
<p>S, I, R, D = y</p>
<p>dS_dt = -beta * S * I</p>
<p>dI_dt = beta * S * I - gamma * I - mu * I</p>
<p>dR_dt = gamma * I</p>
<p>dD_dt = mu * I</p>
<p>return [dS_dt, dI_dt, dR_dt, dD_dt]</p>
<p># 시간 벡터 (일 단위)</p>
<p>t = np.linspace(0, 160, 160)</p>
<p># ODE 풀기</p>
<p>solution = odeint(sird_model, initial_conditions, t, args=(beta, gamma, mu))</p>
<p>S, I, R, D = solution.T</p>
<p># 결과 그래프 출력</p>
<p>plt.figure(figsize=(10, 6))</p>
<p>plt.plot(t, S, label='Susceptible')</p>
<p>plt.plot(t, I, label='Infected')</p>
<p>plt.plot(t, R, label='Recovered')</p>
<p>plt.plot(t, D, label='Deceased')</p>
<p>plt.xlabel('Time (days)')</p>
<p>plt.ylabel('Proportion of Population')</p>
<p>plt.legend()</p>
<p>plt.title('SIRD Model')</p>
<p>plt.grid(True)</p>
<p>plt.show()</p></td>
</tr>
</tbody>
</table>
<p>Chapter 4. 고유치와 고유벡터</p>
<p>1기초</p>
<p>개념</p>
<p>고유치는 행렬의 선형변환에서 중요한 특성을 나타내는 값이다. 특정 벡터(고유벡터)가 행렬 <span class="math inline">\(A\)</span>에 의해 변환될 때, 방향은 변하지 않고 크기만 일정 비율로 변한다면, 이 비율을 고유치라고 한다.<img src="media/image23.png" style="width:3.14768in;height:2.18206in" alt="붙여넣은 동영상.png"></p>
<p>위 그래프는 행렬 <span class="math inline">\(A = \begin{bmatrix}
3 &amp; 1 \\
0 &amp; 2
\end{bmatrix}\)</span>의 고유치(<span class="math inline">\(\lambda = 3,2\)</span>)와 고유벡터의 변환을 시각적으로 보여준다.</p>
<p>빨간색 화살표: 첫 번째 고유벡터 <span class="math inline">\(\mathbf{v}_{1}\)</span></p>
<p>투명 빨간색 화살표: 첫 번째 고유벡터가 행렬 <span class="math inline">\(A\)</span>에 의해 변환된 결과로, 고유치 <span class="math inline">\(\lambda_{1} = 3\)</span>에 의해 크기만 3배로 늘어난다.</p>
<p>파란색 화살표: 두 번째 고유벡터 <span class="math inline">\(\mathbf{v}_{2}\)</span>.</p>
<p>투명 파란색 화살표: 두 번째 고유벡터가 행렬 A 에 의해 변환된 결과로, 고유치 <span class="math inline">\(\lambda_{2} = 2\)</span>에 의해 크기만 2배로 늘어난다.</p>
<p>고유벡터의 방향은 행렬 변환 후에도 유지되며, 크기만 고유치 값에 따라 변한다. 이를 통해 고유치와 고유벡터의 개념을 시각적으로 이해할 수 있다.</p>
<p>통계학 활용</p>
<p>고유치 분석을 통해 얻을 수 있는 통계적 통찰은 다음과 같다.</p>
<p>데이터의 분산 설명: 공분산 행렬의 고유치는 각 축의 분산 크기를 나타내며, 데이터가 어떤 축에서 더 많은 정보를 가지고 있는지 보여준다.</p>
<p>중요한 변수 식별: PCA나 LDA에서 고유치를 사용해 데이터를 가장 잘 설명하는 주성분이나 판별 방향을 찾는다.</p>
<p>데이터의 차원 축소: 가장 큰 고유치를 가진 축만 선택함으로써 데이터의 복잡성을 줄이고, 분석의 효율성을 높는다.</p>
<p>시각화: MDS, PCA를 활용해 고차원 데이터를 저차원으로 투영하여 시각화할 수 있는다.</p>
<p>주성분 분석(PCA, Principal Component Analysis)</p>
<p>PCA는 데이터의 고차원 공간을 낮은 차원으로 축소하면서 데이터의 주요 정보를 보존하는 방법이다.</p>
<p>데이터의 공분산 행렬에서 고유치를 계산하여 주성분의 중요도를 평가한다.</p>
<p>가장 큰 고유치는 데이터의 분산을 가장 많이 설명하는 방향(주성분)을 나타낸다.</p>
<p>예: 변수 100개로 구성된 데이터를 분석할 때, 고유치를 계산하여 주요한 2~3개의 주성분만 선택해 데이터 차원을 축소할 수 있다.</p>
<p>선형 판별 분석(LDA, Linear Discriminant Analysis)</p>
<p>LDA는 여러 클래스 간의 분산을 극대화하면서 각 클래스 내의 분산을 최소화하는 투영 방향을 찾는 방법이다.</p>
<p>클래스 간 분산 행렬과 클래스 내 분산 행렬의 비율로 구성된 행렬의 고유치를 계산하여 최적의 분리 축을 결정한다.</p>
<p>다차원 척도법(MDS, Multidimensional Scaling)</p>
<p>MDS는 데이터 간의 거리 행렬을 기반으로 저차원 공간에 데이터를 시각화하는 방법이다.</p>
<p>거리 행렬을 고유치 분해하여 데이터를 저차원 공간에 배치한다.</p>
<p>가장 큰 고유치를 가진 방향이 데이터 구조의 주요 변화를 설명한다.</p>
<p>공분산 행렬 및 상관 행렬 분석</p>
<p>공분산 행렬이나 상관 행렬의 고유치는 데이터의 선형 독립성과 분산 구조를 분석하는 데 사용된다.</p>
<p>고유치가 큰 방향은 데이터의 분산이 큰 축(정보가 많이 분포된 축)을 나타낸다.</p>
<p>고유치가 0에 가까운 경우 변수들 간의 선형 종속성을 암시한다.</p>
<p>행렬 분해 및 차원 축소</p>
<p>고유치와 고유벡터는 행렬 분해 방법(예: 특이값 분해(SVD), 고유분해(Eigendecomposition))의 핵심이다.</p>
<p>차원 축소, 데이터 압축, 노이즈 제거 등에 사용된다.</p>
<p>예: 특이값 분해(SVD)는 추천 시스템이나 텍스트 분석(Latent Semantic Analysis, LSA)에서 널리 사용된다.</p>
<p>시계열 데이터 분석 Autoregressive 모델(AR)</p>
<p>시계열 모델에서 안정성을 분석할 때, 고유치를 통해 시스템의 특성을 평가한다. 예: 고유치가 1보다 크면 시스템이 불안정함을 나타낸다.</p>
<p>2고유치, 고유벡터 구하기</p>
<p>대칭행렬 <span class="math inline">\(A_{n \times n}\)</span>에 대하여 고유치 <span class="math inline">\(\lambda\)</span>, 고유벡터 <span class="math inline">\(\underset{¯}{v}\)</span>는 다음 방정식이 성립한다. <span class="math inline">\(A\underset{¯}{v} = \lambda\underset{¯}{v}\)</span></p>
<p>고유치 eigenvalue 구하기</p>
<p><span class="math inline">\(det(A - \lambda I) = 0\)</span>을 만족하는 <span class="math inline">\(\lambda\)</span>를 고유치라 한다.</p>
<p>고유치는 행렬 <span class="math inline">\(A\)</span>의 차수만큼 존재한다. <span class="math inline">\(\lambda_{1},\lambda_{2},...,\lambda_{n}\)</span></p>
<p>고유벡터 eigenvector 구하기</p>
<p><span class="math inline">\(A\underset{¯}{v_{i}} = \lambda_{i}\underset{¯}{v_{i}}\)</span> 을 만족하는 벡터(<span class="math inline">\(\underset{¯}{v}\)</span>)를 고유벡터라 한다.</p>
<p><span class="math inline">\(det(A - \lambda I) = 0\)</span>(singlular)가 성립하므로 고유벡터는 무수히 많이 존재한다.</p>
<p>고유벡터 중 Norm(<span class="math inline">\(\underset{¯}{v}'\underset{¯}{v} = 1\)</span>)이 1인 고유 벡터를 주성분분석에서 사용한다.</p>
<p>3고유치 활용</p>
<p>고유치 분해 eigenvalue decomposition</p>
<p>정방행렬 <span class="math inline">\(A_{n \times n}A\)</span>의 고유치(<span class="math inline">\(\lambda_{i}\)</span>)를 대각원소로 하는 대각행렬 <span class="math inline">\(\Lambda\)</span>, 고유벡터(<span class="math inline">\(\underset{¯}{v_{i}}\)</span>)로 이루어진 직교 orthogonal 행렬 <span class="math inline">\(Q\)</span>라 하면 행렬 <span class="math inline">\(A\)</span>는 다음과 같이 고유치 분해 된다. <span class="math inline">\(A = Q\Lambda Q^{- 1}\)</span></p>
<p>주성분분석</p>
<p>데이터 행렬 : <span class="math inline">\(X_{n \times p} = \begin{bmatrix}
x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1p} \\
x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2p} \\
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\
x_{n1} &amp; x_{n2} &amp; \cdots &amp; x_{np}
\end{bmatrix}\)</span> (변수 개수 <span class="math inline">\(p\)</span>)</p>
<p><span class="math inline">\(\underset{¯}{y} = P\underset{¯}{x}\)</span> : 원 변수의 선형결합(선형계수 행렬은 고유벡터)으로 주성분변수를 만든다.</p>
<ul>
<li><p><span class="math inline">\(X'X\)</span> 고유치분해 : <span class="math inline">\(X'X = (Q\Lambda Q^{- 1})'(Q\Lambda Q^{- 1}) = Q\Lambda Q^{- 1}\)</span></p>
<p><span class="math inline">\(X\)</span>의 공분산행렬(측정 단위가 다른 경우 상관계수 행렬)로부터 고유치와 고유벡터(Norm=1인 정규고유벡터)를 구하여 서로 독립인 차원으로 변환한다.</p>
<p>공분산행렬에 대한 고유치, 고유벡터 : <span class="math inline">\(COV_{p \times p}\underset{¯}{v} = \lambda\underset{¯}{v}\)</span></p>
<p>공분산 행렬은 양의 정부호 행렬이므로 변수의 차수만큼의 고유치, 그에 대응하는 고유벡터가 존재한다.</p>
<p>고유벡터는 원변수를 직교 축을 갖는 주성분 변수로 변환한다. 그러므로 차수는 줄어들지 않으나 모든 차원에서 관측값은 직교(독립)이다.</p>
<p>주요 2~3개 차원만으로 <span class="math inline">\(p\)</span>차원의 원변수 변동(정보)를 축약한다. 이를 주성분분석이라 한다.</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image24.tif" style="width:4.49986in;height:1.51158in" class="figure-img"></p>
<figcaption>pasted-image.tiff</figcaption>
</figure>
</div>
<ol type="1">
<li>특이값 분해 Singular Value Decomposition</li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image25.png" style="width:4.05779in;height:1.69211in" class="figure-img"></p>
<figcaption>pasted-image.png</figcaption>
</figure>
</div>
<p>직교행렬 <span class="math inline">\(U\)</span>(<span class="math inline">\(UU' = I\)</span>) : <span class="math inline">\(AA'\)</span>의 고유벡터</p>
<p>직교행렬 <span class="math inline">\(V'\)</span>(<span class="math inline">\(V'V = I\)</span>) : <span class="math inline">\(A'A\)</span>의 고유벡터</p>
<p>대각행렬 <span class="math inline">\(\Sigma\)</span>의 대각원소 : <span class="math inline">\(AA'\)</span>, <span class="math inline">\(A'A\)</span>의 고유치분해 대각원소의 제곱근 값을 대각원소로 한다.</p>
<p>Cholesky factorization</p>
<p>대칭행렬 <span class="math inline">\(A\)</span>가 양의 정부호 행렬일 경우 사용되는 분해방법이다.</p>
<p><span class="math inline">\(A = LL^{T}\)</span>, <span class="math inline">\(L\)</span> : 대각원소가 양이 하단 삼각행렬</p>
<p>[활용] 최소제곱추정과 같은 최적해를 구할 때 사용하면 빠른 연산이 가능하다. <span class="math inline">\(A\underset{¯}{x} = \underset{¯}{b}\)</span> (연립방정식) <span class="math inline">\(\underset{¯}{x} = A^{- 1}\underset{¯}{b}\)</span> ➠ <span class="math inline">\(LL^{T}\underset{¯}{x} = \underset{¯}{b}\)</span> 이것을 풀면 연산이 더 간편하다. <span class="math inline">\(\underset{¯}{x} = (LL^{T})^{- 1}\underset{¯}{b} = (L^{- 1})'L^{- 1}\underset{¯}{b}\)</span></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th><img src="media/image8.tif" style="width:0.84067in;height:0.2745in" alt="pasted-image.tiff"> 고유치와 고유벡터, 고유치 분해</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>#고유치, 고유벡터</p>
<p>import numpy as np</p>
<p>A=np.array([[1,2,3], [4,5,7],[8,9,10]])</p>
<p>import numpy.linalg as la</p>
<p>val,vec=la.eig(A)</p>
<p>val,vec</p></td>
</tr>
<tr class="even">
<td><p>(array([17.71571559, -1.44163052, -0.27408507]),</p>
<p>array([[-0.21078452, -0.49872133, 0.47929184],</p>
<p>[-0.52147269, -0.47685414, -0.81047488],</p>
<p>[-0.82682291, 0.7238005 , 0.33676373]]))</p></td>
</tr>
<tr class="odd">
<td><p>#고유벡터 분해</p>
<p>import numpy as np</p>
<p>A=np.array([[1,2,3],</p>
<p>[4,5,7],</p>
<p>[8,9,10]])</p>
<p>import numpy.linalg as la</p>
<p>val,vec=la.eig(A)</p>
<p>S=np.diag(val); P=vec</p>
<p>P@<a href="mailto:S@la.inv"><u>S@la.inv</u></a>(P)</p></td>
</tr>
<tr class="even">
<td><p>array([[ 1., 2., 3.],</p>
<p>[ 4., 5., 7.],</p>
<p>[ 8., 9., 10.]])</p></td>
</tr>
<tr class="odd">
<td><p>#SVD decomposition</p>
<p>u, s, vh = np.linalg.svd(A, full_matrices=True)</p>
<p>u,s,vh</p></td>
</tr>
<tr class="even">
<td><p>(array([[-0.19462586, -0.6193003 , -0.76064966],</p>
<p>[-0.5071685 , -0.6002356 , 0.61846369],</p>
<p>[-0.83958376, 0.50614657, -0.19726824]]),</p>
<p>array([18.62202941, 1.46779937, 0.25609691]),</p>
<p>array([[-0.48007495, -0.56284671, -0.67285334],</p>
<p>[ 0.70100172, 0.21497525, -0.67998694],</p>
<p>[ 0.52737523, -0.79811604, 0.29135228]]))</p></td>
</tr>
<tr class="odd">
<td><p>#Cholesky decomposition</p>
<p>import numpy as np</p>
<p>A=np.array([[25,15,-5],</p>
<p>[15,18,0],</p>
<p>[-5,0,11]])</p>
<p>import numpy.linalg as la</p>
<p>np.linalg.cholesky(A)</p></td>
</tr>
<tr class="even">
<td><p>array([[ 5., 0., 0.],</p>
<p>[ 3., 3., 0.],</p>
<p>[-1., 1., 3.]])</p></td>
</tr>
<tr class="odd">
<td><p>#확인 LL'</p>
<p>np.linalg.cholesky(A)<span class="citation" data-cites="np.linalg.cholesky">@np.linalg.cholesky</span>(A).T</p></td>
</tr>
<tr class="even">
<td><p>array([[25., 15., -5.],</p>
<p>[15., 18., 0.],</p>
<p>[-5., 0., 11.]])</p></td>
</tr>
</tbody>
</table>
<p>Chapter 5. 행렬미분</p>
<p>1미분 공식</p>
<p>벡터미분</p>
<p>상수벡터 : <span class="math inline">\({\underset{¯}{a}}_{n} = \left\lbrack \begin{array}{r}
a_{1} \\
a_{2} \\
... \\
a_{n}
\end{array} \right\rbrack\)</span> 확률변수 벡터 : <span class="math inline">\({\underset{¯}{x}}_{n} = \left\lbrack \begin{array}{r}
x_{1} \\
x_{2} \\
... \\
x_{n}
\end{array} \right\rbrack\)</span></p>
<p>확률변수 <span class="math inline">\(x_{i} \sim (iid)f(x)\)</span>는 확률표본이다.</p>
<p><span class="math inline">\(\frac{\partial(\underset{¯}{a}'\underset{¯}{x})}{\partial\underset{¯}{x}} = \underset{¯}{a}\)</span></p>
<p><span class="math inline">\(\frac{\partial(\underset{¯}{x}'\underset{¯}{a})}{\partial\underset{¯}{x}} = \underset{¯}{a}\)</span></p>
<p>이차형식 미분</p>
<p><span class="math inline">\(\frac{\partial(\underset{¯}{x}'A\underset{¯}{x})}{\partial\underset{¯}{x}} = (A + A')\underset{¯}{x}\)</span> 만약 A가 대칭행렬이면) <span class="math inline">\(2A\underset{¯}{x}\)</span></p>
<p>2이차형식</p>
<p>이차형식 정의</p>
<p>정방행렬 : <span class="math inline">\(A_{n \times n} = \begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\
a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}
\end{bmatrix}\)</span></p>
<p>이차형식 : <span class="math inline">\(Q(x_{1},x_{2},...,x_{n}) = \underset{¯}{x}'A\underset{¯}{x}\)</span></p>
<p>2차형식의 경우 대칭행렬인 <span class="math inline">\(A\)</span>는 적어도 한 개는 존재한다.</p>
<p>이차형식 종류</p>
<p>대칭행렬 <span class="math inline">\(A\)</span>, 이차형식 <span class="math inline">\(Q(x_{1},x_{2},...,x_{n}) = \underset{¯}{x}'A\underset{¯}{x}\)</span>에 대하여</p>
<p>모든 <span class="math inline">\(x \neq 0\)</span>에 대하여 <span class="math inline">\(Q &gt; 0\)</span>이면 양의 정부호 positive definite</p>
<p>모든 <span class="math inline">\(x \neq 0\)</span>에 대하여 <span class="math inline">\(Q \geq 0\)</span>이면 양의 반부호 positive semidefinite</p>
<p>주축정리 The Principal Axes Theorem</p>
<p>이차형식 <span class="math inline">\(\underset{¯}{x}'A\underset{¯}{x}\)</span>을 교차항이 없는 이차형식 <span class="math inline">\(\underset{¯}{y}'D\underset{¯}{y}\)</span>으로 변환하는 직교변환 <span class="math inline">\(\underset{¯}{x} = P\underset{¯}{y}\)</span> 존재한다. <span class="math inline">\(P\)</span>를 주축행렬이라 하고 대칭행렬 <span class="math inline">\(A\)</span>의 고유벡터로 이루어져 있다.</p>
<p>교차항이 없는 이차형식은 주축 변량에 대칭이다.</p>
<p><img src="media/image26.png" style="width:1.97617in;height:1.62679in" alt="pasted-image.png"> <img src="media/image27.tif" style="width:1.9548in;height:1.94611in" alt="pasted-image.tiff"></p>
<p>이차형식과 고유치 관계</p>
<p>이차형식 <span class="math inline">\(Q = \underset{¯}{x}'A\underset{¯}{x}\)</span>이 양의 정부호이면 모든 고유치는 0보다 크다.</p>
<p>양의 정부호 행렬의 역행렬도 양의 정부호 행렬이다.</p>
<p>공분산 행렬은 양의 정부호 행렬이다.</p>
<p>3이차형식 만들기</p>
<p><span class="math display">\[Q(x) = x_{1}^{2} + 2x_{2}^{2} - 7x_{3}^{2} - 4x_{1}x_{2} + 8x_{1}x_{3}\]</span></p>
<p>이차형식으로 만들면 다음과 같다. 제곱항은 그대로 대각원소로 하고 교차항은 1/2로 하여 각 셀에 배분한다.</p>
<p><span class="math display">\[Q(x) = \begin{bmatrix}
x_{1} &amp; x_{2} &amp; x_{3}
\end{bmatrix}\begin{bmatrix}
1 &amp; - 2 &amp; 4 \\
- 2 &amp; 2 &amp; 0 \\
4 &amp; 0 &amp; - 7
\end{bmatrix}\left\lbrack \begin{array}{r}
x_{1} \\
x_{2} \\
x_{3}
\end{array} \right\rbrack = \underset{¯}{x}'A\underset{¯}{x}\]</span></p>
<p><span class="math inline">\(\underset{¯}{x} = P\underset{¯}{y}\)</span>, 주축행렬 <span class="math inline">\(P\)</span>는 대칭행렬 <span class="math inline">\(A\)</span>의 고유벡터이다.</p>
<p><span class="math inline">\(A\)</span>의 교유치를 대각원소로 하는 행렬 <span class="math inline">\(D = diag(\lambda_{1},\lambda_{2},\lambda_{3})\)</span>를 이용하여 교차항이 없는 이차형식으로 변형한다.</p>
<p>이렇게 되면 주축 변환된 이차형식의 변수 간에는 교차항이 없으므로 두 변수간에는 서로 독립이 된다.</p>
<p><span class="math inline">\(Q(x) = \underset{¯}{x}'A\underset{¯}{x}\)</span> ⇢ <span class="math inline">\(Q(y) = \underset{¯}{y}'D\underset{¯}{y}\)</span> (<span class="math inline">\(\underset{¯}{x} = P\underset{¯}{y}\)</span>)</p>
<p>4선형 회귀모형</p>
<p>데이터 구조</p>
<p>목표변수 1개, <span class="math inline">\(p\)</span>개 예측변수, 표본크기 n인 데이터를 가정하면 선형 회귀모형은 다음과 같다. <span class="math inline">\(\underset{¯}{y} = X\underset{¯}{\beta} + \underset{¯}{e}\)</span></p>
<p><span class="math inline">\(\left\lbrack \begin{array}{r}
y_{1} \\
y_{2} \\
\cdots \\
y_{n}
\end{array} \right\rbrack\)</span>=<span class="math inline">\(\begin{bmatrix}
1 &amp; x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1p} \\
1 &amp; x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2p} \\
\cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \\
1 &amp; x_{n1} &amp; x_{n2} &amp; \cdots &amp; x_{np}
\end{bmatrix}\left\lbrack \begin{array}{r}
a \\
b_{1} \\
\cdots \\
b_{p}
\end{array} \right\rbrack\)</span>+<span class="math inline">\(\left\lbrack \begin{array}{r}
e_{1} \\
e_{2} \\
\cdots \\
e_{n}
\end{array} \right\rbrack\)</span></p>
<p>예측변수 데이터 행렬/벡터</p>
<p><span class="math inline">\(X_{n \times p} = \begin{bmatrix}
x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1p} \\
x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2p} \\
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\
x_{n1} &amp; x_{n2} &amp; \cdots &amp; x_{np}
\end{bmatrix}\)</span>, <span class="math inline">\(X_{n \times p} = \begin{bmatrix}
{\underset{¯}{x}}_{1} &amp; {\underset{¯}{x}}_{2} &amp; \cdots &amp; {\underset{¯}{x}}_{p} &amp;
\end{bmatrix}\)</span></p>
<p>(데이터 벡터) <span class="math inline">\({\underset{¯}{x}}_{k} = \left\lbrack \begin{array}{r}
x_{1k} \\
x_{2k} \\
\cdots \\
x_{nk}
\end{array} \right\rbrack\)</span></p>
<p>확률변수 벡터, 평균벡터, 공분산행렬</p>
<p><span class="math inline">\(\underset{¯}{x} = \left\lbrack \begin{array}{r}
x_{1} \\
x_{2} \\
\cdots \\
x_{p}
\end{array} \right\rbrack\)</span>, <span class="math inline">\(x_{i}\)</span>는 확률변수이고 <span class="math inline">\(E(x_{i}) = \mu_{i},V(x_{i}) = \sigma_{ii}\)</span>,</p>
<p>(두 변수의 공분산) <span class="math inline">\(COV(x_{i},x_{j}) = \sigma_{ij}\)</span></p>
<p>(평균벡터) <span class="math inline">\(E(\underset{¯}{x}) = \underset{¯}{\mu} = \left\lbrack \begin{array}{r}
\mu_{1} \\
\mu_{2} \\
\cdots \\
\mu_{p}
\end{array} \right\rbrack\)</span></p>
<p>(공분산행렬) <span class="math inline">\(COV(\underset{¯}{x}) = \Sigma = \begin{bmatrix}
\sigma_{11} &amp; \sigma_{12} &amp; \cdots &amp; \sigma_{1p} \\
\sigma_{21} &amp; \sigma_{22} &amp; \cdots &amp; \sigma_{2p} \\
\cdots &amp; \cdots &amp; \cdots &amp; \cdots \\
\sigma_{p1} &amp; \sigma_{p2} &amp; \cdots &amp; \sigma_{pp}
\end{bmatrix}\)</span></p>
<p>상수벡터 : <span class="math inline">\(\underset{¯}{a} = \left\lbrack \begin{array}{r}
a_{1},a_{2},\cdots a_{p}
\end{array} \right\rbrack\)</span></p>
<p><span class="math inline">\(\underset{¯}{a}'\underset{¯}{x}\)</span>의 평균 : <span class="math inline">\(E(\underset{¯}{a}'\underset{¯}{x}) = \underset{¯}{a}'\underset{¯}{\mu}\)</span>, 분산 <span class="math inline">\(V(\underset{¯}{a}'\underset{¯}{x}) = \underset{¯}{a}'\underset{¯}{\Sigma}\underset{¯}{a}\)</span></p>
<p>선형 회귀모형</p>
<p><span class="math inline">\(\underset{¯}{y} = X\underset{¯}{b} + \underset{¯}{e}\)</span>, <span class="math inline">\(\underset{¯}{e} \sim N(\underset{¯}{0},\sigma^{2}I)\)</span></p>
<p>최소제곱법 추정</p>
<p><span class="math display">\[min_{a,b_{1},b_{2},...,b_{p}}\sum e_{i}^{2} = min_{\underset{¯}{b}}\underset{¯}{e}'\underset{¯}{e}\]</span></p>
<p><span class="math display">\[Q(\underset{¯}{b}) = \underset{¯}{e}'\underset{¯}{e} = (\underset{¯}{y} - X\underset{¯}{b})'(\underset{¯}{y} - X\underset{¯}{b}) = \underset{¯}{y}'\underset{¯}{y} + \underset{¯}{b}'X'X\underset{¯}{b} - 2\underset{¯}{y}'X\underset{¯}{b}\]</span></p>
<p><span class="math inline">\(\frac{\partial Q}{\partial\underset{¯}{b}} = 2X'X\underset{¯}{b} - 2X'\underset{¯}{y} = 0\)</span> ⇢ <span class="math inline">\(\widehat{\underset{¯}{b}} = (X'X)^{- 1}X'\underset{¯}{y}\)</span></p>
<p>적합치 fitted values 와 잔차 residuals</p>
<p>적합치 : <span class="math inline">\(\widehat{\underset{¯}{y}} = X\widehat{\underset{¯}{b}} = X(X'X)^{- 1}X'\underset{¯}{y} = H\underset{¯}{y}\)</span>,</p>
<p><span class="math inline">\(H = X(X'X)^{- 1}X'\)</span> hat 행렬이라 하고 대칭행렬이고 멱등행렬이다. <span class="math inline">\(HH = H,H' = H\)</span></p>
<p>잔차 : <span class="math inline">\(\widehat{\underset{¯}{e}} = \underset{¯}{y} - \widehat{\underset{¯}{y}} = (I - H)\underset{¯}{y}\)</span> <span class="math inline">\(H\)</span>가 멱등행렬이면 <span class="math inline">\((I - H)\)</span>도 멱등행렬이다.</p>
<p>잔차의 분포 <span class="math inline">\(\widehat{\underset{¯}{e}} \sim N(\underset{¯}{0},\sigma^{2}I)\)</span></p>
<p>오차의 가정 : <span class="math inline">\(\underset{¯}{e} \sim N(\underset{¯}{0},\sigma^{2}I)\)</span> ⇢ <span class="math inline">\(\underset{¯}{y} \sim N(X\underset{¯}{b},\sigma^{2}I)\)</span></p>
<p>그러므로 <span class="math inline">\(E(\widehat{\underset{¯}{e}}) = (I - H)E(\underset{¯}{y}) = (I - H)(X\underset{¯}{b}) = (X\underset{¯}{b} - HX\underset{¯}{b}) = \underset{¯}{0}V(\widehat{\underset{¯}{e}}) = V((I - H)\underset{¯}{y}) = (I - H)\sigma^{2}I(I - H)' = \sigma^{2}I\)</span></p>
<p>목표변수 분해</p>
<p><span class="math inline">\(\underset{¯}{y} = H\underset{¯}{y} + (I - H)\underset{¯}{y}\)</span>=(설명하는 변동) + (설명하지 못하는 변동)</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/image28.png" style="width:3.51998in;height:1.38181in" class="figure-img"></p>
<figcaption>pasted-image.png</figcaption>
</figure>
</div>
<p>높이를 최소화 하는 <span class="math inline">\(\underset{¯}{b}\)</span>를 구하는 것이 최소제곱추정법이다.</p>
<p>추정치 분포</p>
<p><span class="math inline">\(\widehat{\underset{¯}{b}} = (X'X)^{- 1}X'\underset{¯}{y}\)</span>이고 <span class="math inline">\(\underset{¯}{y} \sim N(X\underset{¯}{b},\sigma^{2}I)\)</span>이므로</p>
<p><span class="math display">\[E(\widehat{\underset{¯}{b}}) = (X'X)^{- 1}X'E(\underset{¯}{y}) = (X'X)^{- 1}X'X\underset{¯}{b} = \underset{¯}{b}\]</span></p>
<p><span class="math display">\[V(\widehat{\underset{¯}{b}}) = \sigma^{2}(X'X)^{- 1}\]</span></p>
<p><span class="math inline">\(\widehat{\underset{¯}{b}} \sim N(\underset{¯}{b},\sigma^{2}(X'X)^{- 1})\)</span>, <span class="math inline">\({\widehat{\sigma}}^{2} = SSE\)</span></p>
<p>변동 분해 ANOVA</p>
<p>총변동 Total Sum of Squares : <span class="math inline">\(SST = \sum(y_{i} - \overline{y})^{2}\)</span></p>
<p><span class="math inline">\(SST = \sum y_{i}^{2} - \frac{(\sum y_{i})^{2}}{n} = \underset{¯}{y}'\underset{¯}{y} - (\frac{1}{n})\underset{¯}{y}'J_{n \times n}\underset{¯}{y}\)</span>, <span class="math inline">\(J\)</span>는 1행렬</p>
<p><span class="math display">\[SST = \underset{¯}{y}'(I - (\frac{1}{n})J)\underset{¯}{y}\]</span></p>
<p>오차변동 Error Sum of Squares</p>
<p><span class="math display">\[SSE = \sum(y_{i} - \widehat{y_{i}})^{2}\]</span></p>
<p><span class="math display">\[SSE = (\underset{¯}{y} - X\underset{¯}{b})'(\underset{¯}{y} - X\underset{¯}{b}) = \underset{¯}{y}'\underset{¯}{y} - \underset{¯}{b}'X'\underset{¯}{y} = \underset{¯}{y}'(I - H)\underset{¯}{y}\]</span></p>
<p>회귀변동 Regression Sum of Squares</p>
<p><span class="math inline">\(SSR = \sum(\widehat{y_{i}} - \overline{y})^{2}\)</span>, <span class="math inline">\(SSR = \underset{¯}{y}'(H - (\frac{1}{n})J)\underset{¯}{y}\)</span></p>
<p><span class="math display">\[SSR = SST - SSE = \underset{¯}{b}X'\underset{¯}{y} - (\frac{1}{n})\underset{¯}{y}'J\underset{¯}{y}\]</span></p>
<p>결정계수</p>
<p><span class="math inline">\(R^{2} = \frac{SSR}{SST} = 1 - \frac{SSE}{SST}\)</span> : 모형의 총변동 설명 비중</p>
<p>SSE, SSR 분포 및 <span class="math inline">\(\sigma^{2}\)</span> 추정량</p>
<p><span class="math inline">\(\underset{¯}{x} \sim N(\underset{¯}{\mu},\Sigma)\)</span> 이면 이차형식 <span class="math inline">\(\underset{¯}{x}'A\underset{¯}{x}\)</span>의 평균은<br>
<span class="math inline">\(E(\underset{¯}{x}'A\underset{¯}{x}) = tr(A\Sigma) + \mu'A\mu\)</span>이다.</p>
<p><span class="math inline">\(\underset{¯}{x} \sim N(\underset{¯}{\mu},\sigma^{2}I)\)</span> 이면 이차형식 <span class="math inline">\(\underset{¯}{x}'A\underset{¯}{x}\)</span>(<span class="math inline">\(A\)</span> 대칭행렬이고 멱등행렬이면)에 대하여 <span class="math inline">\(\frac{\underset{¯}{x}'A\underset{¯}{x}}{\sigma^{2}} \sim \chi^{2}(df = rank(A))\)</span>이다.</p>
<p><span class="math inline">\(SSE = \underset{¯}{y}'(I - H)\underset{¯}{y}\)</span>, 이차형식이고 <span class="math inline">\((I - H)\)</span>는 멱등행렬<br>
<span class="math inline">\(rank(I - H) = n - p - 1\)</span>이므로 <span class="math inline">\(\frac{SSE}{\sigma^{2}} \sim \chi^{2}(n - p - 1)\)</span>이다.</p>
<p>오차 분산의 추정량 : <span class="math inline">\(\widehat{\sigma^{2}} = MSE\)</span>.</p>
<p><span class="math inline">\(\frac{SSR}{\sigma^{2}} \sim \chi^{2}(p)\)</span>, <span class="math inline">\(F = \frac{SSR/p}{SSE/(n - p - 1)} \sim F(p,n - p - 1)\)</span></p>
<p>분산분석 표</p>
<table class="caption-top table">
<colgroup>
<col style="width: 8%">
<col style="width: 10%">
<col style="width: 14%">
<col style="width: 31%">
<col style="width: 31%">
</colgroup>
<thead>
<tr class="header">
<th>변동</th>
<th>제곱변동</th>
<th>자유도</th>
<th>평균제곱</th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>회귀</td>
<td><span class="math display">\[SSR\]</span></td>
<td><span class="math display">\[p\]</span></td>
<td><span class="math display">\[MSR = \frac{SSR}{p}\]</span></td>
<td rowspan="2"><span class="math display">\[\frac{MSR}{MSE}\]</span></td>
</tr>
<tr class="even">
<td>오차</td>
<td><span class="math display">\[SSE\]</span></td>
<td><span class="math display">\[n - p - 1\]</span></td>
<td><span class="math display">\[MSE = \frac{SSE}{n - p - 1}\]</span></td>
</tr>
<tr class="odd">
<td>총변동</td>
<td><span class="math display">\[SST\]</span></td>
<td><span class="math display">\[n - 1\]</span></td>
<td colspan="2"><span class="math display">\[{E(MSE) = \sigma^{2}
}{E(MSR) = \sigma^{2} + b_{1}^{2}\sum(x_{i} - \overline{x})^{2}}\]</span></td>
</tr>
</tbody>
</table>
<p>저자 정보</p>
<p>1982. 성균관대학교 통계학 학사</p>
<p>1985. 성균관대학교 통계학 석사</p>
<p>1992. 미국 North Carolina State University 통계학 박사</p>
<p>1993-1995. 전자통신연구원 선임연구원</p>
<p>1995-2026. 한남대학교 통계학과 교수</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>