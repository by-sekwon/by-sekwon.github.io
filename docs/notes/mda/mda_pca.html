<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>다변량분석 2. 주성분분석 – 세상 모든 통계 이야기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-d24c3880db9ce3ca4ea2d5bb002bea1f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">세상 모든 통계 이야기</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">기초수학</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-">    
        <li>
    <a class="dropdown-item" href="../../notes/math/function.html">
 <span class="dropdown-text">함수</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math/derivate_integral.html">
 <span class="dropdown-text">미분적분</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math/vector.html">
 <span class="dropdown-text">벡터</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math/matrix.html">
 <span class="dropdown-text">행렬</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--1" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">수리통계</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--1">    
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/probability.html">
 <span class="dropdown-text">확률</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/random_variable.html">
 <span class="dropdown-text">확률변수</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/famous_distribution.html">
 <span class="dropdown-text">유명한분포</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/multi_variate.html">
 <span class="dropdown-text">다변량확률변수</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/random_sample.html">
 <span class="dropdown-text">확률표본_난수생성</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/estimation.html">
 <span class="dropdown-text">추정</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/hypothesis_testing.html">
 <span class="dropdown-text">가설검정_신뢰구간</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--2" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">일변량분석</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--2">    
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/concept_of_stat.html">
 <span class="dropdown-text">일변량분석 개념</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/data.html">
 <span class="dropdown-text">데이터와 통계</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/univariate.html">
 <span class="dropdown-text">일변량분석</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/crosstab.html">
 <span class="dropdown-text">교차표분석</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/goodness_of_fits.html">
 <span class="dropdown-text">적합성검정</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/normality.html">
 <span class="dropdown-text">정규변환</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/correlation.html">
 <span class="dropdown-text">상관분석</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/anova.html">
 <span class="dropdown-text">실험설계 분산분석</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/time_series.html">
 <span class="dropdown-text">시계열분석</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--3" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">회귀분석</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--3">    
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_concept.html">
 <span class="dropdown-text">회귀분석 개념&amp;추정</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_selection.html">
 <span class="dropdown-text">변수선택</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_multicolin.html">
 <span class="dropdown-text">다중공선성</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_diagnosis.html">
 <span class="dropdown-text">회귀진단</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_logistic.html">
 <span class="dropdown-text">로지스틱회귀</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--4" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">다변량분석</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--4">    
        <li>
    <a class="dropdown-item" href="../../notes/mda/mda_concepts.html">
 <span class="dropdown-text">다변량분석 개념</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--5" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">조사방법론</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--5">    
        <li>
    <a class="dropdown-item" href="../../notes/survey/survey_intro.html">
 <span class="dropdown-text">조사방법 기초</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/sample_design.html">
 <span class="dropdown-text">표본설계</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/questionnaire.html">
 <span class="dropdown-text">설문지</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/nonresponse.html">
 <span class="dropdown-text">무응답 대체</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/data_process.html">
 <span class="dropdown-text">데이터 처리</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/survey_scale.html">
 <span class="dropdown-text">조사지 척도</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/delphi_ahp_conjoint.html">
 <span class="dropdown-text">델파이_AHP_컨조인트</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/psm.html">
 <span class="dropdown-text">PSM 성향점수매칭</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../cardnews/index.html"> 
<span class="menu-text">카드뉴스</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../consult.html"> 
<span class="menu-text">통계상담</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--6" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">📡스트리밍</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--6">    
        <li>
    <a class="dropdown-item" href="https://by-sekwonappio-esqshnv7wueapp4da6jrizn.streamlit.app" target="_blank">
 <span class="dropdown-text">실시간주가[5대종목]</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://by-sekwonappio-k5e5n7wasvj3kveyqbwmgc.streamlit.app/" target="_blank">
 <span class="dropdown-text">대전유성구 일기예보</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#chapter-1.-차원축소-개념" id="toc-chapter-1.-차원축소-개념" class="nav-link active" data-scroll-target="#chapter-1.-차원축소-개념">Chapter 1. 차원축소 개념</a>
  <ul>
  <li><a href="#특성-추출이란" id="toc-특성-추출이란" class="nav-link" data-scroll-target="#특성-추출이란">1. 특성 추출이란</a></li>
  <li><a href="#차원축소와-주성분분석" id="toc-차원축소와-주성분분석" class="nav-link" data-scroll-target="#차원축소와-주성분분석">2. 차원축소와 주성분분석</a></li>
  <li><a href="#차원축소-방법론" id="toc-차원축소-방법론" class="nav-link" data-scroll-target="#차원축소-방법론">3. 차원축소 방법론</a></li>
  </ul></li>
  <li><a href="#chapter-2.-주성분분석" id="toc-chapter-2.-주성분분석" class="nav-link" data-scroll-target="#chapter-2.-주성분분석">Chapter 2. 주성분분석</a>
  <ul>
  <li><a href="#주성분분석-개념" id="toc-주성분분석-개념" class="nav-link" data-scroll-target="#주성분분석-개념">1. 주성분분석 개념</a></li>
  <li><a href="#주성분-구하기" id="toc-주성분-구하기" class="nav-link" data-scroll-target="#주성분-구하기">2. 주성분 구하기</a></li>
  <li><a href="#주성분-사례분석" id="toc-주성분-사례분석" class="nav-link" data-scroll-target="#주성분-사례분석">3. 주성분 사례분석</a></li>
  </ul></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">다변량분석 2. 주성분분석</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="chapter-1.-차원축소-개념" class="level3">
<h3 class="anchored" data-anchor-id="chapter-1.-차원축소-개념">Chapter 1. 차원축소 개념</h3>
<section id="특성-추출이란" class="level4">
<h4 class="anchored" data-anchor-id="특성-추출이란">1. 특성 추출이란</h4>
<p>대용량 데이터 <span class="math inline">\(X_{n \times p}\)</span>에서 행 n은 개체, 열 p는 변수를 나타낸다. 개체의 특성을 시각화하거나 분석하기 위해서는 변수가 매우 많을 경우 차원을 축소할 필요가 있다. 이를 feature extraction(특성 추출)이라고 한다. 특성 추출은 원 데이터의 구조적 관계를 활용하여 새로운 변수를 생성하거나, 고차원의 공간을 저차원의 새로운 공간으로 사상하는 방식으로 이루어진다.</p>
<p>예를 들어 변수 간 상관계수를 유사성 척도로 활용하여 변수 구조를 탐색하기도 한다. 대표적인 방법으로는 주성분분석(PCA), 특이값 분해(SVD)에 기반한 차원축소 기법이 있으며, 두 변수 집합 간의 상관성을 극대화하는 정준상관분석(CCA)도 새로운 특성을 생성한다는 점에서 넓은 의미의 특성 추출 과정으로 이해할 수 있다. 이러한 방법들은 협의의 차원 축소에 속한다.</p>
<p>특성 선택은 변수에 중요도나 우선순위를 부여하여 목표 변수에 영향을 주는 주요 변수의 부분집합을 선택하거나, 불필요한 변수를 제거하여 변수의 차원(개수)을 줄이는 과정이다. 예를 들어, 의사결정나무 모형에서는 트리 상단에 위치하는 변수가 중요도가 높으며, 이를 바탕으로 변수별 중요도를 평가할 수 있다. 회귀모형에서는 단계적 선택법과 같은 유의 변수 선택 알고리즘을 활용하여 변수 선택이 가능하다.</p>
<p>특성 선택 기법에는 상관분석과 같은 통계적 방법, 라쏘 회귀·재귀적 특성 제거법·트리 기반 모형, 그리고 판별분석이나 로지스틱 회귀기반 방법 등이 있다.</p>
</section>
<section id="차원축소와-주성분분석" class="level4">
<h4 class="anchored" data-anchor-id="차원축소와-주성분분석">2. 차원축소와 주성분분석</h4>
<p>차원축소는 말 그대로 데이터를 요약하는 과정이다. 변수가 지나치게 많을 때, 모든 변수를 그대로 두고 분석하는 것은 계산량도 커지고 해석도 어렵다. 그래서 정보 손실을 최소화하면서도 적은 수의 새로운 변수로 데이터를 표현하는 방법이 필요하다. 이를 통해 데이터는 단순해지면서도 본질적인 구조와 패턴은 유지할 수 있다. 차원축소의 목적은 크게 두 가지로 볼 수 있는데, 하나는 데이터 시각화를 가능하게 하는 것이고, 다른 하나는 분석 효율성을 높이는 것이다. 시각화는 고차원 데이터를 2차원이나 3차원으로 줄여 그림으로 표현할 수 있게 해 주며, 효율성 측면에서는 계산 속도 향상, 불필요한 잡음 제거, 다중공선성 문제 완화, 저장·전송의 압축 효과 등을 제공한다.</p>
<p>주성분분석(PCA)은 이러한 차원축소 방법 가운데 가장 널리 쓰이는 전형적인 기법이다. PCA는 데이터가 분산을 가장 크게 보이는 방향을 찾아 새로운 좌표축을 세우고, 그 축을 따라 데이터를 재배치한다. 첫 번째 주성분은 데이터가 가장 넓게 퍼진 방향이고, 두 번째 주성분은 첫 번째와 직교하면서 그다음으로 넓게 퍼진 방향이다. 이렇게 이어지는 주성분들은 서로 독립적이면서도 데이터의 구조를 가장 잘 설명하는 순서대로 배열된다. 따라서 처음 몇 개의 주성분만으로도 원래 데이터의 대부분의 변동성을 설명할 수 있다.</p>
<p>주성분분석을 통해 얻어지는 결과는 크게 두 가지이다. 하나는 각 개체가 새로운 좌표축에서 어디에 위치하는지를 보여 주는 점수이고, 다른 하나는 새로운 좌표축이 원래 변수들의 어떤 조합으로 만들어졌는지를 알려 주는 적재치이다. 점수는 개체들 사이의 유사성과 차이를 시각적으로 드러내는 데 유용하며, 적재치는 어떤 변수가 서로 묶여 함께 움직이는지를 해석할 수 있게 해 준다.</p>
<p>결국 차원축소는 데이터의 복잡성을 줄이는 큰 틀의 개념이고, 주성분분석은 그 안에서 가장 대표적이고 직관적인 방법이라고 할 수 있다. 주성분분석은 데이터를 요약하면서도 시각화를 쉽게 하고, 노이즈를 줄이며, 다중공선성과 같은 문제를 완화하는 데 효과적이다. 따라서 차원축소와 주성분분석은 포괄적 개념과 구체적 방법의 관계로 이해할 수 있다.</p>
</section>
<section id="차원축소-방법론" class="level4">
<h4 class="anchored" data-anchor-id="차원축소-방법론">3. 차원축소 방법론</h4>
<p>주성분분석은 차원축소 기법들 가운데 가장 기본적이고 널리 쓰이는 방법이지만, 다른 기법들과의 관계를 이해하면 언제 어떤 방법을 선택해야 하는지 분명해진다.</p>
<p>먼저 특이값분해(SVD)는 구현 관점에서 PCA와 사실상 같은 몸이라고 볼 수 있다. 데이터를 평균 중심화한 뒤 SVD를 적용하면 곧바로 PCA의 주성분을 얻을 수 있다. 실제로 대용량 데이터에서는 SVD 기반의 계산 방식이 주로 사용되며, 속도와 메모리 문제를 해결하기 위해 랜덤화된 SVD나 점진적 SVD와 같은 변형 기법들이 활용된다.</p>
<p>요인분석(FA)은 겉보기에는 PCA와 비슷해 보이지만, 목적은 다르다. 요인분석은 공통된 잠재 요인으로 변수들의 공분산 구조를 설명하려는 모형 기반 접근이다. 반면 PCA는 단순히 분산을 최대화하는 새로운 축을 찾는 기하학적 요약 방식이다. 그래서 요인분석은 해석 가능성을 중시할 때, PCA는 데이터 요약과 압축이 필요할 때 주로 쓰인다.</p>
<p>독립성분분석(ICA)와 비음수행렬분해(NMF)는 데이터 구조를 바라보는 또 다른 시각을 제공한다. ICA는 변수들 간의 독립성을 극대화하려 하고, NMF는 변수들을 음수가 아닌 조합으로만 표현한다는 제약을 둔다. 두 방법 모두 PCA와 달리 분산 대신 다른 기준을 사용해 차원을 축소하며, 데이터의 성질과 해석 목적에 따라 선택된다.</p>
<p>부분최소제곱회귀(PLS)나 선형판별분석(LDA)은 PCA와 달리 감독학습 기반의 차원축소 기법이다. 이들은 목표변수(y)의 정보를 활용하여 새로운 축을 찾기 때문에, 예측 성능을 높이고자 할 때 주로 적용된다. PCA가 목표변수를 고려하지 않는 비감독적 방법이라는 점과 대비된다.</p>
<p>마지막으로 커널 PCA는 비선형 구조를 포착하기 위한 확장판이다. PCA가 선형 변환만으로는 잡아내기 힘든 곡선적·비선형적 패턴을, 고차원 공간에서의 변환을 통해 드러내는 방식이다. 따라서 복잡한 데이터 구조를 다루는 데 유리하다.</p>
<p>정리하면, PCA는 차원축소의 출발점이자 기본형이고, 다른 기법들은 목적과 데이터의 특성에 따라 PCA의 한계를 보완하거나 대체하는 방식으로 발전해왔다고 볼 수 있다.</p>
</section>
</section>
<section id="chapter-2.-주성분분석" class="level3">
<h3 class="anchored" data-anchor-id="chapter-2.-주성분분석">Chapter 2. 주성분분석</h3>
<section id="주성분분석-개념" class="level4">
<h4 class="anchored" data-anchor-id="주성분분석-개념">1. 주성분분석 개념</h4>
<section id="공간적-개념" class="level5">
<h5 class="anchored" data-anchor-id="공간적-개념">(1) 공간적 개념</h5>
<p>이차원 공간 정보(아래 그림)를 1차원(직선)으로 표시한다면 어디에서 봐야 희생되는 정보(나무의 위치와 거리)가 최소일까? 만약 (1)에서 본다면 1번 나무에 가려 2번 나무는 직선 상에 나타나지 않아 나무가 2개 인 것처럼 보인다. (2)의 관점에서 본다면 역시 3번 나무로 인하여 2번 나무가 가려져 직선 상에 나타나지 않는다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/pca 개념.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
<p>나무의 공간 정보를 최소화하는 관점은 (3)에서 보는 것이다. 그러나 이 역시 희생되는 정보가 있다. 2차원 공간에 있을 때 각 나무의 거리는 직선 상에서는 실제 거리 <span class="math inline">\(\sqrt{2}\)</span>보다 가까워졌다. 이는 2차원 공간 정보를 1차원 직선으로 표현하여 잃은 정보가 존재한다는 것이다.</p>
<p>주성분분석은 이처럼 희생되는 정보를 최소화 하면서 데이터의 차원을 축약하는 방법이다. 다음은 주성분 분석을 활용하여 다차원 데이터를 2차원 공간에 축소하여 개체를 시각화 하고 개체를 군집화 하는 과정을 보여 준 것이다. 이처럼 주성분 분석은 최종 분석이 아니라 중간 단계 분석에 해당된다.</p>
<p>주성분분석(PCA)은 고차원 데이터 속에서 분산이 가장 큰 방향을 찾아 새로운 축을 설정하는 방법이다. 고차원 공간에 존재하는 데이터 점들은 서로 뒤섞여 있어 구조를 파악하기 어렵다. 그러나 주성분분석을 통해 데이터를 새로운 좌표축, 즉 주성분 축으로 투영하면 원래 보이지 않던 패턴이나 군집이 드러나게 된다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/pca 개념02.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
<p>그림의 중앙에 있는 점은 원래의 고차원 공간을 나타낸 것이다. 이 공간에서는 점들이 무질서하게 흩어져 있어 클러스터를 구분하기가 쉽지 않다. 하지만 주성분축(Subspace)으로 투영하면 상황이 달라진다. Subspace 1로 데이터를 비추면 Cluster 3이, Subspace 2로 투영하면 Cluster 2가, Subspace 3에서는 Cluster 1이 명확하게 드러난다. 이는 주성분분석이 데이터의 분산이 큰 방향을 찾아내어 차원을 축소하면서 동시에 데이터의 내재된 구조를 보존한다는 것을 보여준다.</p>
<p>결국 주성분분석은 차원축소를 통해 데이터의 복잡성을 줄이면서도, 군집이나 패턴과 같은 중요한 구조적 특징을 드러내는 대표적인 방법이다.</p>
</section>
<section id="활용사례" class="level5">
<h5 class="anchored" data-anchor-id="활용사례">(2) 활용사례</h5>
<p>주성분분석은 많은 변수로 이루어진 데이터를 소수의 핵심 지표로 요약하는 방법이다. 온라인에서 옷을 구입하는 사례가 좋은 비유가 된다. 상의는 단순히 55사이즈, M사이즈와 같이 하나의 값으로 표현되며, 하의 역시 허리둘레 34인치와 같이 하나의 수치로 표시된다. 그러나 맞춤옷을 구입하려면 어깨 넓이, 어깨에서 손목까지의 길이, 허벅지 두께, 허리에서 무릎까지의 길이, 무릎에서 발꿈치까지의 길이 등 다양한 신체 치수를 측정해야 한다. 이 많은 정보가 결국 하나의 단위로 축약된 것이 바로 55사이즈나 34인치라는 값이다. 이러한 값은 다른 여러 치수 정보를 반영하는 일종의 골든 지표, 즉 주성분이라고 볼 수 있다. 따라서 많은 정보를 하나로 요약하는 과정에서 세부적인 차이가 사라지므로, 온라인에서 구매한 옷이 모든 사람의 체형에 꼭 맞지 않는 것이다. 이 때문에 Big &amp; Tall 매장이나 디자이너 매장이 따로 존재한다.</p>
<p>이미지 데이터 역시 주성분분석의 활용을 이해하기 좋은 예다. 이미지 데이터는 기본적으로 가로, 세로, 색상 채널을 포함하는 3차원 공간 데이터이다. 그러나 통계 분석이나 기계학습에 활용하려면 이를 2차원 행렬 데이터로 축약해야 한다. 축약 과정을 사람이 직접 설계한다면 학습지도 기법, 즉 전통적 머신러닝에 해당한다. 반대로 컴퓨터가 스스로 중요한 특징을 찾아내는 경우는 비학습지도 기법, 즉 딥러닝에 해당한다. 이러한 학습 과정에서 널리 쓰이는 알고리즘으로는 서포트 벡터 머신(SVM), 아다부스트(AdaBoost) 등이 있다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/pca mldl.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
<p>이미지나 음성, 텍스트와 같은 데이터는 본질적으로 고차원 공간에 존재한다. 예를 들어 자동차 사진은 수많은 픽셀 값으로 이루어져 있어 차원이 수천에서 수백만에 이른다. 이렇게 높은 차원의 데이터를 바로 다루기는 어렵기 때문에, 먼저 핵심 정보를 유지하면서 데이터의 차원을 축약하는 과정이 필요하다.</p>
<p>머신러닝은 차원축약과 특징 추출을 사람이 직접 설계하고 정의하는 방식이다. 분석자가 중요한 특징을 선택하거나 PCA와 같은 방법을 통해 차원을 줄인 후, 그 결과를 학습 알고리즘(SVM, AdaBoost 등)에 입력한다. 이때 분류기는 입력된 특징을 바탕으로 자동차인지 아닌지를 판별한다. 따라서 머신러닝은 사람이 특징을 만들어주고, 알고리즘은 그것을 이용해 학습하는 방식이다.</p>
<p>딥러닝은 이와 달리 사람이 직접 특징을 설계하지 않는다. 인공신경망이 여러 층을 거치면서 데이터를 단계적으로 변환하여 스스로 중요한 특징을 추출하고 차원을 축약한다. 즉, 원본 이미지가 그대로 신경망에 입력되면, 네트워크 내부에서 차원축약과 특징 추출이 동시에 이루어지고, 마지막 단계에서 자동차인지 아닌지의 판별이 자동으로 수행된다. 이는 기계가 스스로 특징을 학습하는 방식이다.</p>
<p>따라서 머신러닝과 딥러닝의 차이는 차원축약과 특징 추출이 사람의 설계에 의해 이루어지느냐, 기계가 스스로 학습하느냐에 있다. 그림은 이를 시각적으로 보여주며, <span dir="rtl">”</span>Car vs Not Car”라는 단순한 예시를 통해 두 접근법의 차이를 직관적으로 설명한다.</p>
</section>
</section>
<section id="주성분-구하기" class="level4">
<h4 class="anchored" data-anchor-id="주성분-구하기">2. 주성분 구하기</h4>
<section id="데이터-행렬-변수벡터" class="level5">
<h5 class="anchored" data-anchor-id="데이터-행렬-변수벡터">(1) 데이터 행렬, 변수벡터</h5>
<p>데이터 행렬 (개체 행 n, 변수 열 p) : <span class="math inline">\(X_{n \times p} = \begin{pmatrix}
x_{11} &amp; x_{12} &amp; ... &amp; x_{1p} \\
x_{21} &amp; x_{22} &amp; ... &amp; x_{2p} \\
&amp; ... &amp; &amp; \\
x_{n1} &amp; x_{n2} &amp; ... &amp; x_{np}
\end{pmatrix}\)</span></p>
<p>변수벡터 : <span class="math inline">\({\underset{¯}{x}}_{1 \times p} = \left( \begin{array}{r}
x_{1} \\
x_{2} \\
... \\
x_{p}
\end{array} \right)\)</span>, <span class="math inline">\(x_{i}\)</span>는 i -번째 확률변수이며 <span class="math inline">\(\underset{¯}{x} \sim (\underset{¯}{\mu},\Sigma)\)</span> 다변량 분포이다.</p>
<p>평균벡터: <span class="math inline">\({\underset{¯}{\mu}}_{1 \times p} = \left( \begin{array}{r}
\mu_{1} \\
\mu_{2} \\
... \\
\mu_{p}
\end{array} \right)\)</span>, <span class="math inline">\(E(x_{i}) = \mu_{i}\)</span></p>
<p>공분산 행렬 <span class="math inline">\(\Sigma_{p \times p} = \begin{pmatrix}
\sigma_{11} &amp; \sigma_{12} &amp; ... &amp; \sigma_{1p} \\
\sigma_{21} &amp; \sigma_{22} &amp; ... &amp; \sigma_{2p} \\
&amp; ... &amp; &amp; \\
\sigma_{p1} &amp; \sigma_{p2} &amp; ... &amp; \sigma_{pp}
\end{pmatrix}\)</span></p>
</section>
<section id="주성분-전처리" class="level5">
<h5 class="anchored" data-anchor-id="주성분-전처리">(2) 주성분 전처리</h5>
<p>데이터에서 개체를 설명하는 변수의 구조는 변수들의 변동성과 공변동에 의해 요약된다. 이 구조를 수량화하는 대표적 도구가 공분산행렬이며, 변수의 단위와 규모 차이를 제거하여 비교 가능하게 만든 것이 상관행렬이다. 공분산행렬은 각 변수의 측정 단위와 규모(분산)를 그대로 반영하는 반면, 상관행렬은 변수를 평균 0, 분산 1로 표준화한 뒤의 상호 관련성을 반영한다.</p>
<p>따라서 변수의 단위가 같고 분산의 크기 차이가 의미 있는 정보라면 공분산행렬을 사용하는 것이 타당하다. 반대로 변수의 단위가 서로 다르거나, 분산의 규모 차이로 특정 변수가 결과를 지배할 우려가 있으면 상관행렬(= 표준화 후 공분산행렬)을 사용하는 것이 바람직하다. 상관행렬 기반 PCA는 곧 표준화 변수를 입력으로 한 공분산 기반 PCA와 동치이다. 한편, 두 경우 모두 중심화(평균 0)는 필수적이다.</p>
<p>확률변수(데이터) <span class="math inline">\(x_{i}\)</span>의 평균은 <span class="math inline">\(\overline{x}\)</span>, 표준편차를 <span class="math inline">\(s(x)\)</span>라 하자.</p>
<p>중심화 centering : <span class="math inline">\(c_{i} = x_{i} - \overline{x}\)</span>, 변수의 평균만 0으로 이동한다.</p>
<p>표준화 standardization : <span class="math inline">\(z_{i} = \frac{x_{i} - \overline{x}}{s(x)}\)</span>: 평균=0, 표준편차 1로 변환한다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 24%">
<col style="width: 24%">
<col style="width: 24%">
<col style="width: 24%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;">상황</td>
<td style="text-align: left;">중심화 필요 여부</td>
<td style="text-align: left;">표준화 필요 여부</td>
<td style="text-align: left;">사용 행렬</td>
</tr>
<tr class="even">
<td style="text-align: left;">모든 변수가 같은 단위, 분산 차이 의미 있음</td>
<td style="text-align: left;">필요</td>
<td style="text-align: left;">불필요</td>
<td style="text-align: left;">공분산 행렬</td>
</tr>
<tr class="odd">
<td style="text-align: left;">모든 변수가 같은 단위, 분산 차이 너무 큼</td>
<td style="text-align: left;">필요</td>
<td style="text-align: left;">경우에 따라</td>
<td style="text-align: left;">공분산/상관행렬</td>
</tr>
<tr class="even">
<td style="text-align: left;">변수가 서로 다른 단위(예: cm, kg)</td>
<td style="text-align: left;">필요</td>
<td style="text-align: left;">필요</td>
<td style="text-align: left;">상관행렬</td>
</tr>
</tbody>
</table>
<p>PCA를 구할 때는 우선 변수를 평균 0으로 중심화해야 한다. 또한 변수의 단위가 서로 다르거나 분산 크기가 크게 차이 나는 경우에는 표준화까지 수행해야 한다. 이때 분석은 상관행렬을 기반으로 하게 된다.</p>
</section>
<section id="주성분-구하기-1" class="level5">
<h5 class="anchored" data-anchor-id="주성분-구하기-1">(3) 주성분 구하기</h5>
<p>데이터 공분산행렬: <span class="math inline">\(S_{p \times p} = \begin{pmatrix}
s_{11} &amp; s_{12} &amp; ... &amp; s_{1p} \\
s_{21} &amp; s_{22} &amp; ... &amp; s_{2p} \\
&amp; ... &amp; &amp; \\
s_{p1} &amp; s_{p2} &amp; ... &amp; s_{pp}
\end{pmatrix}\)</span></p>
<p>데이터 상관계수 행렬: <span class="math inline">\({\widehat{R}}_{p \times p} = \begin{pmatrix}
r_{11} &amp; r_{12} &amp; ... &amp; r_{1p} \\
r_{21} &amp; r_{22} &amp; ... &amp; r_{2p} \\
&amp; ... &amp; &amp; \\
r_{p1} &amp; r_{p2} &amp; ... &amp; r_{pp}
\end{pmatrix}\)</span></p>
<p>공분산행렬(상관계수행렬)은 양반정치(positive definite) 행렬이므로 다음 식을 만족하는 고유값 <span class="math inline">\(\lambda\)</span>는 0보다 큰 실수이고 행렬의 차수 p개만큼 존재한다.</p>
<p>선형계수 행렬(부하 행렬) <span class="math inline">\(L_{n \times n}\)</span>에 의해 원 데이터 행렬로부터 주성분 행렬 <span class="math inline">\(Y_{n \times p} = X_{n \times p}L_{p \times p}\)</span>가 계산된다. 주성분 데이터의 차원은 원데이터 행렬의 차수와 동일하다.</p>
<p><span class="math inline">\({\underset{¯}{y}}_{1 \times p} = \left( \begin{array}{r}
y_{1} \\
y_{2} \\
... \\
y_{p}
\end{array} \right)\)</span><span class="math inline">\(= \begin{pmatrix}
l_{11} &amp; l_{12} &amp; ... &amp; l_{1p} \\
l_{21} &amp; l_{22} &amp; ... &amp; l_{2p} \\
&amp; ... &amp; &amp; \\
l_{p1} &amp; l_{p2} &amp; ... &amp; l_{pp}
\end{pmatrix}\)</span><span class="math inline">\(\left( \begin{array}{r}
x_{1} \\
x_{2} \\
... \\
x_{p}
\end{array} \right)\)</span>=<span class="math inline">\(L\underset{¯}{x}\)</span></p>
<p>위의 식에 의해 원데이터와 선형계수를 이용하여 계산된 주성분 값을 주성분 점수 score 라 한다.</p>
<p><strong>선형계수 (부하)</strong></p>
<p>공분산행렬 S의 고유벡터 중 <span class="math inline">\({\underset{¯}{e}}_{i}'\underset{¯}{e} = 1\)</span>을 만족하는 놈(Norm, 정규) 고유벡터를 k-번째 주성분 변수의 선형계수(부하) 벡터 <span class="math inline">\({\underset{¯}{l}}_{k}\)</span>로 사용한다.</p>
<p><strong>왜 고유벡터(선형계수)를 이용하나?</strong></p>
<p>주성분분석은 데이터가 가장 넓게 퍼져 있는 방향, 즉 분산이 최대가 되는 축을 찾는 것이 목적이다. 공분산행렬은 변수들의 분산과 공분산을 모두 담고 있어 데이터가 어떤 방향으로 크게 퍼져 있는지를 보여주는 지도를 제공한다. 이 공분산행렬을 고유분해하면 고유벡터와 고유값을 얻을 수 있는데, 고유벡터는 데이터가 퍼져 있는 방향을, 고유값은 그 방향으로의 분산 크기를 의미한다.</p>
<p>따라서 가장 큰 고유값에 대응하는 고유벡터는 데이터가 가장 넓게 퍼진 방향이 되고, 이것이 첫 번째 주성분이 된다. 두 번째로 큰 고유값의 고유벡터는 첫 번째 주성분과 직교하면서 남은 분산을 가장 크게 설명하는 방향이 되고, 이렇게 차례대로 주성분들이 정해진다.</p>
<p>결국 주성분을 공분산행렬의 고유벡터로 구하는 것은 우연이 아니라, 주성분분석의 핵심 목표인 <span dir="rtl">”</span>데이터의 분산을 가장 잘 보존하는 새로운 좌표축”을 찾는 데에 고유벡터가 정확히 그 역할을 하기 때문이다.</p>
<p><strong>제1 주성분 변수</strong></p>
<p><span class="math inline">\({\underset{¯}{e}}_{i}'{\underset{¯}{e}}_{i} = 1\)</span>이면서 <span class="math inline">\(V({\underset{¯}{e}}_{i}'\underset{¯}{x})\)</span>을 최대화 하는 열벡터를 구하고 이를 <span class="math inline">\({\underset{¯}{l}}_{1}\)</span>이라 하고 이를 선형계수로 하여 제 1 주성분 변수를 구한다. <span class="math inline">\({\underset{¯}{y}}_{1} = {\underset{¯}{l}}_{1}'\underset{¯}{x}\)</span></p>
<p><strong>제2 주성분 변수</strong></p>
<p><span class="math inline">\({\underset{¯}{l}}_{1}'{\underset{¯}{e}}_{j} = 1\)</span>이면서 <span class="math inline">\({\underset{¯}{e}}_{j}'{\underset{¯}{e}}_{j} = 1\)</span> 이면서 <span class="math inline">\(V({\underset{¯}{e}}_{j}'\underset{¯}{x})\)</span>을 최대화 하는 열벡터를 구하고 이를 <span class="math inline">\({\underset{¯}{l}}_{2}\)</span>이라 하고 이를 선형계수로 하여 제2 주성분변수 <span class="math inline">\({\underset{¯}{y}}_{2} = {\underset{¯}{l}}_{2}'\underset{¯}{x}\)</span>을 구한다. 이는 제1 주성분 변수와는 서로 독립이고 원변수 변동에 대한 설명력은 제1 주성분 변수보다 낮다.</p>
<p><strong>제3주성분 변수</strong></p>
<p><span class="math inline">\({\underset{¯}{l}}_{1}'{\underset{¯}{e}}_{k} = 1\)</span>, <span class="math inline">\({\underset{¯}{l}}_{2}'{\underset{¯}{e}}_{k} = 1\)</span>이면서 <span class="math inline">\({\underset{¯}{e}}_{k}'{\underset{¯}{e}}_{k} = 1\)</span> 이면서 <span class="math inline">\(V({\underset{¯}{e}}_{k}'\underset{¯}{x})\)</span>을 최대화 하는 열벡터를 구하고 이를 이를 선형계수로 하여 제3 주성분변수 <span class="math inline">\({\underset{¯}{y}}_{3} = {\underset{¯}{l}}_{3}'\underset{¯}{x}\)</span>을 구한다. 제3 주성분 변수는 제1, 제2 주성분변수와는 독립이고 변동 설명력은 제1, 제2 주성분 변수보다 낮다. 이렇게 계속 원변수의 개수만큼 주성분변수를 구한다.</p>
<p><strong>공분산 행렬 고유값 및 고유벡터 성질</strong></p>
<ul>
<li><p>양반 정치 행렬인 공분산 행렬의 고유치는 모두 양의 실수이고, 원변수의 개수(차수)만큼 존재한다. <span class="math inline">\(\lambda_{1} \geq \lambda_{2} \geq ...\lambda_{p} \geq 0\)</span></p></li>
<li><p>고유 값이 제일 큰 <span class="math inline">\(\lambda_1\)</span> 에 의해 만들어지는 주성분변수를 제1 주성분, <span class="math inline">\(\lambda_2\)</span> 에 의해 만들어지는 주성분 변수를 제2 주성분 변수, 그리고 제3 주성분 변수 … 이다.</p></li>
<li><p>고유값 <span class="math inline">\(\lambda_{k}\)</span>에 대응하는 고유벡터는 무수히 많이 존재하는데 그 중 놈 벡터(<span class="math inline">\({\underset{¯}{e}}_{k}'{\underset{¯}{e}}_{k} = 1\)</span>)를 선형계수 벡터, 부하 벡터로 하여 제 k-주성분 변수, <span class="math inline">\({\underset{¯}{y}}_{k} = l_k' \underline x\)</span> 을 구한다.</p></li>
<li><p>모든 주성분 변수들은 원 변수의 선형 결합이고 서로 독립이다. 이는 모든 고유 벡터(선형계수 벡터)는 서로 독립이 되도록 하여 구하였기 때문이다. 즉, <span class="math inline">\({\underset{¯}{y}}_{i}'{\underset{¯}{y}}_{j} = 0,fori \neq j\)</span>이다.</p></li>
<li><p>k-번째 주성분 변수 <span class="math inline">\({\underset{¯}{y}}_{k}\)</span>의 분산은 <span class="math inline">\(V({\underset{¯}{y}}_{k}) = \lambda_{k}\)</span>이고 원 변수의 변동합은 고유값의 합과 같다. <span class="math inline">\(\sigma_{11} + \sigma_{22} + ... + \sigma_{pp} = \lambda_{1} + \lambda_{2} + ... + \lambda_{p}\)</span></p></li>
<li><p>만약 공분산 행렬의 경우 원 변수의 변동합은 상관계수 대각원소(모두 1)의 합이므로 변수의 개수 p가 대각원소 합이므로 <span class="math inline">\(p = \lambda_{1} + \lambda_{2} + ... + \lambda_{p}\)</span>이다.</p></li>
<li><p>그러므로 제k-번째 주성분 변동 기여율은 <span class="math inline">\(\frac{\lambda_{k}}{\sum_{i = 1}^{p}\lambda_{i}}\)</span>이다. 즉 고유값 <span class="math inline">\(\lambda_{k}\)</span>는 k-번째 주성분이 원변수들릐 변동을 설명하는 능력이다. 상관계수 행렬의 변동 기여율은 <span class="math inline">\(\frac{\lambda_{k}}{p}\)</span>이다.</p></li>
<li><p>주성분 변수는 원 변수들의 변동을 설명하고 순서대로 설명력은 줄어든다.</p></li>
</ul>
<p><strong>시각적 직관</strong></p>
<p>그림 속 원 데이터는 원형에 가깝게 흩어져 있어 X와 Y 변수 간의 상관관계는 거의 0에 가깝다. 두 변수의 분산 역시 동일하기 때문에, 원래 좌표축에서는 특별히 한쪽 축이 더 큰 변동을 설명한다고 보기는 어렵다. 그러나 데이터를 주성분 축으로 회전시키면 상황은 달라진다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/pca 시각적판단.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:60.0%"></p>
</figure>
</div>
<p>주성분 1과 주성분 2는 서로 직교하는 축이므로 독립적이다. 이때 주성분 1 방향의 분산은 타원의 장축에 해당하며, 주성분 2 방향의 분산은 단축에 해당한다. 따라서 주성분 1이 설명하는 변동성이 주성분 2보다 크다. 즉, 데이터의 구조를 파악하는 데 있어 주성분 1의 설명력이 더 크다고 할 수 있다.</p>
<p>결과적으로 이 경우에는 원래의 두 변수(X, Y)를 모두 사용하는 것과 주성분 1만으로 개체를 설명하는 것 사이에 큰 차이가 없다. 다시 말해, 주성분분석을 통해 얻은 단 하나의 주성분으로도 데이터의 본질적인 분산 구조를 충분히 설명할 수 있다.</p>
</section>
<section id="주성분-개수-결정" class="level5">
<h5 class="anchored" data-anchor-id="주성분-개수-결정">(4) 주성분 개수 결정</h5>
<p>주성분변수는 원래 변수들의 공분산행렬(혹은 변수 단위가 다른 경우 상관행렬)을 고유분해하여 얻은 고유값과 고유벡터를 바탕으로 구성된다. 각 주성분은 해당 고유값의 크기만큼 원 데이터의 변동을 설명하며, 고유벡터는 주성분을 형성하는 선형계수 역할을 한다. 주성분들은 서로 독립적이며, 제1주성분이 가장 큰 변동을 설명하고, 그다음 제2주성분, 제3주성분 순으로 설명력이 줄어든다. 따라서 주성분의 개수 자체는 원래 변수의 개수와 동일하게 존재한다.</p>
<p>그러나 주성분분석의 본래 목적은 모든 주성분을 다 사용하는 것이 아니다. 주성분분석은 데이터 차원을 줄여서 보다 단순한 구조로 요약하려는 데에 그 의의가 있다. 즉, 원래 변수의 개수가 많더라도 실제로는 누적 설명력이 충분한 일부 주성분만을 선택해 사용함으로써 변수의 차원을 축소하는 것이 주성분분석의 핵심이다.</p>
<p><strong>변동 기여율 기준</strong></p>
<p>주성분분석에서 각 주성분은 원래 데이터의 변동성을 일정 부분 설명한다. 이때 한 주성분이 전체 변동성 가운데 얼마만큼을 차지하는지를 나타내는 비율을 변동 기여율(Explained Variance Ratio)이라 한다.</p>
<p>[공분산행렬] k-번째 주성분변수의 변동설명 기여율(variance explianed ratio) = <span class="math inline">\(\frac{\lambda_{k}}{\sum_{i}^{p}\lambda_{i}}\)</span></p>
<p>[상관행렬] k-번째 주성분변수의 변동설명 기여율 = <span class="math inline">\(\frac{\lambda_{k}}{p}\)</span></p>
<p>예를 들어 제1주성분의 고유값이 전체 고유값의 합에서 차지하는 비율이 40%라면, 제1주성분이 전체 데이터 변동성의 40%를 설명한다는 의미이다. 또한 변동 기여율을 누적하여 계산하면, 여러 개의 주성분이 함께 전체 변동성을 얼마만큼 설명하는지를 알 수 있다. 이를 누적 변동 기여율이라고 한다. 예를 들어 제1, 제2, 제3주성분까지의 누적 기여율이 85%라면, 이 세 개 주성분만으로도 데이터의 전체 변동성의 85%를 보존할 수 있음을 의미한다.</p>
<p>변동 기여율은 주성분의 개수를 선택할 때 중요한 기준이 된다. 보통 누적 기여율이 일정 수준(예: 70% 이상, 혹은 80~90% 이상)에 도달하는 지점까지만 주성분을 선택한다. 이렇게 하면 원 데이터의 대부분의 정보를 유지하면서도 변수 수를 크게 줄일 수 있다.</p>
<p>【Cochran Rule (Rule of Thumb)】 원변수 변동설명의 누적 기여율이 80%까지 되는 주성분변수까지 선택한다. 즉 20% 정보는 희생된다. 원변수의 상관관계가 높을수록 변수의 차원은 축약이 쉽게되므로 80% 규칙에 의한 주성분변수 개수는 작게 된다.</p>
<p>원 변수들의 상관관계가 높지 않으면 80%를 선택하게 되면 주성분 개수가 많아져 차원 축소가 적어져 일반적으로 주성분은 4개 이상 사용하지는 않는다.</p>
<p><strong>고유값 1이상(Kaiser 기준)</strong></p>
<p>상관행렬을 이용하는 경우 원변수 변동의 합은 p이므로 평균인 1이상 고유값을 갖는 주성분변수만 선택한다. 일반적으로 고유값 1 이상이 주성분을 선택하면 누적 변동설명 기여율 80%와 일치한다.</p>
<p><strong>스크리 플롯(Scree Plot) 방법</strong></p>
<p>고유값의 크기를 순서대로 그래프에 그리면, 설명력이 급격히 감소하다가 완만해지는 지점이 나타난다. 이 꺾이는 부분(엘보 포인트) 이전까지의 주성분을 선택하는 것이 일반적이다. 아래 그림의 스크리 플롯을 기준으로 할 때, 곡선이 꺾이는 지점인 엘보 포인트는 네 번째 주성분 근처에서 나타난다. 따라서 엘보 기준으로 선택되는 주성분의 개수는 4개이다. 반면 Kaiser 기준(고유값이 1보다 큰 경우)을 적용하면 첫 번째, 두 번째, 세 번째 주성분까지만 선택된다. 따라서 이 경우 Kaiser 기준에 따른 주성분 개수는 3개이다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/pca 스크리도표.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
<p>즉, 같은 데이터라도 엘보 기준은 4개, Kaiser 기준은 3개라는 서로 다른 결과를 제시할 수 있으며, 실제 분석에서는 누적 설명 분산비율과 연구 목적까지 함께 고려하여 최종 개수를 결정하게 된다.</p>
</section>
<section id="주성분-변수-이름-부여" class="level5">
<h5 class="anchored" data-anchor-id="주성분-변수-이름-부여">(5) 주성분 변수 이름 부여</h5>
<p>주성분변수는 원래 변수들의 선형결합으로 정의된다. 즉, 공분산행렬(또는 상관행렬)의 고유벡터를 선형계수로 하여 원 변수를 변환한 것이 주성분변수이다. 이때 각 원 변수의 기여 정도를 나타내는 계수가 바로 부하(loadings)이며, 부하의 절댓값이 클수록 해당 변수가 주성분 형성에 더 큰 영향을 미친다.</p>
<p>따라서 주성분에 이름을 부여하는 과정은, 부하 행렬에서 어떤 변수가 주성분에 강하게 기여하는지를 살펴보고 그 특징을 요약하여 직관적인 이름을 붙이는 것이다.</p>
<p>그러나 이 과정은 결코 단순하지 않다. 하나의 주성분에 여러 변수가 동시에 기여하거나, 서로 해석이 상충되는 부하 값이 섞여 있을 수 있기 때문이다. 또한 부호 방향에 따라 변수 간의 해석이 달라질 수 있고, 실제 데이터의 맥락과 결합해 해석하지 않으면 오해의 소지가 크다.</p>
<p>결국 주성분의 이름 부여는 수학적 계산 결과만으로 자동으로 정해지는 것이 아니라, 연구자가 부하 값의 크기와 방향을 바탕으로 변수군의 공통된 의미를 찾아내는 해석 과정이다. 따라서 단순히 부하의 절댓값만 보는 것이 아니라, 해당 데이터의 맥락과 연구 목적을 종합적으로 고려해야 한다.</p>
<p>즉, 주성분의 이름은 부하 행렬에서 큰 기여를 보이는 변수들의 특성을 요약해 붙이지만, 이는 연구자의 통계적 해석과 도메인 지식이 반드시 결합되어야 하는 작업이다.</p>
</section>
</section>
<section id="주성분-사례분석" class="level4">
<h4 class="anchored" data-anchor-id="주성분-사례분석">3. 주성분 사례분석</h4>
<p>Lahman Baseball Database</p>
<p>파이썬의 lahman 모듈은 파이썬에서 메이저리그(MLB) 통계의 표준 데이터베이스인 Lahman Baseball Database를 불러다 쓸 수 있도록 만든 패키지이다.</p>
<ul>
<li><p>Lahman Baseball Database란? Sean Lahman이 만든 공개 MLB 기록 데이터베이스</p></li>
<li><p>1871년부터 최근 시즌까지 선수별/팀별 성적, 경기 기록, 연봉, 올스타, 수상 내역 등을 체계적으로 정리한 자료, 가장 최근 데이터 불러 왔는데 2020년 데이터이다. yearID=2020</p></li>
<li><p>Lahman DB를 파이썬 pandas DataFrame 형태로 불러오는 간단한 API 제공한다.</p></li>
</ul>
<p>batting() → 타자 성적 (연도별, 팀별 기록 포함) <br> pitching() → 투수 성적 <br> fielding() → 수비 기록 <br> people() → 선수 기본 인적 정보 (이름, 생년월일, 출신국 등) <br> teams() → 팀별 시즌 기록 <br> salaries() → 연봉 데이터</p>
<p>불러온 데이터프레임은 곧바로 pandas 연산, scikit-learn 모델링, matplotlib 시각화 등에 활용 가능하다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>pip install lahman <span class="co">#모듈 설치</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> lahman <span class="im">import</span> batting, people</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 1) 성적 데이터</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>bat <span class="op">=</span> batting()</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>latest_year <span class="op">=</span> <span class="bu">int</span>(bat[<span class="st">'yearID'</span>].<span class="bu">max</span>())</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>bat_latest <span class="op">=</span> bat[bat[<span class="st">'yearID'</span>] <span class="op">==</span> latest_year].copy()</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>bat_latest <span class="op">=</span> bat_latest[bat_latest[<span class="st">'AB'</span>].fillna(<span class="dv">0</span>) <span class="op">&gt;=</span> <span class="dv">200</span>]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 2) 이름 데이터</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>peo <span class="op">=</span> people()</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co"># 필요한 열만 추출 (이름/ID)</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>peo_names <span class="op">=</span> peo[[<span class="st">'playerID'</span>,<span class="st">'nameFirst'</span>,<span class="st">'nameLast'</span>]]</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co"># 3) merge</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>bat_with_name <span class="op">=</span> bat_latest.merge(peo_names, on<span class="op">=</span><span class="st">'playerID'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="co"># 4) 확인</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>bat_with_name.head()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이하 분석은 200 타석 이상인 66명 타자에 대하여 분석이다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/pca mlb데이터.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>상관분석</p>
<p>주성분분석(PCA)은 변수들 간의 상관관계를 토대로 새로운 축을 찾아내어 데이터의 차원을 줄이는 방법이다. 이렇게 도출된 주성분은 다시 개체의 분류나 예측 모델의 설명 변수로 활용되는 등 다양한 2차 분석으로 이어질 수 있다. 따라서 PCA를 수행하기에 앞서 변수들 간의 상관 구조를 사전에 분석하는 것은 매우 중요한 의미를 가진다.</p>
<p>첫째, 상관분석은 변수 간 중복성, 즉 다중공선성의 존재 여부를 파악할 수 있게 해 준다. 주성분분석의 목적은 서로 강하게 연관된 변수들을 요약해 새로운 축으로 재구성하는 데 있다. 만약 변수들 사이의 상관이 거의 없다면 주성분분석을 통해 얻을 수 있는 정보의 압축 효과는 크지 않다. 반대로 변수들이 강하게 상관되어 있다면 소수의 주성분만으로도 전체 변동을 효과적으로 설명할 수 있다. 결국 상관관계의 크기는 PCA를 수행할 가치가 있는지 판단하는 중요한 지표가 된다.</p>
<p>둘째, 상관분석은 변수의 단위 문제를 점검하는 데 도움이 된다. 서로 다른 단위를 가진 변수를 공분산 행렬을 통해 분석하면 단위가 큰 변수가 주성분의 방향을 지배하게 된다. 이때 상관행렬을 사용하면 모든 변수를 표준화한 것과 동일한 효과를 주어 단위 차이를 제거할 수 있다. 따라서 사전 상관분석을 통해 변수 간의 구조를 비교할 때 표준화가 필요한지를 확인할 수 있다.</p>
<p>셋째, 상관분석은 주성분 해석의 방향성을 제공한다. 예를 들어 키와 체중이 강한 양의 상관을 가진다거나, 속도와 시간이 음의 상관을 보인다는 사실은 이후 주성분을 해석할 때 중요한 단서가 된다. 특정 변수들이 함께 움직이는 경향이나 서로 반대 방향으로 움직이는 패턴을 파악해 두면, 추출된 주성분의 의미를 보다 명확하게 해석할 수 있다.</p>
<p>넷째, 상관분석은 불필요한 변수, 즉 노이즈 변수를 걸러내는 데에도 유용하다. 어떤 변수는 다른 변수들과 거의 상관이 없고 독립적으로 움직일 수 있는데, 이런 변수는 전체 구조 요약에 기여도가 낮다. 이 경우 PCA에 포함시키더라도 분석의 효율을 떨어뜨릴 수 있다. 따라서 사전에 상관분석을 실시하면 기여도가 낮은 변수를 미리 파악해 제거함으로써, 보다 간결하고 해석 가능한 주성분 구조를 얻을 수 있다.</p>
<p>이처럼 상관분석은 PCA의 전처리 단계로서 단순한 변수 관계의 탐색을 넘어, 분석 수행의 타당성 점검, 단위 조정 필요성 확인, 주성분 해석의 실마리 제공, 그리고 불필요한 변수 제거를 통한 효율성 제고라는 중요한 역할을 한다고 할 수 있다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td><p># 1) 분석 변수</p>
<p>cols = ['HR','RBI','SB','BB','SO','H','AB','GIDP']</p>
<p>X = bat_with_name[cols].fillna(0)</p>
<p># 2) 상관행렬 계산</p>
<p>corr_matrix = X.corr()</p>
<p># 3) 히트맵 시각화</p>
<p>import matplotlib.pyplot as plt</p>
<p>import seaborn as sns</p>
<p>plt.figure(figsize=(8,6))</p>
<p>sns.heatmap(corr_matrix, annot=True, cmap="coolwarm", fmt=".3f", linewidths=0.5)</p>
<p>plt.title(f"{latest_year} correlation matrix")</p>
<p>plt.show()</p></td>
</tr>
</tbody>
</table>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/pca 산점도행렬.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>주성분분석을 실시하기 전에 상관행렬을 살펴보면, 변수들 간의 중복성과 구조를 확인할 수 있다. 2020년 타격 지표 상관분석 결과를 보면, 홈런(HR)과 타점(RBI)의 상관계수가 0.777로 매우 높게 나타나는데, 이는 두 지표가 사실상 같은 성향을 반영하고 있음을 의미한다. 따라서 PCA에서는 이 두 변수가 동일한 주성분 축에 강하게 기여할 가능성이 크다. 또한 안타(H)와 타수(AB) 역시 상관계수가 0.594로 높게 나타나, 경기 기회가 많을수록 안타도 많아지는 구조가 반영된 것이다. 이러한 변수 간의 강한 상관은 다중공선성 문제를 드러내며, 바로 PCA를 적용할 필요성을 보여준다.</p>
<p>또한 변수들의 측정 단위가 다르기 때문에, 단위가 큰 변수가 주성분 방향을 지배하지 않도록 상관행렬 기반의 PCA를 활용하는 것이 타당하다. 상관행렬을 사전에 확인하는 과정은 이러한 표준화 필요성을 확인하는 절차가 된다.</p>
<p>상관계수의 패턴은 주성분 해석의 방향성도 제시한다. HR–RBI–BB는 서로 양의 상관을 보이므로 <span dir="rtl">’</span>장타 및 생산력<span dir="rtl">’</span> 요인으로 묶일 수 있고, H–AB의 높은 상관은 <span dir="rtl">’</span>경기 기회와 안타 생산<span dir="rtl">’</span> 요인을 형성할 수 있다. 한편 삼진(SO)은 안타(H)와 음의 상관(-0.294)을 보이는데, 이는 <span dir="rtl">’</span>컨택 능력 대 삼진 성향<span dir="rtl">’</span>이라는 대비적 축으로 해석될 수 있다.</p>
<p>마지막으로 상관계수가 전반적으로 낮은 변수들은 노이즈 변수로 볼 수 있다. 병살타(GIDP)는 대부분의 지표와 관련성이 약해 전체 변동 요약에 크게 기여하지 못할 가능성이 크고, 도루(SB) 역시 주요 타격 지표들과는 거의 상관이 없어 별도의 부차적 주성분 축을 형성할 가능성이 있다.</p>
<p>결국 이 상관행렬을 통해 PCA에서 형성될 주성분의 구조를 예측할 수 있다. HR–RBI–BB가 하나의 주성분을, H–AB가 또 다른 주성분을 형성하며, SO는 이와 대립되는 방향의 변동을 설명하고, SB와 GIDP는 부차적이거나 설명력이 낮은 변수로 작용할 것임을 짐작할 수 있다. 이는 곧 PCA가 선수들의 타격 성향을 2~3개의 주성분으로 압축할 수 있음을 보여주는 사전적 근거이다.</p>
<p>주성분 구하기</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td><p>import pandas as pd</p>
<p>import numpy as np</p>
<p>from sklearn.preprocessing import StandardScaler</p>
<p>from sklearn.decomposition import PCA</p>
<p>import matplotlib.pyplot as plt</p>
<p># 1) 분석 변수</p>
<p>cols = ['HR','RBI','SB','BB','SO','H','AB','GIDP']</p>
<p>X = bat_with_name[cols].fillna(0)</p>
<p># 2) 표준화</p>
<p>scaler = StandardScaler()</p>
<p>X_std = scaler.fit_transform(X)</p>
<p># 3) PCA (전체 성분 학습)</p>
<p>pca = PCA()</p>
<p>scores = pca.fit_transform(X_std)</p>
<p># 3-1) 점수 붙이기</p>
<p>for j in range(scores.shape[1]):</p>
<p>bat_with_name[f'PC{j+1}'] = scores[:, j]</p>
<p># 4) 고유값과 Kaiser 필터</p>
<p>eigs = pca.explained_variance_</p>
<p>mask = eigs &gt;= 1</p>
<p>selected_idx = np.where(mask)[0]</p>
<p>selected_eigs = eigs[mask]</p>
<p># 5) 부하 행렬 (선택된 PC만)</p>
<p>loadings = pd.DataFrame(</p>
<p>pca.components_.T[:, mask] * np.sqrt(selected_eigs),</p>
<p>index=cols,</p>
<p>columns=[f'PC{i+1}' for i in selected_idx] # ✅ +1 제거!</p>
<p>)</p>
<p># ✅ 부하 행렬 출력</p>
<p>print("고유값 (전체):", np.round(eigs, 3))</p>
<p>print("선택된 주성분 (λ ≥ 1):", selected_idx+1)</p>
<p>print("부하 행렬 (loadings):")</p>
<p>print(loadings.round(3))</p>
<p># 6) 각 주성분의 설명 분산 비율</p>
<p>explained_ratio = pca.explained_variance_ratio_</p>
<p># 7) 누적 설명 분산 비율</p>
<p>cumulative_ratio = np.cumsum(explained_ratio)</p>
<p># ✅ 출력</p>
<p>print("주성분별 변동 설명 기여율:")</p>
<p>for i, (r, c) in enumerate(zip(explained_ratio, cumulative_ratio), start=1):</p>
<p>print(f"PC{i}: {r:.3f} (누적 {c:.3f})")</p></td>
</tr>
</tbody>
</table>
<p>고유값 (전체): [2.423 1.854 1.258 0.945 0.633 0.542 0.306 0.162]</p>
<p>선택된 주성분 (λ ≥ 1): [1 2 3]</p>
<p>부하 행렬 (loadings):</p>
<p>PC1 PC2 PC3</p>
<p>HR 0.776 0.467 -0.070</p>
<p>RBI 0.865 0.282 -0.200</p>
<p>SB 0.090 -0.291 0.838</p>
<p>BB 0.135 0.719 0.186</p>
<p>SO 0.079 0.609 0.175</p>
<p>H 0.696 -0.532 0.122</p>
<p>AB 0.709 -0.371 0.238</p>
<p>GIDP 0.229 -0.403 -0.611</p>
<p>주성분별 변동 설명 기여율:</p>
<p>PC1: 0.298 (누적 0.298)</p>
<p>PC2: 0.228 (누적 0.527)</p>
<p>PC3: 0.155 (누적 0.681)</p>
<p>PC4: 0.116 (누적 0.798)</p>
<p>PC5: 0.078 (누적 0.876)</p>
<p>PC6: 0.067 (누적 0.942)</p>
<p>PC7: 0.038 (누적 0.980)</p>
<p>PC8: 0.020 (누적 1.000)</p>
<p>주성분 이름부여</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td><p>#부하 산점도 그리기</p>
<p>import plotly.express as px</p>
<p># Plotly 산점도 (PC1 vs PC2)</p>
<p>fig = px.scatter(</p>
<p>loadings.reset_index(), # index(변수명)를 컬럼으로 복원</p>
<p>x="PC1",</p>
<p>y="PC2",</p>
<p>text="index" # 변수명을 라벨로 표시</p>
<p>)</p>
<p>fig.update_traces(textposition="top center")</p>
<p>fig.update_layout(title_text="Loading Scatterplot of PC1 and PC2")</p>
<p>fig.show()</p></td>
</tr>
</tbody>
</table>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/pca 부하산점도.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>PC1: 파워</p>
<ul>
<li><p>높은 부하: RBI (0.865), HR (0.776), H (0.696), AB (0.709) → 타점, 홈런, 안타, 타수 모두 양의 기여.</p></li>
<li><p>해석: 타격 생산력과 파워를 반영하는 주성분: <span dir="rtl">”</span>타격 생산력/파워 성분”</p></li>
</ul>
<p>PC2: 선구안</p>
<ul>
<li><p>높은 부하: BB (0.719), SO (0.609) (+), HR (0.467)(중간), 음의 부하: H (-0.532), GIDP (-0.403) → 볼넷과 삼진이 동시에 높고, 안타는 음의 방향.</p></li>
<li><p>해석: 컨택(안타 중심)과 선구안·삼진 경향의 대비: <span dir="rtl">”</span>선구안 vs 컨택 성분”</p></li>
</ul>
<p>PC3: 주루</p>
<ul>
<li><p>높은 부하: SB (0.838) 양수, GIDP (-0.611) 음수 → 도루가 많은 선수일수록 병살타는 적은 경향.</p></li>
<li><p>해석: 주루 능력(스피드)을 보여주는 주성분: <span dir="rtl">”</span>스피드/주루 성분”</p>
<p>주성분 활용(1) 개체분류</p></li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td><p># PC1, PC2 산점도</p>
<p>plt.figure(figsize=(9,7))</p>
<p>plt.scatter(bat_with_name['PC1'], bat_with_name['PC2'], alpha=0.6)</p>
<p># 선수 이름 표시 (홈런 15개 이상 선수)</p>
<p>for _, row in bat_with_name.iterrows():</p>
<p>if row['HR'] &gt;= 15:</p>
<p>plt.text(row['PC1']+0.05, row['PC2']+0.05,</p>
<p>f"{row['nameFirst']} {row['nameLast']}", fontsize=8)</p>
<p>plt.xlabel("PC1 (batting ability / power)")</p>
<p>plt.ylabel("PC2 (plate discipline vs contact)")</p>
<p>plt.title("MLB Batters PCA (PC1 vs PC2)")</p>
<p>plt.grid(True)</p>
<p>plt.show()</p></td>
</tr>
</tbody>
</table>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/pca mlb분류.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/pca mlb분류02.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
<table class="caption-top table">
<colgroup>
<col style="width: 101%">
</colgroup>
<tbody>
<tr class="odd">
<td><p># 각 주성분별 상위 5명 출력</p>
<p>for pc in [’PC1','PC2','PC3']:</p>
<p>print(f"\n{pc} 상위 5명:")</p>
<p>top5 = (bat_with_name[['nameFirst','nameLast','HR','RBI','SB',pc]]</p>
<p>.sort_values(pc, ascending=False)</p>
<p>.head(5))</p>
<p>print(top5.to_string(index=False))</p></td>
</tr>
</tbody>
</table>
<p>PC1 타격 상위 5명:</p>
<p>nameFirst nameLast HR RBI SB PC1</p>
<p>Jose Abreu 19 60.0 0.0 4.934120</p>
<p>Marcell Ozuna 18 56.0 0.0 3.823145</p>
<p>Manny Machado 16 47.0 6.0 2.837655</p>
<p>Trea Turner 12 41.0 12.0 2.651955</p>
<p>Freddie Freeman 13 53.0 2.0 2.554560</p>
<p>PC2 선구안 상위 5명:</p>
<p>nameFirst nameLast HR RBI SB PC2</p>
<p>Matt Olson 14 42.0 1.0 3.382615</p>
<p>Christian Yelich 12 22.0 4.0 3.281660</p>
<p>Max Muncy 12 27.0 1.0 2.790429</p>
<p>Yoan Moncada 6 24.0 0.0 2.166739</p>
<p>Carlos Santana 8 30.0 0.0 2.059597</p>
<p>PC3 주루 상위 5명:</p>
<p>nameFirst nameLast HR RBI SB PC3</p>
<p>Adalberto Mondesi 6 22.0 24.0 3.875285</p>
<p>Trevor Story 11 28.0 15.0 2.501421</p>
<p>Trent Grisham 10 26.0 10.0 2.397888</p>
<p>Whit Merrifield 9 30.0 12.0 2.271729</p>
<p>Dansby Swanson 10 35.0 5.0 2.135323</p>
<p>주성분 활용(2) 타자 능력 종합지표</p>
<p>PCA의 큰 장점은 여러 개의 서로 다른 변수들을 중복 없이 압축해 낼 수 있다는 점이다. 예컨대 PCA 결과에서 PC2, PC3, PC4가 각각 파워, 선구안, 그리고 주루 능력을 나타낸다. 그러면 이 세 가지 축은 서로 독립적이면서도 타자의 주요 특성을 대표하는 성분이라고 볼 수 있다.</p>
<p>이때 각 선수의 타격 능력을 하나의 종합 지표로 나타내고 싶다면, 세 성분을 단순 합이 아니라 설명 분산 기여율을 가중치로 반영한 가중합으로 설계할 수 있다. 즉, 각 주성분의 설명력이 큰 만큼 그 성분의 기여도를 더 크게 반영하는 방식이다.</p>
<p>이렇게 하면 최종적으로 얻어지는 PCA-Batting Index는 단일 수치로 선수의 타격 능력을 요약하면서도, 원래 다양한 변수들의 정보를 균형 있게 담아낼 수 있다. 말하자면 OPS나 WAR 같은 전통적 지표와는 다른, 데이터 축약 기반의 통합 평가 지표가 되는 셈이다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 101%">
</colgroup>
<tbody>
<tr class="odd">
<td><p># 선택된 PC 점수만 추출 (예: PC1, PC2, PC3)</p>
<p>selected_pcs = ['PC1','PC2','PC3']</p>
<p>weights = explained_ratio[0:3] / explained_ratio[0:3].sum() # PC1~PC3 비율 정규화</p>
<p># 종합 지표 계산</p>
<p>bat_with_name['PCA_Batting_Index'] = (</p>
<p>bat_with_name[selected_pcs].values @ weights</p>
<p>)</p>
<p># 상위 10명 확인</p>
<p>print(bat_with_name[['nameFirst','nameLast','HR','RBI','SB','PCA_Batting_Index']]</p>
<p>.sort_values('PCA_Batting_Index', ascending=False)</p>
<p>.head(10))</p></td>
</tr>
</tbody>
</table>
<p>nameFirst nameLast HR RBI SB PCA_Batting_Index</p>
<p>43 Marcell Ozuna 18 56.0 0.0 2.237267</p>
<p>46 Jose Ramirez 17 46.0 10.0 1.567421</p>
<p>59 Fernando Tatis 17 45.0 11.0 1.446034</p>
<p>0 Jose Abreu 19 60.0 0.0 1.446032</p>
<p>63 Luke Voit 22 52.0 0.0 1.287682</p>
<p>22 Freddie Freeman 13 53.0 2.0 1.231654</p>
<p>42 Matt Olson 14 42.0 1.0 1.209545</p>
<p>58 Dansby Swanson 10 35.0 5.0 1.205611</p>
<p>7 Mookie Betts 16 39.0 10.0 1.043342</p>
<p>57 Trevor Story 11 28.0 15.0 0.910111</p>
<p>주성분 활용(4) 이상치 진단</p>
<p>주성분 분석은 원 변수들의 선형함수를 이용하여 그 변수들의 공분산 구조를 설명하는 방법이다. 표본이 <span class="math inline">\(n\)</span>, 변수 개수가 <span class="math inline">\(p\)</span>개인 데이터 행렬 로부터의 공분산 행렬을 <span class="math inline">\(S_{p \times p}\)</span>라 하고, <span class="math inline">\(\Sigma\)</span>의 고유값을<span class="math inline">\(\lambda_{1} \geq \cdots \geq \lambda_{p}\)</span>, 대응 고유벡터를 <span class="math inline">\(e_{i}\)</span>라 하자. 고유벡터 <span class="math inline">\(e_{i}\)</span>를 계수로 하는 원변수의 선형결합 <span class="math inline">\(y_{i} = e_{i}^{\top}(x - \mu)\)</span>를 i-번째 주성분이라 한다. 다변량 정규 <span class="math inline">\(x \sim N_{p}(\mu,\Sigma)\)</span>를 가정하면 <span class="math inline">\(y_{i} \sim N(0,\lambda_{i})\)</span>이며 서로 독립이다.</p>
<p>이상치 진단은 공통 변동을 대표하는 주요 주성분과, 그 밖의 잔차(부) 주성분을 구분하여 수행할 수 있다. 데이터의 전체 변동 중 주요 공통 요인을 설명하는 상위 k개의 주성분을 선택하는 기준은 누적기여율, 스크리 플롯, Kaiser 기준, 병렬분석 등으로 정하는 것이 일반적이다. 이때 Cochran 정리에 의해 정규화된 제곱합은 다음과 같은 카이제곱 분포를 가진다.(Johnson과 Wichern, 2007).</p>
<p>주요 주성분에 의한 이상치 진단 통계량: <span class="math inline">\(\overset{k}{\sum_{i = 1}}\frac{y_{i}^{2}}{\lambda_{i}} \sim \chi^{2}(k)\)</span></p>
<p>잔차 주성분에 의한 이상치 발견 통계량: <span class="math inline">\(\overset{p}{\sum_{i = k + 1}}\frac{y_{i}^{2}}{\lambda_{i}} \sim \chi^{2}(p - k)\)</span></p>
<p>두 통계량은 서로 독립이다. 첫 번째 통계량은 공통 구조(저차 공간)에서의 이상 행동을, 두 번째 통계량은 공통 구조로 설명되지 않는 잔차 공간에서의 이상 행동을 포착한다. 실무에서는 <span class="math inline">\(\Sigma\)</span> 대신 표본공분산 S와 표본 고유분해를 사용하므로 분포는 엄밀히 근사이며, 대응 임계값은 경험적 기준 또는 모니터링 기법(Hotelling의 T^2, Q-통계 등)과 함께 사용되는 것이 권장된다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td><h1 id="pca-기반-이상치-진단"># === PCA 기반 이상치 진단</h1>
<p>from scipy.stats import chi2</p>
<p>import numpy as np</p>
<p>import pandas as pd</p>
<p># 0) 준비 (위에서 이미 계산된 것들 사용)</p>
<p># - scores: PCA 점수 (표준화된 X에 대해 학습)</p>
<p># - eigs: 고유값 (explained_variance_)</p>
<p># - selected_idx: Kaiser(λ&gt;=1)로 선택된 성분의 인덱스 (0-based)</p>
<p>p = scores.shape[1]</p>
<p>sel = np.array(sorted(selected_idx)) # 주요 주성분 index</p>
<p>res = np.setdiff1d(np.arange(p), sel) # 잔차 주성분 index</p>
<p>k = len(sel)</p>
<p>df_main = k</p>
<p>df_res = p - k</p>
<p>alpha_main = 0.05</p>
<p>alpha_res = 0.05</p>
<p># 1) 정규화된 PC 점수 (각 성분을 표준편차 sqrt(λ)로 나눔)</p>
<p>z = scores / np.sqrt(eigs) # shape: (n_samples, p)</p>
<p># 2) 통계량 계산</p>
<p>T2_main = (z[:, sel]**2).sum(axis=1) if k &gt; 0 else np.zeros(len(z))</p>
<p>T2_res = (z[:, res]**2).sum(axis=1) if df_res &gt; 0 else np.zeros(len(z))</p>
<p># 3) 임계값 (카이제곱)</p>
<p>crit_main = chi2.ppf(1 - alpha_main, df_main) if df_main &gt; 0 else np.inf</p>
<p>crit_res = chi2.ppf(1 - alpha_res, df_res) if df_res &gt; 0 else np.inf</p>
<p># 4) 데이터프레임에 부착 및 플래그</p>
<p>bat_with_name["T2_main"] = T2_main</p>
<p>bat_with_name["T2_res"] = T2_res</p>
<p>bat_with_name["flag_main"] = (T2_main &gt; crit_main) if np.isfinite(crit_main) else False</p>
<p>bat_with_name["flag_res"] = (T2_res &gt; crit_res) if np.isfinite(crit_res) else False</p>
<p>bat_with_name["flag_any"] = bat_with_name["flag_main"] | bat_with_name["flag_res"]</p>
<p>print(f"[선택 성분 개수 k={k}, df_main={df_main}, df_res={df_res}]")</p>
<p>print(f"임계값(α=0.05): main χ²({df_main})={crit_main:.3f}, residual χ²({df_res})={crit_res:.3f}")</p>
<p># 5) 상위 이상치 후보 확인 (주요/잔차 각각 상위 10명씩)</p>
<p>top_main = bat_with_name.sort_values("T2_main", ascending=False).head(10)[</p>
<p>["nameFirst","nameLast","T2_main","flag_main"]</p>
<p>]</p>
<p>top_res = bat_with_name.sort_values("T2_res", ascending=False).head(10)[</p>
<p>["nameFirst","nameLast","T2_res","flag_res"]</p>
<p>]</p>
<p>print("\n[주요 주성분 영역 이상치 후보 TOP 10]")</p>
<p>print(top_main.to_string(index=False))</p>
<p>print("\n[잔차 주성분 영역 이상치 후보 TOP 10]")</p>
<p>print(top_res.to_string(index=False))</p></td>
</tr>
</tbody>
</table>
<p>[선택 성분 개수 k=3, df_main=3, df_res=5]</p>
<p>임계값(α=0.05): main χ²(3)=7.815, residual χ²(5)=11.070</p>
<p>[주요 주성분 영역 이상치 후보 TOP 10]</p>
<p>nameFirst nameLast T2_main flag_main</p>
<p>Jose Abreu 13.735414 True</p>
<p>Adalberto Mondesi 13.266429 True</p>
<p>Whit Merrifield 9.340053 True</p>
<p>Marcell Ozuna 7.434100 False</p>
<p>Christian Yelich 6.806291 False</p>
<p>Trea Turner 6.614026 False</p>
<p>Trevor Story 6.595463 False</p>
<p>Matt Olson 6.206043 False</p>
<p>Trent Grisham 5.437111 False</p>
<p>Hanser Alberto 5.087521 False</p>
<p>[잔차 주성분 영역 이상치 후보 TOP 10]</p>
<p>nameFirst nameLast T2_res flag_res</p>
<p>Cesar Hernandez 15.628843 True</p>
<p>Adalberto Mondesi 14.008599 True</p>
<p>Freddie Freeman 13.942985 True</p>
<p>Javier Baez 11.264646 True</p>
<p>Dansby Swanson 10.582634 False</p>
<p>Carlos Santana 10.357712 False</p>
<p>Tim Anderson 10.154598 False</p>
<p>Kyle Seager 9.084776 False</p>
<p>Kyle Tucker 8.849439 False</p>
<p>Keston Hiura 8.728401 False</p>
<table class="caption-top table">
<colgroup>
<col style="width: 101%">
</colgroup>
<tbody>
<tr class="odd">
<td><p># 6) 2D 타원 시각화 (PC1 vs PC2, 95%)</p>
<p>import matplotlib.pyplot as plt</p>
<p>from matplotlib.patches import Ellipse</p>
<p>from scipy.stats import chi2</p>
<p>import numpy as np</p>
<p># (1) 좌표와 공분산</p>
<p>pcx, pcy = 0, 1 # 필요시 주성분은 pc1=0, pc2=1, ...</p>
<p>x = scores[:, pcx]</p>
<p>y = scores[:, pcy]</p>
<p>XY = np.column_stack([x, y])</p>
<p>mu = XY.mean(axis=0)</p>
<p>cov = np.cov(XY, rowvar=False)</p>
<p># (2) 타원 파라미터</p>
<p>vals, vecs = np.linalg.eigh(cov)</p>
<p>order = vals.argsort()[::-1]</p>
<p>vals, vecs = vals[order], vecs[:, order]</p>
<p>chi2_val = chi2.ppf(0.95, df=2)</p>
<p>width, height = 2*np.sqrt(vals*chi2_val)</p>
<p>angle = np.degrees(np.arctan2(*vecs[:,0][::-1]))</p>
<p># (3) 마할라노비스 거리^2로 이상치 판정(타원 밖)</p>
<p>inv_cov = np.linalg.inv(cov)</p>
<p>d = XY - mu</p>
<p>d2 = np.einsum('ij,jk,ik-&gt;i', d, inv_cov, d) # 거리^2</p>
<p>outlier_mask = d2 &gt; chi2_val</p>
<p># 4) 플롯 (수정 버전)</p>
<p>fig, ax = plt.subplots(figsize=(8,6))</p>
<p>ax.scatter(x, y, s=25)</p>
<p>ax.scatter(mu[0], mu[1], c='black', s=30) # 중심점</p>
<p># 🔧 angle을 keyword argument로 명시!</p>
<p>ellipse = Ellipse(xy=mu, width=width, height=height, angle=angle,</p>
<p>edgecolor='orange', facecolor='none', lw=2)</p>
<p>ax.add_patch(ellipse)</p>
<p># 라벨: 타원 밖만 표시 (playerID 없으면 nameFirst+nameLast 사용)</p>
<p>label_col = 'playerID' if 'playerID' in bat_with_name.columns else None</p>
<p>for i in np.where(outlier_mask)[0]:</p>
<p>if label_col:</p>
<p>txt = str(bat_with_name.iloc[i][label_col])</p>
<p>else:</p>
<p>txt = f"{bat_with_name.iloc[i]['nameLast']}{bat_with_name.iloc[i]['nameFirst']}"</p>
<p>ax.text(x[i], y[i]+0.12, txt, fontsize=9)</p>
<p># 축 라벨: 분산 기여율 표시</p>
<p>vx = pca.explained_variance_ratio_[pcx]*100</p>
<p>vy = pca.explained_variance_ratio_[pcy]*100</p>
<p>ax.set_xlabel(f'PC{pcx+1} component ({vx:.0f}%)')</p>
<p>ax.set_ylabel(f'PC{pcy+1} component ({vy:.0f}%)')</p>
<p>ax.set_title('scatter plot of POWER and Hitting components (Anomaly)')</p>
<p>ax.grid(True, alpha=0.3)</p>
<p>plt.tight_layout()</p>
<p>plt.show()</p></td>
</tr>
</tbody>
</table>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/pca 이상개체진단.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>주성분 활용(5) 연봉과 상관관계</p>
<p>연봉과 주성분 점수 간의 관계를 살펴볼 때는 굳이 회귀분석까지 갈 필요는 없는데 이유는 다음과 같다.</p>
<p>연봉은 잡음이 많음: MLB 연봉은 단순히 성적뿐 아니라 나이, 계약 시점, FA·ARB 제도, 포지션, 팀 재정 여건 등 외생 변수가 강하게 작용하여 예측력 지표인 결정계수가 매우 낮아 타격 성적만으로 설명하는 회귀모형은 편향적일 가능성이 크다.</p>
<p>분석 목적이 <span dir="rtl">”</span>설명력”이 아니라 <span dir="rtl">”</span>관계 파악”: 분석 목적은 <span dir="rtl">”</span>어떤 능력(PC2=파워, PC3=선구안, PC4=스피드)이 시장에서 평가받는가?“를 보는 것이므로 상관분석 정도로 충분히 의미를 전달할 수 있다.</p>
<p>연봉 데이터는 2020년 데이터가 없어 타자 능력 데이터와 달리 2016년 데이터를 이용하여 분석 대상 선수는 33명이다(최초 분석 데이터 66명).</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td><p>from lahman import salaries</p>
<p># 연봉 데이터 불러오기</p>
<p>sal = salaries()</p>
<p># 분석 시즌(예: latest_year) 연봉 데이터 선택</p>
<p>sal_latest = sal[sal['yearID'] == 2016] #2020 연봉이 없어 2016년 연봉을 사용</p>
<p># 선수 이름+PCA 점수 데이터와 연봉 join</p>
<p>bat_with_salary = bat_with_name.merge(</p>
<p>sal_latest[['playerID','salary']],</p>
<p>on='playerID',</p>
<p>how='left'</p>
<p>)</p>
<p># 결측치 제거</p>
<p>bat_with_salary = bat_with_salary.dropna(subset=['salary'])</p>
<p># 상관계수 계산 (연봉과 PC 점수)</p>
<p>corrs = bat_with_salary[[’salary','PC1','PC2','PC3']].corr()</p>
<p>print("연봉과 PCA 성분 상관계수:")</p>
<p>print(corrs['salary'].round(3))</p></td>
</tr>
</tbody>
</table>
<p>연봉과 PCA 성분 상관계수:</p>
<p>salary 1.000</p>
<p>PC1(타격 생산력/파워 성분) 0.074</p>
<p>PC2 (plate discipline vs contact) 0.259</p>
<p>PC3 (speed/baserunning) -0.215</p>
<p>연봉(5salary)–PC1(타격 생산력/파워 성분): +0.074</p>
<p>PC1은 홈런(HR), 타점(RBI), 안타(H) 등 공격 생산력의 공통 변동을 대표하는 성분이다.</p>
<p>상관계수 +0.07은 매우 약한 양(+)의 상관으로, 파워 중심의 성적이 연봉에 일부 긍정적 영향을 주지만, 설명력은 미미하다는 의미이다.</p>
<p>즉, MLB 연봉이 단순히 타격 지표(홈런·타점 등)에 의해 결정되지 않으며, 계약 시기·경력·포지션·수비력 등 복합적 요인이 작용함을 시사한다.</p>
<p>연봉(salary)–PC2(plate discipline vs contact): +0.259</p>
<p>PC2는 볼넷(BB)과 삼진(SO)의 대립 구조로, <span dir="rtl">”</span>선구안·출루력 vs 컨택 능력”의 대비를 나타내는 축이다.</p>
<p>상관계수 +0.26은 약한 양(+)의 상관으로, 볼넷이 많고 삼진이 적은, 즉 선구안이 좋은 타자일수록 연봉이 높은 경향이 있음을 보여준다.</p>
<p>이는 현대 MLB 시장이 <span dir="rtl">”</span>출루(OBP)“와 <span dir="rtl">”</span>타석 퀄리티(plate discipline)”를 일정 부분 보상하고 있음을 시사한다.</p>
<p>다만 0.26 정도면 여전히 제한적 관계이므로, 선구안이 뛰어나도 파워·포지션 프리미엄이 더 큰 영향력을 가질 가능성이 높다.</p>
<p>연봉(salary)–PC3(speed/baserunning): -0.215</p>
<p>PC3은 도루(SB)·주루 능력 등 스피드형 변동을 나타내는 성분이다.</p>
<p>상관계수 -0.22는 음(-)의 약한 상관으로, 주루 능력이 좋은 선수일수록 오히려 연봉이 낮은 경향이 있음을 의미한다.</p>
<p>이는 현대 MLB 시장에서 스피드보다는 파워·출루 중심의 효율적 공격이 더 높은 경제적 가치를 지니는 흐름을 반영한다.</p>
<p>과거 <span dir="rtl">’</span>도루왕=고액 연봉<span dir="rtl">’</span>의 공식이 이미 무너졌으며, 스피드는 부가적 능력으로만 평가되고 있음을 보여준다.</p>
<p>연봉과 PCA 성분 간의 상관 구조는 전반적으로 약하며,</p>
<p>시장 가치가 특정 기술(파워, 주루, 선구안) 하나로 결정되지 않는다는 점을 드러낸다.</p>
<p>특히 **plate discipline(PC2)**의 양(+)의 상관이 가장 높게 나타났다는 점은,</p>
<p>최근 MLB에서 <span dir="rtl">’</span>볼넷 관리 능력<span dir="rtl">’</span>이 점차 중요해지고 있다는 신호로 해석할 수 있다.</p>
<p>결국 연봉은 성적 지표 + 나이 + 계약제도 + 포지션 희소성 + 팀 전략적 필요가 교차하여 형성되는 복합 함수임을 시사한다.</p>
<p>Chapter 3. SVD 차원축소</p>
<p>1. PCA와 SVD 비교</p>
<p>PCA는 원래 변수들 간의 공분산 구조를 분석하여 변수의 수를 줄이는 차원 축소 방법이다.즉, 여러 변수가 내포한 중복된 정보를 제거하고, 분산이 큰 방향으로 축을 회전시켜 소수의 주성분 변수로 요약한다.</p>
<p>반면, SVD는 데이터 행렬 자체를 직교 행렬과 특이값 대각행렬로 분해하는 행렬 분해 기법으로, 변수뿐 아니라 관측치(행) 의 차원까지 함께 축소할 수 있다.</p>
<p>이 때문에 SVD는 데이터의 행과 열을 동시에 저차원 공간으로 표현할 수 있으며, 특히 이미지나 문서처럼 고차원 행렬 데이터를 다루는 기계학습(예: 이미지 분류, LSA 등) 에 널리 활용된다.</p>
<p>PCA는 공분산행렬을 기반으로 하므로 각 주성분의 부하량(loadings) 을 통해 원래 변수들이 주성분에 어떻게 기여하는지를 해석할 수 있지만, SVD는 행렬 전체를 수치적으로 분해하기 때문에 변수의 해석보다는 구조적 압축과 근사에 초점을 둔다.</p>
<p>요약하자면, PCA는 <span dir="rtl">”</span>변수를 줄이고 해석하는” 통계적 방법이고 SVD는 <span dir="rtl">”</span>행렬 전체를 축소하고 근사하는” 수학적 방법이다.</p>
<p>PCA</p>
<p>SVD</p>
<p>2. Sigular Value Decomposition</p>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 9%">
<col style="width: 64%">
</colgroup>
<tbody>
<tr class="odd">
<td>원데이터</td>
<td></td>
<td>행렬분해</td>
</tr>
<tr class="even">
<td><span class="math display">\[X_{n \times p}\]</span></td>
<td><span class="math display">\[=\]</span></td>
<td><span class="math display">\[U_{n \times n}\Sigma_{n \times p}V_{p \times p}\]</span></td>
</tr>
<tr class="odd">
<td>(단위 표준화)</td>
<td></td>
<td><p><span class="math inline">\(U\)</span>: &nbsp;특이값 직교행렬<br>
<span class="math inline">\(\Sigma\)</span> : 대각행렬</p>
<p><span class="math inline">\(V\)</span> : 특이값 직교행렬</p></td>
</tr>
</tbody>
</table>
<p>Full SVD and Reduced SVD</p>
<ul>
<li><p><span class="math inline">\(\Sigma_{n \times p} = \begin{bmatrix}
\text{diag}(\sigma_{1},\sigma_{2},\ldots,\sigma_{r}) &amp; 0 \\
0 &amp; 0
\end{bmatrix}\)</span>, 여기서 <span class="math inline">\(\sigma_{i} = \sqrt{\lambda_{i}}\)</span>(<span class="math inline">\(X'X\)</span>의 고유치)이며 <span class="math inline">\(r = \text{rank}(X)\)</span>이다. <span class="math inline">\(\Sigma_{n \times p}\)</span>은 비대칭 대각행렬이다.</p></li>
<li><p><span class="math inline">\(U'U = I_{n}\)</span>: <span class="math inline">\(U\)</span>가 <span class="math inline">\(n \times n\)</span> 정사각행렬이면 <span class="math inline">\(U'U = I_{n}\)</span>이다(Full SVD). 그러나 실제 SVD 계산에서는 보통 Reduced SVD 형태를 사용하므로 <span class="math inline">\(U\)</span>가 <span class="math inline">\(n \times r\)</span> 정사각행렬이면 <span class="math inline">\(U'U = I_{r}\)</span>이다.</p></li>
<li><p><span class="math inline">\(V'V = I_{p}\)</span>: 같은 이유로, Reduced SVD에서는 <span class="math inline">\(V'V = I_{r}\)</span>이다. <span class="math inline">\(X'X\)</span>의 고유벡터는 <span class="math inline">\(p \times p\)</span> 행렬 <span class="math inline">\(V\)</span>의 열로 구성되지만, 실제 계산에서는 <span class="math inline">\(r\)</span>개의 주축만 사용한다.</p>
<p>Truncated SVD</p></li>
</ul>
<p>reduced SVD은 원 데이터 행렬의 계수 r 까지 차원을 줄인다면 Truncated SVD는 그 중에서도 상위 <span class="math inline">\(k( &lt; r)\)</span>개의 특이값과 대응하는 성분만 남겨, 정보의 손실을 최소화하면서 행렬을 근사하는 방법이다.</p>
<p>즉, 전체 구조를 완전히 복원하는 Reduced SVD와 달리, Truncated SVD는 데이터의 주요 패턴(가장 큰 변동 방향)만 보존하고 미세한 변동이나 노이즈에 해당하는 뒷부분 성분을 버림으로써 데이터를 압축하고 계산 효율을 높이는 목적을 가진다.</p>
<p><span class="math inline">\(k\)</span>를 결정할 때는 일반적으로 누적 설명변동 비율(예: 80%)을 기준으로 하므로, 주성분분석에서 차원을 선택하는 방식과 동일하다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td><p>import numpy as np</p>
<p>import pandas as pd</p>
<p>from sklearn.preprocessing import StandardScaler</p>
<p>from sklearn.decomposition import TruncatedSVD</p>
<p># 1) 변수 선택</p>
<p>cols = ['HR','RBI','SB','BB','SO','H','AB','GIDP']</p>
<p>X = bat_with_name[cols].fillna(0)</p>
<p># 2) 표준화: 평균 0, 표준편차 1</p>
<p>scaler = StandardScaler()</p>
<p>Z = scaler.fit_transform(X)</p>
<p># Full SVD: 모든 직교기저 포함</p>
<p>U_full, S_full, Vt_full = np.linalg.svd(Z, full_matrices=True)</p>
<p>print("U_full:", U_full.shape) # (n, n)</p>
<p>print("S_full:", S_full.shape) # (min(n, p),)</p>
<p>print("Vt_full:", Vt_full.shape) # (p, p)</p>
<p># 복원 확인 (완벽하게 동일해야 함)</p>
<p>Z_recon_full = (U_full[:, :len(S_full)] * S_full) @ Vt_full</p>
<p>np.allclose(Z, Z_recon_full, atol=1e-10)</p></td>
</tr>
</tbody>
</table>
<p>U_full: (66, 66)</p>
<p>S_full: (8,)</p>
<p>Vt_full: (8, 8)</p>
<p>True</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td><p># 3) Reduced (Thin) SVD: 정확한 분해</p>
<p>U_r, S_r, Vt_r = np.linalg.svd(Z, full_matrices=False)</p>
<p># r = rank(Z)</p>
<p>r = len(S_r)</p>
<p>print("rank:", r) # (Z 행렬 계수)</p>
<p>print("U_r:", U_r.shape) # (n, n)</p>
<p>print("S_r:", S_r.shape) # (min(n, p),)</p>
<p>print("Vt_r:", Vt_r.shape) # (p, p)</p>
<p># 복원 확인</p>
<p>Z_recon = (U_r * S_r) @ Vt_r</p></td>
</tr>
</tbody>
</table>
<p>rank: 8</p>
<p>U_r: (66, 8)</p>
<p>S_r: (8,)</p>
<p>Vt_r: (8, 8)</p>
<table class="caption-top table">
<colgroup>
<col style="width: 100%">
</colgroup>
<tbody>
<tr class="odd">
<td><p># 4) Truncated SVD (상위 k개 성분만 근사)</p>
<p>k = 3</p>
<p>svd_k = TruncatedSVD(n_components=k, random_state=0)</p>
<p>Z_k = svd_k.fit_transform(Z) # U_k Σ_k</p>
<p>Vk = svd_k.components_ # Vt_k</p>
<p>Sk = svd_k.singular_values_</p>
<p># 5) 누적 분산비율로 정보량 확인</p>
<p>explained_var = (S_r**2)</p>
<p>ratio = explained_var / explained_var.sum()</p>
<p>cumulative = np.cumsum(ratio)</p>
<p>print(f"Reduced rank r = {r}")</p>
<p>print(f"상위 {k}개 누적 분산 비율: {cumulative[:k]}")</p>
<p>print("Sk:", Sk.shape) # (min(n, p),)</p>
<p>print("Vk:", Vk.shape) # (p, p)</p></td>
</tr>
</tbody>
</table>
<p>Reduced rank r = 8</p>
<p>상위 3개 누적 분산 비율: [0.29831468 0.52653148 0.68138709]</p>
<p>Sk: (3,)</p>
<p>Vk: (3, 8)</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "복사완료!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "복사완료!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© 2025 Kwon</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>Built with Quarto</p>
</div>
  </div>
</footer>




</body></html>