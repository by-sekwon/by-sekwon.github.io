<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>다변량분석 7. 정준상관분석 | 다변량분산분석 – 세상의 모든 통계 이야기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-2757cfadcc89ddbfb9e61569f8c3689f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">세상의 모든 통계 이야기</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../notes/math/index.html"> 
<span class="menu-text">기초수학</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/math_stat/index.html"> 
<span class="menu-text">수리통계</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/intro_stat/index.html"> 
<span class="menu-text">기초통계</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/survey/index.html"> 
<span class="menu-text">조사방법론</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/linear_model/index.html"> 
<span class="menu-text">회귀분석</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mda/index.html"> 
<span class="menu-text">다변량분석</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes/mldl/index.html"> 
<span class="menu-text">머신·딥러닝 개념 w/GPT</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../notes/mldl_method/index.html" aria-current="page"> 
<span class="menu-text">머신·딥러닝 방법론 w/GPT</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cardnews/index.html"> 
<span class="menu-text">카드뉴스</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../consult.html"> 
<span class="menu-text">통계상담</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">다변량분석 7. 정준상관분석 | 다변량분산분석</li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">【HOME】</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 방법론 소개</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../notes/mldl_method/mldlmethod_prediction_intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">📄 예측방법: 서론</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">contents</h2>
   
  <ul>
  <li><a href="#chapter-1.-정준상관분석" id="toc-chapter-1.-정준상관분석" class="nav-link active" data-scroll-target="#chapter-1.-정준상관분석">Chapter 1. 정준상관분석</a>
  <ul>
  <li><a href="#정준상관분석이란" id="toc-정준상관분석이란" class="nav-link" data-scroll-target="#정준상관분석이란">1. 정준상관분석이란?</a></li>
  <li><a href="#개념-및-기본설정" id="toc-개념-및-기본설정" class="nav-link" data-scroll-target="#개념-및-기본설정">2. 개념 및 기본설정</a></li>
  <li><a href="#정준변수-구하기" id="toc-정준변수-구하기" class="nav-link" data-scroll-target="#정준변수-구하기">3. 정준변수 구하기</a></li>
  <li><a href="#정준변수-특성" id="toc-정준변수-특성" class="nav-link" data-scroll-target="#정준변수-특성">4. 정준변수 특성</a></li>
  <li><a href="#정준변수-활용" id="toc-정준변수-활용" class="nav-link" data-scroll-target="#정준변수-활용">5. 정준변수 활용</a></li>
  <li><a href="#정준상관분석-사례" id="toc-정준상관분석-사례" class="nav-link" data-scroll-target="#정준상관분석-사례">6. 정준상관분석 사례</a></li>
  </ul></li>
  <li><a href="#chapter-2.-다변량분산분석" id="toc-chapter-2.-다변량분산분석" class="nav-link" data-scroll-target="#chapter-2.-다변량분산분석">Chapter 2. 다변량분산분석</a>
  <ul>
  <li><a href="#다변량분산분석이란" id="toc-다변량분산분석이란" class="nav-link" data-scroll-target="#다변량분산분석이란">1. 다변량분산분석이란?</a></li>
  <li><a href="#다변량분산분석-모형과-추정" id="toc-다변량분산분석-모형과-추정" class="nav-link" data-scroll-target="#다변량분산분석-모형과-추정">2. 다변량분산분석 모형과 추정</a></li>
  <li><a href="#사례연구" id="toc-사례연구" class="nav-link" data-scroll-target="#사례연구">3. 사례연구</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">다변량분석 7. 정준상관분석 | 다변량분산분석</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="chapter-1.-정준상관분석" class="level3">
<h3 class="anchored" data-anchor-id="chapter-1.-정준상관분석">Chapter 1. 정준상관분석</h3>
<section id="정준상관분석이란" class="level4">
<h4 class="anchored" data-anchor-id="정준상관분석이란">1. 정준상관분석이란?</h4>
<section id="필요-이유" class="level5">
<h5 class="anchored" data-anchor-id="필요-이유">필요 이유</h5>
<p>다변량분석에서는 하나의 변수만으로 현상을 설명하기 어려운 경우가 많다. 사회과학, 경영학, 심리학, 보건학 등 다양한 분야에서 연구자는 여러 개의 설명변수와 여러 개의 반응변수를 동시에 관측하게 된다. 이러한 상황에서 분석의 핵심 질문은 개별 변수 간의 단순한 관계를 넘어, 변수 집합과 변수 집합 사이에 어떤 구조적 연관성이 존재하는가로 확장된다.</p>
<p>전통적인 회귀분석은 하나의 종속변수를 기준으로 설명변수의 영향을 추정하는 데 초점을 둔다. 이 접근법은 예측이나 인과 해석에는 유용하지만, 종속변수가 여러 개인 경우 각각의 회귀모형을 따로 적합해야 하며, 그 과정에서 종속변수들 간의 상관 구조는 충분히 반영되지 않는다. 반면 주성분분석이나 요인분석은 여러 변수의 정보를 요약하는 데 효과적이지만, 하나의 변수 집합 내부의 구조만을 다룰 뿐 서로 다른 두 변수 집합 간의 관계를 직접적으로 설명하지는 못한다.</p>
<p>정준상관분석(canonical correlation analysis)은 이러한 분석상의 공백을 메우기 위해 제안된 다변량 기법이다. 이 방법은 두 개의 변수 집합이 주어졌을 때, 각각의 집합에서 선형 결합을 구성하여 그 결합들 사이의 상관을 최대화하는 방향을 찾는다. 즉, 개별 변수 간의 관계가 아니라 두 변수 집합 전체를 대표하는 요약 변수들 간의 관계를 분석의 대상으로 삼는다. 이를 통해 연구자는 한 변수 집합이 다른 변수 집합과 어떤 방식으로 연결되어 있는지를 보다 구조적인 관점에서 이해할 수 있다.</p>
</section>
<section id="정준상관분석-특성" class="level5">
<h5 class="anchored" data-anchor-id="정준상관분석-특성">정준상관분석 특성</h5>
<p>정준상관분석의 중요한 특징은 분석의 초점이 예측이나 검정에만 있지 않다는 점이다. 이 방법은 두 변수 집합 간의 대응 구조를 탐색하는 데 목적이 있으며, 여러 개의 정준변수를 순차적으로 도출함으로써 복수의 관계 축을 제시한다. 각 정준변수 쌍은 이전 쌍과 직교하도록 구성되므로, 서로 중복되지 않는 독립적인 관계 구조를 단계적으로 해석할 수 있다. 이러한 특성은 복잡한 다차원 관계를 체계적으로 분해하여 이해하는 데 큰 장점을 제공한다.</p>
<p>정준상관분석은 또한 다변량 분산분석이나 판별분석과 같은 다른 다변량 기법을 이론적으로 연결해 주는 역할을 한다. 예를 들어, 집단 정보를 더미 변수로 구성하여 설명변수 집합으로 두는 경우, 다변량 분산분석은 정준상관분석의 특수한 형태로 해석될 수 있다. 이러한 관점은 다변량분석을 개별 기법의 나열이 아니라, 공통된 수리적 틀 위에서 이해되는 하나의 체계로 인식하게 한다는 점에서 교육적으로 중요한 의미를 갖는다.</p>
<p>그럼에도 불구하고 정준상관분석은 실무 연구에서 자주 사용되는 기법은 아니다. 해석이 직관적이지 않고, 표본 크기와 가정에 대한 요구가 상대적으로 크기 때문이다.</p>
</section>
</section>
<section id="개념-및-기본설정" class="level4">
<h4 class="anchored" data-anchor-id="개념-및-기본설정">2. 개념 및 기본설정</h4>
<p>정준상관분석은 여러 변수로 이루어진 두 변수 군(집합) 간의 선형 상관 관계를 분석하는 다변량 통계 방법이다. 이 방법의 목적은 개별 변수 간의 관계를 각각 살펴보는 것이 아니라, 두 변수 집합을 대표하는 선형 결합을 구성하여 그 결합들 사이의 상관을 최대화하는 데 있다.</p>
<p>예를 들어, 신체적 조건을 나타내는 변수군(키, 몸무게, 가슴둘레 등)과 운동 능력을 나타내는 변수군(달리기 기록, 윗몸일으키기 횟수, 턱걸이 횟수 등)이 주어졌다고 하자. 이 경우 연구의 관심은 특정 신체 조건 하나가 특정 운동 능력 하나와 얼마나 관련되는가가 아니라, 신체적 조건 전반과 운동 능력 전반 사이에 체계적인 선형 관계가 존재하는가에 있다. 정준상관분석은 이러한 질문에 답하기 위한 분석 방법이다.</p>
<section id="변수-군-간-선형-결합과-정준변수" class="level5">
<h5 class="anchored" data-anchor-id="변수-군-간-선형-결합과-정준변수">변수 군 간 선형 결합과 정준변수</h5>
<p>정준상관분석에서는 다음과 같이 두 개의 변수 집합을 고려한다.</p>
<p><span class="math display">\[(X_{1},X_{2},\ldots,X_{m}),(Y_{1},Y_{2},\ldots,Y_{n})\]</span></p>
<p>분석의 핵심은 각 변수 집합에 대해 선형 결합을 구성하고, 이 두 선형 결합 간의 상관계수를 최대화하는 것이다. 즉,</p>
<p><span class="math inline">\(U = a_{1}X_{1} + a_{2}X_{2} + \cdots + a_{m}X_{m}\)</span>,</p>
<p><span class="math inline">\(V = b_{1}Y_{1} + b_{2}Y_{2} + \cdots + b_{n}Y_{n}\)</span>와 같은 두 개의 선형 결합을 정의하고, <span class="math inline">\(\text{Corr}(U,V)\)</span>가 최대가 되도록 계수 <span class="math inline">\(a_{1},\ldots,a_{m},b_{1},\ldots,b_{n}\)</span>을 결정한다. 여기서 U와 V를 각각 정준변수(canonical variate) 라고 한다.</p>
<p>이 과정은 단일한 상관계수를 계산하는 데서 끝나지 않으며, 첫 번째 정준변수 쌍과 직교하면서 그다음으로 큰 상관을 갖는 두 번째 정준변수 쌍을 순차적으로 구할 수 있다. 이를 통해 두 변수 집합 간의 다차원적 관계 구조를 단계적으로 파악할 수 있다.</p>
</section>
<section id="확률적-설정과-공분산-구조" class="level5">
<h5 class="anchored" data-anchor-id="확률적-설정과-공분산-구조">확률적 설정과 공분산 구조</h5>
<p>전체 변수를 하나의 벡터로 묶어 <span class="math inline">\(\mathbf{x} = (x_{1},x_{2},\ldots,x_{p})^{\top}\)</span>라 하고, 이를 두 개의 부분 벡터로 나눈다고 하자. <span class="math inline">\(\mathbf{x} = \left( \begin{array}{r}
\mathbf{x}_{1} \\
\mathbf{x}_{2}
\end{array} \right)\)</span>. 정준상관분석에서는 일반적으로 이 벡터가 다변량 정규분포를 따른다고 가정한다.</p>
<p><span class="math inline">\(\mathbf{x} \sim \mathcal{N}\left( \left( \begin{array}{r}
\mathbf{\mu}_{1} \\
\mathbf{\mu}_{2}
\end{array} \right),\begin{pmatrix}
\Sigma_{11} &amp; \Sigma_{12} \\
\Sigma_{21} &amp; \Sigma_{22}
\end{pmatrix} \right)\)</span> 여기서 <span class="math inline">\(\Sigma_{12}\)</span>와 <span class="math inline">\(\Sigma_{21}\)</span>은 두 변수 집합 간의 공분산 구조를 나타내며, 정준상관분석은 이 공분산 구조를 바탕으로 두 집합의 선형적 연관성을 최대화하는 방향을 찾는다.</p>
</section>
<section id="정준상관분석의-특수한-경우" class="level5">
<h5 class="anchored" data-anchor-id="정준상관분석의-특수한-경우">정준상관분석의 특수한 경우</h5>
<p>정준상관분석은 여러 익숙한 통계 분석 방법을 포괄하는 일반적인 틀로 이해할 수 있다.</p>
<p>첫째, 각 변수 군이 모두 하나의 변수로만 구성되어 있다면, 정준상관분석은 두 변수 간의 단순 상관계수로 귀결된다.</p>
<p>둘째, 한쪽 변수 군이 하나의 변수로만 구성되어 있고, 다른 한쪽이 여러 변수로 이루어진 경우에는 다중회귀분석과 밀접한 관련을 갖는다. 이때 정준상관계수는 다중회귀모형에서의 결정계수 <span class="math inline">\(R^{2} = \frac{\text{SSR}}{\text{SST}}\)</span>의 제곱근 <span class="math inline">\(\sqrt{R^{2}}\)</span>에 해당한다. 즉, 종속변수와 설명변수들의 선형 결합 사이의 최대 상관을 의미한다.</p>
<p>이와 같이 정준상관분석은 단순 상관분석과 다중회귀분석을 포함하는 보다 일반적인 분석 방법이며, 다변량 자료에서 변수 집합 간 관계를 체계적으로 이해하기 위한 이론적 기반을 제공한다.</p>
</section>
</section>
<section id="정준변수-구하기" class="level4">
<h4 class="anchored" data-anchor-id="정준변수-구하기">3. 정준변수 구하기</h4>
<p>정준상관분석의 핵심은 두 변수 군을 각각 하나의 대표 변수로 요약하고, 이 두 요약 변수 간의 상관을 최대화하는 데 있다. 이를 위해 각 변수 군에 대한 선형 결합을 정의하고, 그 선형 결합 간 상관계수가 최대가 되도록 하는 계수를 구한다. 이때 얻어지는 선형 결합을 정준변수(canonical variate) 라 한다.</p>
<section id="제1-정준변수" class="level5">
<h5 class="anchored" data-anchor-id="제1-정준변수">제1 정준변수</h5>
<p>두 변수 군의 선형 결합 간 상관계수를 가장 크게 하는 경우를 먼저 고려하자. 두 변수 군을 각각 <span class="math inline">\(\mathbf{x}_{1},\mathbf{x}_{2}\)</span>라 하면, 다음과 같은 선형 결합을 정의할 수 있다. <span class="math inline">\(V_{1} = \mathbf{a}_{1}^{\top}\mathbf{x}_{1},W_{1} = \mathbf{b}_{1}^{\top}\mathbf{x}_{2}\)</span></p>
<p>정준상관분석에서는 다음의 최적화 문제를 고려한다.</p>
<p><span class="math inline">\(\rho_{1} = \max_{\mathbf{a}_{1} \neq 0,\mathbf{b}_{1} \neq 0}\text{corr}(V_{1},W_{1})\)</span> 이 조건을 만족하는 <span class="math inline">\(\mathbf{a}_{1},\mathbf{b}_{1}\)</span>에 의해 정의되는 <span class="math inline">\(V_{1},W_{1}\)</span>을 제1정준변수라 하고, 이때의 상관계수 <span class="math inline">\(\rho_{1}\)</span>을 제1정준상관계수라 한다. 정준변수는 크기의 임의성이 존재하므로, 해의 유일성을 확보하기 위해 다음과 같은 정규화 조건을 부여한다.</p>
<p><span class="math display">\[\text{Var}(V_{1}) = \text{Var}(W_{1}) = 1\]</span></p>
<p>이는 공분산 행렬을 이용하여 다음과 같이 표현된다.</p>
<p><span class="math display">\[\mathbf{a}_{1}^{\top}\Sigma_{11}\mathbf{a}_{1} = 1,\mathbf{b}_{1}^{\top}\Sigma_{22}\mathbf{b}_{1} = 1\]</span></p>
</section>
<section id="제2-정준변수" class="level5">
<h5 class="anchored" data-anchor-id="제2-정준변수">제2 정준변수</h5>
<p>제1정준변수가 두 변수 군 간의 가장 강한 선형 관계를 설명한다면, 그다음 단계에서는 이미 설명된 관계와 독립적인 추가 관계를 탐색한다. 이를 위해 다음과 같은 선형 결합을 정의한다.</p>
<p><span class="math inline">\(V_{2} = \mathbf{a}_{2}^{\top}\mathbf{x}_{1},W_{2} = \mathbf{b}_{2}^{\top}\mathbf{x}_{2}\)</span>. 제2정준변수는 다음의 조건을 만족하도록 정의된다.</p>
<p><span class="math inline">\(V_{2}\)</span>와 <span class="math inline">\(W_{2}\)</span>는 각각 <span class="math inline">\(V_{1}\)</span>과 <span class="math inline">\(W_{1}\)</span>에 대해 직교(독립)한다.</p>
<p><span class="math display">\[\text{Var}(V_{2}) = \text{Var}(W_{2}) = 1\]</span></p>
<p>이 조건하에서 <span class="math inline">\(\rho_{2} = \text{corr}(V_{2},W_{2})\)</span>를 제2정준상관계수라 한다.</p>
<p>이와 같은 방식으로 이후의 정준변수들도 순차적으로 정의할 수 있으나, 실제 분석에서는 해석의 어려움으로 인해 보통 2–3개의 정준변수까지만 해석하는 경우가 많다.</p>
</section>
<section id="정준상관계수의-개수" class="level5">
<h5 class="anchored" data-anchor-id="정준상관계수의-개수">정준상관계수의 개수</h5>
<p>정준상관계수의 개수는 두 변수 군의 차원에 의해 결정된다. 한 변수 군의 변수 수가 p, 다른 변수 군의 변수 수가 q일 때, 정의될 수 있는 정준상관계수의 최대 개수는 <span class="math inline">\(\min(p,q)\)</span>이다. 이는 두 변수 군 중 차원이 더 작은 변수 군의 정보만큼만 독립적인 관계 축을 구성할 수 있기 때문이다. 일반적으로 각각 2개 정준변수를 사용한다.</p>
</section>
<section id="정준상관계수의-유의성-검정" class="level5">
<h5 class="anchored" data-anchor-id="정준상관계수의-유의성-검정">정준상관계수의 유의성 검정</h5>
<p>정준상관계수의 통계적 유의성은 두 변수 군 간에 선형 관계가 존재하는지를 검정하는 문제로 귀결된다. 먼저 제1정준상관계수에 대해 다음의 가설을 고려한다.</p>
<p><span class="math inline">\(H_{01}:\rho_{1} = 0\text{vs.}H_{01}:\rho_{1} \neq 0\)</span> 이는 공분산 행렬의 관점에서 다음의 가설과 동치이다.</p>
<p><span class="math display">\[H_{01}:\Sigma_{12} = 0\text{vs.}H_{01}:\Sigma_{12} \neq 0\]</span></p>
<p>이때 사용되는 검정 통계량은 Wilks의 람다(Wilks<span dir="rtl">’</span> Lambda)로,</p>
<p><span class="math inline">\(T = \frac{|\widehat{\Sigma}|}{|{\widehat{\Sigma}}_{11}||{\widehat{\Sigma}}_{22}|} = \overset{k}{\prod_{i = 1}}(1 - {\widehat{\rho}}_{i}^{2}),k = \min(p,q)\)</span>로 정의된다.</p>
<p>보다 일반적으로 r번째 이후의 정준상관계수에 대한 검정은</p>
<p><span class="math inline">\(H_{0r}:\rho_{r} = 0\text{vs.}H_{0r}:\rho_{r} \neq 0\)</span> 의 형태로 설정되며, 이에 대한 검정 통계량은 <span class="math inline">\(T_{r} = \overset{k}{\prod_{i = r}}(1 - {\widehat{\rho}}_{i}^{2})\)</span>이다. 이 통계량은 적절한 변환을 거쳐 카이제곱 분포를 따르며, 이를 이용해 정준상관계수의 유의성을 판단한다.</p>
</section>
</section>
<section id="정준변수-특성" class="level4">
<h4 class="anchored" data-anchor-id="정준변수-특성">4. 정준변수 특성</h4>
<p>정준상관분석에서 정준변수는 두 변수군 각각에 대해 구성된 선형결합 변수로서, 서로 짝을 이루어 해석된다. 각 정준변수 쌍은 두 변수군 간의 관계를 가장 잘 요약하는 축을 의미하며, 이 축은 상관계수가 최대가 되도록 정의된다. 따라서 정준변수 간의 관계는 개별 관측변수 간의 단순한 상관관계가 아니라, 두 변수군 전체의 구조적 연관성을 요약한 결과로 이해할 수 있다.</p>
<p>정준변수의 관계는 순차적이고 계층적인 구조를 가진다. 제1정준변수 쌍은 두 변수군 사이의 가장 강한 선형적 연관성을 설명하며, 이후의 제2, 제3 정준변수 쌍은 앞선 정준변수 쌍과 서로 직교하도록 구성된다. 이 직교성은 각 정준변수 쌍이 이전 정준관계로 설명되지 않은 새로운 관계 구조를 독립적으로 포착함을 의미한다. 따라서 정준상관분석은 단일한 관계 요약에 그치지 않고, 두 변수군 간에 존재하는 다차원적 연관 구조를 단계적으로 분해하는 분석 방법이라 할 수 있다.</p>
<p>정준변수 간의 상관관계는 각 정준쌍 내부에서만 의미를 가지며, 서로 다른 차수의 정준변수 사이에는 상관이 존재하지 않는다. 이는 각 정준변수 쌍이 서로 중복되지 않는 정보만을 담고 있음을 보장한다. 이러한 성질로 인해 연구자는 정준상관계수의 크기와 통계적 유의성을 기준으로, 해석에 포함할 정준변수 쌍의 수를 합리적으로 결정할 수 있다.</p>
<p>해석 측면에서 정준변수 간의 관계는 두 변수군을 대표하는 잠재적 요약 축 간의 관계로 이해된다. 즉, 정준변수는 개별 변수의 효과를 직접적으로 설명하기보다는, 여러 변수가 결합된 종합적인 경향이나 패턴을 나타낸다. 따라서 정준변수 간의 높은 상관관계는 두 변수군이 공통적으로 공유하는 구조적 특성이 강하다는 것을 의미하며, 반대로 낮은 상관관계는 두 변수군 간의 연관성이 제한적이거나 특정 차원에만 국한되어 있음을 시사한다.</p>
<p>요약하면, 정준변수 간의 관계는 두 변수군 사이의 연관성을 가장 효과적으로 요약한 잠재 축 간의 관계이며, 이러한 관계는 순차적·직교적 구조를 통해 체계적으로 분해된다. 정준상관분석은 이와 같은 정준변수 관계를 바탕으로, 복수의 변수군이 어떻게 연결되어 있는지를 전체 구조 차원에서 이해하도록 돕는 분석 방법이다.</p>
<section id="정준변수-적재량" class="level5">
<h5 class="anchored" data-anchor-id="정준변수-적재량">정준변수 적재량</h5>
<p>정준상관분석에서 정준적재량(canonical loadings)은 각 관측변수가 동일한 변수군에서 도출된 정준변수와 어느 정도의 선형적 연관성을 가지는지를 나타내는 지표이다. 이는 관측변수와 정준변수 간의 상관계수로 정의되며, 정준변수가 어떤 변수들의 공통된 변동을 주로 반영하고 있는지를 파악하는 데 사용된다. 따라서 정준적재량은 정준변수의 해석을 가능하게 하는 핵심적인 도구로, 정준변수를 단순한 수학적 결합이 아닌 의미 있는 요약 축으로 이해하도록 돕는다.</p>
<p>정준적재량은 정준계수와 구별되어 해석되어야 한다. 정준계수가 정준변수를 구성하는 선형결합의 가중치를 의미한다면, 정준적재량은 그 결과로 형성된 정준변수와 원변수 간의 실제 연관 정도를 보여준다. 이로 인해 정준적재량은 변수의 단위나 다중공선성의 영향을 상대적으로 덜 받으며, 해석의 안정성이 높다. 실제 분석에서는 정준변수의 성격을 규정할 때 정준계수보다 정준적재량을 중심으로 해석하는 것이 일반적이다<strong>.</strong></p>
<p>교차적재량(cross-loadings)은 한 변수군의 관측변수가 다른 변수군에서 도출된 정준변수와 가지는 상관관계를 의미한다. 이는 두 변수군 간의 관계가 정준변수 수준에서만 존재하는 것이 아니라, 개별 변수 차원에서 어떻게 연결되는지를 구체적으로 보여주는 지표이다. 교차적재량을 통해 연구자는 두 변수군 간의 연관 구조가 어떤 변수들을 매개로 형성되는지를 보다 직접적으로 파악할 수 있다.</p>
<p>교차적재량은 두 변수군 사이의 실질적인 연결 강도를 평가하는 데 활용된다. 정준상관계수가 두 정준변수 간의 전반적인 연관성을 요약한다면, 교차적재량은 그 연관성이 각 관측변수 수준에서 어떻게 분해되는지를 설명한다. 따라서 교차적재량은 정준상관분석 결과를 해석 가능한 형태로 구체화하며, 분석 결과를 실천적·정책적 논의로 확장하는 데 중요한 근거를 제공한다.</p>
<p>종합하면, 정준적재량은 각 정준변수가 무엇을 대표하는지를 설명하는 내부적 해석 지표이며, 교차적재량은 두 변수군이 어떻게 연결되는지를 변수 수준에서 드러내는 외부적 해석 지표라 할 수 있다. 정준상관분석의 해석에서는 정준상관계수만으로 결론을 도출하기보다는, 정준적재량과 교차적재량을 함께 고려함으로써 두 변수군 간 관계의 구조적 의미를 보다 명확하고 체계적으로 이해할 수 있다.</p>
</section>
</section>
<section id="정준변수-활용" class="level4">
<h4 class="anchored" data-anchor-id="정준변수-활용">5. 정준변수 활용</h4>
<p>정준변수는 두 변수군에 포함된 다수의 변수를 각각 하나의 요약된 축으로 축약함으로써, 변수 차원 축소의 역할을 수행한다. 원래 정준상관분석에서는 p개의 설명변수와 q개의 반응변수를 동시에 고려해야 하지만, 정준변수 쌍을 이용하면 이들 변수군 사이의 관계를 소수의 정준축으로 요약할 수 있다. 이러한 축은 단순한 분산 설명이 아니라, 두 변수군 간 상관구조가 가장 강하게 드러나는 방향으로 구성된다는 점에서 의미를 가진다. 즉, 정준변수는 <span dir="rtl">”</span>두 변수군 사이의 핵심적인 연관 구조”를 저차원 공간에서 표현하는 도구로 이해할 수 있다. 이 점에서 단일 변수군 내부의 분산 구조를 요약하는 주성분분석(PCA)과 대비되며, 정준상관분석은 두 변수군 간의 공통된 구조를 요약하는 데 목적이 있다.</p>
<p>정준변수는 또한 두 변수군 간 관계를 해석하기 위한 핵심적인 분석 도구로 활용된다. 이를 통해 연구자는 두 변수군 사이에 통계적으로 의미 있는 연관성이 존재하는지, 그 연관성이 어떤 변수들의 결합을 통해 주로 형성되는지, 그리고 제1정준관계 이후에도 서로 독립적인 추가적 관계 구조가 존재하는지를 체계적으로 검토할 수 있다. 이러한 해석을 위해서는 정준상관계수의 크기를 통해 각 정준변수 쌍의 중요성을 평가하고, 정준적재량을 통해 각 관측변수가 해당 정준변수에 기여하는 정도를 파악하며, 교차적재량을 통해 한 변수군의 정준변수가 다른 변수군의 개별 변수들과 어떻게 연관되는지를 함께 살펴보는 것이 일반적이다.</p>
<p>더 나아가 정준변수는 해석 가능한 잠재지표로서의 역할도 수행한다. 정준변수는 개별 관측변수들의 단순한 집합이 아니라, 이들 변수를 선형 결합하여 구성한 잠재적인 종합 지표로 이해될 수 있다. 예를 들어, 학습투입을 나타내는 공부시간, 출석률, 과제수행도로 구성된 변수군과 학습성과를 나타내는 시험점수와 프로젝트 평가 점수로 구성된 변수군을 고려할 경우, 정준변수는 각각 <span dir="rtl">”</span>학습투입의 종합적 수준”과 <span dir="rtl">”</span>학습성과의 종합적 수준”을 대표하는 지표로 해석될 수 있다. 이와 같이 정준변수는 복수의 관측변수를 하나의 해석 가능한 축으로 통합함으로써, 다변량 자료의 구조적 관계를 직관적으로 이해할 수 있도록 돕는다.</p>
</section>
<section id="정준상관분석-사례" class="level4">
<h4 class="anchored" data-anchor-id="정준상관분석-사례">6. 정준상관분석 사례</h4>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.cross_decomposition <span class="im">import</span> CCA</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">123</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">40</span>  <span class="co"># 표본 수</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.DataFrame({</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># X 변수군: 학습투입</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">"study_time"</span>: np.random.normal(<span class="dv">10</span>, <span class="dv">3</span>, n),</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">"attendance"</span>: np.random.normal(<span class="dv">90</span>, <span class="dv">5</span>, n),</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">"assignment"</span>: np.random.normal(<span class="dv">80</span>, <span class="dv">8</span>, n),</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">"participation"</span>: np.random.normal(<span class="dv">4</span>, <span class="fl">0.6</span>, n),</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Y 변수군: 학습성과</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="st">"exam"</span>: np.random.normal(<span class="dv">82</span>, <span class="dv">7</span>, n),</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="st">"project"</span>: np.random.normal(<span class="dv">85</span>, <span class="dv">6</span>, n),</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="st">"achievement"</span>: np.random.normal(<span class="dv">84</span>, <span class="dv">6</span>, n)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(data.head())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>study_time attendance assignment participation exam project achievement <br> 0 6.743108 85.973167 90.041899 3.834528 82.142212 89.219861 85.745246 <br> 1 12.992036 81.361653 74.489048 3.668735 80.642253 81.411368 85.677976 <br> (이하 생략)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">#정준상관분석은 척도에 민감하므로 표준화가 필수이다.</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> data[[<span class="st">"study_time"</span>, <span class="st">"attendance"</span>, <span class="st">"assignment"</span>, <span class="st">"participation"</span>]]</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> data[[<span class="st">"exam"</span>, <span class="st">"project"</span>, <span class="st">"achievement"</span>]]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>scaler_X <span class="op">=</span> StandardScaler()</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>scaler_Y <span class="op">=</span> StandardScaler()</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>X_std <span class="op">=</span> scaler_X.fit_transform(X)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>Y_std <span class="op">=</span> scaler_Y.fit_transform(Y)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">#정준상관분석 적합</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>cca <span class="op">=</span> CCA(n_components<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>cca.fit(X_std, Y_std)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>X_c, Y_c <span class="op">=</span> cca.transform(X_std, Y_std)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co">#정준상관계수 계산</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>corrs <span class="op">=</span> [np.corrcoef(X_c[:, i], Y_c[:, i])[<span class="dv">0</span>, <span class="dv">1</span>]</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>         <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(X_c.shape[<span class="dv">1</span>])]</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, c <span class="kw">in</span> <span class="bu">enumerate</span>(corrs, start<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"제</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">정준상관계수: </span><span class="sc">{</span>c<span class="sc">:.3f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>제1정준상관계수는 <strong>0.376</strong>으로, 두 변수군(X: 학습투입, Y: 학습성과) 사이에 중간 이하 수준의 양<strong>(+)</strong>의 선형 연관성이 존재함을 의미한다. 즉, 학습투입 변수들의 특정 선형결합과 학습성과 변수들의 특정 선형결합 사이에 일정한 방향성 있는 관계는 관찰되지만, 그 크기는 강하다고 보기는 어렵다. 순차적 <strong>Wilks<span dir="rtl">’</span> Lambda</strong> 검정 결과, 제1정준상관에 대한 p-value가 <strong>0.8662</strong>로 매우 크게 나타나, 모집단 수준에서 해당 정준상관이 통계적으로 유의하다고 판단할 근거는 없다.</p>
<p>제2정준상관계수는 <strong>0.208</strong>로, 제1정준상관보다 더 약한 수준의 연관성을 보인다. 이에 대한 Wilks<span dir="rtl">’</span> Lambda 검정에서도 p-value가 <strong>0.9562</strong>로 나타나, 제2정준상관 역시 통계적으로 전혀 유의하지 않다. 이는 첫 번째 정준관계를 제거한 이후에는 추가적인 의미 있는 공통 구조가 거의 남아 있지 않음을 시사한다.</p>
<p>종합하면, 본 결과는 표본에서는 약한 정준상관이 관찰되지만, 두 변수군 간의 관계를 통계적으로 유의한 구조적 연관성으로 일반화하기는 어렵다는 결론에 해당한다. 즉, 학습투입과 학습성과 사이에 명확하고 안정적인 다변량적 연결 구조가 존재한다고 말하기에는 근거가 부족한 상황이다.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">#정준 적재량</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>loadings_X <span class="op">=</span> np.corrcoef(X_std.T, X_c.T)[:X.shape[<span class="dv">1</span>], X.shape[<span class="dv">1</span>]:]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>loadings_Y <span class="op">=</span> np.corrcoef(Y_std.T, Y_c.T)[:Y.shape[<span class="dv">1</span>], Y.shape[<span class="dv">1</span>]:]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>load_X <span class="op">=</span> pd.DataFrame(loadings_X,</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>                      index<span class="op">=</span>X.columns,</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>                      columns<span class="op">=</span>[<span class="ss">f"Can</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(cca.n_components)])</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>load_Y <span class="op">=</span> pd.DataFrame(loadings_Y,</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>                      index<span class="op">=</span>Y.columns,</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>                      columns<span class="op">=</span>[<span class="ss">f"Can</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(cca.n_components)])</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>load_X, load_Y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>정준상관분석 결과, 두 개의 정준축이 도출되었으며, 해석의 중심은 제1정준축에 두는 것이 타당하다. 제1정준축에서 X 변수군의 정준적재량을 보면, <em>assignment</em>가 0.96으로 매우 높은 값을 보여 다른 변수들에 비해 압도적인 기여를 하고 있다. 반면 <em>study_time</em>은 거의 0에 가까운 적재량을 보이며, <em>attendance</em>와 <em>participation</em> 역시 상대적으로 작은 값을 나타내어 제1정준축 형성에 있어 핵심적인 역할을 하지 않는 것으로 판단된다. 이는 제1정준변수가 학습투입 중에서도 단순한 시간 투자나 출석보다는 과제 수행 정도를 중심으로 구성된 축임을 의미한다.</p>
<p>Y 변수군의 제1정준축 적재량을 살펴보면, <em>achievement</em>가 −0.78로 가장 큰 절댓값을 보이며, <em>project</em> 또한 0.45로 중간 수준의 기여를 하고 있다. 반면 <em>exam</em>은 거의 0에 가까운 값을 보여 제1정준관계에서 실질적인 역할을 하지 않는다. 이를 종합하면, 제1정준변수는 학습성과 측면에서 종합적인 성취도를 중심으로 형성된 축으로 해석할 수 있다. 정준적재량의 부호는 상대적인 방향을 의미할 뿐이므로, 해석에서는 부호보다는 절댓값의 크기와 변수 조합에 주목하는 것이 중요하다.</p>
<p>따라서 제1정준관계는 과제 수행 중심의 학습투입과 종합적 학습 성취도 사이의 연관 구조를 나타내는 것으로 해석된다. 이는 학습성과를 설명하는 데 있어 단순한 시험 점수나 출석보다 과제 기반 학습 활동이 더 핵심적인 역할을 할 수 있음을 시사한다.</p>
<p>한편 제2정준축에서는 X 변수군 중 <em>participation</em>이 0.69로 가장 높은 적재량을 보여, 이 축이 수업 참여도를 중심으로 형성되어 있음을 알 수 있다. Y 변수군에서는 <em>project</em>와 <em>achievement</em>가 각각 −0.79, −0.60으로 비교적 큰 절댓값을 보여 프로젝트 및 성취도와 관련된 성과 축으로 해석된다. 다만 제2정준상관계수의 크기가 작고, 유의성 검정에서도 통계적으로 유의하지 않은 것으로 나타났기 때문에, 이 축은 독립적인 의미 있는 관계 구조라기보다는 보조적·탐색적 수준에서만 해석하는 것이 적절하다.</p>
<p>종합하면, 본 분석에서 실질적인 해석 가치는 제1정준축에 집중되며, 학습투입 변수 중 과제 수행이 학습성과 중 종합 성취도와 가장 밀접하게 연결되는 구조가 확인된다. 이는 정준상관분석이 두 변수군 간의 관계를 개별 변수 간 상관이 아니라, 변수들의 선형 결합을 통한 구조적 관계로 이해하게 해주는 분석 방법임을 잘 보여주는 사례라 할 수 있다.</p>
<p>( Can1 Can2 <br> study_time 0.026286 0.215788 <br> attendance -0.293917 -0.333222 <br> assignment 0.960446 -0.265262 <br> participation 0.157126 0.686076,</p>
<p>Can1 Can2 <br> exam -0.005259 0.163121 <br> project 0.451057 -0.793028 <br> achievement -0.775036 -0.602302)</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 교차 적재량 (Cross-loadings)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co"># X 변수 ↔ Y 정준변수</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>cross_XY <span class="op">=</span> np.corrcoef(X_std.T, Y_c.T)[:X.shape[<span class="dv">1</span>], X.shape[<span class="dv">1</span>]:]</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>cross_XY <span class="op">=</span> pd.DataFrame(</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    cross_XY,</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    index<span class="op">=</span>X.columns,</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    columns<span class="op">=</span>[<span class="ss">f"CanY</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(cca.n_components)]</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Y 변수 ↔ X 정준변수</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>cross_YX <span class="op">=</span> np.corrcoef(Y_std.T, X_c.T)[:Y.shape[<span class="dv">1</span>], Y.shape[<span class="dv">1</span>]:]</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>cross_YX <span class="op">=</span> pd.DataFrame(</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    cross_YX,</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    index<span class="op">=</span>Y.columns,</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    columns<span class="op">=</span>[<span class="ss">f"CanX</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(cca.n_components)]</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>cross_XY, cross_YX</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>교차적재량은 한 변수군의 개별 변수가 상대 변수군의 정준변수와 얼마나 직접적으로 연결되는지를 보여주는 지표이다. 본 분석에서 X 변수군(학습투입)의 교차적재량을 살펴보면, 제1정준축(CanY1)에서 <em>assignment</em>가 0.36으로 가장 큰 값을 나타내어, 학습투입 변수 중 과제 수행이 학습성과 측 정준변수와 가장 밀접하게 관련되어 있음을 알 수 있다. 반면 <em>study_time</em>과 <em>participation</em>은 매우 작은 값을 보이며, <em>attendance</em> 역시 −0.11 수준에 그쳐 학습성과 정준축과의 직접적인 연관성은 크지 않은 것으로 나타난다. 이는 학습투입 중에서도 단순한 시간 투자나 출석보다는 과제 수행이 성과 측 정준구조와 실질적으로 연결되는 핵심 요소임을 시사한다.</p>
<p>Y 변수군(학습성과)의 교차적재량을 보면, 제1정준축(CanX1)에서 <em>achievement</em>가 −0.29로 가장 큰 절댓값을 보이며, <em>project</em>는 0.17로 제한적인 기여를 하고 있다. 반면 <em>exam</em>은 거의 0에 가까운 값을 보여 학습투입 정준변수와의 직접적인 관련성이 거의 없음을 확인할 수 있다. 이는 학습성과 중에서도 종합적인 성취도가 학습투입 구조와 가장 밀접하게 연결되어 있으며, 시험 점수는 이 정준관계에서 중심적인 역할을 하지 않는다는 점을 의미한다.</p>
<p>제2정준축(CanY2, CanX2)에서는 모든 교차적재량 값이 전반적으로 작게 나타난다. X 변수군에서는 <em>participation</em>이 0.14로 상대적으로 큰 값을 보이지만 절댓값 기준으로 해석 임계치에는 미치지 못하며, Y 변수군에서도 <em>project</em>와 <em>achievement</em>가 각각 −0.16, −0.13 수준에 그친다. 이는 제2정준관계가 두 변수군 사이의 추가적인 독립적 연관 구조를 충분히 설명하지 못함을 시사하며, 앞서 정준상관계수의 유의성 검정 결과와도 일관된 해석이다.</p>
<p>종합하면, 교차적재량 분석 결과는 과제 수행 중심의 학습투입이 종합적 학습 성취도와 가장 직접적으로 연결되어 있음을 보여주며, 단순한 시험 점수나 출석, 학습 시간은 정준관계의 핵심 연결 고리로 작용하지 않는 것으로 나타난다. 이러한 결과는 정준적재량 해석에서 도출된 구조를 교차적 관점에서 다시 확인해 주는 보완적 증거로 이해할 수 있다.</p>
<p>( CanY1 CanY2 <br> study_time 0.009878 0.044975 <br> attendance -0.110385 -0.069362 <br> assignment 0.360666 -0.055188 <br> participation 0.059028 0.142663,</p>
<p>CanX1 CanX2 <br> exam -0.001975 0.033933 <br> project 0.169384 -0.164955 <br> achievement -0.291048 -0.125320)</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">#제1 정준변수 산점도</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">5</span>))</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>plt.scatter(X_c[:, <span class="dv">0</span>], Y_c[:, <span class="dv">0</span>])</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>plt.axhline(<span class="dv">0</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="dv">0</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Canonical Variable U1 (X)"</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Canonical Variable V1 (Y)"</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"First Canonical Variable Scatter"</span>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>제1정준변수 산점도는 X 변수군의 제1정준변수(U1)와 Y 변수군의 제1정준변수(V1) 사이에 완만한 양<strong>(+)</strong>의 선형 경향이 존재함을 시각적으로 보여준다. 이는 제1정준상관계수(ρ = 0.376)가 양의 값을 갖는다는 점과 일관된다. 다만 점들의 분포가 대각선 방향으로 조밀하게 집중되어 있지 않고, 사분면 전반에 비교적 넓게 흩어져 있어 관계의 강도는 제한적임을 알 수 있다.</p>
<p>정준적재량을 함께 고려하면, 제1정준변수(U1)는 X 변수군 중에서 과제 수행 정도(assignment)의 기여가 압도적으로 크며, 나머지 변수들(study_time, attendance, participation)은 상대적으로 작은 적재량을 보인다. 따라서 U1 축의 양(+) 방향은 주로 과제 수행 수준이 높은 학습자를 의미하는 축으로 해석할 수 있다.</p>
<p>한편, Y 변수군의 제1정준변수(V1)는 achievement(성취도)가 큰 음(-)의 적재량을 가지며, project는 중간 정도의 양(+) 적재량을 보인다. 이는 V1 축이 단일 성과 지표라기보다는 성과 구성 간의 대비 구조를 반영하고 있음을 시사한다.</p>
<p>이러한 적재량 구조를 바탕으로 산점도를 해석하면, 우상단 사분면에 위치한 관측치는 과제 수행 수준이 높고<strong>(project</strong> 중심의 성과가 상대적으로 높은<strong>)</strong> 집단으로, 좌하단 사분면의 관측치는 과제 수행 수준이 낮고 성취도 중심 성과가 상대적으로 높은 집단으로 해석할 수 있다. 그러나 사분면 간 경계가 명확하지 않고 중심부에 많은 점들이 분포해 있다는 점에서, 이러한 구분은 뚜렷한 군집이라기보다는 경향 수준의 해석에 그친다.</p>
<p>종합하면, 제1정준변수 산점도는 정준적재량에서 확인된 핵심 변수(assignment, achievement)의 구조를 반영하여 두 변수군 간의 약한 공통 경향을 시각적으로 보여주지만, 점 분포의 산포가 커 강한 구조적 연관성이나 명확한 집단 구분을 주장하기에는 한계가 있다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/cancorr_scatter.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
</section>
</section>
<section id="chapter-2.-다변량분산분석" class="level3">
<h3 class="anchored" data-anchor-id="chapter-2.-다변량분산분석">Chapter 2. 다변량분산분석</h3>
<section id="다변량분산분석이란" class="level4">
<h4 class="anchored" data-anchor-id="다변량분산분석이란">1. 다변량분산분석이란?</h4>
<section id="개념과-필요성" class="level5">
<h5 class="anchored" data-anchor-id="개념과-필요성">개념과 필요성</h5>
<p>분산분석은 집단 간 평균 차이가 존재하는지를 검정하는 통계적 방법이다. 예를 들어, 한 지역에 세 개의 호수가 존재할 때 호수별 산소량에 차이가 있는지를 알고자 한다면, 호수를 요인으로 하는 일원 분산분석을 통해 각 호수의 평균 산소량 차이를 검정할 수 있다. 또한 호수의 오염 정도를 파악하기 위해 수은 함유량을 측정하였다면, 이 역시 호수별 평균 수은 함유량의 차이를 일원 분산분석으로 분석할 수 있다. 이처럼 하나의 종속변수에 대해 집단 간 평균 차이를 검정하는 경우에는 단변량 분산분석으로 충분하다.</p>
<p>그러나 실제 문제에서는 관심 있는 종속변수가 하나에 그치지 않는 경우가 많다. 예를 들어 호수의 수질 상태를 평가할 때 산소량과 수은 함유량은 서로 독립적인 특성이 아니라 일정한 상관관계를 가질 가능성이 크다. 이러한 상황에서 산소량과 수은 함유량을 각각 따로 분산분석으로 검정한다면, 두 변수 간의 상관 구조를 무시한 채 부분적인 결론만을 얻게 된다. 이 경우 각 변수에 대해 반복적으로 검정을 수행함으로써 제1종 오류가 증가하는 문제도 발생할 수 있다.</p>
<p>이처럼 분산분석에서 동시에 고려해야 할 종속변수가 두 개 이상인 경우, 이들 변수 간의 상관관계를 반영하여 집단 간 차이를 검정하는 방법이 다변량 분산분석이다. 다변량 분산분석은 여러 종속변수를 하나의 평균 벡터로 묶어 집단 간 차이를 검정함으로써, 단변량 분석으로는 포착하기 어려운 종합적인 차이를 평가할 수 있도록 한다. 즉, 다변량 분산분석은 개별 변수의 평균 차이가 아니라, 종속변수들의 결합된 구조적 차이를 분석하는 방법이다.</p>
<p>다변량 분산분석은 심리학, 사회과학, 교육학 등 다양한 분야에서 특히 유용하다. 예를 들어 근심 지수, 불면 지수, 불쾌 지수와 같이 서로 상관된 여러 심리적 지표를 동시에 고려할 때, 성별이나 재산 수준에 따른 차이를 분석하기 위해 다변량 분산분석을 적용하는 것이 바람직하다. 이러한 경우 각각의 지표를 따로 분석하는 것보다, 여러 지표를 하나의 다변량 반응으로 다루는 것이 현상을 보다 정확하고 일관되게 설명할 수 있다. 요인이 하나인 경우에는 이를 일원 다변량 분산분석이라 하며, 요인이 둘 이상인 경우에는 이원 또는 다원 다변량 분산분석으로 확장된다.</p>
<p>일원 다변량 분산분석은 본질적으로 집단 간 다변량 평균 벡터의 차이를 검정하는 방법이다. 다시 말해, 여러 종속변수로 구성된 평균 벡터가 집단에 따라 동일한지 여부를 검정하는 것이다. 본 교재에서는 개념 이해와 방법론적 설명의 명확성을 위해 일원 다변량 분산분석을 중심으로 다루며, 이원 다변량 분산분석은 단변량 분산분석의 확장과 유사한 방식으로 이해할 수 있음을 함께 제시한다.</p>
</section>
<section id="정준상관분석과-관계" class="level5">
<h5 class="anchored" data-anchor-id="정준상관분석과-관계">정준상관분석과 관계</h5>
<p>다변량 분산분석(MANOVA)은 집단 간에 여러 종속변수로 이루어진 평균 벡터의 차이가 존재하는지를 검정하는 방법이다. MANOVA의 1차적인 목적은 집단 효과의 존재 여부를 판단하는 데 있으며, 이 단계에서는 Wilks<span dir="rtl">’</span> Lambda, Pillai의 추적, Hotelling–Lawley 추적과 같은 다변량 검정 통계량을 통해 전체적인 차이가 유의한지를 평가한다. 그러나 이러한 검정 결과만으로는 집단 간 차이가 구체적으로 어떤 방향과 구조를 통해 나타나는지를 파악하기 어렵다.</p>
<p>이때 MANOVA의 해석 단계에서 핵심적인 역할을 하는 것이 정준변수이다. MANOVA는 본질적으로 집단 효과를 가장 잘 분리하는 종속변수들의 선형결합을 찾는 문제로 해석할 수 있으며, 이 선형결합이 바로 정준변수에 해당한다. 즉, 정준변수는 집단 간 차이를 최대화하도록 구성된 종속변수의 요약 축으로, MANOVA에서 관측된 집단 효과가 어떤 다변량 방향에서 가장 뚜렷하게 나타나는지를 설명해 준다.</p>
<p>MANOVA에서의 정준변수는 집단 요인과 종속변수 집합 사이의 관계를 정준상관의 관점에서 이해할 수 있게 한다. 집단을 나타내는 범주형 요인은 적절한 지시변수 형태로 표현될 수 있으며, 이 집단 정보와 종속변수 집합 사이의 관계를 정준상관분석으로 해석하면, 집단 차이를 가장 잘 설명하는 정준축이 도출된다. 따라서 MANOVA의 정준변수는 집단 구분을 최대로 드러내는 방향으로 종속변수들이 결합된 결과라고 볼 수 있다.</p>
<p>정준변수 해석을 통해 연구자는 단순히 <span dir="rtl">”</span>집단 간 차이가 있다”는 결론을 넘어서, 어떤 종속변수들이 결합되어 집단 차이를 주도하는지를 파악할 수 있다. 정준적재량을 살펴보면 각 종속변수가 해당 정준변수에 기여하는 정도를 확인할 수 있으며, 이를 통해 집단 차이의 실질적 내용을 해석할 수 있다. 다시 말해, 정준변수는 MANOVA 결과를 해석 가능한 잠재 차원으로 전환하는 역할을 수행한다.</p>
<p>요약하면, MANOVA는 집단 간 다변량 평균 차이의 존재 여부를 검정하는 단계이며, 정준변수 해석은 그 차이가 어떤 다변량 구조를 통해 형성되는지를 설명하는 단계이다. 이 두 단계는 서로 분리된 분석이 아니라, MANOVA의 검정 결과를 구조적으로 해석하기 위해 정준변수 분석이 필연적으로 뒤따르는 하나의 연속적인 과정으로 이해하는 것이 바람직하다. MANOVA에서 정준변수는 집단 효과의 방향과 성격을 밝혀주는 핵심적인 해석 도구라 할 수 있다.</p>
</section>
</section>
<section id="다변량분산분석-모형과-추정" class="level4">
<h4 class="anchored" data-anchor-id="다변량분산분석-모형과-추정">2. 다변량분산분석 모형과 추정</h4>
<section id="다변량-선형모형의-기본-설정" class="level5">
<h5 class="anchored" data-anchor-id="다변량-선형모형의-기본-설정">다변량 선형모형의 기본 설정</h5>
<p>다변량분석에서는 각 개체 i에 대해 하나의 반응값이 아닌, p차원의 반응벡터가 관측된다.</p>
<p><span class="math inline">\(\mathbf{y}_{i} = \left( \begin{array}{r}
y_{i1} \\
y_{i2} \\
\vdots \\
y_{ip}
\end{array} \right),i = 1,\ldots,n\)</span> 이를 행렬 형태로 모으면 다음과 같은 다변량 선형모형이 된다.</p>
<p><span class="math inline">\(\mathbf{Y} = \mathbf{XB} + \mathbf{E}\)</span>, 여기서 <span class="math inline">\(\mathbf{Y}(n \times p)\)</span>는 반응변수 행렬, <span class="math inline">\(\mathbf{X}(n \times k)\)</span>는 설계행렬 (요인 또는 설명변수), <span class="math inline">\(\mathbf{B}(k \times p)\)</span>는 모수 행렬, 그리고 <span class="math inline">\(\mathbf{E}(n \times p)\)</span>는 오차 행렬이다.</p>
</section>
<section id="확률적-가정-오차-구조" class="level5">
<h5 class="anchored" data-anchor-id="확률적-가정-오차-구조">확률적 가정 (오차 구조)</h5>
<p>각 행의 오차벡터 <span class="math inline">\(\mathbf{\varepsilon}_{i}\)</span>는 다음을 따른다고 가정한다. <span class="math inline">\(\mathbf{\varepsilon}_{i} \sim N_{p}(\mathbf{0},\mathbf{\Sigma})\)</span>. 즉, 평균은 0 벡터, 공분산 행렬은 <span class="math inline">\(\mathbf{\Sigma}\)</span>이며, 서로 독립이다. 행렬 형태로는 <span class="math inline">\(\mathbf{E} \sim MN_{n \times p}(\mathbf{0},\mathbf{I}_{n},\mathbf{\Sigma})\)</span>로 표현할 수 있다.</p>
</section>
<section id="모수-추정-최소제곱-및-최대우도" class="level5">
<h5 class="anchored" data-anchor-id="모수-추정-최소제곱-및-최대우도">모수 추정 (최소제곱 및 최대우도)</h5>
<p><strong>모수 행렬 <span class="math inline">\(\mathbf{B}\)</span>의 추정</strong></p>
<p>다변량 최소제곱 추정량은 <span class="math inline">\(\widehat{\mathbf{B}} = (\mathbf{X}^{\top}\mathbf{X})^{- 1}\mathbf{X}^{\top}\mathbf{Y}\)</span>이며, 이는 각 종속변수에 대해 동시에 최소제곱을 적용한 결과이다.</p>
<p><strong>공분산 행렬 <span class="math inline">\(\mathbf{\Sigma}\)</span>의 추정</strong></p>
<p>잔차행렬 <span class="math inline">\(\widehat{\mathbf{E}} = \mathbf{Y} - \mathbf{X}\widehat{\mathbf{B}}\)</span>를 이용하여 <span class="math inline">\(\widehat{\mathbf{\Sigma}} = \frac{1}{n - k}{\widehat{\mathbf{E}}}^{\top}\widehat{\mathbf{E}}\)</span>로 추정한다.</p>
</section>
<section id="manova에서의-변동-행렬-분해" class="level5">
<h5 class="anchored" data-anchor-id="manova에서의-변동-행렬-분해">MANOVA에서의 변동 행렬 분해</h5>
<p>MANOVA에서는 전체 변동을 행렬 단위로 분해한다. <span class="math inline">\(\mathbf{T} = \mathbf{H} + \mathbf{E}\)</span>, 여기서 <span class="math inline">\(\mathbf{T}\)</span>는 전체 변동 행렬(Total SSCP), <span class="math inline">\(\mathbf{H}\)</span>는 집단 간 변동 행렬 (Hypothesis SSCP), 그리고 <span class="math inline">\(\mathbf{E}\)</span>는 집단 내 변동 행렬 (Error SSCP)이다. 이는 단변량 ANOVA의 <span class="math inline">\(SS_{T} = SS_{B} + SS_{W}\)</span>의 다변량 확장이다.</p>
</section>
<section id="manova-검정-통계량" class="level5">
<h5 class="anchored" data-anchor-id="manova-검정-통계량">MANOVA 검정 통계량</h5>
<p><strong>Wilks<span dir="rtl">’</span> Lambda</strong>: <span class="math inline">\(\Lambda = \frac{|\mathbf{E}|}{|\mathbf{H} + \mathbf{E}|}\)</span> → 집단 간 변동이 클수록 \Lambda는 작아진다.</p>
<p><strong>Pillai</strong>의 추적: <span class="math inline">\(V = tr\left( \mathbf{H}(\mathbf{H} + \mathbf{E})^{- 1} \right)\)</span></p>
<p><strong>Hotelling–Lawley</strong> 추적: <span class="math inline">\(U = tr(\mathbf{E}^{- 1}\mathbf{H})\)</span></p>
</section>
<section id="정준변수와의-수식적-연결" class="level5">
<h5 class="anchored" data-anchor-id="정준변수와의-수식적-연결">정준변수와의 수식적 연결</h5>
<p>MANOVA에서 정준변수는 다음의 일반화된 고유값 문제의 해로 정의된다. <span class="math inline">\(|\mathbf{H} - \lambda\mathbf{E}| = 0\)</span>, 여기서 <span class="math inline">\(\lambda_{1} \geq \lambda_{2} \geq \cdots\)</span>는 정준근(canonical roots)이고 각 고유벡터가 정준변수의 계수에 해당된다.</p>
<p>정준변수는 <span class="math inline">\(\mathbf{u} = \mathbf{a}^{\top}\mathbf{Y}\)</span> 형태의 선형결합으로 나타나며, 집단 간 분리를 최대화하는 방향이다.</p>
</section>
<section id="정준상관분석cca-모형과의-통합-표현" class="level5">
<h5 class="anchored" data-anchor-id="정준상관분석cca-모형과의-통합-표현">정준상관분석(CCA) 모형과의 통합 표현</h5>
<p>두 변수군 <span class="math inline">\(\mathbf{X},\mathbf{Y}\)</span>에 대해 <span class="math inline">\(\mathbf{u} = \mathbf{a}^{\top}\mathbf{X},\mathbf{v} = \mathbf{b}^{\top}\mathbf{Y}\)</span>가 되도록 <span class="math inline">\(\max_{\mathbf{a},\mathbf{b}}corr(\mathbf{u},\mathbf{v})\)</span> 를 만족하는 <span class="math inline">\(\mathbf{a},\mathbf{b}\)</span>를 찾는다. 이 역시 공분산 행렬을 이용한 고유값 문제로 귀결되며, MANOVA의 정준변수와 동일한 수학적 구조를 가진다.</p>
</section>
<section id="모형-관점에서의-통합-정리" class="level5">
<h5 class="anchored" data-anchor-id="모형-관점에서의-통합-정리">모형 관점에서의 통합 정리</h5>
<p>다변량 선형모형: <span class="math inline">\(\mathbf{Y} = \mathbf{XB} + \mathbf{E}\)</span>, 집단 효과에 대한 <span class="math inline">\(\mathbf{H}\)</span>와 <span class="math inline">\(\mathbf{E}\)</span> 비교</p>
<p>정준분석: <span class="math inline">\(\mathbf{H}\)</span>와 <span class="math inline">\(\mathbf{E}\)</span>의 고유값 분해</p>
<p>즉, MANOVA와 정준분석은 동일한 모형의 서로 다른 해석 단계이다. 다변량분석은 반응변수를 벡터로 취급하는 선형모형을 기반으로 하며, 모수 추정은 최소제곱 및 최대우도 원리에 의해 이루어진다. MANOVA에서는 변동을 행렬로 분해하고, 정준분석에서는 이 행렬 구조를 고유값 문제로 변환하여 집단 차이를 최대화하는 잠재 축을 도출한다.</p>
</section>
</section>
<section id="사례연구" class="level4">
<h4 class="anchored" data-anchor-id="사례연구">3. 사례연구</h4>
<section id="데이터-만들기" class="level5">
<h5 class="anchored" data-anchor-id="데이터-만들기">데이터 만들기</h5>
<p>이 데이터는 호수 유형(lake: Lake_A, Lake_B, Lake_C)이라는 하나의 범주형 요인이, 산소량(oxygen)과 수은 함유량(mercury)이라는 두 개의 연속형 종속변수의 결합된 평균 벡터에 차이를 유발하는지를 검정하기 위해 설정되었다. 즉, 관심의 초점은 개별 변수의 평균 차이가 아니라, 두 환경 지표를 동시에 고려했을 때 호수 간에 통계적으로 유의한 차이가 존재하는가에 있다.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 설정: 3개 집단, 각 40명</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>groups <span class="op">=</span> [<span class="st">"Lake_A"</span>, <span class="st">"Lake_B"</span>, <span class="st">"Lake_C"</span>]</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>n_per <span class="op">=</span> <span class="dv">40</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 종속변수 2개: oxygen, mercury (서로 상관되도록 공분산 설정)</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>Sigma <span class="op">=</span> np.array([[<span class="fl">1.0</span>, <span class="op">-</span><span class="fl">0.6</span>],</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>                  [<span class="op">-</span><span class="fl">0.6</span>, <span class="fl">1.0</span>]])   <span class="co"># 산소량-수은함유량 음의 상관</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="co"># 집단별 평균(다변량 평균 벡터): 집단 차이를 일부러 줌</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> {</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Lake_A"</span>: np.array([ <span class="fl">0.8</span>, <span class="op">-</span><span class="fl">0.6</span>]),</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Lake_B"</span>: np.array([ <span class="fl">0.0</span>,  <span class="fl">0.0</span>]),</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Lake_C"</span>: np.array([<span class="op">-</span><span class="fl">0.7</span>,  <span class="fl">0.7</span>]),</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>rows <span class="op">=</span> []</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> g <span class="kw">in</span> groups:</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    Y <span class="op">=</span> np.random.multivariate_normal(mean<span class="op">=</span>mu[g], cov<span class="op">=</span>Sigma, size<span class="op">=</span>n_per)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_per):</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        rows.append([g, Y[i, <span class="dv">0</span>], Y[i, <span class="dv">1</span>]])</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(rows, columns<span class="op">=</span>[<span class="st">"lake"</span>, <span class="st">"oxygen"</span>, <span class="st">"mercury"</span>])</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.head())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>lake oxygen mercury <br> 0 Lake_A 0.293892 -0.217559 <br> 1 Lake_A 0.901809 0.660430 <br> (이하 생략)</p>
</section>
<section id="요인별-기술통계량" class="level5">
<h5 class="anchored" data-anchor-id="요인별-기술통계량">요인별 기술통계량</h5>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">#호수별 산소량-수은 평균, 표준편차 출력</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>summary <span class="op">=</span> df.groupby(<span class="st">"lake"</span>).agg(</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    oxygen_mean<span class="op">=</span>(<span class="st">"oxygen"</span>, <span class="st">"mean"</span>),</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    oxygen_sd<span class="op">=</span>(<span class="st">"oxygen"</span>, <span class="st">"std"</span>),</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    mercury_mean<span class="op">=</span>(<span class="st">"mercury"</span>, <span class="st">"mean"</span>),</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    mercury_sd<span class="op">=</span>(<span class="st">"mercury"</span>, <span class="st">"std"</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(summary)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>호수별 기술통계를 살펴보면, Lake_A는 평균 산소량이 가장 높고 수은 함유량은 가장 낮은 반면, Lake_C는 산소량 평균이 가장 낮고 수은 평균은 가장 높게 나타난다. Lake_B는 두 변수 모두에서 중간적인 수준을 보이며, 세 호수 간에 산소량과 수은 함유량의 조합에서 뚜렷한 차이가 존재함을 시사한다. 이러한 결과는 두 종속변수를 동시에 고려하는 다변량분산분석의 필요성을 뒷받침한다.</p>
<p>oxygen_mean oxygen_sd mercury_mean mercury_sd <br> Lake_A 0.921449 0.892285 -0.788171 0.916423 <br> Lake_B 0.106840 0.923339 -0.049165 0.947157 <br> Lake_C -0.603968 0.950955 0.820634 0.941350</p>
</section>
<section id="다변량분산분석" class="level5">
<h5 class="anchored" data-anchor-id="다변량분산분석">다변량분산분석</h5>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> statsmodels.multivariate.manova <span class="im">import</span> MANOVA</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co"># MANOVA 적합</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>maov <span class="op">=</span> MANOVA.from_formula(<span class="st">'oxygen + mercury ~ lake'</span>, data<span class="op">=</span>df)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co"># mv_test 결과에서 lake 부분만 선택 출력</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> maov.mv_test()</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(res.results[<span class="st">'lake'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>본 다변량분산분석은 호수 유형에 따라 산소량과 수은 함유량으로 구성된 다변량 평균 벡터가 동일한지를 검정한 것이다. 즉, 관심의 대상은 개별 변수의 평균 차이가 아니라, 두 환경 지표를 동시에 고려했을 때 호수 간 환경 구조에 차이가 존재하는가이다.</p>
<p>호수 요인에 대해 보고된 네 가지 다변량 검정 통계량이 모두 매우 작은 p-value(p &lt; 0.001)를 보이며 일관되게 유의하게 나타났다. 이는 어떤 검정 기준을 적용하더라도 호수 유형에 따라 산소량과 수은 함유량의 결합된 평균 구조가 통계적으로 유의하게 다르다는 것을 의미한다. 특히 Wilks<span dir="rtl">’</span> Lambda = 0.6039라는 값은, 집단 내 변동에 비해 집단 간 변동이 상당한 비중을 차지하고 있음을 시사한다. 다시 말해, 두 종속변수를 동시에 고려할 때 호수 간 차이는 우연적 변동으로 설명되기 어려운 수준이며, 환경 특성이 다변량 공간에서 뚜렷이 구분된다고 해석할 수 있다.</p>
<p>이 결과는 산소량과 수은 함유량이 서로 상관된 변수라는 점에서 더욱 의미를 가진다. MANOVA는 이러한 공분산 구조를 고려한 상태에서 집단 효과를 검정하므로, 단변량 ANOVA를 각각 수행하는 것보다 환경 상태의 종합적 차이를 보다 적절하게 반영한다. 따라서 본 단계의 결론은 <span dir="rtl">”</span>어떤 변수가 더 중요한가”가 아니라, <span dir="rtl">”</span>호수 유형이 환경 프로파일 전체에 영향을 미치는가”에 대한 판단이다.</p>
<p>종합하면, 본 MANOVA 결과는 호수 유형이 산소량과 수은 함유량으로 구성된 다변량 환경 특성에 유의한 영향을 미친다는 것을 명확히 보여준다. 이 결론을 바탕으로 이후 단계에서 정준판별축, LDA 계수, 또는 사후 단변량 분석을 통해 어떤 방향에서, 어떤 변수 조합이 호수 간 차이를 주도하는지를 보조적으로 해석하는 것이 논리적으로 타당하다.</p>
<p>{'stat': Value Num DF Den DF F Value Pr &gt; F <br> Wilks' lambda 0.603905 4 232.0 16.635179 0.0 <br> Pillai's trace 0.397509 4.0 234.0 14.51131 0.0 <br> Hotelling-Lawley trace 0.653548 4 138.166667 18.899687 0.0 <br> Roy's greatest root 0.649946 2 117 38.021819 0.0,</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">#사후 해석용: 단변량 ANOVA(참고)</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.formula.api <span class="im">as</span> smf</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> statsmodels.stats.anova <span class="im">import</span> anova_lm</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>m1 <span class="op">=</span> smf.ols(<span class="st">"oxygen ~ C(lake)"</span>, data<span class="op">=</span>df).fit()</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>m2 <span class="op">=</span> smf.ols(<span class="st">"mercury ~ C(lake)"</span>, data<span class="op">=</span>df).fit()</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"ANOVA: oxygen"</span>)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(anova_lm(m1, typ<span class="op">=</span><span class="dv">2</span>), <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"ANOVA: mercury"</span>)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(anova_lm(m2, typ<span class="op">=</span><span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>산소량(oxygen)에 대한 해석</strong></p>
<p>호수 유형(lake)에 따른 산소량의 평균 차이를 검정한 결과, 집단 효과가 매우 유의하게 나타났다 (F = 27.38, p &lt; 0.001). 이는 세 호수 간에 산소량 평균이 동일하다는 귀무가설을 기각할 수 있음을 의미한다.<br>
즉, 호수 유형에 따라 산소 공급 상태 또는 수질 환경이 통계적으로 뚜렷하게 구분된다고 해석할 수 있다.</p>
<p><strong>수은 함유량(mercury)에 대한 해석</strong></p>
<p>수은 함유량에 대해서도 호수 유형의 효과가 매우 유의하게 나타났다<br>
(F = 29.67, p &lt; 0.001). 이는 세 호수 간에 수은 오염 수준의 평균이 유의하게 다르다는 것을 의미하며, 호수 유형에 따라 오염 정도가 체계적으로 구분된다는 해석이 가능하다.</p>
<p><strong>MANOVA 결과와의 관계에서의 위치 정리 </strong> 이 두 단변량 ANOVA 결과는 앞선 MANOVA에서 확인된 다변량 집단 차이를 각 종속변수 수준에서 구체화해 주는 보조적 증거에 해당한다.</p>
<p>MANOVA → 산소량과 수은 함유량을 동시에 고려했을 때 호수 유형 간 환경 프로파일이 다르다.</p>
<p>단변량 ANOVA → 그 차이가 산소량과 수은 함유량 각각에서도 모두 유의하게 나타난다.</p>
<p>따라서 본 결과는 호수 유형에 따른 환경 차이는 특정 단일 지표에 국한되지 않고, 산소량과 수은 함유량 모두에서 일관되게 관찰된다는 점을 뒷받침한다.</p>
<p>ANOVA: oxygen <br> sum_sq df F PR(&gt;F) <br> C(lake) 46.609756 2.0 27.384833 1.755918e-10 <br> Residual 99.568645 117.0 NaN NaN</p>
<p>ANOVA: mercury <br> sum_sq df F PR(&gt;F) <br> C(lake) 51.879101 2.0 29.666932 3.786457e-11 <br> Residual 102.300010 117.0 NaN NaN</p>
<p><strong>호수별 산소량, 수은량 평균 비교 측면에서 해석</strong></p>
<p>Lake_A는 산소량 평균이 0.92로 가장 높고, 수은 함유량 평균은 –0.79로 가장 낮아, 산소가 풍부하고 수은 오염 수준이 낮은 환경을 나타낸다. 반면 Lake_C는 산소량 평균이 –0.60으로 가장 낮고, 수은 함유량 평균이 0.82로 가장 높아, 산소 부족과 높은 수은 오염이 동시에 나타나는 환경으로 해석된다. Lake_B는 두 변수 모두 평균이 0 부근에 위치하여, 중간적 성격의 환경 상태를 보인다.</p>
<p>한편, 산소량과 수은 함유량의 표준편차는 세 호수 모두에서 유사한 수준(약 0.89~0.95)으로 나타나, 집단 간 차이는 변동성의 크기보다는 평균 위치의 이동, 즉 다변량 평균 구조의 차이에 의해 주도되고 있음을 시사한다. 이는 MANOVA에서 관측된 집단 효과가 특정 집단의 분산 증가 때문이 아니라, 환경 특성의 체계적인 수준 차이에 기인함을 뒷받침한다.</p>
<p>종합하면, 본 결과는 호수 유형에 따라 “Lake_A → 고산소·저수은, Lake_B → 중간적 환경, Lake_C → 저산소·고수은” 이라는 뚜렷한 다변량 환경 프로파일 차이가 존재함을 보여준다. 이러한 평균 구조의 대비가 MANOVA에서 확인된 유의한 집단 효과의 실질적 해석 근거에 해당한다.</p>
</section>
<section id="선형판별분석lda-linear-discriminant-analysis" class="level5">
<h5 class="anchored" data-anchor-id="선형판별분석lda-linear-discriminant-analysis">선형판별분석(LDA, Linear Discriminant Analysis</h5>
<p>선형판별분석(여러 변수의 선형결합 중에서 집단 간 분리를 가장 크게 만드는 축을 찾는 분석)을 이용해 호수를 가장 잘 구분하는 1차 판별축 점수를 계산한 것이다.</p>
<p>연속형 설명변수 산소량과 수은 함유량을 어떤 비율로 묶으면 세 호수가 가장 잘 분리되는가? 그 결과가 1차 판별축 점수이다.</p>
<p><span class="math inline">\(z_{i} = a \times Oxygen_{i} + b \times Mercury_{i}\)</span>, a,b는 집단 간 분산 / 집단 내 분산 비율을 최대화하도록 추정된 계수이다. 즉, 집단 평균 벡터 사이 거리를 가장 크게 만드는 방향이다. 이 LDA 계수는 <span dir="rtl">”</span>누구를 어디로 분류할 것인가”를 위한 가중치이며, 해석의 핵심은 산소–수은의 대비 구조가 집단 분리를 만든다는 점이다.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">#집단 분리 축(정준변수 관점) 간단 시각화</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.discriminant_analysis <span class="im">import</span> LinearDiscriminantAnalysis</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> df[[<span class="st">"oxygen"</span>, <span class="st">"mercury"</span>]].values</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> df[<span class="st">"lake"</span>].values</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>lda <span class="op">=</span> LinearDiscriminantAnalysis(n_components<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> lda.fit_transform(X, y).ravel()</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">7</span>,<span class="dv">4</span>))</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> g <span class="kw">in</span> groups:</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    plt.hist(z[y<span class="op">==</span>g], bins<span class="op">=</span><span class="dv">12</span>, alpha<span class="op">=</span><span class="fl">0.6</span>, label<span class="op">=</span>g)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Group separation along 1st discriminant axis (interpretation aid)"</span>)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Axis score"</span>)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Frequency"</span>)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"LDA coefficients for axis:"</span>, lda.coef_)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>LDA coefficients for axis: [[ 0.61766397 -0.59103148] <br> [-0.08770726 -0.09303387] <br> [-0.52995671 0.68406535]]</p>
<p>판별축은 산소량(+)과 수은 함유량(–)의 선형결합으로 구성된 축으로,앞선 결과를 종합하면 오른쪽으로 갈수록 저산소·고수은, 왼쪽으로 갈수록 고산소·저수은을 의미하는 환경 대비 축이다.</p>
<p>Lake_A: 분포가 주로 음(-)의 영역에 위치, 판별축 값이 낮음 → 산소량이 높고 수은 함유량이 낮은 환경이 지배적 → Lake_A의 대표적 환경 특성을 잘 반영</p>
<p>Lake_B: 분포가 0 근처를 중심으로 비교적 넓게 퍼짐, 음·양 영역 모두에 일부 중첩 → 중간적·전이적 성격의 환경 → Lake_A와 Lake_C 사이의 완충 집단 역할</p>
<p>Lake_C: 분포가 양(+)의 영역에 집중, 판별축 값이 가장 큼 → 산소량이 낮고 수은 함유량이 높은 환경 → Lake_C의 환경적 불리함(오염·저산소)을 명확히 반영</p>
<p>중첩(overlap)에 대한 해석: 히스토그램을 보면 Lake_A ↔︎ Lake_B, Lake_B ↔︎ Lake_C 사이에 일부 중첩이 존재한다. 이는 다음을 의미한다.</p>
<p><strong>집단 간 차이는 확률적·경향적 차이</strong></p>
<p>완벽한 분리는 아니다. 환경 프로파일의 평균적 차이가 존재함을 보여줄 뿐, 개별 관측치는 일부 겹칠 수 있다. 이는 MANOVA와 LDA의 전형적 결과로, 현실적인 데이터 특성에 부합합니다.</p>
<p><strong>MANOVA 결과와의 연결 해석</strong></p>
<p>MANOVA → 호수 유형에 따라 산소–수은의 결합된 평균 구조가 다르다 (통계적 검정)</p>
<p>LDA 히스토그램 → 그 차이가 어떤 축에서, 어떤 방향으로 나타나는가 (기하학적·시각적 해석)</p>
<p>따라서 이 그림은 MANOVA 결과를 직관적으로 설명하는 보조 도구이다. 제1 판별축 상에서 Lake_A는 음의 영역, Lake_C는 양의 영역에 주로 분포하고 Lake_B는 그 사이에 위치하여, 산소량–수은 함유량의 대비로 형성된 환경 축을 따라 호수 유형이 체계적으로 구분됨을 확인할 수 있다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/manova_lda.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>