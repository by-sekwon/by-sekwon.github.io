<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>다변량분석 5. 군집분석(계층적, 비계층적방법) – 세상 모든 통계 이야기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-1b3e43c72e8be34557c75123b0b69e0d.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-302e6895c9654fb97c48ad8f826d3f42.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">세상 모든 통계 이야기</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">기초수학</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-">    
        <li>
    <a class="dropdown-item" href="../../notes/math/function.html">
 <span class="dropdown-text">함수</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math/derivate_integral.html">
 <span class="dropdown-text">미분적분</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math/vector.html">
 <span class="dropdown-text">벡터</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math/matrix.html">
 <span class="dropdown-text">행렬</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--1" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">수리통계</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--1">    
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/probability.html">
 <span class="dropdown-text">확률</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/random_variable.html">
 <span class="dropdown-text">확률변수</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/famous_distribution.html">
 <span class="dropdown-text">유명한분포</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/multi_variate.html">
 <span class="dropdown-text">다변량확률변수</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/random_sample.html">
 <span class="dropdown-text">확률표본_난수생성</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/estimation.html">
 <span class="dropdown-text">추정</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/math_stat/hypothesis_testing.html">
 <span class="dropdown-text">가설검정_신뢰구간</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--2" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">일변량분석</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--2">    
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/concept_of_stat.html">
 <span class="dropdown-text">일변량분석 개념</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/data.html">
 <span class="dropdown-text">데이터와 통계</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/univariate.html">
 <span class="dropdown-text">일변량분석</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/crosstab.html">
 <span class="dropdown-text">교차표분석</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/goodness_of_fits.html">
 <span class="dropdown-text">적합성검정</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/normality.html">
 <span class="dropdown-text">정규변환</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/correlation.html">
 <span class="dropdown-text">상관분석</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/anova.html">
 <span class="dropdown-text">실험설계 분산분석</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/intro_stat/time_series.html">
 <span class="dropdown-text">시계열분석</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--3" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">조사방법론</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--3">    
        <li>
    <a class="dropdown-item" href="../../notes/survey/survey_intro.html">
 <span class="dropdown-text">조사방법 기초</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/sample_design.html">
 <span class="dropdown-text">표본설계</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/questionnaire.html">
 <span class="dropdown-text">설문지</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/nonresponse.html">
 <span class="dropdown-text">무응답 대체</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/data_process.html">
 <span class="dropdown-text">데이터 처리</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/survey_scale.html">
 <span class="dropdown-text">조사지 척도</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/delphi_ahp_conjoint.html">
 <span class="dropdown-text">델파이_AHP_컨조인트</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/survey/psm.html">
 <span class="dropdown-text">PSM 성향점수매칭</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--4" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">회귀분석</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--4">    
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_concept.html">
 <span class="dropdown-text">회귀분석 개념&amp;추정</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_selection.html">
 <span class="dropdown-text">변수선택</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_multicolin.html">
 <span class="dropdown-text">다중공선성</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_diagnosis.html">
 <span class="dropdown-text">회귀진단</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/linear_model/lm_logistic.html">
 <span class="dropdown-text">로지스틱회귀</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--5" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">다변량분석</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--5">    
        <li>
    <a class="dropdown-item" href="../../notes/mda/mda_concepts.html">
 <span class="dropdown-text">다변량분석 개념</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://by-sekwon.github.io/notes/intro_stat/correlation.html#chapter-3.-%EB%8B%A4%EB%B3%80%EB%9F%89-%EC%83%81%EA%B4%80%EA%B3%84%EC%88%98">
 <span class="dropdown-text">다변량 상관계수</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/mda/mda_pca.html">
 <span class="dropdown-text">주성분분석 svd</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/mda/mda_factor.html">
 <span class="dropdown-text">요인분석 구조방정식</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/mda/mda_discriminant.html">
 <span class="dropdown-text">판별분석 Fisher|Logistic</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/mda/mda_cluster.html">
 <span class="dropdown-text">군집분석 계층적|비계층적방법</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/mda/mda_mds_ca.html">
 <span class="dropdown-text">다차원척도법|대응분석</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/mda/mda_cancorr_manova.html">
 <span class="dropdown-text">정준상관분석|다변량분산분석</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-wgpt" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">머신러닝딥러닝 개념 w/GPT</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-wgpt">    
        <li>
    <a class="dropdown-item" href="../../notes/mldl/mldl_concepts01.html">
 <span class="dropdown-text">MLDL AI 통계 01</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/mldl/mldl_concepts02.html">
 <span class="dropdown-text">MLDL AI 통계 02</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/mldl/mldl_concepts.html">
 <span class="dropdown-text">머신러닝 통계적사고</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/mldl/mldl_supervised.html">
 <span class="dropdown-text">지도학습</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/mldl/mldl_unsupervised.html">
 <span class="dropdown-text">비지도학습</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/mldl/mldl_evaluation.html">
 <span class="dropdown-text">모델평가</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/mldl/mldl_deeplearning.html">
 <span class="dropdown-text">딥러닝</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../notes/mldl/mldl_uncertainty.html">
 <span class="dropdown-text">불학실성</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-wgpt-1" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">머신러닝딥러닝 방법론 w/GPT</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-wgpt-1">    
        <li>
    <a class="dropdown-item" href="../../notes/mldlmethod/mldlmethod_introduction.html">
 <span class="dropdown-text">MLDL방법론 서론</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../cardnews/index.html"> 
<span class="menu-text">카드뉴스</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../consult.html"> 
<span class="menu-text">통계상담</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu--6" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">📡스트리밍</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu--6">    
        <li>
    <a class="dropdown-item" href="https://by-sekwonappio-esqshnv7wueapp4da6jrizn.streamlit.app" target="_blank">
 <span class="dropdown-text">실시간주가[5대종목]</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://by-sekwonappio-k5e5n7wasvj3kveyqbwmgc.streamlit.app/" target="_blank">
 <span class="dropdown-text">대전유성구 일기예보</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#chapter-1.-군집분석-개요" id="toc-chapter-1.-군집분석-개요" class="nav-link active" data-scroll-target="#chapter-1.-군집분석-개요">Chapter 1. 군집분석 개요</a>
  <ul>
  <li><a href="#군집분석-개념" id="toc-군집분석-개념" class="nav-link" data-scroll-target="#군집분석-개념">1. 군집분석 개념</a></li>
  </ul></li>
  <li><a href="#chapter-2.-유사성비유사성-척도" id="toc-chapter-2.-유사성비유사성-척도" class="nav-link" data-scroll-target="#chapter-2.-유사성비유사성-척도">Chapter 2. 유사성/비유사성 척도</a>
  <ul>
  <li><a href="#유사성-척도" id="toc-유사성-척도" class="nav-link" data-scroll-target="#유사성-척도">1. 유사성 척도</a></li>
  <li><a href="#비유사성-척도" id="toc-비유사성-척도" class="nav-link" data-scroll-target="#비유사성-척도">2. 비유사성 척도</a></li>
  </ul></li>
  <li><a href="#chapter-3.-계층적-군집분석" id="toc-chapter-3.-계층적-군집분석" class="nav-link" data-scroll-target="#chapter-3.-계층적-군집분석">Chapter 3. 계층적 군집분석</a>
  <ul>
  <li><a href="#군집화-과정" id="toc-군집화-과정" class="nav-link" data-scroll-target="#군집화-과정">1. 군집화 과정</a></li>
  <li><a href="#군집-개수-결정" id="toc-군집-개수-결정" class="nav-link" data-scroll-target="#군집-개수-결정">2. 군집 개수 결정</a></li>
  <li><a href="#사례-실습" id="toc-사례-실습" class="nav-link" data-scroll-target="#사례-실습">3. 사례 실습</a></li>
  </ul></li>
  <li><a href="#chapter-4.-비계층적-군집분석" id="toc-chapter-4.-비계층적-군집분석" class="nav-link" data-scroll-target="#chapter-4.-비계층적-군집분석">Chapter 4. 비계층적 군집분석</a>
  <ul>
  <li><a href="#k-means-방법" id="toc-k-means-방법" class="nav-link" data-scroll-target="#k-means-방법">1. K-means 방법</a></li>
  <li><a href="#k-medoidspam" id="toc-k-medoidspam" class="nav-link" data-scroll-target="#k-medoidspam">2. k-medoids(PAM)</a></li>
  </ul></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">다변량분석 5. 군집분석(계층적, 비계층적방법)</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="chapter-1.-군집분석-개요" class="level3">
<h3 class="anchored" data-anchor-id="chapter-1.-군집분석-개요">Chapter 1. 군집분석 개요</h3>
<section id="군집분석-개념" class="level4">
<h4 class="anchored" data-anchor-id="군집분석-개념">1. 군집분석 개념</h4>
<section id="군집분석-목적-및-개념" class="level5">
<h5 class="anchored" data-anchor-id="군집분석-목적-및-개념">(1) 군집분석 목적 및 개념</h5>
<p>군집분석의 기본 목적은 자료 속에 잠재되어 있는 구조(structure)를 탐색하고, 변수들 간의 유사성에 기반하여 자연스럽게 형성되는 집단(clusters)을 발견하는 데 있다. 즉, 사전에 집단 정보가 주어지지 않은 상황에서 개체들 사이의 거리 또는 유사성을 분석하여, 내재된 패턴을 파악하고 데이터가 어떠한 방식으로 스스로 그룹화되는지를 밝히는 것이 군집분석의 핵심 목표이다.</p>
<p>개체 간의 간격을 직관적으로 파악하기 위해 시각적 도구를 활용할 수 있다. 변수의 개수에 따라 사용되는 대표 시각화 기법은 다음과 같다.</p>
<p>측정 변수가 2개일 때 → 산점도(Scatter Plot)</p>
<p>측정 변수가 3개일 때 → 버블 플롯(Bubble Plot) x축, y축, 버블 크기(또는 색)를 이용하여 3차원 정보를 2D에서 표현</p>
<p>측정 변수가 4개 이상일 때 → 주성분 분석(PCA)을 이용한 산점도, 고차원의 변수를 2~3개의 주성분으로 차원 축소한 뒤 시각적으로 군집 패턴 탐색한다.</p>
</section>
<section id="군집분석과-판별분석-비교" class="level5">
<h5 class="anchored" data-anchor-id="군집분석과-판별분석-비교">(2) 군집분석과 판별분석 비교</h5>
<p>군집분석(clustering)과 판별분석(discriminant analysis)은 모두 개체들을 여러 집단으로 나누거나 구분하는 데 사용되는 다변량 분석 기법이지만, 출발점과 목적, 그리고 사용되는 정보의 종류가 서로 다르다.</p>
<p><strong>군집분석(Clustering)</strong></p>
<p>군집분석은 사전에 집단 정보가 전혀 주어지지 않은 상태에서, 개체들 간의 유사성(similarity) 또는 거리(distance)를 기준으로 집단을 구성하는 방법이다. 즉, 데이터가 관측될 때는 모든 개체가 동일한 상태로 취급되며, 분석 과정에서 서로 가까운 개체끼리 묶어 자연스럽게 군집이 형성되는 비지도 학습(unsupervised learning) 절차이다.</p>
<p>군집 형성 방식은 크게 두 가지로 나눌 수 있다.</p>
<p>계층적 군집분석(Hierarchical clustering): 개체 간 거리가 가까운 것끼리 순차적으로 묶어 나가며, 트리 형태(dendrogram)의 구조를 형성하는 방법이다.</p>
<p>비계층적 군집분석(K-means 등): 군집의 개수 K를 미리 정해두고, 중심점(centroid)을 기준으로 개체를 반복적으로 재배정하여 군집을 형성하는 방법이다.</p>
<p><strong>판별분석(Discriminant Analysis)</strong></p>
<p>판별분석은 군집분석과 달리, 자료 수집 단계에서 이미 집단(label)이 주어진 상태에서 출발한다. 즉, 각 개체가 어느 모집단에 속하는지 정보가 주어져 있으며, 이 정보를 이용하여 집단 간 차이를 가장 잘 설명하는 판별함수를 추정하는 분석이다.</p>
<p>판별분석의 목표는 두 가지이다.</p>
<p>집단 간 차이 설명: 어떤 변수들이 집단 구분에 기여하는지 파악한다.</p>
<p>새로운 개체의 집단 판별: 추정된 판별규칙(classification rule)을 이용하여 새로운 표본이 어느 집단에 속할지를 예측한다.</p>
<p>마케팅 담당자가 고객 세분화를 위해 나이, 학력, 소득, 결혼 상태, 자녀 수, 직업 등의 정보를 수집하였다면, 이와 같은 다변량 정보를 이용하여 고객들을 서로 유사한 특성을 가진 집단으로 묶는 방법이 바로 군집분석이다. 군집분석은 개체 간의 유사성 또는 거리 측정을 바탕으로, 자료 속에 내재된 구조를 찾아 자연스럽게 형성되는 고객 그룹을 탐색하는 비지도 학습(unsupervised) 기법이다.</p>
<p>군집분석의 중요한 특징은 분석 전에는 어떤 개체가 어떤 그룹에 속하는지, 그리고 그룹이 몇 개인지조차 알려져 있지 않다는 점이다. 다시 말해, 집단의 이름과 개수는 분석이 수행된 후에야 결정된다. 이러한 이유로 군집분석은 grouping, classification, 또는 unsupervised classification이라고 불리기도 한다.</p>
<p>반면, 판별분석(Discriminant Analysis)은 상황이 정반대이다. 판별분석에서는 자료 수집 단계에서 이미 개체가 속한 집단 변수가 포함되어 있으며, 이 집단 정보에 기반하여 집단을 가장 잘 구분하는 판별함수(discriminant function)를 찾는 것이 목표이다. 즉, 판별분석은 지도 학습(supervised learning)의 형태로, 새로운 개체가 주어졌을 때 어느 집단에 속할지를 예측하는 데 초점을 둔다.</p>
</section>
<section id="군집분석-장단점" class="level5">
<h5 class="anchored" data-anchor-id="군집분석-장단점">(3) 군집분석 장단점</h5>
<p>군집분석은 데이터에 내재된 구조를 탐색하여 서로 유사한 개체들을 그룹화하는 비지도 학습 기법으로, 다양한 분석 상황에서 널리 활용된다. 그러나 유연성이 큰 만큼 결과의 안정성과 해석 측면에서 주의해야 할 점도 많다. 아래에서는 군집분석의 주요 장점과 단점을 정리한다.</p>
<p><strong>장점</strong></p>
<p>1. 탐색적(Exploratory) 분석 기법: 군집분석은 사전에 집단 정보를 요구하지 않기 때문에, 자료 내부 구조에 대한 가정 없이 의미 있는 패턴이나 자연스러운 그룹을 탐색해낼 수 있다. 따라서 데이터의 숨겨진 구조를 파악하거나 시장세분화, 유형화, 패턴 탐색 등 초기 탐색 단계에서 매우 유용하다.</p>
<p>2. 다양한 형태의 데이터에 적용 가능: 유사성을 정의할 수만 있다면, 수치형 데이터뿐 아니라 범주형, 이진형, 심지어 텍스트 데이터에도 적용할 수 있다.</p>
<p>자연어 처리에서는 단어/문서 간 유사도 기반 군집</p>
<p>마케팅에서는 고객 행동 데이터 기반 세분화</p>
<p>생물정보학에서는 유전자 발현 패턴 군집화</p>
<p>즉, <span dir="rtl">”</span>거리(distance)” 또는 <span dir="rtl">”</span>유사도(similarity)“가 정의되기만 하면, 자료의 형태에 큰 제약이 없다.</p>
<p>3. 적용 용이성 및 직관성: 자료의 사전 정보가 없기 때문에 누구나 쉽게 적용할 수 있으며, 기초적인 산점도나 거리 개념을 통해 직관적으로 이해할 수 있다. 계층적 군집이나 K-means 알고리즘은 구현도 간단하고 계산 속도도 빠르기 때문에 실무에서 활용도가 높다.</p>
<p><strong>단점</strong></p>
<p>1. 거리 및 가중치 정의에 민감: 군집분석의 핵심은 개체 간 유사성을 측정하는 거리인데, 거리의 정의가 달라지면 군집 결과도 크게 달라진다. 또한 변수마다 가중치를 어떻게 설정하느냐에 따라서도 결과가 크게 변한다.</p>
<p>표준화 유무에 따라 K-means 결과가 완전히 달라짐</p>
<p>Manhattan vs Euclidean 거리 선택에 따라 군집 경계 변화 → 즉, 메타 결정이 분석 결과에 매우 민감하다.</p>
<p>2. 군집 수 결정의 어려움: K-means처럼 군집 수를 지정해야 하는 알고리즘에서는 적절한 군집 수(K)를 결정하는 것이 쉽지 않다. Elbow method, Silhouette score, Gap statistic 등 다양한 기준이 존재하지만, <span dir="rtl">”</span>정답”은 존재하지 않는다.</p>
<p>3. 결과 해석의 어려움: 군집은 데이터로부터 자동적으로 형성되므로,형성된 군집이 무엇을 의미하는지는 분석자가 별도로 해석해야 한다.종종 군집이 다음과 같은 문제를 가질 수 있다.</p>
<p>군집이 의미하는 특성이 명확하지 않음</p>
<p>군집 간 차이를 설명하기 어려움</p>
<p>외부 변수(인구학적 특성 등) 없이는 군집의 특성을 파악하기 어려움</p>
<p>이러한 경우 주성분 분석(PCA)으로 차원을 줄여 군집 특성을 시각화하거나, 군집별 외부 특성 요약을 통해 군집의 의미를 재해석해야 한다.</p>
</section>
<section id="군집분석-활용" class="level5">
<h5 class="anchored" data-anchor-id="군집분석-활용">(4) 군집분석 활용</h5>
<p>시장세분화 (마케팅)</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/ca_segment.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:60.0%"></p>
</figure>
</div>
<p>시장 세분화는 구매 태도, 구매 성향, 매체 사용 습관, 인구사회학적 특성 등에서 서로 유사한 성향을 지닌 소비자 집단을 찾아내고, 이러한 내재된 군집을 바탕으로 시장을 의미 있는 하위 단위로 나누는 과정이다. 예를 들어 나이, 성별, 직업, 학력, 거주지와 같은 변수들을 이용하면, 소비자들의 행동적·사회적 특성에 따라 자연스럽게 차별적인 그룹이 형성된다. 실제 예시 표에서는 전체 소비자를 <span dir="rtl">’</span>추종자<span dir="rtl">’</span>, <span dir="rtl">’</span>EB<span dir="rtl">’</span>, <span dir="rtl">’</span>기본 기능<span dir="rtl">’</span>과 같은 세 집단으로 나누었으며, 각 집단은 서로 다른 인구학적 프로필을 가진다는 점을 보여준다.</p>
<p>시장 세분화의 핵심 목적은 소비자를 분류함으로써 그들의 행동 패턴을 보다 정교하게 이해하는 데 있다. 즉, 특정 특성(측정 변수)에 따라 소비자를 군집화함으로써, 표면적으로는 드러나지 않는 내재적 특성을 도출할 수 있으며, 이러한 특성은 소비자 행동 연구나 타깃 마케팅 전략을 수립하는 데 매우 유용하다.</p>
<p>또한 시장 세분화는 잠재적 신제품 기회 탐색에도 기여한다. 전체 시장을 하나의 동질적 집단으로 보지 않고 경쟁 상황이나 기업 특성에 따라 하위 시장을 구분하면, 각 세분시장에서 보다 명확한 수요와 니즈를 파악할 수 있게 된다. 이는 기업이 전략적으로 우위를 확보할 수 있는 영역을 발견하는 데 도움을 준다.</p>
<p>더 나아가, 세분화된 집단은 **표본추출 설계(sample design)**에도 활용될 수 있다. 조사 대상 지역이나 소비자를 구분해야 하는 상황에서 군집분석을 통해 서로 유사한 특성을 가진 대상을 묶어 계층을 구성하면, 이후 표본추출 과정이 단순해지고, 표집의 정확성이 향상된다. 즉, 세분화는 마케팅 전략뿐 아니라 조사 방법론 측면에서도 실질적인 장점을 제공한다.</p>
<p><strong>고객 세분화</strong></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/ca_segment0.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:40.0%"></p>
</figure>
</div>
<p>고객 세분화는 기업이 보유한 고객들을 하나의 동질적 집단으로 보지 않고, 고객별 가치·행동·특성의 차이에 따라 하위 집단으로 나누는 과정이다. 예를 들어, 고객의 수입(기업에 대한 매출 기여도)과 브랜드 인지도(브랜드와의 친밀도 또는 충성도)를 두 축으로 고려하면, 그림과 같이 고객들이 자연스럽게 두 개 정도의 군집으로 나뉜다. 이 중 기업의 수익에 더 크게 기여하면서 브랜드 인지도도 높은 고객군은 마케팅 공략 대상(target segment)으로 선정될 수 있다.</p>
<p>고객 세분화의 목적은 단순한 분류가 아니라, 기업의 수익 창출과 전략적 의사결정을 보다 정교하게 수행하기 위한 기반을 마련하는 데 있다. 다음은 대표적인 활용 방향들이다.</p>
<p>1. 고객 기여도 기반 세분화</p>
<p>고객이 기업의 수익에 얼마나 기여하는지를 기준으로 고객을 구분함으로써, 고가 제품 위주 구매 고객, 반복 구매 고객, 단발성 구매 고객과 같은 전략적 차이를 명확히 파악할 수 있다.</p>
<p>이러한 세분화는 CRM(Customer Relationship Management)의 핵심으로, 각 고객군에 맞는 차별적 관리 전략 수립을 가능하게 한다.</p>
<p>2. 우수 고객의 특성 및 생활패턴 파악</p>
<p>특정 고객군이 높은 가치를 창출하는 것으로 확인되면, 그들의 인구통계적 특성, 소비습관, 생활패턴을 파악하여 더 정교한 개별고객 맞춤 관리가 가능해진다. 연령대별 맞춤 프로모션, 관심사 기반 추천 서비스, 구매 이력 기반 개인화 마케팅</p>
<p>3. 표적 집단 구성(Target Group Design)</p>
<p>신상품 판촉, 교차판매(cross-selling), 업셀링(up-selling) 등의 목적을 위해 특정 특성을 공유하는 고객을 표적 집단으로 구성한다. 이는 군집분석을 활용하여 유사한 특성을 가진 고객을 묶고, 해당 그룹을 대상으로 맞춤 전략을 실행하는 과정으로 이어진다.</p>
</section>
<section id="유사성과-비유사성-개념" class="level5">
<h5 class="anchored" data-anchor-id="유사성과-비유사성-개념">(5) 유사성과 비유사성 개념</h5>
<p>다변량 자료에서 개체들을 분류하거나 군집화하려면, 먼저 개체 간의 관계를 정량적으로 측정해야 한다. 이때 사용되는 가장 기본적 개념이 유사성(similarity)과 비유사성(dissimilarity)이다.</p>
<p>유사성은 두 개체가 얼마나 비슷한지를 나타내고, 비유사성은 얼마나 다른지를 나타낸다. 유사성은 값이 클수록 두 개체가 닮았음을 의미하며, 비유사성은 값이 클수록 서로 다름을 의미한다. 군집분석에서 개체들은 보통 비유사성(거리)이 작은 개체들끼리 묶여 군집을 형성한다. 따라서 유사성과 비유사성의 정의는 군집 결과에 직접적인 영향을 미치는 핵심 개념이다.</p>
<p><strong>1. 유사성(Similarity)</strong></p>
<p>유사성은 두 개체가 서로 얼마나 비슷한지를 나타내는 개념이다. 유사성이 높다는 것은 두 개체가 속성값이 서로 가까우며, 행동·특성·측정값이 유사한 패턴을 보인다는 의미이다. 일반적으로 유사성은 값이 클수록 두 개체가 더 유사하다는 방식으로 표현된다.</p>
<ul>
<li>상관계수(correlation): <span dir="rtl">±</span>1에 가까울수록 유사</li>
<li>Cosine similarity: 1에 가까울수록 유사</li>
</ul>
<p><strong>2. 비유사성(Dissimilarity, Distance)</strong></p>
<p>반대로 비유사성은 두 개체가 서로 얼마나 다른지를 나타낸다. 이는 종종 거리(distance)라는 개념을 사용하여 정의된다. 비유사성은 값이 클수록 두 개체가 서로 더 다르다는 의미이다. 대표적인 비유사성 지표는 다음과 같다.</p>
<ul>
<li>유클리드 거리(Euclidean distance)</li>
<li>맨해튼 거리(Manhattan distance)</li>
<li>마할라노비스 거리(Mahalanobis distance)</li>
</ul>
<p>거리 기반 군집분석에서는 두 점이 가까울수록(= 비유사성이 작을수록) 같은 군집에 속할 가능성이 높다.</p>
<p><strong>3. 유사성과 비유사성의 관계</strong></p>
<p>유사성과 비유사성은 서로 반대개념처럼 보이지만, 실제로는 동일한 정보를 서로 다른 방식으로 표현한 것이다.</p>
<ul>
<li>두 개체의 유사성이 높다는 것은 → 두 개체 간 비유사성이 낮다는 의미</li>
<li>두 개체의 비유사성이 크다는 것은 → 두 개체가 서로 유사하지 않다는 의미</li>
</ul>
<p>즉, 분석 목적에 따라 유사성 행렬, 비유사성 행렬 중 하나를 사용하면 되고, 수학적 변환이 가능한 경우가 많다.</p>
</section>
</section>
</section>
<section id="chapter-2.-유사성비유사성-척도" class="level3">
<h3 class="anchored" data-anchor-id="chapter-2.-유사성비유사성-척도">Chapter 2. 유사성/비유사성 척도</h3>
<section id="유사성-척도" class="level4">
<h4 class="anchored" data-anchor-id="유사성-척도">1. 유사성 척도</h4>
<p>군집분석에서는 개체들 간의 유사성이 얼마나 큰지 또는 작은지를 기준으로 군집을 형성한다. 유사성은 두 개체가 패턴·특성·수치 등이 얼마나 닮았는가를 수치로 표현한 값이며, 일반적으로 값이 클수록 유사성이 높다.</p>
<p>유사성 척도는 자료의 형태(연속형, 범주형, 이진형, 텍스트 등)에 따라 선택해야 한다. 유사성이 정의되면, 필요할 때 이를 거리(비유사성)로 변환하여 군집 알고리즘에서 사용할 수 있다.</p>
<section id="연속형-데이터에서-사용하는-유사성-척도" class="level5">
<h5 class="anchored" data-anchor-id="연속형-데이터에서-사용하는-유사성-척도">(1) 연속형 데이터에서 사용하는 유사성 척도</h5>
<p><strong>피어슨 상관계수 (Pearson Correlation Similarity)</strong></p>
<p><span class="math display">\[\text{corr}(x,y) = r_{xy}\]</span></p>
<p>상관계수는 두 개체가 시간이나 조건의 변화에 따라 얼마나 비슷한 패턴을 보이는지를 측정하는 대표적인 유사성 척도이다. 상관계수 값이 +1에 가까울수록 두 개체의 변화 양상이 거의 동일함을 의미하므로, 패턴 유사성을 평가하는 데 매우 적합하다. 이때 상관계수는 데이터의 절대적인 크기(scale)가 아니라, 증가·감소의 방향과 형태를 비교한다는 특징이 있다.</p>
<p>이러한 특성 때문에 상관계수는 고차원 데이터나 시계열 자료, 혹은 소비자들의 행동 패턴처럼 변화의 형태가 중요한 분석에서 널리 사용된다. 군집분석에서도 상관 기반 유사성을 활용하는 경우가 많으며, 실질적인 군집 알고리즘에서 요구하는 거리 형식으로 활용하기 위해 상관계수를 단순히 <span class="math inline">\(d = 1 - r\)</span> 로 변환하여 사용할 수 있다. 상관계수가 높을수록 거리 값이 작아지므로, 자연스럽게 유사한 개체끼리 가까운 위치를 갖게 된다.</p>
<p>예를 들어, 고객의 월별 구매 패턴(12개월 데이터)을 이용하여 고객 세분화를 수행한다고 하자. 고객 간 총 구매액의 크기가 다르더라도, 월별 증감 패턴이 비슷하다면 상관계수는 높은 값을 갖게 된다. 이 경우 상관 기반 거리를 이용한 군집분석은 유사한 구매 패턴을 가진 고객들을 효과적으로 하나의 그룹으로 묶어낼 수 있으며, 특히 마케팅에서 행동 기반 고객 세분화에 매우 유용하다.</p>
<p><strong>코사인 유사도 (Cosine Similarity)</strong></p>
<p><span class="math display">\[\text{cos}(x,y) = \frac{x \cdot y}{\parallel x \parallel \parallel y \parallel}\]</span></p>
<p>코사인 유사도는 두 벡터가 이루는 방향이 얼마나 유사한가를 측정하는 유사성 척도이다. 즉, 두 개체가 가진 값의 절대 크기보다는 패턴의 모양이 어느 정도 같은 방향을 향하고 있는지가 핵심 비교 기준이 된다. 코사인 유사도의 값은 일반적으로 0에서 1 사이(또는 상황에 따라 -1에서 1)를 가지며, 1에 가까울수록 두 벡터가 거의 동일한 방향을 가진다는 것을 의미한다. 코시인 유사도는 <span class="math inline">\(d = 1 - cos\)</span> 거리로 군집분석에 사용된다.</p>
<p>이 척도는 특히 텍스트 마이닝이나 문서 분석처럼 고차원 희소(sparse) 데이터가 등장하는 분야에서 뛰어난 성능을 보인다. 단어 빈도 기반의 벡터 표현에서는 각 문서가 매우 높은 차원의 공간을 갖게 되는데, 이 경우 크기보다는 <span dir="rtl">”</span>어떤 단어 조합을 사용하는가”라는 방향 정보가 더 의미 있는 유사성 기준이 된다. 따라서 코사인 유사도는 문서 간 의미적 유사성을 평가하는 데 적합하며, 실제로 많은 텍스트 군집분석에서 핵심 유사성 척도로 사용된다.</p>
<p>예를 들어 뉴스 기사를 TF-IDF 벡터로 변환하여 각 기사를 고차원 벡터로 표현한 뒤, 코사인 유사도를 통해 서로 얼마나 비슷한 주제나 표현을 갖는지를 평가할 수 있다. 이 유사도를 기반으로 군집분석을 수행하면, 주제가 비슷한 기사끼리 자연스럽게 하나의 군집을 형성하게 되며, 이는 뉴스 자동 분류, 정보 검색, 주제 모델링과 같은 다양한 응용에 활용될 수 있다.</p>
</section>
<section id="범주형이진형-데이터의-유사성-척도" class="level5">
<h5 class="anchored" data-anchor-id="범주형이진형-데이터의-유사성-척도">(2) 범주형·이진형 데이터의 유사성 척도</h5>
<p><strong>자카드 유사도 (Jaccard Similarity)</strong></p>
<p><span class="math display">\[\text{J}(A,B) = \frac{|A \cap B|}{|A \cup B|}\]</span></p>
<p>자카드 유사도는 두 개체가 가진 이진형(0/1) 변수 또는 집합 정보가 얼마나 겹치는지를 측정하는 유사성 척도이다. 특히 두 개체가 공통으로 1을 가지는 항목의 비율을 중심으로 유사성을 평가한다는 점이 특징이다. 예를 들어 구매 여부, 보유 여부, 특정 관심 항목의 포함 여부처럼 <span dir="rtl">”</span>있다/없다”로 표현되는 자료에 적합하며, 고객의 구매내역이나 SNS 태그처럼 집합 기반의 특성을 지닌 데이터를 분석할 때 유용하다.</p>
<p>군집분석에서는 자카드 유사도를 거리로 변환하여 사용하며, 그 방식은 매우 간단하다. <span class="math inline">\(d = 1 - \text{Jaccard}\)</span> 자카드 유사도가 높을수록 두 개체가 공유하는 항목이 많다는 의미이므로, 자카드 거리는 작아지고 두 개체는 군집에서 서로 가까운 위치로 판단된다.</p>
<p>예를 들어, 고객이 구매한 상품 목록을 0/1 형태로 기록한 데이터가 있다면, 같은 상품을 자주 함께 구매한 고객들끼리는 공통의 <span dir="rtl">’</span>1<span dir="rtl">’</span> 항목이 많아지므로 자카드 유사도가 높아지고, 자연스럽게 같은 군집으로 묶인다. 마찬가지로 SNS 사용자들이 사용하는 해시태그(Hashtag)를 집합으로 표현하면, 비슷한 태그를 사용하는 이용자들끼리 서로 높은 자카드 유사도를 띠게 되며, 이는 관심사 기반 이용자 군집화에 매우 효과적으로 활용된다.</p>
<p><strong>단순 일치계수(SMC: Simple Matching Coefficient)</strong></p>
<p><span class="math display">\[\text{SMC} = \frac{\text{일치 항목 수}}{\text{전체 항목 수}}\]</span></p>
<p>단순 일치계수(SMC)는 두 개체가 가진 이진형(0/1) 정보가 얼마나 일치하는지를 측정하는 유사성 척도이다. 자카드 계수가 <span dir="rtl">”</span>두 개체가 공통으로 1을 가지는 경우”만을 강조하는 것과 달리, SMC는 0과 1을 동일하게 중요하게 다루며, 두 개체가 어떤 값이든 서로 같은 값을 가지면 유사하다고 판단한다. 즉, SMC는 <span dir="rtl">”</span>두 개체가 전체 항목 중 얼마나 많은 정보를 동일하게 가지고 있는가?“를 비율로 나타내는 지표이다.</p>
<p>이러한 특성 때문에 SMC는 Yes/No 형태의 이진 설문 데이터를 다룰 때 매우 유용하다. 예를 들어 흡연 여부, 결혼 여부, 자동차 보유 여부처럼 단순한 소유·상태·행동을 나타내는 항목이 여러 개 있을 때, 두 응답자가 같은 응답을 많이 할수록 SMC 값은 높아지고 서로 유사한 개체로 판단된다.</p>
<p>실제 군집분석 예를 들면, 여러 개의 Yes/No 설문 문항을 이용하여 고객을 분류하고자 할 때 두 고객이 설문 항목에 대해 비슷한 응답 패턴을 보이면 SMC가 높아지며, 이를 바탕으로 **유사한 생활양식 또는 행동 특성을 공유하는 고객군(cluster)**을 형성할 수 있다.</p>
<p><strong>Dice 계수 (Dice Coefficient)</strong></p>
<p><span class="math display">\[\text{DICE}(A,B) = \frac{2|A \cap B|}{|A| + |B|}\]</span></p>
<p>Dice 계수는 두 집합이 얼마나 많은 공통 요소를 가지고 있는가를 측정하는 유사성 척도로, 자카드 유사도와 유사하지만 교집합의 크기를 더 크게 반영한다는 점이 특징이다.</p>
<p>Dice 계수는 문자열 비교(string matching), 이미지 특징 유사성 분석, 자연어처리(NLP)와 같이 데이터 요소 간의 공통 패턴이 핵심적인 분야에서 널리 사용된다. 예를 들어 DNA 염기서열처럼 특정 패턴의 일치 여부가 중요하게 작용하는 데이터에서는 동일하거나 유사한 부분서열이 많을수록 Dice 계수가 크게 나타나므로, 서열 간 유사성을 직관적으로 파악할 수 있다. 마찬가지로 소비자 검색어 집합을 비교할 때, 공통으로 검색한 키워드가 많을수록 높은 Dice 값을 갖기 때문에, 검색어 기반 소비자 군집화를 수행할 때 효과적인 척도로 활용된다.</p>
</section>
</section>
<section id="비유사성-척도" class="level4">
<h4 class="anchored" data-anchor-id="비유사성-척도">2. 비유사성 척도</h4>
<p>군집분석에서 개체들을 분류하는 핵심 기준은 개체들 간의 비유사성이 얼마나 큰가 또는 작은가이다. 비유사성은 두 개체가 서로 얼마나 다른지를 수치로 표현하는 척도이며, 값이 클수록 두 개체가 더 멀리 떨어져 있음, 즉 서로 다른 특성을 가지고 있음을 나타낸다. 이 비유사성은 군집분석 알고리즘(K-means, 계층적 군집 등)의 입력으로 직접 사용되며, 실제로 군집 형성은 비유사성이 작은 개체들이 서로 가까이 묶이는 방식으로 이루어진다.</p>
<p>비유사성 척도는 자료의 형태가 연속형인지, 범주형인지, 이진형인지 등에 따라 다양한 정의가 존재하지만, 가장 기본적인 개념은 두 벡터의 차이를 수학적으로 측정하는 것이다. 아래는 대표적인 비유사성 척도들의 개념과 공식을 정리한 것이다.</p>
<p><strong>유클리드 거리(Euclidean Distance)</strong></p>
<p><span class="math display">\[d(x,y) = \sqrt{\overset{p}{\sum_{i = 1}}(x_{i} - y_{i})^{2}}\]</span></p>
<p>유클리드 거리는 군집분석에서 가장 널리 사용되는 비유사성 척도로, 두 점 사이의 직선거리를 계산하는 방식이다. 연속형 변수로 이루어진 자료에서 개체 간 차이를 측정하는 가장 기본적인 방법이며, 거리가 클수록 두 개체가 서로 크게 다르다는 의미를 갖는다.</p>
<p>다만 유클리드 거리는 각 변수의 규모에 민감하기 때문에, 변수의 단위나 범위가 서로 다를 경우 표준화를 수행한 뒤 사용하는 것이 일반적이다. 이러한 특성 때문에 K-means 군집분석에서는 표준화된 연속형 변수에 대해 유클리드 거리를 기본 거리 척도로 사용하여, 서로 가깝고 유사한 개체들끼리 하나의 군집으로 묶어 나간다.</p>
<p><strong>맨해튼 거리(Manhattan Distance)</strong></p>
<p><span class="math display">\[d(x,y) = \overset{p}{\sum_{i = 1}}|x_{i} - y_{i}|\]</span></p>
<p>맨해튼 거리는 두 점 사이의 차이를 좌표별 절댓값의 합으로 계산하는 비유사성 척도로, 마치 격자(grid) 위를 직선과 수직 방향으로만 이동해 도달하는 거리와 같다고 하여 이러한 이름이 붙었다. 이 거리 척도는 각 변수의 차이를 단순한 절댓값으로 누적하기 때문에, 유클리드 거리보다 이상치(outlier)에 덜 민감한 특징을 지닌다.</p>
<p>또한 차원이 높아질수록 유클리드 거리는 거리의 분산이 커지고 계산의 안정성이 떨어지는 반면, 맨해튼 거리는 절댓값 기반이기 때문에 고차원 공간에서도 비교적 안정적으로 개체 간 차이를 반영할 수 있다. 이러한 특성 덕분에 고차원 데이터나 잡음이 많은 데이터 환경에서 유용하게 활용되는 거리 척도이다.</p>
<p><strong>마할라노비스 거리(Mahalanobis Distance)</strong></p>
<p><span class="math display">\[d(x,y) = \sqrt{(x - y)'S^{- 1}(x - y)}\]</span></p>
<p>마할라노비스 거리는 변수 간 상관구조를 고려하여 두 점 사이의 비유사성을 측정하는 척도로, 다변량 자료에서 개체 간 차이를 평가할 때 매우 유용하게 사용된다. 일반적인 유클리드 거리가 각 변수 축을 독립적이고 동일한 스케일로 가정하는 데 반해, 마할라노비스 거리는 변수들 사이의 공분산 구조를 반영하여 거리 값을 계산한다.</p>
<p>이러한 방식은 데이터가 변수 간 상관을 가지고 있거나, 변수들의 분포 폭이 서로 다른 경우에 특히 중요한데, 마할라노비스 거리는 이러한 정보까지 함께 고려하여 축 방향이 서로 다른 타원형 분포에서도 개체 간 차이를 정확하게 비교할 수 있게 한다.</p>
<p>이런 이유로 마할라노비스 거리는 다변량 통계 분야에서 자주 등장하며, 특히 판별분석(LDA)에서는 서로 다른 집단의 공분산 구조를 고려한 판별함수를 구성하는 데 사용되고, 이상치 탐지에서는 집단 중심에서 얼마나 벗어나 있는지를 판단하는 지표로 활용된다.</p>
<p><strong>자카드 거리(Jaccard Distance) – 이진형 자료용</strong></p>
<p><span class="math display">\[d = 1 - \text{Jaccard}(A,B) = 1 - \frac{|A \cap B|}{|A \cup B|}\]</span></p>
<p>자카드 거리는 이진형 자료나 집합형 자료에서 두 개체가 서로 얼마나 다른지를 측정하는 대표적인 비유사성 척도이다. 자카드 유사도가 두 개체가 공통으로 가진 항목의 비율을 강조하는 반면, 자카드 거리는 그 반대 개념으로, 두 개체가 서로 다르게 가진 항목이 얼마나 많은지를 반영하여 비유사성을 평가한다.</p>
<p>이 방식은 항목의 존재 여부(1) 또는 부재(0)가 중요한 데이터, 예를 들어 고객의 구매내역, SNS 태그, 취미나 관심사와 같이 특정 항목의 포함 여부로 표현되는 자료를 비교할 때 유용하다. 공통으로 가진 항목이 적고 각자 다른 항목을 많이 가지고 있을수록 자카드 거리는 커지며, 두 개체가 서로 상당히 다른 특성을 가진다고 판단한다. 이러한 특성 때문에 자카드 거리는 집합 기반 자료의 군집분석에서 널리 활용된다.</p>
<p><strong>해밍 거리(Hamming Distance)</strong></p>
<p><span class="math display">\[d(x,y) = \overset{p}{\sum_{i = 1}}I(x_{i} \neq y_{i})\]</span></p>
<p>해밍 거리는 문자열 또는 이진 벡터에서 서로 다른 위치가 몇 개나 되는지를 세어 비유사성을 측정하는 거리 척도이다. 두 문자열을 같은 길이로 놓고 비교했을 때, 같은 위치의 문자가 서로 다르면 그만큼 해밍 거리가 증가하며, 값이 클수록 두 문자열이 서로 더 다르다는 의미가 된다.</p>
<p>이 거리 척도는 특히 비트열처럼 0과 1로 표현된 데이터 비교에 적합하며, 단일 항목의 차이가 직접적인 의미를 갖는 상황에서 널리 사용된다. 예를 들어 데이터베이스에서 키 값의 오류 탐지, 통신 시스템에서 전송 오류 검출, 유전학에서 DNA 서열의 변이 위치 파악 등에서 해밍 거리는 중요한 역할을 한다. 각 위치의 일치·불일치만으로 비유사성을 판단하므로 계산이 단순하고 직관적이라는 장점이 있다.</p>
</section>
</section>
<section id="chapter-3.-계층적-군집분석" class="level3">
<h3 class="anchored" data-anchor-id="chapter-3.-계층적-군집분석">Chapter 3. 계층적 군집분석</h3>
<section id="군집화-과정" class="level4">
<h4 class="anchored" data-anchor-id="군집화-과정">1. 군집화 과정</h4>
<p>계층적 군집분석(hierarchical clustering)에서는 개체들 간의 유사성이 가장 높은 순서, 또는 비유사성이 가장 낮은 순서대로 개체들을 차례로 묶어 가며 군집을 형성한다. 여러 연결 방식(linkage method) 중에서 single-linkage clustering은 두 군집 간 거리를 정의할 때, 각 군집에서 가장 가까운 두 점 간 거리(최소 거리)를 기준으로 군집을 병합하는 방법이다.</p>
<p>이 방식은 자료 구조를 자연스럽게 따라가며 가장 가까운 개체 또는 군집끼리 먼저 묶어 나가는 특성을 가지기 때문에, 전체 데이터 구조를 빠르게 파악할 수 있으며 계산 효율성이 높다는 장점이 있다. 이러한 이유로 single-linkage 방법은 효율성이 높고 구현이 간단하여, 계층적 군집 방법 중 가장 기본적이면서도 널리 사용되는 방식으로 알려져 있다.</p>
<section id="군집-간-거리-측정방법" class="level5">
<h5 class="anchored" data-anchor-id="군집-간-거리-측정방법">(1) 군집 간 거리 측정방법</h5>
<p>Single-linkage 방식을 실제 군집화 절차로 구현한 방법 중 하나가 Neighbor Method이다. Neighbor Method는 개체들 간의 거리 행렬을 바탕으로, 가장 가까운 두 개체부터 순차적으로 묶어 가는 방식으로 군집 구조를 형성한다.</p>
<p>첫째, 처음에는 개체의 수(n)만큼의 군집이 있다. 예를 들어 개체 6개가 있고 다음은 각 개체 간 Euclidean 거리(유사성)를 계산한 표이다. 처음에는 군집은 6개이다. 개체 (1, 2) 간 거리(유사성)은 0.1, (2, 3) 개체 유사성은 0.4이다. (2, 3) 개체 간 거리는 (3, 2) 개체 거리와 동일하므로 대각 행렬 형태이다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/ca_clustering.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:40.0%"></p>
</figure>
</div>
<p>둘째, 유사성이 가장 가까운(거리가 가장 가까운) 개체를 군집으로 묶는다. 예제에서는 (1, 2)가 묶인다. 이제 (1, 2)와 3, 4간 거리를 어떻게 정의할 것인가?</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/ca_clustering0.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:40.0%"></p>
</figure>
</div>
<p>계층적 군집분석(hierarchical clustering)에서는 군집을 병합할 때 어떤 기준으로 두 군집 간 거리를 정의하느냐가 매우 중요하다. 개체 간 거리가 주어졌다고 하더라도, <span dir="rtl">”</span>군집과 군집의 거리”는 여러 방식으로 정의할 수 있으며, 이러한 기준에 따라 군집 형성 방식과 결과가 달라진다. 대표적인 linkage 방식은 다음 네 가지이다.</p>
<p>Nearest Neighbor (Single Linkage): 두 군집에 속한 개체들 중 가장 가까운 두 개체 사이의 거리를 군집 간 거리로 정의한다. <span class="math inline">\(D(A,B) = \min_{i \in A,j \in B}d(i,j)\)</span></p>
<p>Furthest Neighbor (Complete Linkage): 두 군집에 속한 개체들 중 가장 멀리 떨어진 두 개체 사이의 거리를 군집 간 거리로 정의한다. <span class="math inline">\(D(A,B) = \max_{i \in A,j \in B}d(i,j)\)</span></p>
<p>Centroid Linkage (중심 연결법): 군집의 중심점(centroid) 간의 거리를 군집 간 거리로 사용한다. <span class="math inline">\(D(A,B) = d({\overline{x}}_{A},{\overline{x}}_{B})\)</span></p>
<p>Average Linkage (Group Average Method): 한 군집의 모든 개체와 다른 군집의 모든 개체 간의 거리 평균을 군집 간 거리로 정의한다. <span class="math inline">\(D(A,B) = \frac{1}{|A||B|}\sum_{i \in A}\sum_{j \in B}d(i,j)\)</span></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/ca_linkage.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
<p>다음은 Nearest neighbor 방법에 의해 개체를 군집화 하는 과정이다. 1과 3의 거리는 0.7, 2와 3의 거리는 0.4이므로 (1, 2)와 3의 거리는 0.4가 된다. 1과 4의 거리는 0.2이고 2와 4의 거리는 0.6이므로 작은 거리 0.2가 (1, 2)와 4의 거리이다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/ca_clustering00.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:40.0%"></p>
</figure>
</div>
<p>(1, 2)의 거리는 0.4이고 3과 4의 거리는 0.3이므로 (1, 2, 4)와 3의 거리는 0.3이 된다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/ca_clustering00.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:40.0%"></p>
</figure>
</div>
</section>
<section id="군집-간-거리-측정방법-선택" class="level5">
<h5 class="anchored" data-anchor-id="군집-간-거리-측정방법-선택">(2) 군집 간 거리 측정방법 선택</h5>
<p>계층적 군집분석에서는 Nearest(단일 연결), Furthest(완전 연결), Centroid, Average, Ward 등 여러 방식으로 군집 간 거리를 정의할 수 있다. 그러나 어느 한 방법이 항상 우수하다고 말할 수는 없으며, 각 방법은 서로 다른 군집 형태를 만들어 내기 때문에 분석 목적과 자료의 특성을 고려해 선택해야 한다.</p>
<p>Nearest 방식(single linkage)은 군집 간 가장 가까운 두 점의 거리를 기준으로 병합하기 때문에 서로 가까운 개체들이 빠르게 묶여 군집의 수가 적게 형성되는 경향이 있고, 그 과정에서 사슬현상(chain effect)이 발생하여 긴 형태의 군집이 만들어지기 쉽다. 반대로 Furthest 방식(complete linkage)은 군집 간 가장 멀리 떨어진 개체의 거리를 기준으로 두 군집의 분리성을 크게 유지하려 하기 때문에 상대적으로 작은 군집이 많이 남는 경향이 있다.</p>
<p>Centroid 방식은 각 군집의 중심점 간 거리를 이용하여 효율적으로 병합을 진행하지만, 군집이 병합되는 과정에서 거리 계산이 역전되는 문제가 발생해 다소 불안정할 수 있다. Average 방식(average linkage)은 두 군집에 속한 모든 개체 쌍의 평균 거리를 사용하여 Single과 Complete linkage의 극단성을 완화한 방법으로, 가장 안정적이고 실무에서 널리 활용되는 방식이다.</p>
<p>또한 Ward 방법은 군집 병합 시 군집 내 제곱합(variance)의 증가를 최소화하는 방향으로 병합을 진행하여 가장 응집력 있고 통계적으로 해석 가능한 군집을 만들어 준다. 특히 연속형 변수로 구성된 자료에서는 매우 좋은 성능을 보이는 방식으로 알려져 있다.</p>
<p>결국 각 방법에는 고유한 장단점이 있으므로, 실제 분석에서는 2~3개의 linkage 방법을 함께 적용해 보고, 자료 구조를 가장 잘 반영하며 해석 가능성이 높은 결과를 선택하는 것이 바람직하다. 이 중 Average linkage는 안정성과 실용성이 뛰어나 가장 널리 사용되는 방식이다.</p>
</section>
</section>
<section id="군집-개수-결정" class="level4">
<h4 class="anchored" data-anchor-id="군집-개수-결정">2. 군집 개수 결정</h4>
<p>군집의 개수를 결정하는 방법은 매우 다양하며, 단일 기준에 의존하기보다 여러 방법을 함께 사용하여 일관된 군집 수를 선택하는 것이 바람직하다. 계층적 군집에서는 덴드로그램, Mojena<span dir="rtl">’</span>s Rule, CCC가 주로 사용된다.</p>
<section id="계층적-나무-다이어그램-dendrogram" class="level5">
<h5 class="anchored" data-anchor-id="계층적-나무-다이어그램-dendrogram">(1) 계층적 나무 다이어그램 (Dendrogram)</h5>
<p>덴드로그램(dendrogram)은 개체 간의 유사성이 높은 순서대로 개체들이 어떻게 묶여 가는지를 단계적으로 보여주는 트리 구조의 그림이다. 덴드로그램에서 각 가지의 높이는 개체 또는 군집 간의 상대적 거리를 의미하며, 거리가 작을수록 서로 유사한 개체들이 먼저 결합된다.</p>
<p>예를 들어, 그림에서는 가장 먼저 E와 F가 서로 가장 가까운 개체로 판단되어 하나의 군집으로 묶이고, 그다음 A와 B가 결합된다. 이후 (E, F) 군집이 D와 결합하고, 다시 C와 묶여 점차 큰 군집이 형성된다. 이러한 병합 과정을 거쳐 결국 모든 개체가 하나의 군집으로 연결되는 것이 계층적 군집분석의 흐름이다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/ca_dendrogram.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
<p>덴드로그램을 활용하여 군집 수를 결정하는 방법은 매우 직관적이다. 그림에서 나무 형태의 수직선(가지)을 살펴보면, 높이의 급격한 증가가 나타나는 지점에서 트리를 자르는 것이 일반적인 기준이다. 예를 들어 군집의 개수를 2개로 설정하면, 덴드로그램에서 큰 분기점 위에서 수평으로 선을 그어보았을 때, (A, B)와 (C, D, E, F)처럼 자연스럽게 두 개의 큰 군집이 형성된다.</p>
<p>이처럼 덴드로그램은 계층적 군집 형성 과정을 시각적으로 보여주기 때문에, 군집 내의 응집력과 군집 간 분리도를 동시에 고려하여 군집의 적절한 개수를 판단할 수 있는 유용한 도구이다. 분석자는 덴드로그램을 통해 어디에서 잘라야 가장 의미 있는 그룹이 형성되는가를 판단하여, 군집의 수를 결정할 수 있다.</p>
</section>
<section id="mojenas-rule" class="level5">
<h5 class="anchored" data-anchor-id="mojenas-rule">(2) Mojena<span dir="rtl">’</span>s Rule</h5>
<p>계층적 군집분석에서는 개체들이 병합되는 순서를 덴드로그램으로 표현하지만, 어디에서 트리를 잘라 군집 수를 정할지 판단이 모호할 수 있다. Mojena<span dir="rtl">’</span>s Rule은 이러한 문제를 해결하기 위해 고안된 고전적 기준으로, 덴드로그램에서 나타나는 병합 거리의 분포를 통계적으로 해석하여 cut height를 수치적으로 결정하는 방법이다.</p>
<p>Mojena는 군집 병합 과정에서 계산되는 병합 거리 <span class="math inline">\(h_{1},h_{2},\ldots,h_{n - 1}\)</span>을 하나의 데이터로 간주하고, 이 값들이 어떤 분포적 특성을 갖는지를 이용하여 <span dir="rtl">”</span>비정상적으로 큰 병합 거리”가 나타나는 지점을 군집 경계로 판단할 수 있다고 보았다. 즉, 병합 높이가 갑자기 커지는 지점은 개체 간 유사성이 떨어지는 두 큰 군집이 합쳐지는 순간이므로, 이 이전 단계가 가장 자연스러운 군집 구조를 반영한다는 원리이다.</p>
<p>이를 위해 Mojena는 다음과 같은 기준을 제안한다.</p>
<p><span class="math inline">\(h_{c} &gt; \overline{h} + ks_{h}\)</span>, 여기서 <span class="math inline">\(h_{c}\)</span>는 cut height 후보(어느 병합 단계의 height인지), <span class="math inline">\(\overline{h}\)</span>는 전체 병합 거리의 평균, <span class="math inline">\(s_{h}\)</span>는 병합 거리의 표준편차, 그리고 <span class="math inline">\(k\)</span>는 경험적 상수(보통 2.75 ~ 3.50 범위에서 사용됨)이다.</p>
<p>즉, 덴드로그램에서의 병합 거리 중에서 평균보다 k배 이상 큰 병합 거리가 나타나는 지점이 자연스러운 분기점이 되며, 해당 height 위에서 트리를 자르면 적절한 군집 수가 결정된다. 이 기준은 단순히 그림을 보고 주관적으로 판단하는 것이 아니라, 병합 거리의 분포를 정량적으로 분석하여 군집 경계를 찾는다는 점에서 의미가 크다.</p>
<p>Mojena<span dir="rtl">’</span>s Rule은 계층적 군집분석이 처음 제안된 시기부터 꾸준히 사용되어 왔으며, 특히 덴드로그램이 복잡하거나 시각적으로 명확한 elbow가 보이지 않을 때 유용하다. 다만, 상수 k 의 선택에 어느 정도 경험적 요소가 포함되어 있으며, 자료 구조에 따라 최적의 k가 다를 수 있다는 점은 고려해야 한다. 그럼에도 불구하고, 덴드로그램 cut height를 명확한 수치 규칙으로 제시한다는 점에서 많은 교과서와 소프트웨어에서 소개되는 전통적인 기준이다.</p>
</section>
<section id="cubic-clustering-criterion-ccc" class="level5">
<h5 class="anchored" data-anchor-id="cubic-clustering-criterion-ccc">(3) Cubic Clustering Criterion (CCC)</h5>
<p>Cubic Clustering Criterion(CCC)은 SAS에서 개발된 군집 타당성 지표로, 특히 계층적 군집분석에서 군집 수를 결정할 때 널리 사용되는 고전적 기준 중 하나이다. CCC는 특정 군집 수 K에 대해 실제 데이터에서 얻어진 군집화 구조가, 동일한 조건에서 생성된 무작위 데이터의 군집 구조보다 얼마나 더 명확하게 분리되는지를 수치화한 값이다. 다시 말해, 군집이 실제로 존재하는지, 혹은 단순히 우연히 생긴 구조인지 비교하는 지표라고 할 수 있다.</p>
<p>CCC의 기본 원리는 다음과 같다.</p>
<p>군집이 <span dir="rtl">”</span>정말 존재한다면”, 동일한 차원의 난수 데이터를 군집화했을 때보다 집단 간 분리도가 훨씬 더 커야 한다. 따라서 CCC는 실제 군집 구조와 난수 데이터의 군집 분리도를 비교하여, 그 차이가 큰 경우에 높은 값을 갖는다. 일반적으로 CCC 값이 2 이상이거나 뚜렷한 피크를 보이는 군집 수는 실제 데이터에서 의미 있는 군집 구조가 존재함을 시사한다.</p>
<p>계층적 군집분석에서 CCC는 각 병합 단계별로 계산되며, CCC 값을 K에 따라 플롯하면 데이터에서 군집 구조가 가장 또렷하게 드러나는 지점에서 샤프한 피크가 나타난다. 이 피크에 해당하는 K가 적절한 군집 수가 된다. 덴드로그램만으로 판단하기 모호한 경우, CCC는 수치적 기준을 제공한다는 점에서 실무와 연구에서 많이 활용된다.</p>
</section>
<section id="pseudo-f-pseudo-t²-통계량" class="level5">
<h5 class="anchored" data-anchor-id="pseudo-f-pseudo-t²-통계량">(4) Pseudo F / Pseudo t² 통계량</h5>
<p>계층적 군집분석에서는 각 병합 단계에서 군집의 응집력과 분리도가 어떻게 변하는지를 평가하여 적절한 군집 수를 결정할 수 있다. SAS의 PROC CLUSTER에서 제공하는 Pseudo F와 Pseudo t² 통계량은 바로 이러한 군집 구조 변화를 수치화한 지표로, 계층적 군집분석에서만 사용되는 특수한 타당성 기준이다.</p>
<p>Pseudo F는 K개 군집이 형성된 상태에서, 군집 간 분산과 군집 내 분산의 비율을 측정한다. 그 해석은 ANOVA의 F 비율과 유사하며, 군집이 잘 분리되어 있을수록 군집 간 분산이 커지고 군집 내 분산이 작아지므로 Pseudo F 값이 커진다.</p>
<p>따라서, Pseudo F가 큰 K가 잘 분리된 군집 구조를 의미한다. K를 바꿔가며 계산했을 때 Pseudo F가 높게 나타나는 지점에서 군집 수를 선택할 수 있다.</p>
<p>Pseudo F는 군집 전체의 분리도를, Pseudo t²는 각 병합 단계의 안정성과 응집력 변화를 평가하는 지표이다. Pseudo t² 값이 급격히 증가하거나 감소하는 지점은 군집 경계가 바뀌는 중요한 단계로, 해당 지점을 중심으로 군집 수를 결정할 수 있다. 이 두 지표는 계층적 군집분석의 군집 수 판단을 수치적으로 보완하는 데 널리 사용된다.</p>
</section>
</section>
<section id="사례-실습" class="level4">
<h4 class="anchored" data-anchor-id="사례-실습">3. 사례 실습</h4>
<section id="메타-정보" class="level5">
<h5 class="anchored" data-anchor-id="메타-정보">(1) 메타 정보</h5>
<p>이 데이터는 미국의 50개 주를 대상으로 수집된 자료로, 총 50개의 관측치로 이루어져 있다. 각 주에 대해 네 가지 연속형 변수가 기록되어 있으며, 이는 모두 강력범죄 발생률과 지역의 도시화 수준을 나타내는 지표들로 구성된다. 다시 말해, 살인·폭행·강간과 같은 범죄 발생률, 그리고 주별 도시 인구 비중을 함께 포함하고 있어, 범죄 패턴과 도시화 정도의 관계를 다변량적으로 살펴보기에 적합한 자료이다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 32%">
<col style="width: 32%">
<col style="width: 32%">
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;">변수명</td>
<td style="text-align: left;">내용</td>
<td style="text-align: left;">단위</td>
</tr>
<tr class="even">
<td style="text-align: left;">Murder</td>
<td style="text-align: left;">살인 사건 발생률</td>
<td style="text-align: left;">인구 10만 명당 발생 건수</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Assault</td>
<td style="text-align: left;">폭행 사건 발생률</td>
<td style="text-align: left;">인구 10만 명당 발생 건수</td>
</tr>
<tr class="even">
<td style="text-align: left;">UrbanPop</td>
<td style="text-align: left;">도시 거주 인구 비율</td>
<td style="text-align: left;">%</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Rape</td>
<td style="text-align: left;">강간 사건 발생률</td>
<td style="text-align: left;">인구 10만 명당 발생 건수</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> sm.datasets.get_rdataset(<span class="st">"USArrests"</span>, package<span class="op">=</span><span class="st">"datasets"</span>).data</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 인덱스를 컬럼으로 빼서 'State'라는 변수로 사용</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.reset_index().rename(columns<span class="op">=</span>{<span class="st">"rownames"</span>: <span class="st">"State"</span>})</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>df.info()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="계층적-군집분석-및-군집-개수-결정" class="level5">
<h5 class="anchored" data-anchor-id="계층적-군집분석-및-군집-개수-결정">(1) 계층적 군집분석 및 군집 개수 결정</h5>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.cluster.hierarchy <span class="im">import</span> linkage, dendrogram, fcluster</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co"># ----------------------------------------</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. 데이터 로드 &amp; 표준화</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co"># ----------------------------------------</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>raw <span class="op">=</span> sm.datasets.get_rdataset(<span class="st">"USArrests"</span>, package<span class="op">=</span><span class="st">"datasets"</span>).data</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co"># State 이름 처리 불필요 (이미 인덱스가 주 이름)</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>raw.index.name <span class="op">=</span> <span class="st">"State"</span>   <span class="co"># 선택 사항: 인덱스 이름만 붙이고 싶을 때</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> raw.values</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>scaler <span class="op">=</span> StandardScaler()</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>X_scaled <span class="op">=</span> scaler.fit_transform(X)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>n, p <span class="op">=</span> X_scaled.shape</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="co"># 전체 TSS (나중에 Pseudo F 계산에 사용)</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>TSS <span class="op">=</span> ((X_scaled <span class="op">-</span> X_scaled.mean(axis<span class="op">=</span><span class="dv">0</span>)) <span class="op">**</span> <span class="dv">2</span>).<span class="bu">sum</span>()</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a><span class="co"># ----------------------------------------</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. 계층적 군집 (Ward)</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a><span class="co"># ----------------------------------------</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> linkage(X_scaled, method<span class="op">=</span><span class="st">'ward'</span>)</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a><span class="co"># ----------------------------------------</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. Pseudo F (Calinski–Harabasz) 계산</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a><span class="co"># ----------------------------------------</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_wss(X, labels):</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    wss <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> g <span class="kw">in</span> np.unique(labels):</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>        Xg <span class="op">=</span> X[labels <span class="op">==</span> g]</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>        mu <span class="op">=</span> Xg.mean(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>        wss <span class="op">+=</span> ((Xg <span class="op">-</span> mu) <span class="op">**</span> <span class="dv">2</span>).<span class="bu">sum</span>()</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> wss</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pseudo_f_table(Z, X, max_k<span class="op">=</span><span class="dv">15</span>):</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> X.shape[<span class="dv">0</span>]</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> []</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>    TSS <span class="op">=</span> ((X <span class="op">-</span> X.mean(axis<span class="op">=</span><span class="dv">0</span>)) <span class="op">**</span> <span class="dv">2</span>).<span class="bu">sum</span>()</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="bu">min</span>(max_k, n)):</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>        labels <span class="op">=</span> fcluster(Z, t<span class="op">=</span>k, criterion<span class="op">=</span><span class="st">'maxclust'</span>)</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>        WSS <span class="op">=</span> compute_wss(X, labels)</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>        BSS <span class="op">=</span> TSS <span class="op">-</span> WSS</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>        pf <span class="op">=</span> (BSS <span class="op">/</span> (k <span class="op">-</span> <span class="dv">1</span>)) <span class="op">/</span> (WSS <span class="op">/</span> (n <span class="op">-</span> k))</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>        results.append((k, pf))</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pd.DataFrame(results, columns<span class="op">=</span>[<span class="st">"k"</span>, <span class="st">"pseudo_F"</span>])</span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>pf_df <span class="op">=</span> pseudo_f_table(Z, X_scaled, max_k<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Calinski–Harabasz Pseudo F:"</span>)</span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(pf_df)</span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a><span class="co"># ----------------------------------------</span></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a><span class="co"># 4. Mojena’s Rule</span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a><span class="co"># ----------------------------------------</span></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mojena_rule(Z, c<span class="op">=</span><span class="fl">2.75</span>):</span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>    heights <span class="op">=</span> Z[:, <span class="dv">2</span>]              <span class="co"># 병합 높이</span></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>    h_mean <span class="op">=</span> heights.mean()</span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>    h_std <span class="op">=</span> heights.std(ddof<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>    cutoff <span class="op">=</span> h_mean <span class="op">+</span> c <span class="op">*</span> h_std</span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> Z.shape[<span class="dv">0</span>] <span class="op">+</span> <span class="dv">1</span>  <span class="co"># 관측치 개수</span></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, h <span class="kw">in</span> <span class="bu">enumerate</span>(heights):</span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> h <span class="op">&gt;</span> cutoff:</span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>            <span class="co"># i번째 병합 이후 군집 수 = n - (i + 1)</span></span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>            k <span class="op">=</span> n <span class="op">-</span> (i <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> {</span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>                <span class="st">"step"</span>: i <span class="op">+</span> <span class="dv">1</span>,</span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>                <span class="st">"k"</span>: k,</span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a>                <span class="st">"height"</span>: h,</span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a>                <span class="st">"cutoff"</span>: cutoff</span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a>mojena_res <span class="op">=</span> mojena_rule(Z, c<span class="op">=</span><span class="fl">2.75</span>)</span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Mojena's Rule (c=2.75) 결과:"</span>)</span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(mojena_res)</span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a><span class="co"># ----------------------------------------</span></span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a><span class="co"># 5. Duda–Hart Je(2)/Je(1) 및 pseudo T²</span></span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a><span class="co"># ----------------------------------------</span></span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> duda_hart_pseudo_t2(Z, X):</span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> X.shape[<span class="dv">0</span>]</span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a>    clusters <span class="op">=</span> {i: np.array([i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)}</span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a>    wss_dict <span class="op">=</span> {}</span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> cluster_wss(idx):</span>
<span id="cb2-91"><a href="#cb2-91" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> idx <span class="kw">in</span> wss_dict:</span>
<span id="cb2-92"><a href="#cb2-92" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> wss_dict[idx]</span>
<span id="cb2-93"><a href="#cb2-93" aria-hidden="true" tabindex="-1"></a>        members <span class="op">=</span> clusters[idx]</span>
<span id="cb2-94"><a href="#cb2-94" aria-hidden="true" tabindex="-1"></a>        Xg <span class="op">=</span> X[members]</span>
<span id="cb2-95"><a href="#cb2-95" aria-hidden="true" tabindex="-1"></a>        mu <span class="op">=</span> Xg.mean(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb2-96"><a href="#cb2-96" aria-hidden="true" tabindex="-1"></a>        wss <span class="op">=</span> ((Xg <span class="op">-</span> mu) <span class="op">**</span> <span class="dv">2</span>).<span class="bu">sum</span>()</span>
<span id="cb2-97"><a href="#cb2-97" aria-hidden="true" tabindex="-1"></a>        wss_dict[idx] <span class="op">=</span> wss</span>
<span id="cb2-98"><a href="#cb2-98" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> wss</span>
<span id="cb2-99"><a href="#cb2-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-100"><a href="#cb2-100" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> []</span>
<span id="cb2-101"><a href="#cb2-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-102"><a href="#cb2-102" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> step, row <span class="kw">in</span> <span class="bu">enumerate</span>(Z):</span>
<span id="cb2-103"><a href="#cb2-103" aria-hidden="true" tabindex="-1"></a>        a, b, height, n_members <span class="op">=</span> row</span>
<span id="cb2-104"><a href="#cb2-104" aria-hidden="true" tabindex="-1"></a>        a, b <span class="op">=</span> <span class="bu">int</span>(a), <span class="bu">int</span>(b)</span>
<span id="cb2-105"><a href="#cb2-105" aria-hidden="true" tabindex="-1"></a>        new_id <span class="op">=</span> n <span class="op">+</span> step</span>
<span id="cb2-106"><a href="#cb2-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-107"><a href="#cb2-107" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 새 클러스터 구성</span></span>
<span id="cb2-108"><a href="#cb2-108" aria-hidden="true" tabindex="-1"></a>        members <span class="op">=</span> np.concatenate([clusters[a], clusters[b]])</span>
<span id="cb2-109"><a href="#cb2-109" aria-hidden="true" tabindex="-1"></a>        clusters[new_id] <span class="op">=</span> members</span>
<span id="cb2-110"><a href="#cb2-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-111"><a href="#cb2-111" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Je(2) = 합치기 전 두 군집의 WSS 합</span></span>
<span id="cb2-112"><a href="#cb2-112" aria-hidden="true" tabindex="-1"></a>        wss_a <span class="op">=</span> cluster_wss(a)</span>
<span id="cb2-113"><a href="#cb2-113" aria-hidden="true" tabindex="-1"></a>        wss_b <span class="op">=</span> cluster_wss(b)</span>
<span id="cb2-114"><a href="#cb2-114" aria-hidden="true" tabindex="-1"></a>        Je2 <span class="op">=</span> wss_a <span class="op">+</span> wss_b</span>
<span id="cb2-115"><a href="#cb2-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-116"><a href="#cb2-116" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Je(1) = 합친 후 WSS</span></span>
<span id="cb2-117"><a href="#cb2-117" aria-hidden="true" tabindex="-1"></a>        Xg <span class="op">=</span> X[members]</span>
<span id="cb2-118"><a href="#cb2-118" aria-hidden="true" tabindex="-1"></a>        mu <span class="op">=</span> Xg.mean(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb2-119"><a href="#cb2-119" aria-hidden="true" tabindex="-1"></a>        Je1 <span class="op">=</span> ((Xg <span class="op">-</span> mu) <span class="op">**</span> <span class="dv">2</span>).<span class="bu">sum</span>()</span>
<span id="cb2-120"><a href="#cb2-120" aria-hidden="true" tabindex="-1"></a>        wss_dict[new_id] <span class="op">=</span> Je1</span>
<span id="cb2-121"><a href="#cb2-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-122"><a href="#cb2-122" aria-hidden="true" tabindex="-1"></a>        ratio <span class="op">=</span> Je2 <span class="op">/</span> Je1 <span class="cf">if</span> Je1 <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> np.nan</span>
<span id="cb2-123"><a href="#cb2-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-124"><a href="#cb2-124" aria-hidden="true" tabindex="-1"></a>        N1 <span class="op">=</span> <span class="bu">len</span>(clusters[a])</span>
<span id="cb2-125"><a href="#cb2-125" aria-hidden="true" tabindex="-1"></a>        N2 <span class="op">=</span> <span class="bu">len</span>(clusters[b])</span>
<span id="cb2-126"><a href="#cb2-126" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> N1 <span class="op">+</span> N2 <span class="op">-</span> <span class="dv">2</span> <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> Je1 <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb2-127"><a href="#cb2-127" aria-hidden="true" tabindex="-1"></a>            T2 <span class="op">=</span> (ratio <span class="op">-</span> <span class="fl">1.0</span>) <span class="op">*</span> (N1 <span class="op">+</span> N2 <span class="op">-</span> <span class="dv">2</span>)</span>
<span id="cb2-128"><a href="#cb2-128" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb2-129"><a href="#cb2-129" aria-hidden="true" tabindex="-1"></a>            T2 <span class="op">=</span> np.nan</span>
<span id="cb2-130"><a href="#cb2-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-131"><a href="#cb2-131" aria-hidden="true" tabindex="-1"></a>        num_clusters <span class="op">=</span> n <span class="op">-</span> (step <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb2-132"><a href="#cb2-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-133"><a href="#cb2-133" aria-hidden="true" tabindex="-1"></a>        results.append({</span>
<span id="cb2-134"><a href="#cb2-134" aria-hidden="true" tabindex="-1"></a>            <span class="st">"step"</span>: step <span class="op">+</span> <span class="dv">1</span>,</span>
<span id="cb2-135"><a href="#cb2-135" aria-hidden="true" tabindex="-1"></a>            <span class="st">"num_clusters"</span>: num_clusters,</span>
<span id="cb2-136"><a href="#cb2-136" aria-hidden="true" tabindex="-1"></a>            <span class="st">"height"</span>: height,</span>
<span id="cb2-137"><a href="#cb2-137" aria-hidden="true" tabindex="-1"></a>            <span class="st">"Je2_over_Je1"</span>: ratio,</span>
<span id="cb2-138"><a href="#cb2-138" aria-hidden="true" tabindex="-1"></a>            <span class="st">"pseudo_T2"</span>: T2</span>
<span id="cb2-139"><a href="#cb2-139" aria-hidden="true" tabindex="-1"></a>        })</span>
<span id="cb2-140"><a href="#cb2-140" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pd.DataFrame(results)</span>
<span id="cb2-141"><a href="#cb2-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-142"><a href="#cb2-142" aria-hidden="true" tabindex="-1"></a>dh_df <span class="op">=</span> duda_hart_pseudo_t2(Z, X_scaled)</span>
<span id="cb2-143"><a href="#cb2-143" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Duda–Hart Je(2)/Je(1) 및 pseudo T² (상위 10단계):"</span>)</span>
<span id="cb2-144"><a href="#cb2-144" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dh_df.head(<span class="dv">10</span>))</span>
<span id="cb2-145"><a href="#cb2-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-146"><a href="#cb2-146" aria-hidden="true" tabindex="-1"></a><span class="co"># ----------------------------------------</span></span>
<span id="cb2-147"><a href="#cb2-147" aria-hidden="true" tabindex="-1"></a><span class="co"># 6. 덴드로그램 (Mojena 기준선 포함)</span></span>
<span id="cb2-148"><a href="#cb2-148" aria-hidden="true" tabindex="-1"></a><span class="co"># ----------------------------------------</span></span>
<span id="cb2-149"><a href="#cb2-149" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb2-150"><a href="#cb2-150" aria-hidden="true" tabindex="-1"></a>dendrogram(</span>
<span id="cb2-151"><a href="#cb2-151" aria-hidden="true" tabindex="-1"></a>    Z,</span>
<span id="cb2-152"><a href="#cb2-152" aria-hidden="true" tabindex="-1"></a>    labels<span class="op">=</span>raw.index.tolist(),</span>
<span id="cb2-153"><a href="#cb2-153" aria-hidden="true" tabindex="-1"></a>    leaf_rotation<span class="op">=</span><span class="dv">90</span></span>
<span id="cb2-154"><a href="#cb2-154" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb2-155"><a href="#cb2-155" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"USArrests - Ward Hierarchical Clustering"</span>)</span>
<span id="cb2-156"><a href="#cb2-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-157"><a href="#cb2-157" aria-hidden="true" tabindex="-1"></a><span class="co"># Mojena 기준 높이에 수평선</span></span>
<span id="cb2-158"><a href="#cb2-158" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> mojena_res <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb2-159"><a href="#cb2-159" aria-hidden="true" tabindex="-1"></a>    plt.axhline(</span>
<span id="cb2-160"><a href="#cb2-160" aria-hidden="true" tabindex="-1"></a>        y<span class="op">=</span>mojena_res[<span class="st">"height"</span>],</span>
<span id="cb2-161"><a href="#cb2-161" aria-hidden="true" tabindex="-1"></a>        linestyle<span class="op">=</span><span class="st">"--"</span>,</span>
<span id="cb2-162"><a href="#cb2-162" aria-hidden="true" tabindex="-1"></a>        linewidth<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb2-163"><a href="#cb2-163" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span><span class="ss">f"Mojena cutoff (k=</span><span class="sc">{</span>mojena_res[<span class="st">'k'</span>]<span class="sc">}</span><span class="ss">)"</span></span>
<span id="cb2-164"><a href="#cb2-164" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb2-165"><a href="#cb2-165" aria-hidden="true" tabindex="-1"></a>    plt.legend()</span>
<span id="cb2-166"><a href="#cb2-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-167"><a href="#cb2-167" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb2-168"><a href="#cb2-168" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Calinski–Harabasz Pseudo F 해석</p>
<p>Pseudo F는 군집 간 분산(BSS)이 크고 군집 내 분산(WSS)이 작을수록 큰 값을 가지므로 일반적으로 피크(최댓값) 근처의 k가 후보가 된다.</p>
<ul>
<li>k = 2일 때 최댓값 → 가장 뚜렷한 분리.</li>
<li>k = 4는 두 번째로 높은 피크 → 4군집 구조도 상대적으로 해석 가능.</li>
</ul>
<p>Calinski–Harabasz Pseudo F: <br> k pseudo_F <br> 0 2 41.894858 <br> 1 3 34.936527 <br> 2 4 36.533996 <br> 3 5 32.009982 <br> 4 6 29.648747 <br> 5 7 28.210572 <br> 6 8 27.475667 <br> 7 9 27.648135</p>
<p><strong>Mojena's Rule</strong></p>
<p>Mojena의 컷오프가 약 7.93인데, 실제 Ward 병합의 최종 병합 높이(13.65)가 이를 초과하여 마지막 병합에서 기준을 충족한다. 즉, <span dir="rtl">”</span>더 이상 분리할 의미 있는 군집 구조가 없다”는 결론을 낸다. 하지만 이것은 Mojena의 한계로, Ward 거리의 분포 특성에 따라 매우 보수적으로 동작한다. 실무적으로는 이 값을 그대로 받아들이지 않고, 덴드로그램 형태와 다른 지표(Pseudo F 등)와 함께 고려한다.</p>
<p>Mojena's Rule (c=2.75) 결과:</p>
<p>{'step': 49, 'k': 1, 'height': np.float64(13.653466603337856), 'cutoff': np.float64(7.930106044456396)}</p>
<p><strong>Duda–Hart Je(2)/Je(1) 및 pseudo T² 해석</strong></p>
<p>Je2/Je1 = 0 은 “합치기 전 두 군집 WSS가 0이었다”는 뜻 → 실제론 불가능</p>
<p>pseudo T²가 음수 → 수학적으로는 Je2/Je1 &lt; 1 에서만 발생하는데, Je2 &lt; Je1이라는 의미이며 비정상적 결과이다.</p>
<p>이 데이터에서는 Duda–Hart 기준이 안정적이지 않게 동작한다.</p>
<p>Duda–Hart Je(2)/Je(1) 및 pseudo T² (상위 10단계):</p>
<p>step num_clusters height Je2_over_Je1 pseudo_T2 <br> 0 1 49 0.207944 0.000000 NaN <br> 1 2 48 0.353774 0.000000 NaN <br> 2 3 47 0.433124 0.000000 NaN <br> 3 4 46 0.499099 0.000000 NaN <br> 4 5 45 0.540825 0.000000 NaN <br> 5 6 44 0.559148 0.375011 -0.624989 <br> 6 7 43 0.599560 0.000000 NaN <br> 7 8 42 0.662585 0.089663 -0.910337 <br> 8 9 41 0.710977 0.000000 NaN <br> 9 10 40 0.718098 0.000000 NaN</p>
<p><strong>덴드로그램</strong></p>
<p>덴드로그램 최상단의 두 큰 가지가 매우 높은 높이(약 13.5)에서 합쳐지고 있다. 오른쪽(초록색 큰 가지), 왼쪽(주황색 큰 가지)</p>
<p>즉, Ward 거리 기준으로 두 초대형 블록 간의 이질성이 가장 큼을 의미한다. → 이것은 Pseudo F가 k=2에서 최대값을 갖는 이유와 정확히 일치한다. 군집을 2개로 나누면 두 그룹 간 분리가 가장 크다는 뜻입니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/ca_dendrogram0.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>Mojena 기준선(cutoff ≈ 7.93)이 덴드로그램에 표시된 수평선이다. 실제로 데이터에서는 마지막 병합 높이(13.6)가 이 cutoff를 넘는 유일한 지점 → 그래서 Mojena 알고리즘은 <span dir="rtl">”</span>이 시점에서 처음 기준선을 넘었다”고 판단하여 k = 1을 반환한다. (군집개수 결정 활용 불가)</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.cluster.hierarchy <span class="im">import</span> linkage, fcluster</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># ---- 데이터 준비 ----</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>raw <span class="op">=</span> sm.datasets.get_rdataset(<span class="st">"USArrests"</span>, <span class="st">"datasets"</span>).data</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> StandardScaler().fit_transform(raw.values)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>n, p <span class="op">=</span> X.shape</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co"># 전체 TSS</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>TSS <span class="op">=</span> ((X <span class="op">-</span> X.mean(axis<span class="op">=</span><span class="dv">0</span>)) <span class="op">**</span> <span class="dv">2</span>).<span class="bu">sum</span>()</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co"># ---- 군집 결과 ----</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> linkage(X, method<span class="op">=</span><span class="st">'ward'</span>)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="co"># ---- WSS 계산 함수 ----</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_wss(X, labels):</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    wss <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> g <span class="kw">in</span> np.unique(labels):</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        Xg <span class="op">=</span> X[labels <span class="op">==</span> g]</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        mu <span class="op">=</span> Xg.mean(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        wss <span class="op">+=</span> ((Xg <span class="op">-</span> mu) <span class="op">**</span> <span class="dv">2</span>).<span class="bu">sum</span>()</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> wss</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="co"># ---- CCC 계산 ----</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_ccc(Z, X, max_k<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    n, p <span class="op">=</span> X.shape</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    TSS <span class="op">=</span> ((X <span class="op">-</span> X.mean(axis<span class="op">=</span><span class="dv">0</span>)) <span class="op">**</span> <span class="dv">2</span>).<span class="bu">sum</span>()</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> []</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, max_k <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>        labels <span class="op">=</span> fcluster(Z, k, criterion<span class="op">=</span><span class="st">"maxclust"</span>)</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>        WSS <span class="op">=</span> compute_wss(X, labels)</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>        BSS <span class="op">=</span> TSS <span class="op">-</span> WSS</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>        R2 <span class="op">=</span> BSS <span class="op">/</span> TSS</span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Expected R2 under null (SAS 방식)</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>        E_R2 <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> ((n <span class="op">-</span> k) <span class="op">/</span> (n <span class="op">-</span> <span class="dv">1</span>))<span class="op">**</span>(<span class="dv">2</span> <span class="op">/</span> p)</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Variance approximation</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>        V_R2 <span class="op">=</span> (<span class="dv">2</span> <span class="op">*</span> E_R2<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> (n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>        CCC <span class="op">=</span> (R2 <span class="op">-</span> E_R2) <span class="op">/</span> np.sqrt(V_R2)</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>        results.append([k, R2, E_R2, CCC])</span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pd.DataFrame(results, columns<span class="op">=</span>[<span class="st">"k"</span>, <span class="st">"R2"</span>, <span class="st">"E(R2)"</span>, <span class="st">"CCC"</span>])</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>ccc_df <span class="op">=</span> compute_ccc(Z, X, max_k<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>ccc_df</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>CCC 해석</strong></p>
<p>CCC ≥ 2 → 군집 구조 강함 → CCC가 높을수록 더 뚜렷한 군집 구조이므로 <span dir="rtl">”</span>피크”(peak)를 찾는 것이 핵심이다.</p>
<ul>
<li>CCC가 갑자기 크게 증가하면 <span dir="rtl">”</span>새로운 군집 구조 발견”</li>
<li>CCC가 감소 or 완만해지면 <span dir="rtl">”</span>추가 군집은 의미 없음”</li>
</ul>
<p>k=2에서 CCC = 219.96: 매우 높은 값으로 <span dir="rtl">”</span>두 개로 나누면 군집 구조가 극도로 강함”, 보통 4~10 정도도 큰 값인데, 200대는 압도적이다.</p>
<p>k=3에서 CCC = 138.56, 여전히 매우 큼, k=2보다는 낮지만 여전히 군집 구조 존재</p>
<p>k=4에서 CCC = 107.17, 여전히 높지만 감소 추세 시작된다.</p>
<p>k R2 E(R2) CCC <br> 0 2 0.466043 0.010257 219.956775 <br> 1 3 0.597854 0.020621 138.557379 <br> 2 4 0.704374 0.031096 107.170943 <br> 3 5 0.739944 0.041685 82.912183 <br> 4 6 0.771124 0.052393 67.901102 <br> 5 7 0.797422 0.063223 57.480555 <br> 6 8 0.820765 0.074180 49.816855 <br> 7 9 0.843622 0.085268 44.021931 <br> 8 10 0.862420 0.096492 39.289737</p>
</section>
<section id="군집-결과-활용" class="level5">
<h5 class="anchored" data-anchor-id="군집-결과-활용">(2) 군집 결과 활용</h5>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.decomposition <span class="im">import</span> PCA</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.cluster.hierarchy <span class="im">import</span> fcluster</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 이미 위에서 사용한 raw, X, Z를 그대로 활용한다고 가정합니다.</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co"># raw: USArrests 데이터 (index = 주 이름)</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co"># X  : 표준화된 데이터 (X = StandardScaler().fit_transform(raw.values))</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Z  : linkage(X, method='ward')</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. 군집 개수를 2개로 고정</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>labels_2 <span class="op">=</span> fcluster(Z, k, criterion<span class="op">=</span><span class="st">'maxclust'</span>)  <span class="co"># 1, 2 라벨</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. PCA 2차원으로 차원 축소</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>pca <span class="op">=</span> PCA(n_components<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>X_pca <span class="op">=</span> pca.fit_transform(X)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. 시각화</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">7</span>))</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>markers <span class="op">=</span> [<span class="st">'o'</span>, <span class="st">'s'</span>]</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> g, m <span class="kw">in</span> <span class="bu">zip</span>([<span class="dv">1</span>, <span class="dv">2</span>], markers):</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">=</span> (labels_2 <span class="op">==</span> g)</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    plt.scatter(</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        X_pca[idx, <span class="dv">0</span>],</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>        X_pca[idx, <span class="dv">1</span>],</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        marker<span class="op">=</span>m,</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span><span class="ss">f'Cluster </span><span class="sc">{</span>g<span class="sc">}</span><span class="ss">'</span>,</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>        alpha<span class="op">=</span><span class="fl">0.8</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 주(State) 이름 라벨 달기</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> np.where(idx)[<span class="dv">0</span>]:</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>        plt.text(</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>            X_pca[i, <span class="dv">0</span>] <span class="op">+</span> <span class="fl">0.02</span>,</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>            X_pca[i, <span class="dv">1</span>] <span class="op">+</span> <span class="fl">0.02</span>,</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>            raw.index[i],</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>            fontsize<span class="op">=</span><span class="dv">8</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>plt.axhline(<span class="dv">0</span>, linestyle<span class="op">=</span><span class="st">':'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="dv">0</span>, linestyle<span class="op">=</span><span class="st">':'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'PC1'</span>)</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'PC2'</span>)</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'USArrests - Ward Clustering (k=2, PCA 2D)'</span>)</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/ca_pca.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># PC1, PC2 loading matrix</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>loadings <span class="op">=</span> pd.DataFrame(</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    pca.components_.T,</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    columns<span class="op">=</span>[<span class="st">'PC1'</span>, <span class="st">'PC2'</span>],</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    index<span class="op">=</span>raw.columns)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"PCA Loadings (부하값):"</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(loadings)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>PC1의 부하값은 Murder(0.54), Assault(0.58), Rape(0.54)에서 모두 크고 양의 값을 보인다. 즉 세 가지 주요 강력범죄 지표가 모두 같은 방향으로 작용하고 있습니다. UrbanPop도 양의 부하값이지만 크기가 상대적으로 작다. → 따라서 PC1 점수가 높은 주(State)는 Murder·Assault·Rape가 모두 높은 곳이다. PC1은 살인, 폭행, 강간 등 강력범죄 발생률이 공통적으로 높아지는 방향을 가장 잘 설명하는 축으로, <span dir="rtl">’</span>전반적 강력범죄 수준<span dir="rtl">’</span>을 나타내는 주성분으로 해석할 수 있다.</p>
<p>PC2에서는 UrbanPop이 0.873으로 매우 큰 양의 부하값을 보이며, 다른 변수들은 양·음이 섞여 있고 절대값도 작다. PC2는 도시 거주 인구 비율이 가장 큰 비중으로 작용하는 축으로, 주의 도시화 수준과 관련된 패턴을 반영하는 주성분이다. 즉, <span dir="rtl">’</span>도시화 기반 범죄 패턴<span dir="rtl">’</span> 또는 <span dir="rtl">’</span>도시화 수준 축<span dir="rtl">’</span>으로 이해할 수 있다.</p>
<p>PCA Loadings (부하값):</p>
<p>PC1 PC2 <br> Murder 0.535899 -0.418181 <br> Assault 0.583184 -0.187986 <br> UrbanPop 0.278191 0.872806 <br> Rape 0.543432 0.167319</p>
</section>
</section>
</section>
<section id="chapter-4.-비계층적-군집분석" class="level3">
<h3 class="anchored" data-anchor-id="chapter-4.-비계층적-군집분석">Chapter 4. 비계층적 군집분석</h3>
<p>비계층적 군집분석은 군집 수 k를 사전에 정하고, 관측치를 반복적으로 재배정하여 최적의 군집 분할을 찾는 방식으로, 대표적인 전통적 방법은 k-means, k-medoids(PAM), CLARA, CLARANS, Fuzzy C-means 등이 있다. 이들 방법은 계층적 군집과 달리 대규모 자료에서도 적용 가능하며, 초깃값 설정과 거리 함수 선택이 군집 결과에 큰 영향을 준다.</p>
<p>여기서는 전통적인 다변량 기법인 k-means와 k-means의 약점을 보완한 방법인 PAM 기법만을 다룬다. 다른 기법은 빅데이터 기법의 군집분석에서 다루기로 한다.</p>
<section id="k-means-방법" class="level4">
<h4 class="anchored" data-anchor-id="k-means-방법">1. K-means 방법</h4>
<p><strong>군집화 방법</strong></p>
<p>K-means 방법은 사전에 정해진 군집 수 K 를 기준으로, 각 관측치를 가장 가까운 군집 중심에 배정하면서 군집 구조를 반복적으로 갱신해 나가는 비계층적 군집 방법이다. 알고리즘의 기본 절차는 다음과 같다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/ca_kmeans.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
<p>① 군집 수 결정: 우선 계층적 군집분석 결과나 군집 타당성 지표 등을 이용하여 적절한 군집 수 K를 결정한다.</p>
<p>② 초기 중심값 설정: 결정된 군집 수 K에 대해 초기 군집 중심을 무작위로 선택하거나, 다른 기준에 따라 초기 중심을 설정한다.</p>
<p>③ 관측치 배정(assignment step): 각 관측치는 현재의 군집 중심들 중에서 가장 가까운(center와의 거리 최소) 군집에 배정된다.</p>
<p>④ 중심값 갱신(update step): 새롭게 배정된 군집을 기준으로 각 군집의 평균을 계산하여 군집 중심을 다시 업데이트한다.</p>
<p>⑤ 수렴할 때까지 반복: 배정과 중심 갱신(단계 ③–④)을 반복하여, 더 이상 군집의 변화가 나타나지 않을 때 알고리즘을 종료한다.</p>
<p><strong>사례분석</strong></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.cluster <span class="im">import</span> KMeans</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.decomposition <span class="im">import</span> PCA</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co"># ---- 데이터 준비 ----</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>raw <span class="op">=</span> sm.datasets.get_rdataset(<span class="st">"USArrests"</span>, <span class="st">"datasets"</span>).data</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> StandardScaler().fit_transform(raw.values)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 1. K-means (k=2) ---</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>kmeans <span class="op">=</span> KMeans(n_clusters<span class="op">=</span>k, n_init<span class="op">=</span><span class="dv">20</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>labels_km <span class="op">=</span> kmeans.fit_predict(X_scaled)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 2. PCA 차원축소 ---</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>pca <span class="op">=</span> PCA(n_components<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>X_pca <span class="op">=</span> pca.fit_transform(X_scaled)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 3. 시각화 ---</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">7</span>))</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>markers <span class="op">=</span> [<span class="st">'o'</span>, <span class="st">'s'</span>]</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">'tab:blue'</span>, <span class="st">'tab:orange'</span>]</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> g, m, c <span class="kw">in</span> <span class="bu">zip</span>(<span class="bu">range</span>(k), markers, colors):</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">=</span> (labels_km <span class="op">==</span> g)</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    plt.scatter(</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>        X_pca[idx, <span class="dv">0</span>],</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        X_pca[idx, <span class="dv">1</span>],</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        marker<span class="op">=</span>m,</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span>c,</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span><span class="ss">f'Cluster </span><span class="sc">{</span>g<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">'</span>,</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>        alpha<span class="op">=</span><span class="fl">0.8</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 주 이름 라벨</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> np.where(idx)[<span class="dv">0</span>]:</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>        plt.text(</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>            X_pca[i, <span class="dv">0</span>] <span class="op">+</span> <span class="fl">0.02</span>,</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>            X_pca[i, <span class="dv">1</span>] <span class="op">+</span> <span class="fl">0.02</span>,</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>            raw.index[i],</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>            fontsize<span class="op">=</span><span class="dv">8</span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>plt.axhline(<span class="dv">0</span>, linestyle<span class="op">=</span><span class="st">':'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="dv">0</span>, linestyle<span class="op">=</span><span class="st">':'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"PC1: Violent Crime Level"</span>)</span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"PC2: Urbanization Level"</span>)</span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"USArrests - K-means (k=2) on PCA Space"</span>)</span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>계층적 군집분석 결과와 차이는 missouri 주가 <span dir="rtl">’</span>전반적 강력범죄 수준<span dir="rtl">’</span> 높은 집단으로 분류되었다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/ca_kmeans_pca.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
</section>
<section id="k-medoidspam" class="level4">
<h4 class="anchored" data-anchor-id="k-medoidspam">2. k-medoids(PAM)</h4>
<p>K-medoids 군집분석은 군집의 중심을 평균(mean) 대신, 데이터 중에서 실제 존재하는 관측치 하나(medoid)로 선택하는 분석법이다. 여기서 medoid는 군집 내에서 다른 모든 관측치들과의 거리 합이 최소가 되는 대표점 을 의미한다.</p>
<p>즉, K-means의 <span dir="rtl">”</span>중심(centroid)“이 가상의 점이라면 K-medoids의 <span dir="rtl">”</span>medoid”는 실제로 존재하는 데이터 점이다.</p>
<p>K-means 알고리즘은 단순하고 계산이 빠르다는 장점이 있지만, 군집의 중심을 각 군집 내 관측치들의 평균값으로 정의하는 방식 때문에 여러 한계를 갖는다. 우선 평균은 이상치에 민감하므로, 소수의 극단값이 존재할 경우 중심점이 크게 왜곡될 수 있다. 또한 변수들의 스케일에 매우 민감하여, 적절한 표준화가 이루어지지 않으면 특정 변수가 군집 구조를 과도하게 좌우하게 된다. 더불어 K-means는 일반적으로 유클리드 거리를 전제로 하기 때문에 비유클리드 거리 공간에서는 적용이 어렵고, 범주형 변수와 같이 평균값이 의미를 갖지 않는 자료에는 사용할 수 없다는 제한이 있다.</p>
<p>이러한 단점을 보완하기 위해 고안된 방법이 K-medoids 알고리즘이다. K-medoids는 군집 중심을 평균이 아닌 실제 관측치(medoid) 중 하나로 선택함으로써 이상치의 영향을 크게 줄인다. 또한 군집 형성에 사용되는 거리 척도를 자유롭게 선택할 수 있어, 연속형뿐만 아니라 범주형 혹은 혼합형 데이터에도 적용할 수 있다는 유연성을 갖는다. 군집의 중심이 실제 존재하는 관측치이기 때문에 해석 또한 직관적이며, 이러한 이유로 의료 자료, 마케팅 고객 세분화, 생태학적 데이터와 같이 다양한 거리 구조를 가진 분야에서 널리 활용되고 있다.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>pip install scikit<span class="op">-</span>learn<span class="op">-</span>extra</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> pairwise_distances</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.decomposition <span class="im">import</span> PCA</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 0. 데이터 준비 (USArrests + 표준화)</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>raw <span class="op">=</span> sm.datasets.get_rdataset(<span class="st">"USArrests"</span>, <span class="st">"datasets"</span>).data</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>X_scaled <span class="op">=</span> StandardScaler().fit_transform(raw.values)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. k-medoids(PAM) 구현</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> k_medoids(X, k, max_iter<span class="op">=</span><span class="dv">100</span>, random_state<span class="op">=</span><span class="dv">42</span>):</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="co">    간단한 PAM 알고리즘 구현 (Euclidean 거리)</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="co">    X : (n, p) 데이터</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="co">    k : 군집 수</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    rng <span class="op">=</span> np.random.default_rng(random_state)</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> X.shape[<span class="dv">0</span>]</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 전체 pairwise distance 미리 계산 (n이 작아서 가능)</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    D <span class="op">=</span> pairwise_distances(X, metric<span class="op">=</span><span class="st">"euclidean"</span>)</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 초기 medoid를 임의로 선택</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>    medoids <span class="op">=</span> rng.choice(n, size<span class="op">=</span>k, replace<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 초기 라벨 부여</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> np.argmin(D[:, medoids], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> it <span class="kw">in</span> <span class="bu">range</span>(max_iter):</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>        old_medoids <span class="op">=</span> medoids.copy()</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 각 군집마다 medoid 갱신</span></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> m <span class="kw">in</span> <span class="bu">range</span>(k):</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>            idx <span class="op">=</span> np.where(labels <span class="op">==</span> m)[<span class="dv">0</span>]</span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(idx) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 군집 내 거리 합이 최소가 되는 점을 medoid로 선택</span></span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a>            intra_D <span class="op">=</span> D[np.ix_(idx, idx)]         <span class="co"># 군집 내 거리행렬</span></span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a>            costs <span class="op">=</span> intra_D.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)           <span class="co"># 각 점을 medoid로 했을 때 비용</span></span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a>            best_idx <span class="op">=</span> idx[np.argmin(costs)]</span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a>            medoids[m] <span class="op">=</span> best_idx</span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a>        <span class="co"># medoid가 바뀐 후 새 라벨 부여</span></span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a>        labels <span class="op">=</span> np.argmin(D[:, medoids], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 수렴 체크</span></span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> np.<span class="bu">all</span>(medoids <span class="op">==</span> old_medoids):</span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-57"><a href="#cb8-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> medoids, labels</span>
<span id="cb8-58"><a href="#cb8-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-59"><a href="#cb8-59" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb8-60"><a href="#cb8-60" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. k-medoids 수행 (k=2)</span></span>
<span id="cb8-61"><a href="#cb8-61" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb8-62"><a href="#cb8-62" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb8-63"><a href="#cb8-63" aria-hidden="true" tabindex="-1"></a>medoids, labels_pm <span class="op">=</span> k_medoids(X_scaled, k<span class="op">=</span>k, max_iter<span class="op">=</span><span class="dv">100</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb8-64"><a href="#cb8-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-65"><a href="#cb8-65" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Medoid 인덱스:"</span>, medoids)</span>
<span id="cb8-66"><a href="#cb8-66" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Medoid 주 이름:"</span>, raw.index[medoids].tolist())</span>
<span id="cb8-67"><a href="#cb8-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-68"><a href="#cb8-68" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb8-69"><a href="#cb8-69" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. PCA 2차원 축으로 시각화</span></span>
<span id="cb8-70"><a href="#cb8-70" aria-hidden="true" tabindex="-1"></a><span class="co"># -----------------------------</span></span>
<span id="cb8-71"><a href="#cb8-71" aria-hidden="true" tabindex="-1"></a>pca <span class="op">=</span> PCA(n_components<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb8-72"><a href="#cb8-72" aria-hidden="true" tabindex="-1"></a>X_pca <span class="op">=</span> pca.fit_transform(X_scaled)</span>
<span id="cb8-73"><a href="#cb8-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-74"><a href="#cb8-74" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">7</span>))</span>
<span id="cb8-75"><a href="#cb8-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-76"><a href="#cb8-76" aria-hidden="true" tabindex="-1"></a>markers <span class="op">=</span> [<span class="st">'o'</span>, <span class="st">'s'</span>]</span>
<span id="cb8-77"><a href="#cb8-77" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">'tab:blue'</span>, <span class="st">'tab:orange'</span>]</span>
<span id="cb8-78"><a href="#cb8-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-79"><a href="#cb8-79" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> g, m, c <span class="kw">in</span> <span class="bu">zip</span>(<span class="bu">range</span>(k), markers, colors):</span>
<span id="cb8-80"><a href="#cb8-80" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">=</span> (labels_pm <span class="op">==</span> g)</span>
<span id="cb8-81"><a href="#cb8-81" aria-hidden="true" tabindex="-1"></a>    plt.scatter(</span>
<span id="cb8-82"><a href="#cb8-82" aria-hidden="true" tabindex="-1"></a>        X_pca[idx, <span class="dv">0</span>],</span>
<span id="cb8-83"><a href="#cb8-83" aria-hidden="true" tabindex="-1"></a>        X_pca[idx, <span class="dv">1</span>],</span>
<span id="cb8-84"><a href="#cb8-84" aria-hidden="true" tabindex="-1"></a>        marker<span class="op">=</span>m,</span>
<span id="cb8-85"><a href="#cb8-85" aria-hidden="true" tabindex="-1"></a>        label<span class="op">=</span><span class="ss">f'Cluster </span><span class="sc">{</span>g<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">'</span>,</span>
<span id="cb8-86"><a href="#cb8-86" aria-hidden="true" tabindex="-1"></a>        alpha<span class="op">=</span><span class="fl">0.8</span>,</span>
<span id="cb8-87"><a href="#cb8-87" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span>c</span>
<span id="cb8-88"><a href="#cb8-88" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb8-89"><a href="#cb8-89" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 주 이름 라벨</span></span>
<span id="cb8-90"><a href="#cb8-90" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> np.where(idx)[<span class="dv">0</span>]:</span>
<span id="cb8-91"><a href="#cb8-91" aria-hidden="true" tabindex="-1"></a>        plt.text(</span>
<span id="cb8-92"><a href="#cb8-92" aria-hidden="true" tabindex="-1"></a>            X_pca[i, <span class="dv">0</span>] <span class="op">+</span> <span class="fl">0.03</span>,</span>
<span id="cb8-93"><a href="#cb8-93" aria-hidden="true" tabindex="-1"></a>            X_pca[i, <span class="dv">1</span>] <span class="op">+</span> <span class="fl">0.03</span>,</span>
<span id="cb8-94"><a href="#cb8-94" aria-hidden="true" tabindex="-1"></a>            raw.index[i],</span>
<span id="cb8-95"><a href="#cb8-95" aria-hidden="true" tabindex="-1"></a>            fontsize<span class="op">=</span><span class="dv">8</span></span>
<span id="cb8-96"><a href="#cb8-96" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb8-97"><a href="#cb8-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-98"><a href="#cb8-98" aria-hidden="true" tabindex="-1"></a><span class="co"># medoid 위치 별도 표시 (★)</span></span>
<span id="cb8-99"><a href="#cb8-99" aria-hidden="true" tabindex="-1"></a>plt.scatter(</span>
<span id="cb8-100"><a href="#cb8-100" aria-hidden="true" tabindex="-1"></a>    X_pca[medoids, <span class="dv">0</span>],</span>
<span id="cb8-101"><a href="#cb8-101" aria-hidden="true" tabindex="-1"></a>    X_pca[medoids, <span class="dv">1</span>],</span>
<span id="cb8-102"><a href="#cb8-102" aria-hidden="true" tabindex="-1"></a>    s<span class="op">=</span><span class="dv">200</span>,</span>
<span id="cb8-103"><a href="#cb8-103" aria-hidden="true" tabindex="-1"></a>    marker<span class="op">=</span><span class="st">'*'</span>,</span>
<span id="cb8-104"><a href="#cb8-104" aria-hidden="true" tabindex="-1"></a>    edgecolor<span class="op">=</span><span class="st">'k'</span>,</span>
<span id="cb8-105"><a href="#cb8-105" aria-hidden="true" tabindex="-1"></a>    facecolor<span class="op">=</span><span class="st">'none'</span>,</span>
<span id="cb8-106"><a href="#cb8-106" aria-hidden="true" tabindex="-1"></a>    linewidth<span class="op">=</span><span class="fl">1.5</span>,</span>
<span id="cb8-107"><a href="#cb8-107" aria-hidden="true" tabindex="-1"></a>    label<span class="op">=</span><span class="st">'Medoids'</span></span>
<span id="cb8-108"><a href="#cb8-108" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb8-109"><a href="#cb8-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-110"><a href="#cb8-110" aria-hidden="true" tabindex="-1"></a>plt.axhline(<span class="dv">0</span>, linestyle<span class="op">=</span><span class="st">':'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb8-111"><a href="#cb8-111" aria-hidden="true" tabindex="-1"></a>plt.axvline(<span class="dv">0</span>, linestyle<span class="op">=</span><span class="st">':'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb8-112"><a href="#cb8-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-113"><a href="#cb8-113" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"PC1: Violent Crime Level"</span>)</span>
<span id="cb8-114"><a href="#cb8-114" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"PC2: Urbanization Level"</span>)</span>
<span id="cb8-115"><a href="#cb8-115" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"USArrests - k-medoids (PAM, k=2) on PCA space"</span>)</span>
<span id="cb8-116"><a href="#cb8-116" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb8-117"><a href="#cb8-117" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb8-118"><a href="#cb8-118" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>계층적 군집분석 결과와 차이는 missouri 주가 <span dir="rtl">’</span>전반적 강력범죄 수준<span dir="rtl">’</span> 높은 집단으로 분류되었다. 이상 개체가 없어 k-means 군집분석 결과와는 동일하다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/ca_kmeans_pam.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "복사완료!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "복사완료!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© 2025 Kwon</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>Built with Quarto</p>
</div>
  </div>
</footer>




</body></html>